<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>functions.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect finmap ssralg ssrnum ssrint rat.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predI _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predU _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predD _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predC _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ preim _ of _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closedM;
                   GRing.smulr_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedM; GRing.smulr_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed.
New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.sdivr_closed_div;
                   GRing.divr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.sdivr_closedM; GRing.smulr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subalg_closedBM;
                   GRing.subring_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subalg_closedZ; GRing.submod_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divring_closed_div;
                   GRing.sdivr_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divring_closedBM; GRing.subring_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divalg_closedBdiv;
                   GRing.divring_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divalg_closedZ; GRing.subalg_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.Pred.subring_smul;
                   GRing.Pred.smul_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.Pred.subring_semi; GRing.Pred.semiring_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="kn">From</span> HB <span class="kn">Require Import</span> structures.
<span class="kn">Require Import</span> mathcomp_extra boolp classical_sets.
<span class="kn">Add Search Blacklist</span> <span class="s2">&quot;__canonical__&quot;</span>.
<span class="kn">Add Search Blacklist</span> <span class="s2">&quot;__functions_&quot;</span>.
<span class="kn">Add Search Blacklist</span> <span class="s2">&quot;_factory_&quot;</span>.
<span class="kn">Add Search Blacklist</span> <span class="s2">&quot;_mixin_&quot;</span>.

<span class="sd">(******************************************************************************)</span>
<span class="c">(*                            Theory of functions                             *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* This file provides a theory of functions whose domain and codomain are     *)</span>
<span class="c">(* represented by sets.                                                       *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*          set_fun A B f == f : aT -&gt; rT is a function with domain           *)</span>
<span class="c">(*                           A : set aT and codomain B : set rT               *)</span>
<span class="c">(*         set_surj A B f == f is surjective                                  *)</span>
<span class="c">(*          set inj A B f == f is injective                                   *)</span>
<span class="c">(*          set_bij A B f == f is bijective                                   *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*          {fun A &gt;-&gt; B} == type of functions f : aT -&gt; rT from A : set aT   *)</span>
<span class="c">(*                           to B : set rT.                                   *)</span>
<span class="c">(*                           funS f  is a proof of  set_fun A B f             *)</span>
<span class="c">(*       {oinv aT &gt;-&gt; rT} == type of functions with a partial inverse         *)</span>
<span class="c">(*      {oinvfun A &gt;-&gt; B} == combination of {fun A &gt;-&gt; B} and                 *)</span>
<span class="c">(*                           {oinv aT &gt;-&gt; rT}                                 *)</span>
<span class="c">(*        {inv aT &gt;-&gt; rT} == type of functions with an inverse                *)</span>
<span class="c">(*                  f ^-1 == inverse of f : {inv aT &gt;-&gt; rT}                   *)</span>
<span class="c">(*       {invfun A &gt;-&gt; B} == combination of {fun A &gt;-&gt; B} and {inv aT &gt;-&gt; rT} *)</span>
<span class="c">(*         {surj A &gt;-&gt; B} == type of surjective functions                     *)</span>
<span class="c">(*      {surjfun A &gt;-&gt; B} == combination of {fun A &gt;-&gt; B} and {surj A &gt;-&gt; B}  *)</span>
<span class="c">(*    {splitsurj A &gt;-&gt; B} == type of surjective functions with an inverse     *)</span>
<span class="c">(* {splitsurjfun A &gt;-&gt; B} == combination of {fun A &gt;-&gt; B} and                 *)</span>
<span class="c">(*                           {splitsurj A &gt;-&gt; B}                              *)</span>
<span class="c">(*         {inj A &gt;-&gt; rT} == type of injective functions                      *)</span>
<span class="c">(*       {injfun A &gt;-&gt; B} == combination of {fun A &gt;-&gt; B} and {inj A &gt;-&gt; rT}  *)</span>
<span class="c">(*     {splitinj A &gt;-&gt; B} == type of injective functions with an inverse      *)</span>
<span class="c">(*  {splitinjfun A &gt;-&gt; B} == combination of {fun A &gt;-&gt; B} and                 *)</span>
<span class="c">(*                           {splitinj A &gt;-&gt; B}                               *)</span>
<span class="c">(*          {bij A &gt;-&gt; B} == combination of {injfun A &gt;-&gt; B} and              *)</span>
<span class="c">(*                           {surjfun A &gt;-&gt; B}                                *)</span>
<span class="c">(*     {splitbij A &gt;-&gt; B} == combination of {splitinj A &gt;-&gt; B} and            *)</span>
<span class="c">(*                           {splitsurj A &gt;-&gt; B}                              *)</span>
<span class="c">(*                &#39;inj_ f == proof of {in A &amp;, injective f} where f has type  *)</span>
<span class="c">(*                           {splitinj A &gt;-&gt; _}                               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*              funin A f == alias for f : aT -&gt; rT, with A : set aT          *)</span>
<span class="c">(*             [fun f in A] == the function f from the set A to the set f @` A*)</span>
<span class="c">(*            &#39;split_ d f == partial injection from aT : Type to rt : Type;   *)</span>
<span class="c">(*                           f : aT -&gt; rT, d : rT -&gt; aT                       *)</span>
<span class="c">(*                  split := &#39;split_point                                     *)</span>
<span class="c">(*             @to_setT T == function that associates to x : T a dependent    *)</span>
<span class="c">(*                           pair of x with a proof that x belongs to setT    *)</span>
<span class="c">(*                           (i.e., the type set_type [set: T])               *)</span>
<span class="c">(*                incl AB == identity function from T to T, where AB is a     *)</span>
<span class="c">(*                           proof of A `&lt;=` B, with A, B : set T             *)</span>
<span class="c">(*                inclT A := incl (@subsetT _ _)                              *)</span>
<span class="c">(*              eqincl AB == identity function from T to T, where AB is a     *)</span>
<span class="c">(*                           proof of A = B, with A, B : set T                *)</span>
<span class="c">(*              mkfun fAB == builds a function {fun A &gt;-&gt; B} given a function *)</span>
<span class="c">(*                           f : aT -&gt; rT and a proof fAB that                *)</span>
<span class="c">(*                           {homo f : x / A x &gt;-&gt; B x}                       *)</span>
<span class="c">(*           @set_val T A == injection from set_type A to T, where A has      *)</span>
<span class="c">(*                           type set T                                       *)</span>
<span class="c">(*             @ssquash T == function of type                                 *)</span>
<span class="c">(*                           {splitsurj [set: T] &gt;-&gt; [set: $| T |]}           *)</span>
<span class="c">(*        @finset_val T X == function that turns an element x : X             *)</span>
<span class="c">(*                           (with X : {fset T}) into a dependent pair of x   *)</span>
<span class="c">(*                           with a proof that x belongs to X                 *)</span>
<span class="c">(*                           (i.e., the type set_type [set` X])               *)</span>
<span class="c">(*        @val_finset T X == function of type [set` X] -&gt; X with X : {fset T} *)</span>
<span class="c">(*                           that cancels finset_val                          *)</span>
<span class="c">(*         glue XY AB f g == function that behaves as f over X, as g over Y   *)</span>
<span class="c">(*                           XY is a proof that sets X and Y are disjoint,    *)</span>
<span class="c">(*                           AB is a proof that sets A and B are disjoint,    *)</span>
<span class="c">(*                           A and B are intended to be the ranges of f and g *)</span>
<span class="c">(*           &#39;pinv_ d A f == inverse of the function [fun f in A] over        *)</span>
<span class="c">(*                           f @` A, function d outside of f @` A             *)</span>
<span class="c">(*                  pinv := notation for &#39;pinv_point                          *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Function restriction:                                                    *)</span>
<span class="c">(*            patch d A f == &quot;partial function&quot; that behaves as the function  *)</span>
<span class="c">(*                           f over the set A and as the function d otherwise *)</span>
<span class="c">(*           restrict D f := patch (fun=&gt; point) D f                          *)</span>
<span class="c">(*                 f \_ D := restrict D f                                     *)</span>
<span class="c">(*               sigL A f == &quot;left restriction&quot;; given a set A : set U and a  *)</span>
<span class="c">(*                           function f : U -&gt; V, returns the corresponding   *)</span>
<span class="c">(*                           function of type set_type A -&gt; V                 *)</span>
<span class="c">(*               sigR A f == &quot;right restriction&quot;; given a set B : set V and a *)</span>
<span class="c">(*                           function f : {fun [set: U] &gt;-&gt; B}, returns the   *)</span>
<span class="c">(*                           corresponding function of type U -&gt; set_type B   *)</span>
<span class="c">(*            sigLR A B f == the function of type set_type A -&gt; set_type B    *)</span>
<span class="c">(*                           corresponding to f : {fun A &gt;-&gt; B}               *)</span>
<span class="c">(*                valL_ v == function cancelled by sigL A, with A : set U and *)</span>
<span class="c">(*                           v : V                                            *)</span>
<span class="c">(*                 valR f == the function of type U -&gt; V corresponding to     *)</span>
<span class="c">(*                           f : U -&gt; set_type B, with B : set V              *)</span>
<span class="c">(*               valR_fun == the function of type {fun [set: U] &gt;-&gt; B}        *)</span>
<span class="c">(*                           corresponding to f : U -&gt; set_type B, with       *)</span>
<span class="c">(*                           B : set V                                        *)</span>
<span class="c">(*              valLR v f == the function of type U -&gt; V corresponding to     *)</span>
<span class="c">(*                           f : set_type A -&gt; set_type B (where v : V),      *)</span>
<span class="c">(*                           i.e., &#39;valL_ v \o valR_fun                       *)</span>
<span class="c">(*       valLfun_ v A B f := [fun of valL_ f] with f : {fun [set: A] &gt;-&gt; B}   *)</span>
<span class="c">(*                   valL := &#39;valL_ point                                     *)</span>
<span class="c">(*             valLRfun v := &#39;valLfun_ v \o valR_fun                          *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* Section function_space == canonical ringType and lmodType                  *)</span>
<span class="c">(*                           structures for functions whose range is          *)</span>
<span class="c">(*                           a ringType, comRingType, or lmodType.            *)</span>
<span class="c">(*                   fctE == multi-rule for fct                               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="kn">Set Implicit Arguments</span>.
<span class="kn">Unset Strict Implicit</span>.
<span class="kn">Unset Printing Implicit Defensive</span>.

<span class="kn">Reserved Notation</span> <span class="s2">&quot;f \_ D&quot;</span> (<span class="kn">at level</span> <span class="mi">10</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;fun&#39; A &#39;&gt;-&gt;&#39; B &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;fun&#39;  A  &#39;&gt;-&gt;&#39;  B &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;oinv&#39; T &#39;&gt;-&gt;&#39; U &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;oinv&#39;  T  &#39;&gt;-&gt;&#39;  U &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;inv&#39; T &#39;&gt;-&gt;&#39; U &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;inv&#39;  T  &#39;&gt;-&gt;&#39;  U &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;oinvfun&#39; T &#39;&gt;-&gt;&#39; U &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;oinvfun&#39;  T  &#39;&gt;-&gt;&#39;  U &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;invfun&#39; T &#39;&gt;-&gt;&#39; U &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;invfun&#39;  T  &#39;&gt;-&gt;&#39;  U &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;inj&#39; A &#39;&gt;-&gt;&#39; T &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;inj&#39;  A  &#39;&gt;-&gt;&#39;  T &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;splitinj&#39; A &#39;&gt;-&gt;&#39; T &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;splitinj&#39;  A  &#39;&gt;-&gt;&#39;  T &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;surj&#39; A &#39;&gt;-&gt;&#39; B &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;surj&#39;  A  &#39;&gt;-&gt;&#39;  B &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;splitsurj&#39; A &#39;&gt;-&gt;&#39; B &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;splitsurj&#39;  A  &#39;&gt;-&gt;&#39;  B &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;injfun&#39; A &#39;&gt;-&gt;&#39; B &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;injfun&#39;  A  &#39;&gt;-&gt;&#39;  B &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;surjfun&#39; A &#39;&gt;-&gt;&#39; B &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;surjfun&#39;  A  &#39;&gt;-&gt;&#39;  B &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;splitinjfun&#39; A &#39;&gt;-&gt;&#39; B &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;splitinjfun&#39;  A  &#39;&gt;-&gt;&#39;  B &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;splitsurjfun&#39; A &#39;&gt;-&gt;&#39; B &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;splitsurjfun&#39;  A  &#39;&gt;-&gt;&#39;  B &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;bij&#39; A &#39;&gt;-&gt;&#39; B &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;bij&#39;  A  &#39;&gt;-&gt;&#39;  B &#39;}&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;{&#39; &#39;splitbij&#39; A &#39;&gt;-&gt;&#39; B &#39;}&#39;&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;&#39;{&#39; &#39;splitbij&#39;  A  &#39;&gt;-&gt;&#39;  B &#39;}&#39;&quot;</span>).

<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;fun&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;fun&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;oinv&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;oinv&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;inv&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;inv&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;oinv&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;oinv&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;inv&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;inv&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;inj&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;inj&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;splitinj&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;splitinj&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;surj&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;surj&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;splitsurj&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;splitsurj&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;injfun&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;injfun&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;surjfun&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;surjfun&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;splitinjfun&#39; &#39;of&#39; f ]&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;[ &#39;splitinjfun&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;splitsurjfun&#39; &#39;of&#39; f ]&quot;</span>
  (<span class="kn">format</span> <span class="s2">&quot;[ &#39;splitsurjfun&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;bij&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;bij&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;splitbij&#39; &#39;of&#39; f ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;splitbij&#39;  &#39;of&#39;  f ]&quot;</span>).

<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;oinv_&#39; f&quot;</span> (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;oinv_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;funS_&#39; f&quot;</span> (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;funS_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;mem_fun_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span>  <span class="s2">&quot;&#39;&#39;mem_fun_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;oinvK_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;oinvK_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;oinvS_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;oinvS_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;oinvP_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;oinvP_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;oinvT_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;oinvT_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;invK_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;invK_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;invS_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;invS_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;funoK_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;funoK_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;inj_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;inj_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;funK_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;funK_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;totalfun_&#39; A&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, A <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;totalfun_&#39; A&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;surj_&#39; f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;surj_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;split_&#39; a&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, a <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;split_&#39; a&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;bijTT_&#39;  f&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;bijTT_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;bij_&#39; f&quot;</span> (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;bij_&#39; f&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;valL_&#39; v&quot;</span> (<span class="kn">at level</span> <span class="mi">8</span>, v <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;valL_&#39; v&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;valLfun_&#39; v&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, v <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;valLfun_&#39; v&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;pinv_&#39; dflt&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, dflt <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;pinv_&#39; dflt&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;pPbij_&#39; dflt&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, dflt <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;pPbij_&#39; dflt&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;pPinj_&#39; dflt&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, dflt <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;pPinj_&#39; dflt&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;injpPfun_&#39; dflt&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, dflt <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;injpPfun_&#39; dflt&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&#39;funpPinj_&#39; dflt&quot;</span>
  (<span class="kn">at level</span> <span class="mi">8</span>, dflt <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;funpPinj_&#39; dflt&quot;</span>).

<span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.

<span class="kn">Section</span> <span class="nf">MainProperties</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>}  (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : aT -&gt; rT).
<span class="kn">Definition</span> <span class="nf">set_fun</span> := {homo f : x / A x &gt;-&gt; B x}.
<span class="kn">Definition</span> <span class="nf">set_surj</span> := B `&lt;=` f @` A.
<span class="kn">Definition</span> <span class="nf">set_inj</span> := {<span class="kr">in</span> A &amp;, injective f}.
<span class="kn">Definition</span> <span class="nf">set_bij</span> := [/\ set_fun, set_inj &amp; set_surj].
<span class="kn">End</span> <span class="nf">MainProperties</span>.

HB.mixin <span class="kn">Record</span> <span class="nf">IsFun</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : aT -&gt; rT) :=
  { funS : set_fun A B f }.
HB.structure <span class="kn">Definition</span> <span class="nf">Fun</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) :=
  { f of IsFun _ _ A B f }.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;fun&#39; A &gt;-&gt; B }&quot;</span> := (@Fun.type _ _ A B) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;fun&#39;  &#39;of&#39;  f ]&quot;</span> := [the {<span class="kr">fun</span> <span class="nv">_</span> &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.mixin <span class="kn">Record</span> <span class="nf">OInv</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">f</span> : aT -&gt; rT) := { oinv : rT -&gt; option aT }.
HB.structure <span class="kn">Definition</span> <span class="nf">OInversible</span> <span class="nv">aT</span> <span class="nv">rT</span> := {f of OInv aT rT f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;oinv&#39; aT &gt;-&gt; rT }&quot;</span> := (@OInversible.type aT rT) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;oinv&#39;  &#39;of&#39;  f ]&quot;</span> := [the {oinv _ &gt;-&gt; _} of f : _ -&gt; _] :
  form_scope.
<span class="kn">Definition</span> <span class="nf">phant_oinv</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">f</span> : {oinv aT &gt;-&gt; rT})
  <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @oinv _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;oinv_&#39; f&quot;</span> := (@phant_oinv _ _ _ (Phantom (_ -&gt; _) f%FUN)).

HB.structure <span class="kn">Definition</span> <span class="nf">OInvFun</span> <span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">A</span> <span class="nv">B</span> :=
  {f of OInv aT rT f &amp; IsFun aT rT A B f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;oinvfun&#39; A &gt;-&gt; B }&quot;</span> := (@OInvFun.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;oinvfun&#39;  &#39;of&#39;  f ]&quot;</span> :=
  [the {oinvfun _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.mixin <span class="kn">Record</span> <span class="nf">OInv_Inv</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">OInv</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">f</span> := {
  inv : rT -&gt; aT;
  oliftV : olift inv = &#39;oinv_f
}.

HB.factory <span class="kn">Record</span> <span class="nf">Inv</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">f</span> : aT -&gt; rT) := { inv : rT -&gt; aT  }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">Inv</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">f</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv.Build _ _ f (olift inv).
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_Inv.Build _ _ f erefl.
HB.<span class="kr">end</span>.

HB.structure <span class="kn">Definition</span> <span class="nf">Inversible</span> <span class="nv">aT</span> <span class="nv">rT</span> := {f of Inv aT rT f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;inv&#39; aT &gt;-&gt;  rT }&quot;</span> := (@Inversible.type aT rT) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;inv&#39;  &#39;of&#39;  f ]&quot;</span> := [the {inv _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.
<span class="kn">Definition</span> <span class="nf">phant_inv</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">f</span> : {inv aT &gt;-&gt; rT}) <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @inv _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;f ^-1&quot;</span> := (@inv _ _ f%FUN) (<span class="kn">only printing</span>) : fun_scope.
<span class="kn">Notation</span> <span class="s2">&quot;f ^-1&quot;</span> := (@inv _ _ f%function) (<span class="kn">only printing</span>) : function_scope.
<span class="kn">Notation</span> <span class="s2">&quot;f ^-1&quot;</span> := (@phant_inv _ _ _ (Phantom (_ -&gt; _) f%FUN)) : fun_scope.
<span class="kn">Notation</span> <span class="s2">&quot;f ^-1&quot;</span> := (@phant_inv _ _ _ (Phantom (_ -&gt; _) f%function)) : function_scope.

HB.structure <span class="kn">Definition</span> <span class="nf">InvFun</span> <span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">A</span> <span class="nv">B</span> := {f of Inv aT rT f &amp; IsFun aT rT A B f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;invfun&#39; A &gt;-&gt; B }&quot;</span> := (@InvFun.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;invfun&#39;  &#39;of&#39;  f ]&quot;</span> :=
  [the {invfun _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.mixin <span class="kn">Record</span> <span class="nf">OInv_CanV</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT}
  (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">OInv</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">f</span> := {
    oinvS : {homo &#39;oinv_f : x / B x &gt;-&gt; (some @` A) x};
    oinvK : {<span class="kr">in</span> B, ocancel &#39;oinv_f f};
  }.

HB.factory <span class="kn">Record</span> <span class="nf">OCanV</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) := {
    oinv; oinvS : {homo oinv : x / B x &gt;-&gt; (some @` A) x};
          oinvK : {<span class="kr">in</span> B, ocancel oinv f};
  }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT)
   <span class="nv">of</span> <span class="nv">OCanV</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span>.
 HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv.Build _ _ f oinv.
 HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_CanV.Build _ _ A B f oinvS oinvK.
HB.<span class="kr">end</span>.

HB.structure <span class="kn">Definition</span> <span class="nf">Surject</span> {<span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">A</span> <span class="nv">B</span>} := {f of @OCanV aT rT A B f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;surj&#39; A &gt;-&gt; B }&quot;</span> := (@Surject.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;surj&#39;  &#39;of&#39;  f ]&quot;</span> :=
  [the {surj _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.structure <span class="kn">Definition</span> <span class="nf">SurjFun</span> <span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">A</span> <span class="nv">B</span> :=
  {f of @Surject aT rT A B f &amp; @Fun _ _ A B f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;surjfun&#39; A &gt;-&gt; B }&quot;</span> := (@SurjFun.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;surjfun&#39;  &#39;of&#39;  f ]&quot;</span> :=
  [the {surjfun _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.structure <span class="kn">Definition</span> <span class="nf">SplitSurj</span> <span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">A</span> <span class="nv">B</span> :=
  {f of @Surject aT rT A B f &amp; @Inv _ _ f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;splitsurj&#39; A &gt;-&gt; B }&quot;</span> := (@SplitSurj.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;splitsurj&#39;  &#39;of&#39;  f ]&quot;</span> :=
  [the {splitsurj _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.structure <span class="kn">Definition</span> <span class="nf">SplitSurjFun</span> <span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">A</span> <span class="nv">B</span> :=
   {f of @SplitSurj aT rT A B f &amp; @Fun _ _ A B f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;splitsurjfun&#39; A &gt;-&gt; B }&quot;</span> := (@SplitSurjFun.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;splitsurjfun&#39;  &#39;of&#39;  f ]&quot;</span> :=
  [the {splitsurjfun _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.mixin <span class="kn">Record</span> <span class="nf">OInv_Can</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">OInv</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">f</span> :=
  { funoK : {<span class="kr">in</span> A, pcancel f &#39;oinv_f} }.

HB.structure <span class="kn">Definition</span> <span class="nf">Inject</span> <span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">A</span> :=
  {f of OInv aT rT f &amp; OInv_Can aT rT A f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;inj&#39; A &gt;-&gt; rT }&quot;</span> := (@Inject.type _ rT A) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;inj&#39;  &#39;of&#39;  f ]&quot;</span> := [the {inj _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.structure <span class="kn">Definition</span> <span class="nf">InjFun</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) :=
   { f of @Fun _ _ A B f &amp; @Inject _ _ A f }.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;injfun&#39; A &gt;-&gt; B }&quot;</span> := (@InjFun.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;injfun&#39;  &#39;of&#39;  f ]&quot;</span> :=
  [the {injfun _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.structure <span class="kn">Definition</span> <span class="nf">SplitInj</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) :=
  {f of @Inv aT rT f &amp; @Inject aT rT A f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;splitinj&#39; A &gt;-&gt; rT }&quot;</span> := (@SplitInj.type _ rT A) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;splitinj&#39;  &#39;of&#39;  f ]&quot;</span> :=
  [the {splitinj _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.structure <span class="kn">Definition</span> <span class="nf">SplitInjFun</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) :=
  {f of @SplitInj _ rT A f &amp; @IsFun _ _ A B f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;splitinjfun&#39; A &gt;-&gt; B }&quot;</span> := (@SplitInjFun.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;splitinjfun&#39;  &#39;of&#39;  f ]&quot;</span> :=
  [the {splitinjfun _ &gt;-&gt; _} of f : _ -&gt; _] : form_scope.

HB.structure <span class="kn">Definition</span> <span class="nf">Bij</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} :=
   {f of @InjFun _ _ A B f &amp; @SurjFun _ _ A B f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;bij&#39; A &gt;-&gt; B }&quot;</span> := (@Bij.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;bij&#39;  &#39;of&#39;  f ]&quot;</span> := [the {bij _ &gt;-&gt; _} of f] : form_scope.

HB.structure <span class="kn">Definition</span> <span class="nf">SplitBij</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} :=
   {f of @SplitInjFun _ _ A B f &amp; @SplitSurjFun _ _ A B f}.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;splitbij&#39; A &gt;-&gt; B }&quot;</span> := (@SplitBij.type _ _ A B) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;splitbij&#39;  &#39;of&#39;  f ]&quot;</span> := [the {splitbij _ &gt;-&gt; _} of f] : form_scope.</span></pre><div class="doc">
begin hide 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* Hint View for move / Inversible.sort inv | 2. *)</span>
<span class="c">(* Hint View for apply / Inversible.sort inv | 2. *)</span></span></pre><div class="doc">
end hide 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Module</span> <span class="nf">ShortFunSyntax</span>.
<span class="kn">Notation</span> <span class="s2">&quot;A ~&gt; B&quot;</span> := {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;aT &lt;=&gt; rT&quot;</span> := {oinv aT &gt;-&gt; rT} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A &lt;~ B&quot;</span> := {oinvfun A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;aT &lt;&lt;=&gt; rT&quot;</span> := {inv aT &gt;-&gt; rT} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A &lt;&lt;~ B&quot;</span> := {invfun A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A =&gt;&gt; B&quot;</span> := {surj A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A ~&gt;&gt; B&quot;</span> := {surjfun A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A ==&gt;&gt; B&quot;</span> := {splitsurj A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A ~~&gt;&gt; B&quot;</span> := {splitsurjfun A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A &gt;=&gt; rT&quot;</span> := {inj A &gt;-&gt; rT} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A &gt;~&gt; B&quot;</span> := {injfun A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A &gt;&gt;=&gt; rT&quot;</span> := {splitinj A &gt;-&gt; rT} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A &gt;&gt;~&gt; B&quot;</span> := {splitinjfun A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A &lt;~&gt; B&quot;</span> := {bij A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;A &lt;&lt;~&gt; B&quot;</span> := {splitbij A &gt;-&gt; B} (<span class="kn">at level</span> <span class="mi">70</span>) : type_scope.
<span class="kn">End</span> <span class="nf">ShortFunSyntax</span>.

<span class="sd">(**********)</span>
<span class="c">(* Theory *)</span>
<span class="sd">(**********)</span>

<span class="kn">Definition</span> <span class="nf">phant_funS</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT)
  (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @funS _ _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;funS_  f&quot;</span> := (phant_funS (Phantom (_ -&gt; _) f))
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (set_fun _ _ _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: funS] : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (prop_in1 _ _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: funS] : core.

<span class="kn">Definition</span> <span class="nf">fun_image_sub</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) :=
  image_subP.<span class="mi">2</span> (@funS _ _ _ _ f).
<span class="kn">Arguments</span> fun_image_sub {aT rT A B}.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (_ @` _ `&lt;=` _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: fun_image_sub] : core.

<span class="kn">Definition</span> <span class="nf">mem_fun</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) :=
  homo_setP.<span class="mi">2</span> (@funS _ _ _ _ f).
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (prop_in1 _ _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: mem_fun] : core.

<span class="kn">Definition</span> <span class="nf">phant_mem_fun</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT)
  (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := homo_setP.<span class="mi">2</span> (@funS _ _ _ _ f).
<span class="kn">Notation</span> <span class="s2">&quot;&#39;mem_fun_  f&quot;</span> := (phant_funS (Phantom (_ -&gt; _) f))
  (<span class="kn">at level</span> <span class="mi">8</span>, f <span class="kn">at level</span> <span class="mi">2</span>) : form_scope.

<span class="kn">Lemma</span> <span class="nf">some_inv</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">f</span> : {inv aT &gt;-&gt; rT}) <span class="nv">x</span> : Some (f^-<span class="mi">1</span> x) = &#39;oinv_f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -oliftV. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">phant_oinvK</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT)
   (<span class="nv">f</span> : {surj A &gt;-&gt; B}) <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @oinvK _ _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;oinvK_ f&quot;</span> := (phant_oinvK (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> oinvK : core.

<span class="kn">Definition</span> <span class="nf">phant_oinvS</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT)
   (<span class="nv">f</span> : {surj A &gt;-&gt; B}) <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @oinvS _ _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;oinvS_ f&quot;</span> := (phant_oinvS (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> oinvS : core.

<span class="kn">Variant</span> <span class="nf">oinv_spec</span> {<span class="nv">aT</span>} {<span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : {surj A &gt;-&gt; B}) <span class="nv">y</span> :
   rT -&gt; option aT -&gt; <span class="kt">Type</span> :=
  OInvSpec (x : aT) of A x &amp; f x = y : oinv_spec f y (f x) (Some x).

<span class="kn">Lemma</span> <span class="nf">oinvP</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : {surj A &gt;-&gt; B}) <span class="nv">y</span> :
  B y -&gt; oinv_spec f y y (&#39;oinv_f y).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; By; <span class="nb">have</span> :=&#39;oinvK_f (mem_set By).
<span class="bp">by</span> <span class="nb">have</span> /cid2 [x Ax &lt;-] := &#39;oinvS_f By =&gt; &lt;-; <span class="nb">constructor</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">phant_oinvP</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT)
   (<span class="nv">f</span> : {surj A &gt;-&gt; B}) <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @oinvP _ _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;oinvP_ f&quot;</span> := (phant_oinvP (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> oinvP : core.

<span class="kn">Lemma</span> <span class="nf">oinvT</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {surj A &gt;-&gt; B}} <span class="nv">x</span> :
  B x -&gt; &#39;oinv_f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /&#39;oinvS_f [a Aa &lt;-]. <span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">phant_oinvT</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT)
   (<span class="nv">f</span> : {surj A &gt;-&gt; B}) <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @oinvT _ _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;oinvT_ f&quot;</span> := (phant_oinvT (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> oinvT : core.

<span class="kn">Lemma</span> <span class="nf">invK</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {splitsurj A &gt;-&gt; B}} :
   {<span class="kr">in</span> B, cancel f^-<span class="mi">1</span> f}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x Bx; <span class="nb">rewrite</span> -[x <span class="kr">in</span> RHS]&#39;oinvK_f// -some_inv/=. <span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">phant_invK</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT)
   (<span class="nv">f</span> : {splitsurj A &gt;-&gt; B}) <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @invK _ _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;invK_ f&quot;</span> := (phant_invK (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> invK : core.

<span class="kn">Lemma</span> <span class="nf">invS</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {splitsurj A &gt;-&gt; B}} :
  {homo f^-<span class="mi">1</span> : x / B x &gt;-&gt; A x}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x /&#39;oinvS_f/= [a Aa]; <span class="nb">rewrite</span> -some_inv =&gt; -[&lt;-]. <span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">phant_invS</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT)
   {<span class="nv">f</span> : {splitsurjfun A &gt;-&gt; B}} <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @invS _ _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;invS_ f&quot;</span> := (phant_invS (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> invS : core.

<span class="kn">Definition</span> <span class="nf">phant_funoK</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : {inj A &gt;-&gt; rT})
  <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @funoK _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;funoK_ f&quot;</span> := (phant_funoK (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> funoK : core.

<span class="kn">Definition</span> <span class="nf">inj</span> {<span class="nv">aT</span> <span class="nv">rT</span> : nonPropType} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">f</span> : {inj A &gt;-&gt; rT}} :
   {<span class="kr">in</span> A &amp;, injective f} := pcan_in_inj funoK.
<span class="kn">Definition</span> <span class="nf">phant_inj</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : {inj A &gt;-&gt; rT}) <span class="nv">of</span>
   <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @inj _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;inj_ f&quot;</span> := (phant_inj (Phantom (_ -&gt; _) f)) : form_scope.

<span class="kn">Definition</span> <span class="nf">inj_hint</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">f</span> : {inj A &gt;-&gt; rT}} :
   {<span class="kr">in</span> A &amp;, injective f} := inj.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> {<span class="kr">in</span> _ &amp;, injective _} =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: inj_hint] : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (set_inj _ _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: inj_hint] : core.

<span class="kn">Lemma</span> <span class="nf">injT</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">f</span> : {inj [<span class="nb">set</span>: aT] &gt;-&gt; rT}} : injective f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: in2TT; <span class="nb">apply</span>: inj. <span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (injective _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: injT] : core.

<span class="kn">Lemma</span> <span class="nf">funK</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">s</span> : {splitinj A &gt;-&gt; rT}} :
  {<span class="kr">in</span> A, cancel s s^-<span class="mi">1</span>}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x Ax; <span class="nb">apply</span>: Some_inj; <span class="nb">rewrite</span> some_inv funoK. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">phant_funK</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : {splitinj A &gt;-&gt; rT})
  <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @funK _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;funK_  f&quot;</span> := (phant_funK (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> funK : core.

<span class="sd">(**********************)</span>
<span class="c">(* Structure Equality *)</span>
<span class="sd">(**********************)</span>

<span class="kn">Lemma</span> <span class="nf">funP</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> <span class="nv">g</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) :
  f = g &lt;-&gt; f =<span class="mi">1</span> g.
<span class="kn">Proof</span>.
<span class="nb">case</span>: f g =&gt; [f [[ffun]]] [g [[gfun]]]/=; <span class="nb">split</span>=&gt; [[-&gt;//]|/funext eqfg].
<span class="nb">rewrite</span> eqfg <span class="kr">in</span> ffun *; <span class="nb">congr</span> {| Fun.sort := _; Fun.class := {|
  Fun.functions_IsFun_mixin := {|IsFun.funS := _|}|}|}.
<span class="bp">exact</span>: Prop_irrelevance.
<span class="kn">Qed</span>.

<span class="sd">(************************)</span>
<span class="c">(* Preliminary Builders *)</span>
<span class="sd">(************************)</span>

HB.factory <span class="kn">Record</span> <span class="nf">Inv_Can</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">Inv</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">f</span> :=
  { funK : {<span class="kr">in</span> A, cancel f f^-<span class="mi">1</span>} }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} <span class="nv">A</span> (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> @Inv_Can _ _ A f.
  <span class="kn">Local Lemma</span> <span class="nf">funoK</span>: {<span class="kr">in</span> A, pcancel f &#39;oinv_f}.
  <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -oliftV/=; <span class="nb">apply</span>: can_in_pcan; <span class="nb">apply</span>: funK. <span class="kn">Qed</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_Can.Build _ _ A f funoK.
HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">Inv_CanV</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT)
     <span class="nv">of</span> <span class="nv">Inv</span> <span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">f</span> := {
  invS : {homo f^-<span class="mi">1</span> : x / B x &gt;-&gt; A x};
  invK : {<span class="kr">in</span> B, cancel f^-<span class="mi">1</span> f};
}.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT)
    <span class="nv">of</span> <span class="nv">Inv_CanV</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span>.
  #[local] <span class="kn">Lemma</span> <span class="nf">oinvK</span> : {<span class="kr">in</span> B, ocancel &#39;oinv_f f}.
  <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x Bx; <span class="nb">rewrite</span> -some_inv/= invK. <span class="kn">Qed</span>.
  #[local] <span class="kn">Lemma</span> <span class="nf">oinvS</span> : {homo &#39;oinv_f : x / B x &gt;-&gt; (some @` A) x}.
  <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x /invS Af&#39;x; <span class="kr">exists</span> (<span class="nv">f</span>^-<span class="mi">1</span> x); <span class="nb">rewrite</span> // -some_inv. <span class="kn">Qed</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_CanV.Build _ _ _ _ f oinvS oinvK.
HB.<span class="kr">end</span>.

<span class="sd">(*********************)</span>
<span class="c">(* Trivial instances *)</span>
<span class="sd">(*********************)</span>

<span class="kn">Section</span> <span class="nf">OInverse</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT}.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} :=
  OInv.Build _ _ &#39;oinv_f (omap f).

<span class="kn">Lemma</span> <span class="nf">oinvV</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} : &#39;oinv_(&#39;oinv_f) = omap f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) :=
  IsFun.Build rT (option aT) B (some @` A) &#39;oinv_f oinvS.

<span class="kn">Lemma</span> <span class="nf">surjoinv_inj_subproof</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) : OInv_Can _ _ B &#39;oinv_f.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; x Bx/=; <span class="nb">rewrite</span> -[x <span class="kr">in</span> RHS](&#39;oinvK_f Bx).
<span class="bp">by</span> <span class="nb">have</span> := &#39;oinvT_f (set_mem Bx); <span class="nb">case</span>: &#39;oinv_f.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := surjoinv_inj_subproof f.

<span class="kn">Lemma</span> <span class="nf">injoinv_surj_subproof</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) :
  OInv_CanV _ _ B (some @` A) &#39;oinv_f.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [_|_ /set_mem] [a Aa &lt;-]/=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> funoK <span class="nl">?inE</span>.
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">a</span>) =&gt; //; <span class="nb">apply</span>: funS.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) := injoinv_surj_subproof f.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> {<span class="nv">f</span> : {bij A &gt;-&gt; B}} := InjFun.on &#39;oinv_f.

<span class="kn">End</span> <span class="nf">OInverse</span>.

<span class="kn">Section</span> <span class="nf">Inverse</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT}.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inv aT &gt;-&gt; rT}) := Inv.Build rT aT f^-<span class="mi">1</span> f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inv aT &gt;-&gt; rT}) := Inversible.copy inv f^-<span class="mi">1</span>.

<span class="kn">Lemma</span> <span class="nf">invV</span> (<span class="nv">f</span> : {inv aT &gt;-&gt; rT}) : f^-<span class="mi">1</span>^-<span class="mi">1</span> = f. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurj A &gt;-&gt; B}) :=
  IsFun.Build rT aT B A f^-<span class="mi">1</span> invS.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurj A &gt;-&gt; B}) := Fun.copy inv f^-<span class="mi">1</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> {<span class="nv">f</span> : {splitsurj A &gt;-&gt; B}} :=
  Inv_Can.Build _ _ _ f^-<span class="mi">1</span> &#39;invK_f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinjfun A &gt;-&gt; B}) :=
  Inv_CanV.Build _ _ _ _ f^-<span class="mi">1</span> funS funK.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> {<span class="nv">f</span> : {splitbij A &gt;-&gt; B}} := InjFun.on f^-<span class="mi">1</span>.

<span class="kn">End</span> <span class="nf">Inverse</span>.

<span class="kn">Section</span> <span class="nf">Some</span>.
<span class="kn">Context</span> {<span class="nv">T</span>} {<span class="nv">A</span> : <span class="nb">set</span> T}.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv.Build _ _ (@Some T) id.

<span class="kn">Lemma</span> <span class="nf">oinv_some</span> : &#39;oinv_(@Some T) = id. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">some_can_subproof</span> : @OInv_Can _ _ A (@Some T). <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := some_can_subproof.

<span class="kn">Lemma</span> <span class="nf">some_canV_subproof</span> : OInv_CanV _ _ A (some @` A) (@Some T).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; [x|x /set_mem] [a Aa &lt;-]//=; <span class="kr">exists</span> <span class="nv">a</span>. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span>  := some_canV_subproof.

<span class="kn">Lemma</span> <span class="nf">some_fun_subproof</span> : IsFun _ _ A (some @` A) (@Some T).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x; <span class="kr">exists</span> <span class="nv">x</span>. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := some_fun_subproof.

<span class="kn">End</span> <span class="nf">Some</span>.

<span class="kn">Section</span> <span class="nf">OApply</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">b0</span> : rT}.
<span class="kn">Local Notation</span> <span class="nf">oapp</span> f := (oapp f b0).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} :=
  Inv.Build _ _ (oapp f) &#39;oinv_f.

<span class="kn">Lemma</span> <span class="nf">inv_oapp</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} : (oapp f)^-<span class="mi">1</span> = &#39;oinv_f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">oinv_oapp</span>  {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} : &#39;oinv_(oapp f) = olift &#39;oinv_f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -inv_oapp. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">inv_oappV</span> {<span class="nv">f</span> : {inv aT &gt;-&gt; rT}} : olift f^-<span class="mi">1</span> = (oapp f)^-<span class="mi">1</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> inv_oapp -oliftV. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">oapp_can_subproof</span> (<span class="nv">f</span> : {inj A &gt;-&gt; rT}) : Inv_Can _ _ (some @` A) (oapp f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x /set_mem[a Aa &lt;-]/=; <span class="nb">rewrite</span> inv_oapp funoK <span class="nl">?inE</span>. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := oapp_can_subproof f.

<span class="kn">Lemma</span> <span class="nf">oapp_surj_subproof</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) : Inv_CanV _ _ (some @` A) B (oapp f).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>=&gt; [b|b /set_mem] Bb/=; <span class="nb">rewrite</span> inv_oapp; <span class="nb">case</span>: oinvP =&gt; // x; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span>  <span class="nv">f</span> := oapp_surj_subproof f.

<span class="kn">Lemma</span> <span class="nf">oapp_fun_subproof</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) : IsFun _ _ (some @` A) B (oapp f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x [a Aa &lt;-] /=; <span class="nb">apply</span>: funS. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := oapp_fun_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinvfun A &gt;-&gt; B}) := Fun.on (oapp f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) := Fun.on (oapp f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; B}) := Fun.on (oapp f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) := Fun.on (oapp f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitbij A &gt;-&gt; B}) := Fun.on (oapp f).

<span class="kn">End</span> <span class="nf">OApply</span>.

<span class="kn">Section</span> <span class="nf">OBind</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> (option rT)}.
<span class="kn">Local Notation</span> <span class="nf">b</span> f := (oapp f None).
<span class="kn">Local Notation</span> <span class="nf">orT</span> := (option rT).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; orT}} :=
  Inv.Build _ _ (obind f) &#39;oinv_f.

<span class="kn">Lemma</span> <span class="nf">inv_obind</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; orT}} : (obind f)^-<span class="mi">1</span> = &#39;oinv_f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">oinv_obind</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; orT}} : &#39;oinv_(obind f) = olift &#39;oinv_f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">inv_obindV</span> {<span class="nv">f</span> : {inv aT &gt;-&gt; orT}} : (obind f)^-<span class="mi">1</span> = olift f^-<span class="mi">1</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> inv_obind -oliftV. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) := Fun.copy (obind f) (b f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inj A &gt;-&gt; orT}) := Inject.copy (obind f) (b f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) := Fun.on (obind f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) := Surject.copy (obind f) (b f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; B}) := Fun.on (obind f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) := Fun.on (obind f).
<span class="kn">End</span> <span class="nf">OBind</span>.

<span class="kn">Section</span> <span class="nf">Composition</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">sT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">C</span> : <span class="nb">set</span> sT}.

<span class="kn">Local Lemma</span> <span class="nf">comp_fun_subproof</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) (<span class="nv">g</span> : {<span class="kr">fun</span> <span class="nv">B</span> &gt;-&gt; C}) :
  IsFun _ _ A C (g \o f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span> =&gt; x /&#39;funS_f; <span class="nb">apply</span>: funS. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := comp_fun_subproof f g.

<span class="kn">Section</span> <span class="nf">OInv</span>.
<span class="kn">Context</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} {<span class="nv">g</span> : {oinv rT &gt;-&gt; sT}}.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv.Build _ _ (g \o f) (obind &#39;oinv_f \o &#39;oinv_g).
<span class="kn">Lemma</span> <span class="nf">oinv_comp</span> : &#39;oinv_(g \o f) = (obind &#39;oinv_f) \o &#39;oinv_g.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">OInv</span>.

<span class="kn">Section</span> <span class="nf">OInv</span>.
<span class="kn">Context</span> {<span class="nv">f</span> : {inv aT &gt;-&gt; rT}} {<span class="nv">g</span> : {inv rT &gt;-&gt; sT}}.
<span class="kn">Lemma</span> <span class="nf">some_comp_inv</span> : olift (f^-<span class="mi">1</span> \o g^-<span class="mi">1</span>) = &#39;oinv_(g \o f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">rewrite</span> oinv_comp -!oliftV. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_Inv.Build aT sT (g \o f) some_comp_inv.
<span class="kn">Lemma</span> <span class="nf">inv_comp</span> : (g \o f)^-<span class="mi">1</span> = f^-<span class="mi">1</span> \o g^-<span class="mi">1</span>. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">OInv</span>.

<span class="kn">Lemma</span> <span class="nf">comp_can_subproof</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) (<span class="nv">g</span> : {inj B &gt;-&gt; sT}) :
  OInv_Can aT sT A (g \o f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x Ax; <span class="nb">rewrite</span> oinv_comp/= funoK <span class="nl">?mem_fun</span>//= funoK. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := comp_can_subproof f g.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) (<span class="nv">g</span> : {injfun B &gt;-&gt; C}) :=
  Inject.on (g \o f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinjfun A &gt;-&gt; B})
  (<span class="nv">g</span> : {splitinj B &gt;-&gt; sT}) := Inject.on (g \o f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinjfun A &gt;-&gt; B})
  (<span class="nv">g</span> : {splitinjfun B &gt;-&gt; C}) := Inject.on (g \o f).
<span class="kn">End</span> <span class="nf">Composition</span>.

<span class="kn">Section</span> <span class="nf">Composition</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">sT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">C</span> : <span class="nb">set</span> sT}.

<span class="kn">Lemma</span> <span class="nf">comp_surj_subproof</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) (<span class="nv">g</span> : {surj B &gt;-&gt; C}) :
  OInv_CanV _ _ A C (g \o f).
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: funS.
<span class="nb">apply</span>: (@ocan_in_comp _ _ _ (mem B)) oinvK oinvK.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? /set_mem; <span class="nb">rewrite</span> pred_oapp_set inE; <span class="nb">apply</span>: funS.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := comp_surj_subproof f g.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurj A &gt;-&gt; B}) (<span class="nv">g</span> : {splitsurj B &gt;-&gt; C}) :=
  Surject.on (g \o f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; B}) (<span class="nv">g</span> : {surjfun B &gt;-&gt; C}) :=
  Surject.on (g \o f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurjfun A &gt;-&gt; B})
  (<span class="nv">g</span> : {splitsurjfun B &gt;-&gt; C}) := Surject.on (g \o f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) (<span class="nv">g</span> : {bij B &gt;-&gt; C}) :=
  Surject.on (g \o f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitbij A &gt;-&gt; B}) (<span class="nv">g</span> : {splitbij B &gt;-&gt; C}) :=
  Surject.on (g \o f).

<span class="kn">End</span> <span class="nf">Composition</span>.

<span class="kn">Section</span> <span class="nf">totalfun</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>}.
<span class="kn">Definition</span> <span class="nf">totalfun_</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT) := f.
<span class="kn">Context</span> {<span class="nv">A</span> : <span class="nb">set</span> aT}.
<span class="kn">Local Notation</span> <span class="nf">totalfun</span> := (totalfun_ A).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : aT -&gt; rT) :=
  IsFun.Build _ _ A setT (totalfun f) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inj A &gt;-&gt; rT}) := Inject.on (totalfun f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinj A &gt;-&gt; rT}) := SplitInj.on (totalfun f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surj A &gt;-&gt; [<span class="nb">set</span>: rT]}) :=
  Surject.on (totalfun f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurj A &gt;-&gt; [<span class="nb">set</span>: rT]}) :=
  SplitSurj.on (totalfun f).
<span class="kn">End</span> <span class="nf">totalfun</span>.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;totalfun_&#39; A&quot;</span> := (totalfun_ A) : form_scope.
<span class="kn">Notation</span> <span class="nf">totalfun</span> := (totalfun_ setT).

<span class="kn">Section</span> <span class="nf">Olift</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT}.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} := OInversible.on (olift f).

<span class="kn">Lemma</span> <span class="nf">oinv_olift</span>  {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} : &#39;oinv_(olift f) = obind &#39;oinv_f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inj A &gt;-&gt; rT}) :=
  Inject.copy (olift f) (olift (&#39;totalfun_A f)).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) := Surject.on (olift f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) := Fun.on (olift f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinvfun A &gt;-&gt; B}) := Fun.on (olift f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) := Fun.on (olift f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; B}) := Fun.on (olift f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) := Fun.on (olift f).

<span class="kn">End</span> <span class="nf">Olift</span>.

<span class="kn">Section</span> <span class="nf">Map</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT}.
<span class="kn">Local Notation</span> <span class="nf">m</span> f := (obind (olift f)).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) := Fun.copy (omap f) (m f).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} :=
  Inv.Build _ _ (omap f) (obind &#39;oinv_f).

<span class="kn">Lemma</span> <span class="nf">inv_omap</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} : (omap f)^-<span class="mi">1</span> = obind &#39;oinv_f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">oinv_omap</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}} : &#39;oinv_(omap f) = olift (obind &#39;oinv_f).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">omapV</span> {<span class="nv">f</span> : {inv aT &gt;-&gt; rT}} : omap f^-<span class="mi">1</span> = (omap f)^-<span class="mi">1</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> inv_omap -oliftV. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinvfun A &gt;-&gt; B}) := Fun.on (omap f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inj A &gt;-&gt; rT}) := Inject.copy (omap f) (m f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) := Fun.on (omap f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) := Surject.copy (omap f) (m f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; B}) := Fun.on (omap f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) := Fun.on (omap f).
<span class="kn">End</span> <span class="nf">Map</span>.

<span class="sd">(************)</span>
<span class="c">(* Builders *)</span>
<span class="sd">(************)</span>

HB.factory <span class="kn">Record</span> <span class="nf">CanV</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) :=
  { inv; invS : {homo inv : x / B x &gt;-&gt; A x}; invK : {<span class="kr">in</span> B, cancel inv f}; }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">CanV</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span>.
 HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv.Build _ _ f inv.
 HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv_CanV.Build _ _ _ _ f invS invK.
HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">OInv_Can2</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span>
  @OInv _ _ f :=
  {
    funS :  {homo f : x / A x &gt;-&gt; B x};
    oinvS : {homo &#39;oinv_f : x / B x &gt;-&gt; (some @` A) x};
    funoK : {<span class="kr">in</span> A, pcancel f &#39;oinv_f};
    oinvK : {<span class="kr">in</span> B, ocancel &#39;oinv_f f};
  }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">OInv_Can2</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := IsFun.Build aT rT _ _ f funS.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_Can.Build aT rT _ f funoK.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_CanV.Build aT rT _ _ f oinvS oinvK.
HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">OCan2</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) :=
   { oinv; funS :  {homo f : x / A x &gt;-&gt; B x};
           oinvS : {homo oinv : x / B x &gt;-&gt; (some @` A) x};
           funoK : {<span class="kr">in</span> A, pcancel f oinv};
           oinvK : {<span class="kr">in</span> B, ocancel oinv f};
   }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">OCan2</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv.Build aT rT f oinv.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_Can2.Build aT rT _ _ f funS oinvS funoK oinvK.
HB.<span class="kr">end</span>.


HB.factory <span class="kn">Record</span> <span class="nf">Can</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} (<span class="nv">f</span> : aT -&gt; rT) :=
  { inv; funK : {<span class="kr">in</span> A, cancel f inv} }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} <span class="nv">A</span> (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> @Can _ _ A f. <span class="c">(* bug if swap f and A *)</span>
 HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv.Build _ _ f inv.
 HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv_Can.Build _ _ _ f funK.
HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">Inv_Can2</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span>
   <span class="nv">Inv</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">f</span> :=
   { funS : {homo f : x / A x &gt;-&gt; B x};
     invS : {homo f^-<span class="mi">1</span> : x / B x &gt;-&gt; A x};
     funK : {<span class="kr">in</span> A, cancel f f^-<span class="mi">1</span>};
     invK : {<span class="kr">in</span> B, cancel f^-<span class="mi">1</span> f};
   }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">Inv_Can2</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := IsFun.Build aT rT A B f funS.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv_Can.Build aT rT A f funK.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := @Inv_CanV.Build aT rT A B f invS invK.
HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">Can2</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) :=
  { inv; funS : {homo f : x / A x &gt;-&gt; B x};
         invS : {homo inv : x / B x &gt;-&gt; A x};
         funK : {<span class="kr">in</span> A, cancel f inv};
         invK : {<span class="kr">in</span> B, cancel inv f};
   }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">Can2</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv.Build aT rT f inv.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv_Can2.Build aT rT A B f funS invS funK invK.
HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">SplitInjFun_CanV</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span>
     @SplitInjFun _ _ A B f :=
  { invS : {homo f^-<span class="mi">1</span> : x / B x &gt;-&gt; A x}; injV : {<span class="kr">in</span> B &amp;, injective f^-<span class="mi">1</span>} }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">SplitInjFun_CanV</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span>.
  <span class="kn">Let</span> <span class="nf">mem_inv</span> := homo_setP.<span class="mi">2</span> invS.
  <span class="kn">Local Lemma</span> <span class="nf">invK</span> : {<span class="kr">in</span> B, cancel f^-<span class="mi">1</span> f}.
  <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x Bx; <span class="nb">apply</span>: injV; <span class="nb">rewrite</span> <span class="nl">?funK</span> ?(mem_fun, mem_inv). <span class="kn">Qed</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv_CanV.Build aT rT A B f invS invK.
HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">BijTT</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">f</span> : aT -&gt; rT) := { bij : bijective f }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} <span class="nv">f</span> <span class="nv">of</span> <span class="nv">BijTT</span> <span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">f</span>.
  <span class="kn">Local Lemma</span> <span class="nf">exg</span> : {g | cancel f g /\ cancel g f}.
  <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: cid; <span class="nb">case</span>: bij =&gt; g; <span class="kr">exists</span> <span class="nv">g</span>. <span class="kn">Qed</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Can2.Build aT rT setT setT f
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; y) (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; y)
    (in1W (projT2 exg).<span class="mi">1</span>) (in1W (projT2 exg).<span class="mi">2</span>).
HB.<span class="kr">end</span>.

<span class="sd">(**********)</span>
<span class="c">(* Fun in *)</span>
<span class="sd">(**********)</span>

<span class="kn">Section</span> <span class="nf">surj_oinv</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : aT -&gt; rT} (<span class="nv">fsurj</span> : set_surj A B f).

<span class="kn">Let</span> <span class="nf">surjective_oinv</span> (<span class="nv">y</span> : rT) :=
  <span class="kr">if</span> pselect (B y) <span class="kr">is</span> <span class="nb">left</span> By <span class="kr">then</span> some (projT1 (cid2 (fsurj By))) <span class="kr">else</span> None.

<span class="kn">Lemma</span> <span class="nf">surjective_oinvK</span> : {<span class="kr">in</span> B, ocancel surjective_oinv f}.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> /surjective_oinv =&gt; x /set_mem ?; <span class="nb">case</span>: pselect =&gt; // ?; <span class="nb">case</span>: cid2.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surjective_oinvS</span> : set_fun B (some @` A) surjective_oinv.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; y By /=; <span class="nb">rewrite</span> /surjective_oinv; <span class="nb">case</span>: pselect =&gt; // By&#39;.
<span class="bp">by</span> <span class="nb">case</span>: cid2 =&gt; //= x Ax fxy; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">surj_oinv</span>.
<span class="kn">Coercion</span> <span class="nf">surjective_ocanV</span> {aT rT} {A : <span class="nb">set</span> aT} {B : <span class="nb">set</span> rT} {f : aT -&gt; rT}
    (fS : set_surj A B f) :=
  OCanV.Build aT rT A B f (surjective_oinvS fS) (surjective_oinvK fS).

<span class="kn">Section</span> <span class="nf">Psurj</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : aT -&gt; rT} (<span class="nv">fsurj</span> : set_surj A B f).

#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> : OCanV _ _ A B f := fsurj.
<span class="kn">Definition</span> <span class="nf">surjection_of_surj</span> := [surj of f].

<span class="kn">Lemma</span> <span class="nf">Psurj</span> : {s : {surj A &gt;-&gt; B} | f = s}. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [surj of f]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">Psurj</span>.
<span class="kn">Coercion</span> <span class="nf">surjection_of_surj</span> : set_surj &gt;-&gt; Surject.type.

<span class="kn">Lemma</span> <span class="nf">oinv_surj</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : aT -&gt; rT}
   (<span class="nv">fS</span> : set_surj A B f) <span class="nv">y</span> :
 &#39;oinv_fS y = <span class="kr">if</span> pselect (B y) <span class="kr">is</span> <span class="nb">left</span> By <span class="kr">then</span> some (projT1 (cid2 (fS y By))) <span class="kr">else</span> None.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surj</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {surj A &gt;-&gt; B}} : set_surj A B f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; b /&#39;oinvP_f[x Ax _]; <span class="kr">exists</span> <span class="nv">x</span>. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">phant_surj</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : {surj A &gt;-&gt; B})
  <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @surj _ _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;surj_  f&quot;</span> := (phant_surj (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (set_surj _ _ _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: surj] : core.

<span class="kn">Section</span> <span class="nf">funin_surj</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>}.

<span class="kn">Definition</span> <span class="nf">funin</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT) := f.

<span class="kn">Context</span> {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT).

<span class="kn">Lemma</span> <span class="nf">set_fun_image</span> : set_fun A (f @` A) f.
<span class="kn">Proof</span>. <span class="bp">exact</span>/image_subP. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> :=
  @IsFun.Build _ _ _ _ (funin A f) set_fun_image.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> : OCanV _ _ A (f @` A) (funin A f) :=
   ((<span class="kr">fun</span> <span class="nv">_</span> =&gt; id) : set_surj A (f @` A) f).

<span class="kn">End</span> <span class="nf">funin_surj</span>.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;fun&#39; f &#39;in&#39; A ]&quot;</span> := (funin A f)
  (<span class="kn">at level</span> <span class="mi">0</span>, f <span class="kn">at next level</span>,
   <span class="kn">format</span> <span class="s2">&quot;[ &#39;fun&#39;  f  &#39;in&#39;  A ]&quot;</span>) : function_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> set_fun_image : core.

<span class="sd">(*********************)</span>
<span class="c">(* Partial injection *)</span>
<span class="sd">(*********************)</span>

<span class="kn">Section</span> <span class="nf">split</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT).
<span class="kn">Definition</span> <span class="nf">split_</span> (<span class="nv">dflt</span> : rT -&gt; aT) (<span class="nv">f</span> : aT -&gt; rT) := f.

<span class="kn">Context</span> (<span class="nv">dflt</span> : rT -&gt; aT).
<span class="kn">Local Notation</span> <span class="nf">split</span> := (split_ dflt).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) := Fun.on (<span class="nb">split</span> f).

<span class="kn">Section</span> <span class="nf">oinv</span>.
<span class="kn">Context</span> (<span class="nv">f</span> : {oinv aT &gt;-&gt; rT}).
<span class="kn">Let</span> <span class="nf">g</span> <span class="nv">y</span> := odflt (dflt y) (&#39;oinv_f y).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span>  := Inv.Build _ _ (<span class="nb">split</span> f) g.
<span class="kn">Lemma</span> <span class="nf">splitV</span> : (<span class="nb">split</span> f)^-<span class="mi">1</span> = g. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">oinv</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinvfun A &gt;-&gt; B}) := Fun.on (<span class="nb">split</span> f).

<span class="kn">Lemma</span> <span class="nf">splitis_inj_subproof</span> (<span class="nv">f</span> : {inj A &gt;-&gt; rT}) : Inv_Can _ _ A (<span class="nb">split</span> f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x Ax; <span class="nb">rewrite</span> splitV funoK. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := splitis_inj_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) := Inject.on (<span class="nb">split</span> f).

<span class="kn">Lemma</span> <span class="nf">splitid</span> (<span class="nv">f</span> : {splitinjfun A &gt;-&gt; B}) : (<span class="nb">split</span> f)^-<span class="mi">1</span> = f^-<span class="mi">1</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; x; <span class="nb">apply</span>: Some_inj; <span class="nb">rewrite</span> splitV -oliftV. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">splitsurj_subproof</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) : Inv_CanV _ _ A B (<span class="nb">split</span> f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; [+|+ /set_mem] =&gt; b Bb; <span class="nb">rewrite</span> splitV; <span class="nb">case</span>: oinvP. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := splitsurj_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; B}) := Surject.on (<span class="nb">split</span> f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) := Surject.on (<span class="nb">split</span> f).

<span class="kn">End</span> <span class="nf">split</span>.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;split_&#39; a&quot;</span> := (split_ a) : form_scope.
<span class="kn">Notation</span> <span class="nf">split</span> := &#39;split_point.

<span class="sd">(*****************)</span>
<span class="c">(* More Builders *)</span>
<span class="sd">(*****************)</span>

HB.factory <span class="kn">Record</span> <span class="nf">Inj</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT) :=
   { inj : {<span class="kr">in</span> A &amp;, injective f} }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} <span class="nv">A</span> (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span> <span class="nv">Inj</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">A</span> <span class="nv">f</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInversible.copy f [<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">in</span> <span class="nv">A</span>].
  <span class="kn">Lemma</span> <span class="nf">funoK</span> : {<span class="kr">in</span> A, pcancel f &#39;oinv_f}.
  <span class="kn">Proof</span>.
  <span class="nb">move</span>=&gt; x /set_mem Ax; <span class="nb">rewrite</span> oinv_surj.
  <span class="nb">case</span>: pselect =&gt; //=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>; <span class="kr">exists</span> <span class="nv">x</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">case</span>: cid2 =&gt; //= y Ay /inj; <span class="nb">rewrite</span> !inE =&gt; -&gt;.
  <span class="kn">Qed</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_Can.Build _ _ _ f funoK.
HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">SurjFun_Inj</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span>
   @SurjFun _ _ A B f := { inj : {<span class="kr">in</span> A &amp;, injective f} }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span>
    @SurjFun_Inj _ _ A B f.
  <span class="kn">Let</span> <span class="nf">g</span> := f.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inj.Build _ _ A g inj.
  <span class="kn">Let</span> <span class="nf">fcan</span> : OInv_Can aT rT A f.
  <span class="kn">Proof</span>.
  <span class="nb">split</span>=&gt; x /set_mem Ax; <span class="nb">apply</span>: &#39;inj_(omap g); <span class="nb">rewrite</span> <span class="nl">?mem_fun</span> <span class="nl">?inE</span>//=.
  <span class="bp">by</span> <span class="nb">rewrite</span> /g -oinvV/= funoK// <span class="nl">?mem_fun</span> <span class="nl">?inE</span>.
  <span class="kn">Qed</span>.
 HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := fcan.
HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">SplitSurjFun_Inj</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span>
     @SplitSurjFun _ _ A B f :=
   { inj : {<span class="kr">in</span> A &amp;, injective f} }.
HB.builders <span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">of</span>
    @SplitSurjFun_Inj _ _ A B f.
  <span class="kn">Local Lemma</span> <span class="nf">funK</span> : {<span class="kr">in</span> A, cancel f f^-<span class="mi">1</span>%FUN}.
  <span class="kn">Proof</span>.  <span class="bp">by</span> <span class="nb">move</span>=&gt; x Ax; <span class="nb">apply</span>: inj; <span class="nb">rewrite</span> <span class="nl">?invK</span> <span class="nl">?mem_fun</span>. <span class="kn">Qed</span>.
  HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv_Can.Build aT rT _ f funK.
HB.<span class="kr">end</span>.

<span class="kn">Section</span> <span class="nf">Inverses</span>.
<span class="kn">Context</span> <span class="nv">aT</span> <span class="nv">rT</span> {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT}.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inj A &gt;-&gt; rT}) :=
  SurjFun_Inj.Build _ _ _ _ [<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">in</span> <span class="nv">A</span>] &#39;inj_f.
<span class="kn">End</span> <span class="nf">Inverses</span>.

<span class="sd">(********************)</span>
<span class="c">(* Simple Factories *)</span>
<span class="sd">(********************)</span>

<span class="kn">Section</span> <span class="nf">Pinj</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">f</span> : aT -&gt; rT} (<span class="nv">finj</span> : {<span class="kr">in</span> A &amp;, injective f}).
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inj.Build _ _ _ f finj.
<span class="kn">Lemma</span> <span class="nf">Pinj</span> : {i : {inj A &gt;-&gt; rT} | f = i}. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [inj of f]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">Pinj</span>.

<span class="kn">Section</span> <span class="nf">Pfun</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : aT -&gt; rT}
  (<span class="nv">ffun</span> : {homo f : x / A x &gt;-&gt; B x}).
<span class="kn">Let</span> <span class="nf">g</span> : _ -&gt; _ := f.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := IsFun.Build _ _ _ _ g ffun.
<span class="kn">Lemma</span> <span class="nf">Pfun</span> : {i : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B} | f = i}. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">g</span>]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">Pfun</span>.

<span class="kn">Section</span> <span class="nf">injPfun</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {inj A &gt;-&gt; rT}}
   (<span class="nv">ffun</span> : {homo f : x / A x &gt;-&gt; B x}).
<span class="kn">Let</span> <span class="nf">g</span> : _ -&gt; _ := f.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inject.on g.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := IsFun.Build _ _ A B g ffun.
<span class="kn">Lemma</span> <span class="nf">injPfun</span> : {i : {injfun A &gt;-&gt; B} | f = i :&gt; (_ -&gt; _)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [injfun of g]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">injPfun</span>.

<span class="kn">Section</span> <span class="nf">funPinj</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}}
  (<span class="nv">finj</span> : {<span class="kr">in</span> A &amp;, injective f}).
<span class="kn">Let</span> <span class="nf">g</span> : _ -&gt; _ := f.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Fun.on g.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inj.Build _ _ _ g finj.
<span class="kn">Lemma</span> <span class="nf">funPinj</span> : {i : {injfun A &gt;-&gt; B} | f = i}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [injfun of g]; <span class="nb">apply</span>/funP. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">funPinj</span>.

<span class="kn">Section</span> <span class="nf">funPsurj</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}}
        (<span class="nv">fsurj</span> : set_surj A B f).
<span class="kn">Let</span> <span class="nf">g</span> : _ -&gt; _ := f.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Fun.on g.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> : OCanV _ _ A B g := fsurj.
<span class="kn">Lemma</span> <span class="nf">funPsurj</span> : {s : {surjfun A &gt;-&gt; B} | f = s}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [surjfun of g]; <span class="nb">apply</span>/funP. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">funPsurj</span>.

<span class="kn">Section</span> <span class="nf">surjPfun</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {surj A &gt;-&gt; B}}
   (<span class="nv">ffun</span> : {homo f : x / A x &gt;-&gt; B x}).
<span class="kn">Let</span> <span class="nf">g</span> : _ -&gt; _ := f.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Surject.on g.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := IsFun.Build _ _ A B g ffun.
<span class="kn">Lemma</span> <span class="nf">surjPfun</span> : {s : {surjfun A &gt;-&gt; B} | f = s :&gt; (_ -&gt; _)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [surjfun of g]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">surjPfun</span>.

<span class="kn">Section</span> <span class="nf">Psplitinj</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">f</span> : aT -&gt; rT} {<span class="nv">g</span>} (<span class="nv">funK</span> : {<span class="kr">in</span> A, cancel f g}).
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Can.Build _ _ A f funK.
<span class="kn">Lemma</span> <span class="nf">Psplitinj</span> : {i : {splitinj A &gt;-&gt; rT} | f = i}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [splitinj of f]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">Psplitinj</span>.

<span class="kn">Section</span> <span class="nf">funPsplitinj</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}}.
<span class="kn">Context</span> {<span class="nv">g</span>} (<span class="nv">funK</span> : {<span class="kr">in</span> A, cancel f g}).
<span class="kn">Let</span> <span class="nf">f&#39;</span> : _ -&gt; _ := f.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Fun.on f&#39;.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Can.Build _ _ A f&#39; funK.
<span class="kn">Lemma</span> <span class="nf">funPsplitinj</span> : {i : {splitinjfun A &gt;-&gt; B} | f = i}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [splitinjfun of f&#39;]; <span class="nb">apply</span>/funP. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">funPsplitinj</span>.

<span class="kn">Lemma</span> <span class="nf">PsplitinjT</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">f</span> : aT -&gt; rT} {<span class="nv">g</span>} : cancel f g -&gt;
  {i : {splitinj [<span class="nb">set</span>: aT] &gt;-&gt; rT} | f = i}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/in1W/Psplitinj. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">funPsplitsurj</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}}.
<span class="kn">Context</span> {<span class="nv">g</span> : {<span class="kr">fun</span> <span class="nv">B</span> &gt;-&gt; A}} (<span class="nv">funK</span> : {<span class="kr">in</span> B, cancel g f}).
<span class="kn">Let</span> <span class="nf">f&#39;</span> : _ -&gt; _ := f.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Fun.on f&#39;.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := CanV.Build _ _ A B f&#39; funS funK.
<span class="kn">Lemma</span> <span class="nf">funPsplitsurj</span> : {s : {splitsurjfun A &gt;-&gt; B} | f = s :&gt; (_ -&gt; _)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [splitsurjfun of f&#39;]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">funPsplitsurj</span>.

<span class="kn">Lemma</span> <span class="nf">PsplitsurjT</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">f</span> : aT -&gt; rT} {<span class="nv">g</span>} : cancel g f -&gt;
  {s : {splitsurjfun [<span class="nb">set</span>: aT] &gt;-&gt; [<span class="nb">set</span>: rT]} | f = s}.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>/in1W/(@funPsplitsurj _ _ _ _ [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">totalfun</span> <span class="nv">f</span>] [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">totalfun</span> <span class="nv">g</span>]).
<span class="kn">Qed</span>.

<span class="sd">(*************)</span>
<span class="c">(* Instances *)</span>
<span class="sd">(*************)</span>

<span class="sd">(*************************************)</span>
<span class="c">(* The identity is a split bijection *)</span>
<span class="sd">(*************************************)</span>

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">T</span> <span class="nv">A</span> := @Can2.Build T T A A idfun idfun
   (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; y) (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; y) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; erefl) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; erefl).

<span class="sd">(**********************************************************)</span>
<span class="c">(* Iteration preserves Fun, Injectivity, and Surjectivity *)</span>
<span class="sd">(**********************************************************)</span>
<span class="kn">Section</span> <span class="nf">iter_inv</span>.

<span class="kn">Context</span> {<span class="nv">aT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT}.

<span class="kn">Local Lemma</span> <span class="nf">iter_fun_subproof</span> <span class="nv">n</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; A}) : IsFun _ _ A A (iter n f).
<span class="kn">Proof</span>. 
<span class="nb">split</span> =&gt; x; <span class="nb">elim</span>: n =&gt; // n /[<span class="nb">apply</span>] ?; <span class="nb">apply</span>/(fun_image_sub f).
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">iter</span> <span class="nv">n</span> <span class="nv">f</span> <span class="nv">x</span>).
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> <span class="nv">f</span> := iter_fun_subproof n f.

<span class="kn">Section</span> <span class="nf">OInv</span>.
<span class="kn">Context</span> {<span class="nv">f</span> : {oinv aT &gt;-&gt; aT}}.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> := OInv.Build _ _ (iter n f) 
  (iter n (obind &#39;oinv_f) \o some).
<span class="kn">Lemma</span> <span class="nf">oinv_iter</span> <span class="nv">n</span> : &#39;oinv_(iter n f) = iter n (obind &#39;oinv_f) \o some.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">OInv</span>.

<span class="kn">Section</span> <span class="nf">OInv</span>.
<span class="kn">Context</span> {<span class="nv">f</span> : {inv aT &gt;-&gt; aT}}.
<span class="kn">Lemma</span> <span class="nf">some_iter_inv</span> <span class="nv">n</span> : olift (iter n f^-<span class="mi">1</span>) = &#39;oinv_(iter n f).
<span class="kn">Proof</span>.
<span class="nb">elim</span>: n =&gt; // n IH; <span class="nb">rewrite</span> iterfSr olift_comp IH <span class="nl">?oinv_iter</span> -compA.
<span class="nb">rewrite</span> (_ : Some \o f^-<span class="mi">1</span> = &#39;oinv_f); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> iterfSr; <span class="nb">congr</span> (_ \o _).
<span class="bp">by</span> <span class="nb">apply</span>/funeqP =&gt; ? /=; <span class="nb">rewrite</span> some_inv.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> := OInv_Inv.Build _ _ (iter n f) (some_iter_inv n).
<span class="kn">Lemma</span> <span class="nf">inv_iter</span> <span class="nv">n</span> : (iter n f)^-<span class="mi">1</span> = iter n f^-<span class="mi">1</span>. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">OInv</span>.

<span class="kn">Lemma</span> <span class="nf">iter_can_subproof</span> <span class="nv">n</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; A}) : OInv_Can aT aT A (iter n f).
<span class="kn">Proof</span>. 
<span class="nb">split</span>=&gt; x Ax; <span class="nb">rewrite</span> oinv_iter /=; <span class="nb">elim</span>: n=&gt; // n IH.
<span class="nb">rewrite</span> iterfSr /= funoK //; <span class="bp">exact</span>: mem_fun. 
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := iter_can_subproof f g.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; A}) := Inject.on (iter n f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> (<span class="nv">f</span> : {splitinjfun A &gt;-&gt; A}) := Inject.on (iter n f).
<span class="kn">End</span> <span class="nf">iter_inv</span>.

<span class="kn">Section</span> <span class="nf">iter_surj</span>.
<span class="kn">Context</span> {<span class="nv">aT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT}.

<span class="kn">Lemma</span> <span class="nf">iter_surj_subproof</span> <span class="nv">n</span> (<span class="nv">f</span> : {surj A &gt;-&gt; A}) : OInv_CanV _ _ A A (iter n f).
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: funS.
<span class="nb">elim</span>: n=&gt; // n IH; <span class="nb">rewrite</span> oinv_iter iterfSr iterfS.
<span class="nb">apply</span>: (@ocan_in_comp _ _ _ (mem A)) =&gt; //; <span class="nb">last</span> <span class="bp">exact</span>: oinvK.
<span class="nb">elim</span>: n {IH} =&gt; // n IH x Ax; <span class="nb">move</span>: (IH _ Ax); <span class="nb">rewrite</span> pred_oapp_set <span class="nl">?inE</span>.
<span class="nb">case</span>=&gt; y Ay /= ynf; <span class="nb">case</span>: (@oinvS _ _ _ _ f _ Ay) =&gt; z ? zfinv; <span class="kr">exists</span> <span class="nv">z</span> =&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> zfinv /= -ynf.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> <span class="nv">f</span> := iter_surj_subproof n f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> (<span class="nv">f</span> : {splitsurj A &gt;-&gt; A}) := Surject.on (iter n f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; A}) := Surject.on (iter n f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> (<span class="nv">f</span> : {splitsurjfun A &gt;-&gt; A}) :=
  Surject.on (iter n f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> (<span class="nv">f</span> : {bij A &gt;-&gt; A}) := Surject.on (iter n f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> (<span class="nv">f</span> : {splitbij A &gt;-&gt; A}) := Surject.on (iter n f).

<span class="kn">End</span> <span class="nf">iter_surj</span>.

<span class="sd">(**********)</span>
<span class="c">(* Unbind *)</span>
<span class="sd">(**********)</span>

<span class="kn">Section</span> <span class="nf">Unbind</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">dflt</span> : aT -&gt; rT).
<span class="kn">Definition</span> <span class="nf">unbind</span> (<span class="nv">f</span> : aT -&gt; option rT) <span class="nv">x</span> := odflt (dflt x) (f x).

<span class="kn">Lemma</span> <span class="nf">unbind_fun_subproof</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; some @` B}) : IsFun _ _ A B (unbind f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /unbind; <span class="nb">split</span>=&gt; x /&#39;funS_f [y Bu &lt;-]. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := unbind_fun_subproof f.

<span class="kn">Section</span> <span class="nf">Oinv</span>.
<span class="kn">Context</span> (<span class="nv">f</span> : {oinv aT &gt;-&gt; option rT}).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv.Build _ _ (unbind f) (&#39;oinv_f \o some).

<span class="kn">Lemma</span> <span class="nf">oinv_unbind</span> : &#39;oinv_(unbind f) = &#39;oinv_f \o some. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">Oinv</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinvfun A &gt;-&gt; some @` B}) := Fun.on (unbind f).

<span class="kn">Section</span> <span class="nf">Inv</span>.
<span class="kn">Context</span> (<span class="nv">f</span> : {inv aT &gt;-&gt; option rT}).
<span class="kn">Lemma</span> <span class="nf">inv_unbind_subproof</span> : olift (f^-<span class="mi">1</span> \o some) = &#39;oinv_(unbind f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> olift_comp oliftV. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv_Inv.Build _ _ (unbind f) inv_unbind_subproof.

<span class="kn">Lemma</span> <span class="nf">inv_unbind</span> : (unbind f)^-<span class="mi">1</span> = f^-<span class="mi">1</span> \o some. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">Inv</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {invfun A &gt;-&gt; some @` B}) := Fun.on (unbind f).

<span class="kn">Lemma</span> <span class="nf">unbind_inj_subproof</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; some @` B}) :
   @OInv_Can _ _ A (unbind f).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; x Ax; <span class="nb">rewrite</span> oinv_unbind /unbind/=; <span class="nb">have</span> &lt;- := &#39;funoK_f Ax.
<span class="bp">by</span> <span class="nb">have</span> [y By /= &lt;-] := &#39;funS_f (set_mem Ax).
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := unbind_inj_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinjfun A &gt;-&gt; some @` B}) :=
  Inject.on (unbind f).

<span class="kn">Lemma</span> <span class="nf">unbind_surj_subproof</span> (<span class="nv">f</span> : {surj A &gt;-&gt; some @` B}) :
   @OInv_CanV _ _ A B (unbind f).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [b|b /set_mem] Bb; <span class="nb">rewrite</span> oinv_unbind /unbind/=.
  <span class="bp">by</span> <span class="nb">case</span>: oinvP =&gt; [|a]; [<span class="kr">exists</span> <span class="nv">b</span> | <span class="kr">exists</span> <span class="nv">a</span>].
<span class="bp">by</span> <span class="nb">case</span>: oinvP =&gt; [|a Aa /= -&gt;]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">b</span>.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := unbind_surj_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; some @` B}) :=
  Surject.on (unbind f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurj A &gt;-&gt; some @` B}) :=
  Surject.on (unbind f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurjfun A &gt;-&gt; some @` B}) :=
  Surject.on (unbind f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij A &gt;-&gt; some @` B}) := Surject.on (unbind f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitbij A &gt;-&gt; some @` B}) := Bij.on (unbind f).

<span class="kn">End</span> <span class="nf">Unbind</span>.

<span class="sd">(*********)</span>
<span class="c">(* Odflt *)</span>
<span class="sd">(*********)</span>

<span class="kn">Section</span> <span class="nf">Odflt</span>.
<span class="kn">Context</span> {<span class="nv">T</span>} {<span class="nv">A</span> : <span class="nb">set</span> T} (<span class="nv">x</span> : T).

<span class="kn">Lemma</span> <span class="nf">odflt_unbind</span> : odflt x = unbind (<span class="kr">fun</span>=&gt; x) idfun. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv.Build _ _ (odflt x) some.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := SplitBij.copy (odflt x)
  [the {bij some @` A &gt;-&gt; A} of unbind (<span class="kr">fun</span>=&gt; x) idfun].

<span class="kn">End</span> <span class="nf">Odflt</span>.

<span class="sd">(************)</span>
<span class="c">(* Subtypes *)</span>
<span class="sd">(************)</span>

<span class="kn">Section</span> <span class="nf">SubType</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : pred T} (<span class="nv">sT</span> : subType P) (<span class="nv">x0</span> : sT).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv.Build sT T val insub.

<span class="kn">Lemma</span> <span class="nf">oinv_val</span> : &#39;oinv_val = insub. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">val_bij_subproof</span> : OInv_Can2 sT T setT [<span class="nb">set</span>` P] val.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (OInv_Can2.Build _ _ _ _ val (<span class="kr">fun</span> <span class="nv">x</span>  <span class="nv">_</span> =&gt; valP x)
        _ (in1W valK) (in1W (insubK _))).
<span class="bp">by</span> <span class="nb">move</span>=&gt; x Px /=; <span class="kr">exists</span> (<span class="nv">Sub</span> <span class="nv">x</span> <span class="nv">Px</span>) =&gt; //; <span class="nb">rewrite</span> oinv_val insubT.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := val_bij_subproof.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Bij.copy insub &#39;oinv_val.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := SplitBij.copy (insubd x0)
   (odflt x0 \o &#39;split_(<span class="kr">fun</span>=&gt; val x0) insub).

<span class="kn">Lemma</span> <span class="nf">inv_insubd</span> : (insubd x0)^-<span class="mi">1</span> = val. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">SubType</span>.

<span class="sd">(***********)</span>
<span class="c">(* To setT *)</span>
<span class="sd">(***********)</span>

<span class="kn">Definition</span> <span class="nf">to_setT</span> {<span class="nv">T</span>} (<span class="nv">x</span> : T) : [<span class="nb">set</span>: T] :=
  @SigSub _ _ _ x (mem_set I : x \<span class="kr">in</span> setT).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">T</span> := Can.Build T [<span class="nb">set</span>: T] setT to_setT
  ((<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; erefl) : {<span class="kr">in</span> setT, cancel to_setT val}).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">T</span> := IsFun.Build T _ setT setT to_setT (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">T</span> :=
  SplitInjFun_CanV.Build T _ _ _ to_setT (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; I) inj.
<span class="kn">Definition</span> <span class="nf">setTbij</span> {<span class="nv">T</span>} := [splitbij of @to_setT T].

<span class="kn">Lemma</span> <span class="nf">inv_to_setT</span> <span class="nv">T</span> : (@to_setT T)^-<span class="mi">1</span> = val. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="sd">(**********)</span>
<span class="c">(* Subfun *)</span>
<span class="sd">(**********)</span>

<span class="kn">Section</span> <span class="nf">subfun</span>.
<span class="kn">Context</span> {<span class="nv">T</span>} {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T}.

<span class="kn">Definition</span> <span class="nf">subfun</span> (<span class="nv">AB</span> : A `&lt;=` B) (<span class="nv">a</span> : A) : B :=
  SigSub (mem_set (AB _ (set_valP a))).

<span class="kn">Lemma</span> <span class="nf">subfun_inj</span> {<span class="nv">AB</span> : A `&lt;=` B} : injective (subfun AB).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x y /(congr1 val)/= /val_inj. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">AB</span> : A `&lt;=` B) :=
  SurjFun.copy (subfun AB) [<span class="kr">fun</span> <span class="nv">subfun</span> <span class="nv">AB</span> <span class="nv">in</span> <span class="nv">setT</span>].
HB.instance <span class="kn">Definition</span> <span class="nf">_</span>  (<span class="nv">AB</span> : A `&lt;=` B) :=
  SurjFun_Inj.Build A B setT (subfun AB @` setT) (subfun AB) (in2W subfun_inj).

<span class="kn">End</span> <span class="nf">subfun</span>.

<span class="kn">Section</span> <span class="nf">subfun_eq</span>.
<span class="kn">Context</span> {<span class="nv">T</span>} {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T}.

<span class="kn">Lemma</span> <span class="nf">subfun_imageT</span> (<span class="nv">AB</span> : A `&lt;=` B) (<span class="nv">BA</span> : B `&lt;=` A) : subfun AB @` setT = setT.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; x //= _; <span class="kr">exists</span> (<span class="nv">subfun</span> <span class="nv">BA</span> <span class="nv">x</span>) =&gt; //; <span class="bp">exact</span>/val_inj.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subfun_inv_subproof</span> (<span class="nv">AB</span> : A = B) :
  olift (subfun (subsetCW AB)) = &#39;oinv_(subfun (subsetW AB)).
<span class="kn">Proof</span>.
<span class="nb">set</span> g := subfun _; <span class="nb">set</span> f := subfun _; <span class="nb">apply</span>/funext =&gt; x /=.
<span class="nb">apply</span>: &#39;inj_(oapp f x) =&gt; //=.
- <span class="bp">by</span> <span class="nb">rewrite</span> inE/=; <span class="nb">eexists</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> inE/=; <span class="nb">apply</span>: &#39;oinvS_f; <span class="kr">exists</span> (<span class="nv">g</span> <span class="nv">x</span>) =&gt; //; <span class="nb">apply</span>/val_inj.
<span class="nb">rewrite</span> oinvK <span class="nl">?inE</span>//=; <span class="kp">first</span> <span class="bp">exact</span>/val_inj.
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">g</span> <span class="nv">x</span>) =&gt; //; <span class="nb">apply</span>/val_inj.
<span class="kn">Qed</span>.
<span class="c">(* Add a Inj_Can factory *)</span>
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">AB</span> : A = B) :=
  OInv_Inv.Build A B (subfun (subsetW AB)) (subfun_inv_subproof AB).

<span class="kn">End</span> <span class="nf">subfun_eq</span>.

<span class="kn">Section</span> <span class="nf">seteqfun</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>}.

<span class="kn">Definition</span> <span class="nf">seteqfun</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T} (<span class="nv">AB</span> : A = B) := subfun (subsetW AB).

<span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T} (<span class="nv">AB</span> : A = B).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv.Build A B (seteqfun AB) (seteqfun (esym AB)).

<span class="kn">Lemma</span> <span class="nf">seteqfun_can2_subproof</span> : Inv_Can2 A B setT setT (seteqfun AB).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>; <span class="nb">rewrite</span> /seteqfun//; <span class="nb">move</span>=&gt; x _; <span class="nb">apply</span>/val_inj. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := seteqfun_can2_subproof.

<span class="kn">End</span> <span class="nf">seteqfun</span>.

<span class="sd">(*************)</span>
<span class="c">(* Inclusion *)</span>
<span class="sd">(*************)</span>
<span class="kn">Section</span> <span class="nf">incl</span>.
<span class="kn">Context</span>  {<span class="nv">T</span>} {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T}.
<span class="kn">Definition</span> <span class="nf">incl</span> (<span class="nv">AB</span> : A `&lt;=` B) := @id T.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">AB</span> : A `&lt;=` B) := Inv.Build _ _ (incl AB) id.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">AB</span> : A `&lt;=` B) := IsFun.Build _ _ A B (incl AB) AB.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">AB</span> : A `&lt;=` B) :=
  Inv_Can.Build _ _ A (incl AB) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; erefl).

<span class="kn">Definition</span> <span class="nf">eqincl</span> (<span class="nv">AB</span> : A = B) := incl (subsetW AB).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">AB</span> := Inversible.on (eqincl AB).
<span class="kn">Lemma</span> <span class="nf">eqincl_surj</span> <span class="nv">AB</span> : Inv_Can2 _ _ A B (eqincl AB).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; // x; <span class="nb">rewrite</span> /eqincl /incl/= /(_^-<span class="mi">1</span>)/inv/= AB. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">AB</span> := eqincl_surj AB.

<span class="kn">End</span> <span class="nf">incl</span>.
<span class="kn">Notation</span> <span class="nf">inclT</span> A := (incl (@subsetT _ _)).

<span class="sd">(*******************)</span>
<span class="c">(* Ad hoc function *)</span>
<span class="sd">(*******************)</span>

<span class="kn">Section</span> <span class="nf">mkfun</span>.
<span class="kn">Context</span> {<span class="nv">aT</span>} {<span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT}.
<span class="kn">Notation</span> <span class="nf">isfun</span> f := {homo f : x / A x &gt;-&gt; B x}.
<span class="kn">Definition</span> <span class="nf">mkfun</span> <span class="nv">f</span> (<span class="nv">fAB</span> : isfun f) := f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">fAB</span> := @IsFun.Build _ _ A B (@mkfun f fAB) fAB.
<span class="kn">Definition</span> <span class="nf">mkfun_fun</span> <span class="nv">f</span> <span class="nv">fAB</span> := [<span class="kr">fun</span> <span class="nv">of</span> @mkfun f fAB].
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inj A &gt;-&gt; rT}) <span class="nv">fAB</span> := Inject.on (@mkfun f fAB).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinj A &gt;-&gt; rT}) <span class="nv">fAB</span> :=
  SplitInj.on (@mkfun f fAB).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) <span class="nv">fAB</span> :=
  Surject.on (@mkfun f fAB).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurj A &gt;-&gt; B}) <span class="nv">fAB</span> :=
  SplitSurj.on (@mkfun f fAB).
<span class="kn">End</span> <span class="nf">mkfun</span>.

<span class="sd">(***********)</span>
<span class="c">(* set_val *)</span>
<span class="sd">(***********)</span>

<span class="kn">Section</span> <span class="nf">set_val</span>.
<span class="kn">Context</span> {<span class="nv">T</span>} {<span class="nv">A</span> : <span class="nb">set</span> T}.
<span class="kn">Definition</span> <span class="nf">set_val</span> : A -&gt; T := eqincl (set_mem_set A) \o val.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Bij.on set_val.
<span class="kn">Lemma</span> <span class="nf">oinv_set_val</span> : &#39;oinv_set_val = insub. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">set_valE</span> : set_val = val. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">set_val</span>.

#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (set_val _ \<span class="kr">in</span> _)) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: valP] : core.

<span class="sd">(**********)</span>
<span class="c">(* Squash *)</span>
<span class="sd">(**********)</span>

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">T</span> := CanV.Build T $|T| setT setT squash (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I)
                              (in1W unsquashK).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">T</span> := SplitInj.copy (@unsquash T) squash^-<span class="mi">1</span>%FUN.
<span class="kn">Definition</span> <span class="nf">ssquash</span> {<span class="nv">T</span>} := [splitsurj of @squash T].

<span class="sd">(***********************)</span>
<span class="c">(* pickle and unpickle *)</span>
<span class="sd">(***********************)</span>

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">T</span> : countType) :=
  Inj.Build _ _ setT (@choice.pickle T) (in2W (pcan_inj choice.pickleK)).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">T</span> : countType) :=
  IsFun.Build _ _ setT setT (@choice.pickle T) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I).

<span class="sd">(***********)</span>
<span class="c">(* set0fun *)</span>
<span class="sd">(***********)</span>

<span class="kn">Lemma</span> <span class="nf">set0fun_inj</span> {<span class="nv">P</span> <span class="nv">T</span>} : injective (@set0fun P T).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>=&gt; x x0; <span class="nb">have</span> := set_mem x0. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">P</span> <span class="nv">T</span> :=
  Inj.Build (@set0 T) P setT set0fun (in2W set0fun_inj).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">P</span> <span class="nv">T</span> :=
  IsFun.Build _ _ setT setT (@set0fun P T) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I).

<span class="sd">(************)</span>
<span class="c">(* cast_ord *)</span>
<span class="sd">(************)</span>

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> {<span class="nv">m</span> <span class="nv">n</span>} {<span class="nv">eq_mn</span> : m = n} :=
  Can2.Build &#39;I_m &#39;I_n setT setT (cast_ord eq_mn)
    (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I)
    (in1W (cast_ordK _)) (in1W (cast_ordKV _)).

<span class="sd">(************************)</span>
<span class="c">(* enum_val &amp; enum_rank *)</span>
<span class="sd">(************************)</span>

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">T</span> : finType) :=
  Can2.Build T _ setT setT enum_rank (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I)
                                    (in1W enum_rankK) (in1W enum_valK).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">T</span> : finType) :=
  Can2.Build _ T setT setT enum_val (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I)
                                    (in1W enum_valK) (in1W enum_rankK).

<span class="sd">(**************)</span>
<span class="c">(* Finset val *)</span>
<span class="sd">(**************)</span>

<span class="kn">Definition</span> <span class="nf">finset_val</span> {<span class="nv">T</span> : choiceType} {<span class="nv">X</span> : {fset T}} (<span class="nv">x</span> : X) : [<span class="nb">set</span>` X] :=
  exist (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x \<span class="kr">in</span> [<span class="nb">set</span>` X]) (val x) (mem_set (valP x)).
<span class="kn">Definition</span> <span class="nf">val_finset</span> {<span class="nv">T</span> : choiceType} {<span class="nv">X</span> : {fset T}} (<span class="nv">x</span> : [<span class="nb">set</span>` X]) : X :=
  [` set_mem (valP x)]%fset.

<span class="kn">Lemma</span> <span class="nf">finset_valK</span> {<span class="nv">T</span> : choiceType} {<span class="nv">X</span> : {fset T}} :
  cancel (@finset_val T X) val_finset.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">apply</span>/val_inj. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">val_finsetK</span> {<span class="nv">T</span> : choiceType} {<span class="nv">X</span> : {fset T}} :
  cancel (@val_finset T X) finset_val.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">apply</span>/val_inj. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span>  {<span class="nv">T</span> : choiceType} {<span class="nv">X</span> : {fset T}} :=
  Can2.Build X _ setT setT finset_val (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I)
             (in1W finset_valK) (in1W val_finsetK).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span>  {<span class="nv">T</span> : choiceType} {<span class="nv">X</span> : {fset T}} :=
  Can2.Build _ X setT setT val_finset (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I)
             (in1W val_finsetK) (in1W finset_valK).

<span class="sd">(*****************)</span>
<span class="c">(* &#39;I_n and `I_n *)</span>
<span class="sd">(*****************)</span>

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> := Can2.Build _ _ setT setT (@ordII n)
   (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; I) (in1W ordIIK) (in1W IIordK).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">n</span> := SplitBij.copy (@IIord n) (ordII^-<span class="mi">1</span>).

<span class="sd">(***********)</span>
<span class="c">(* Glueing *)</span>
<span class="sd">(***********)</span>

<span class="kn">Definition</span> <span class="nf">glue</span> {<span class="nv">T</span> <span class="nv">T&#39;</span>} {<span class="nv">X</span> <span class="nv">Y</span> : <span class="nb">set</span> T} {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T&#39;}
  <span class="nv">of</span> [disjoint X &amp; Y] &amp; [disjoint A &amp; B] :=
  <span class="kr">fun</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; T&#39;) (<span class="nv">u</span> : T) =&gt; <span class="kr">if</span> u \<span class="kr">in</span> X <span class="kr">then</span> f u <span class="kr">else</span> g u.

<span class="kn">Section</span> <span class="nf">Glue12</span>.
<span class="kn">Context</span> {<span class="nv">T</span> <span class="nv">T&#39;</span>} {<span class="nv">X</span> <span class="nv">Y</span> : <span class="nb">set</span> T} {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T&#39;}.
<span class="kn">Context</span> {<span class="nv">XY</span> : [disjoint X &amp; Y]} {<span class="nv">AB</span> : [disjoint A &amp; B]}.
<span class="kn">Local Notation</span> <span class="nf">gl</span> := (glue XY AB).

<span class="kn">Definition</span> <span class="nf">glue1</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; T&#39;) : {<span class="kr">in</span> X, gl f g =<span class="mi">1</span> f}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> /glue =&gt; -&gt;. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">glue2</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; T&#39;) : {<span class="kr">in</span> Y, gl f g =<span class="mi">1</span> g}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x /set_mem Yx; <span class="nb">rewrite</span> /glue; <span class="nb">case</span>: ifPn =&gt; // /set_mem Xx.
<span class="bp">by</span> <span class="nb">move</span>: XY =&gt; /disj_setPS/(_ x (conj Xx Yx)).
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">Glue12</span>.

<span class="kn">Section</span> <span class="nf">Glue</span>.
<span class="kn">Context</span> {<span class="nv">T</span> <span class="nv">T&#39;</span>} {<span class="nv">X</span> <span class="nv">Y</span> : <span class="nb">set</span> T} {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T&#39;}.
<span class="kn">Context</span> {<span class="nv">XY</span> : [disjoint X &amp; Y]} {<span class="nv">AB</span> : [disjoint A &amp; B]}.
<span class="kn">Local Notation</span> <span class="nf">gl</span> := (glue XY AB).

<span class="kn">Lemma</span> <span class="nf">glue_fun_subproof</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">X</span> &gt;-&gt; A}) (<span class="nv">g</span> : {<span class="kr">fun</span> <span class="nv">Y</span> &gt;-&gt; B}) :
  IsFun T T&#39; (X `|` Y) (A `|` B) (gl f g).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>=&gt; x []xP; [<span class="nb">left</span>; <span class="nb">rewrite</span> glue1|<span class="nb">right</span>; <span class="nb">rewrite</span> glue2];
   <span class="nb">rewrite</span> <span class="nl">?inE</span>//; <span class="nb">apply</span>: funS.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := glue_fun_subproof f g.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> <span class="nv">g</span> : {oinv T &gt;-&gt; T&#39;}) :=
  OInv.Build _ _ (gl f g) (glue AB (eqbRL disj_set_some XY) &#39;oinv_f &#39;oinv_g).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span>  (<span class="nv">f</span> : {oinvfun X &gt;-&gt; A}) (<span class="nv">g</span> : {oinvfun Y &gt;-&gt; B}) :=
  OInversible.on (gl f g).

<span class="kn">Lemma</span> <span class="nf">oinv_glue</span> (<span class="nv">f</span> : {oinv T &gt;-&gt; T&#39;}) (<span class="nv">g</span> : {oinv T &gt;-&gt; T&#39;}) :
  &#39;oinv_(gl f g) = glue AB (eqbRL disj_set_some XY) &#39;oinv_f &#39;oinv_g.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">some_inv_glue_subproof</span> (<span class="nv">f</span> <span class="nv">g</span> : {inv T &gt;-&gt; T&#39;}) :
  some \o (glue AB XY f^-<span class="mi">1</span> g^-<span class="mi">1</span>) = &#39;oinv_(gl f g).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; y; <span class="nb">rewrite</span> oinv_glue /glue /= [LHS]fun_if !some_inv.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> <span class="nv">g</span> : {inv T &gt;-&gt; T&#39;}) :=
  OInv_Inv.Build T T&#39; (gl f g) (some_inv_glue_subproof f g).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {invfun X &gt;-&gt; A}) (<span class="nv">g</span> : {invfun Y &gt;-&gt; B}) :=
  Inversible.on (gl f g).

<span class="kn">Lemma</span> <span class="nf">inv_glue</span> (<span class="nv">f</span> : {invfun X &gt;-&gt; A}) (<span class="nv">g</span> : {invfun Y &gt;-&gt; B}) :
  (gl f g)^-<span class="mi">1</span> = glue AB XY f^-<span class="mi">1</span> g^-<span class="mi">1</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">glueo_can_subproof</span> (<span class="nv">f</span> : {injfun X &gt;-&gt; A}) (<span class="nv">g</span> : {injfun Y &gt;-&gt; B}) :
  OInv_Can _ _ (X `|` Y) (gl f g).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; x; <span class="nb">rewrite</span> inE =&gt; -[] xP; <span class="nb">rewrite</span> oinv_glue.
  <span class="bp">by</span> <span class="nb">rewrite</span> [glue _ _ _ _ x]glue1 <span class="nl">?inE</span>// glue1 <span class="nl">?funoK</span> <span class="nl">?inE</span>//; <span class="nb">apply</span>: funS.
<span class="bp">by</span> <span class="nb">rewrite</span> [glue _ _ _ _ x]glue2 <span class="nl">?inE</span>// glue2 <span class="nl">?funoK</span> <span class="nl">?inE</span>//; <span class="nb">apply</span>: funS.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := glueo_can_subproof f g.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinjfun X &gt;-&gt; A})
  (<span class="nv">g</span> : {splitinjfun Y &gt;-&gt; B}) := Inject.on (gl f g).

<span class="kn">Lemma</span> <span class="nf">glue_canv_subproof</span> (<span class="nv">f</span> : {surj X &gt;-&gt; A}) (<span class="nv">g</span> : {surj Y &gt;-&gt; B}) :
  OInv_CanV _ _ (X `|` Y) (A `|` B) (gl f g).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [z|y /set_mem [] yP]; <span class="nb">rewrite</span> oinv_glue.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; [] zP /=; [<span class="nb">rewrite</span> glue1|<span class="nb">rewrite</span> glue2]; <span class="nb">rewrite</span> <span class="nl">?inE</span>//;
     <span class="nb">case</span>: oinvP=&gt; // x xX _; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; [<span class="nb">left</span>|<span class="nb">right</span>].
- <span class="bp">by</span> <span class="nb">rewrite</span> glue1 <span class="nl">?inE</span>//; <span class="nb">case</span>: oinvP=&gt; //= x xX _; <span class="nb">rewrite</span> glue1 <span class="nl">?inE</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> glue2 <span class="nl">?inE</span>//; <span class="nb">case</span>: oinvP=&gt; //= x xX _; <span class="nb">rewrite</span> glue2 <span class="nl">?inE</span>.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := glue_canv_subproof f g.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun X &gt;-&gt; A}) (<span class="nv">g</span> : {surjfun Y &gt;-&gt; B}) :=
  Surject.on (gl f g).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurj X &gt;-&gt; A}) (<span class="nv">g</span> : {splitsurj Y &gt;-&gt; B}) :=
  Surject.on (gl f g).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurjfun X &gt;-&gt; A}) (<span class="nv">g</span> : {splitsurjfun Y &gt;-&gt; B}) :=
  Surject.on (gl f g).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij X &gt;-&gt; A}) (<span class="nv">g</span> : {bij Y &gt;-&gt; B}) :=
  Surject.on (gl f g).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitbij X &gt;-&gt; A}) (<span class="nv">g</span> : {splitbij Y &gt;-&gt; B}) :=
  Surject.on (gl f g).

<span class="kn">End</span> <span class="nf">Glue</span>.

<span class="sd">(************************************)</span>
<span class="c">(* Z-module addition is a bijection *)</span>
<span class="sd">(************************************)</span>

<span class="kn">Section</span> <span class="nf">addition</span>.
<span class="kn">Context</span> {<span class="nv">V</span> : zmodType} (<span class="nv">x</span> : V).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv.Build V V (+%R x) (+%R (- x)).

<span class="kn">Lemma</span> <span class="nf">inv_addr</span> : (+%R x)^-<span class="mi">1</span> = (+%R (- x)). <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">addr_can2_subproof</span> : Inv_Can2 V V setT setT (+%R x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span> =&gt; // y _; <span class="nb">rewrite</span> inv_addr <span class="nl">?GRing</span>.addKr <span class="nl">?GRing</span>.addNKr. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := addr_can2_subproof.

<span class="kn">End</span> <span class="nf">addition</span>.

<span class="sd">(************************************)</span>
<span class="c">(* Z-module opposite is a bijection *)</span>
<span class="sd">(************************************)</span>

<span class="kn">Section</span> <span class="nf">addition</span>.
<span class="kn">Context</span> {<span class="nv">V</span> : zmodType} (<span class="nv">x</span> : V).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inv.Build V V (-%R) (-%R).

<span class="kn">Lemma</span> <span class="nf">inv_oppr</span> : (-%R)^-<span class="mi">1</span> = (-%R). <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">oppr_can2_subproof</span> : Inv_Can2 V V setT setT (-%R).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span> =&gt; // y _; <span class="nb">rewrite</span> inv_oppr <span class="nl">?GRing</span>.opprK. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := oppr_can2_subproof.

<span class="kn">End</span> <span class="nf">addition</span>.

<span class="sd">(*************)</span>
<span class="c">(* emtpyType *)</span>
<span class="sd">(*************)</span>

<span class="kn">Section</span> <span class="nf">empty</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : emptyType} {<span class="nv">T&#39;</span> : <span class="kt">Type</span>} {<span class="nv">X</span> : <span class="nb">set</span> T}.
<span class="kn">Implicit Type</span> <span class="nf">Y</span> : <span class="nb">set</span> T&#39;.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := OInv.Build _ _ (@any T T&#39;) (<span class="kr">fun</span>=&gt; None).

<span class="kn">Lemma</span> <span class="nf">empty_can_subproof</span> : OInv_Can T T&#39; X any.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x; <span class="nb">rewrite</span> empty_eq0 inE. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := empty_can_subproof.

<span class="kn">Lemma</span> <span class="nf">empty_fun_subproof</span> <span class="nv">Y</span> : IsFun T T&#39; X Y any.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x; <span class="nb">rewrite</span> empty_eq0. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">Y</span> := empty_fun_subproof Y.

<span class="kn">Lemma</span> <span class="nf">empty_canv_subproof</span> : OInv_CanV T T&#39; X set0 any. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := empty_canv_subproof.

<span class="kn">End</span> <span class="nf">empty</span>.

<span class="sd">(************************)</span>
<span class="c">(* Theory of surjection *)</span>
<span class="sd">(************************)</span>

<span class="kn">Section</span> <span class="nf">surj_lemmas</span>.
<span class="kn">Variables</span> <span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>.
<span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : aT -&gt; rT).

<span class="kn">Lemma</span> <span class="nf">surj_id</span> <span class="nv">A</span> : set_surj A A (@idfun aT). <span class="kn">Proof</span>. <span class="bp">exact</span>: surj. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surj_set0</span> <span class="nv">B</span> <span class="nv">f</span> : set_surj set0 B f -&gt; B = set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Bf; <span class="nb">rewrite</span> predeqE =&gt; u; <span class="nb">split</span> =&gt; // /Bf [t []]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surjE</span> <span class="nv">f</span> <span class="nv">A</span> <span class="nv">B</span> : set_surj A B f = (B `&lt;=` f @` A). <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surj_image_eq</span> <span class="nv">B</span> <span class="nv">A</span> <span class="nv">f</span> : f @` A `&lt;=` B -&gt; set_surj A B f -&gt; f @` A = B.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fAB; <span class="nb">rewrite</span> eqEsubset =&gt; BfA. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subl_surj</span> <span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">f</span> : A `&lt;=` A&#39; -&gt; set_surj A B f -&gt; set_surj A&#39; B f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /(@image_subset _ _ f)/(subset_trans _); <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subr_surj</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> <span class="nv">f</span> : B&#39; `&lt;=` B -&gt; set_surj A B f -&gt; set_surj A B&#39; f.
<span class="kn">Proof</span>. <span class="bp">exact</span>: subset_trans. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">can_surj</span> <span class="nv">g</span> <span class="nv">f</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) :
    {<span class="kr">in</span> B, cancel g f} -&gt; g @` B `&lt;=` A -&gt;
  set_surj A B f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; gK gBA y By; <span class="nb">suff</span> : A (g y) <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">g</span> <span class="nv">y</span>); <span class="nb">rewrite</span> <span class="nl">?gK</span> <span class="nl">?inE</span>.
<span class="bp">by</span> <span class="nb">have</span> := image_subP.<span class="mi">1</span> gBA y; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surj_epi</span> <span class="nv">sT</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">g</span> <span class="nv">g&#39;</span> : rT -&gt; sT) :
  set_surj A B f -&gt; {<span class="kr">in</span> A, g \o f =<span class="mi">1</span> g&#39; \o f} -&gt; {<span class="kr">in</span> B, g =<span class="mi">1</span> g&#39;}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fS eqfg y /set_mem By; <span class="nb">suff</span>: B `&lt;=` [<span class="nb">set</span> y | g y = g&#39; y] <span class="bp">by</span> <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">apply</span>: subset_trans fS _ =&gt; _ [a /mem_set Aa &lt;-] /=; <span class="nb">rewrite</span> [LHS]eqfg.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">epiP</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : aT -&gt; rT) : set_surj A B f &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">sT</span> (<span class="nv">g</span> <span class="nv">g&#39;</span> : rT -&gt; sT), {<span class="kr">in</span> A, g \o f =<span class="mi">1</span> g&#39; \o f} -&gt; {<span class="kr">in</span> B, g =<span class="mi">1</span> g&#39;}.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [*| f_epi y By]; <span class="kp">first</span> <span class="bp">exact</span>: (@surj_epi _ A B f).
<span class="nb">have</span> -&gt; // := f_epi _ [<span class="nb">set</span> f x | x <span class="kr">in</span> A] setT; <span class="nb">last</span> <span class="bp">exact</span>: mem_set.
<span class="bp">by</span> <span class="nb">move</span>=&gt; x /set_mem xA; <span class="nb">apply</span>/propT; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">surj_lemmas</span>.
<span class="kn">Arguments</span> can_surj {aT rT} g [f A B].
<span class="kn">Arguments</span> surj_epi {aT rT sT} A {B} f {g}.

<span class="kn">Lemma</span> <span class="nf">surj_comp</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> (<span class="nv">A</span> : <span class="nb">set</span> T1) (<span class="nv">B</span> : <span class="nb">set</span> T2) (<span class="nv">C</span> : <span class="nb">set</span> T3) <span class="nv">f</span> <span class="nv">g</span>:
  set_surj A B f -&gt; set_surj B C g -&gt; set_surj A C (g \o f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fS gS; <span class="nb">apply</span>: &#39;surj_(gS \o fS). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">image_eq</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} (<span class="nv">f</span> : {surjfun A &gt;-&gt; B}) : f @` A = B.
<span class="kn">Proof</span>. <span class="bp">exact</span>: surj_image_eq. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">oinv_image_sub</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT}
    (<span class="nv">f</span> : {surj A &gt;-&gt; B}) {<span class="nv">C</span> : <span class="nb">set</span> rT} :
  C `&lt;=` B -&gt; &#39;oinv_f @` C `&lt;=` some @` (f @^-<span class="mi">1</span>` C).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; CB x [/= y Cy &lt;-]; <span class="nb">case</span>: &#39;oinvP_f =&gt; [|a Aa fay]; <span class="kp">first</span> <span class="bp">exact</span>: CB.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">a</span> =&gt; //; <span class="nb">rewrite</span> fay.
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> oinv_image_sub {aT rT A B} f {C} _.

<span class="kn">Lemma</span> <span class="nf">oinv_Iimage_sub</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} (<span class="nv">f</span> : {inj A &gt;-&gt; rT}) {<span class="nv">C</span> : <span class="nb">set</span> rT} :
  C `&lt;=` f @` A -&gt; some @` (A `&amp;` f @^-<span class="mi">1</span>` C) `&lt;=` &#39;oinv_f @` C.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? _ [a [? ?] &lt;-]; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">a</span>) =&gt; //; <span class="nb">rewrite</span> funoK <span class="nl">?inE</span>. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> oinv_Iimage_sub {aT rT A} f {C} _.

<span class="kn">Lemma</span> <span class="nf">oinv_sub_image</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {bij A &gt;-&gt; B}}
   {<span class="nv">C</span> : <span class="nb">set</span> rT} (<span class="nv">CB</span> : C `&lt;=` B) : &#39;oinv_f @` C = some @` (A `&amp;` f @^-<span class="mi">1</span>` C).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: oinv_Iimage_sub; <span class="nb">rewrite</span> image_eq.
<span class="nb">rewrite</span> some_setI subsetI; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: oinv_image_sub.
<span class="bp">by</span> <span class="nb">apply</span>: (subset_trans (image_subset CB)); <span class="nb">rewrite</span> image_eq.
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> oinv_sub_image {aT rT A B} f {C} _.

<span class="kn">Lemma</span> <span class="nf">preimageEoinv</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {bij [<span class="nb">set</span>: aT] &gt;-&gt; B}}
   {<span class="nv">C</span> : <span class="nb">set</span> rT} (<span class="nv">CB</span> : C `&lt;=` B) : some @` (f @^-<span class="mi">1</span>` C) = &#39;oinv_f @` C.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> oinv_sub_image// setTI. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> preimageEoinv {aT rT B} f {C} _.

<span class="kn">Lemma</span> <span class="nf">inv_image_sub</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT}
    (<span class="nv">f</span> : {splitsurj A &gt;-&gt; B}) {<span class="nv">C</span> : <span class="nb">set</span> rT} :
  C `&lt;=` B -&gt; f^-<span class="mi">1</span> @` C `&lt;=` f @^-<span class="mi">1</span>` C.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; CB x [/= y Cy &lt;-]; <span class="nb">rewrite</span> invK// mem_set//; <span class="nb">apply</span>: CB. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> inv_image_sub {aT rT A B} f {C} _.

<span class="kn">Lemma</span> <span class="nf">inv_Iimage_sub</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} (<span class="nv">f</span> : {splitinj A &gt;-&gt; rT}) {<span class="nv">C</span> : <span class="nb">set</span> rT} :
  C `&lt;=` f @` A -&gt;  A `&amp;` f @^-<span class="mi">1</span>` C `&lt;=` f^-<span class="mi">1</span> @` C.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; CB x [Ax Cfx]; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">x</span>) =&gt; //; <span class="nb">rewrite</span> funK// mem_set. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> inv_Iimage_sub {aT rT A} f {C} _.

<span class="kn">Lemma</span> <span class="nf">inv_sub_image</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {splitbij A &gt;-&gt; B}}
    {<span class="nv">C</span> : <span class="nb">set</span> rT} (<span class="nv">CB</span> : C `&lt;=` B) :
  f^-<span class="mi">1</span> @` C = A `&amp;` f @^-<span class="mi">1</span>` C.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>: image_some_inj; <span class="nb">rewrite</span> image_comp [Some \o _]oliftV oinv_sub_image.
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> inv_sub_image {aT rT A B} f {C} _.

<span class="kn">Lemma</span> <span class="nf">preimageEinv</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {splitbij [<span class="nb">set</span>: aT] &gt;-&gt; B}}
    {<span class="nv">C</span> : <span class="nb">set</span> rT} (<span class="nv">CB</span> : C `&lt;=` B) : f @^-<span class="mi">1</span>` C = f^-<span class="mi">1</span> @` C.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> inv_sub_image// setTI. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> preimageEinv {aT rT B} f {C} _.

<span class="kn">Lemma</span> <span class="nf">reindex_bigcup</span> {<span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">I</span>} (<span class="nv">f</span> : aT -&gt; I) (<span class="nv">P</span> : <span class="nb">set</span> aT) (<span class="nv">Q</span> : <span class="nb">set</span> I)
    (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> rT) : set_fun P Q f -&gt; set_surj P Q f -&gt;
  \bigcup_(x <span class="kr">in</span> Q) F x = \bigcup_(x <span class="kr">in</span> P) F (f x).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /image_subP fPQ /(surj_image_eq fPQ)&lt;-; <span class="nb">rewrite</span> bigcup_image.
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> reindex_bigcup {aT rT I} f P Q.

<span class="kn">Lemma</span> <span class="nf">reindex_bigcap</span> {<span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">I</span>} (<span class="nv">f</span> : aT -&gt; I) (<span class="nv">P</span> : <span class="nb">set</span> aT) (<span class="nv">Q</span> : <span class="nb">set</span> I)
    (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> rT) : set_fun P Q f -&gt; set_surj P Q f -&gt;
  \bigcap_(x <span class="kr">in</span> Q) F x = \bigcap_(x <span class="kr">in</span> P) F (f x).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /image_subP fPQ /(surj_image_eq fPQ)&lt;-; <span class="nb">rewrite</span> bigcap_image.
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> reindex_bigcap {aT rT I} f P Q.

<span class="kn">Lemma</span> <span class="nf">bigcap_bigcup</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">J</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">E</span> : <span class="nb">set</span> J) (<span class="nv">F</span> : I -&gt; J -&gt; <span class="nb">set</span> T) :
  J -&gt;
  \bigcap_(i <span class="kr">in</span> D) \bigcup_(j <span class="kr">in</span> E) F i j =
  \bigcup_(f <span class="kr">in</span> set_fun D E) \bigcap_(i <span class="kr">in</span> D) F i (f i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; j; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; x.
  <span class="nb">move</span>=&gt; /(_ _ _)/cid2 ff.
  <span class="nb">have</span> /(all_sig2_cond j) (i : I) : i \<span class="kr">in</span> D -&gt; {x0 : J | E x0 &amp; F i x0 x}.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; /set_mem; <span class="nb">apply</span>: ff.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [f /(_ _ (mem_set _))Ef /(_ _ (mem_set _))Ff]; <span class="kr">exists</span> <span class="nv">f</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [f fDE fF i Fi]; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">i</span>); [<span class="nb">apply</span>: fDE|<span class="nb">apply</span>: fF].
<span class="kn">Qed</span>.

<span class="sd">(**************)</span>
<span class="c">(* Injections *)</span>
<span class="sd">(**************)</span>

<span class="kn">Lemma</span> <span class="nf">trivIset_inj</span> <span class="nv">T</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; F i !=set0) -&gt; trivIset D F -&gt; set_inj D F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FN0 Ftriv i j; <span class="nb">rewrite</span> !inE =&gt; Di Dj Fij.
<span class="bp">by</span> <span class="nb">apply</span>: Ftriv Di (Dj) _; <span class="nb">rewrite</span> Fij setIid; <span class="nb">apply</span>: FN0.
<span class="kn">Qed</span>.

<span class="sd">(**************)</span>
<span class="c">(* Bijections *)</span>
<span class="sd">(**************)</span>

<span class="kn">Section</span> <span class="nf">set_bij_lemmas</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : aT -&gt; rT}.
<span class="kn">Definition</span> <span class="nf">fun_set_bij</span> <span class="nv">of</span> <span class="nv">set_bij</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> := f.
<span class="kn">Context</span> (<span class="nv">fbij</span> : set_bij A B f).
<span class="kn">Local Notation</span> <span class="nf">g</span> := (fun_set_bij fbij).

<span class="kn">Lemma</span> <span class="nf">set_bij_inj</span> : {<span class="kr">in</span> A &amp;, injective f}. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: fbij. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">set_bij_homo</span> : {homo f : x / A x &gt;-&gt; B x}.  <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: fbij. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">set_bij_sub</span> : f @` A `&lt;=` B. <span class="kn">Proof</span>. <span class="bp">exact</span>/image_subP/set_bij_homo. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">set_bij_surj</span> : set_surj A B f. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: fbij. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> : OCanV _ _ _ _ g := set_bij_surj.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := IsFun.Build _ _ A B g set_bij_homo.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := SurjFun_Inj.Build _ _ A B g set_bij_inj.

<span class="kn">End</span> <span class="nf">set_bij_lemmas</span>.
<span class="kn">Coercion</span> <span class="nf">fun_set_bij</span> : set_bij &gt;-&gt; <span class="kt">Funclass</span>.

<span class="kn">Coercion</span> <span class="nf">set_bij_bijfun</span> aT rT (A : <span class="nb">set</span> aT) (B : <span class="nb">set</span> rT) (f : aT -&gt; rT)
    (fS : set_bij A B f) := Bij.on (fun_set_bij fS).

<span class="kn">Section</span> <span class="nf">Pbij</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : aT -&gt; rT} (<span class="nv">fbij</span> : set_bij A B f).
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> : @Bij _ _ A B f := fbij.
<span class="kn">Definition</span> <span class="nf">bij_of_set_bijection</span> := [bij of f].
<span class="kn">Lemma</span> <span class="nf">Pbij</span> : {s : {bij A &gt;-&gt; B} | f = s}. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [bij of f]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">Pbij</span>.
<span class="kn">Coercion</span> <span class="nf">bij_of_set_bijection</span> : set_bij &gt;-&gt; Bij.type.

<span class="kn">Lemma</span> <span class="nf">bij</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} {<span class="nv">f</span> : {bij A &gt;-&gt; B}} : set_bij A B f.
<span class="kn">Proof</span>. <span class="nb">split</span>=&gt; //. <span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">phant_bij</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : {bij A &gt;-&gt; B}) <span class="nv">of</span>
  <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @bij _ _ _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;bij_&#39; f&quot;</span> := (phant_bij (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (set_bij _ _ _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: bij] : core.

<span class="kn">Section</span> <span class="nf">PbijTT</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">f</span> : aT -&gt; rT} (<span class="nv">fbijTT</span> : bijective f).
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := @BijTT.Build _ _ f fbijTT.
<span class="kn">Definition</span> <span class="nf">bijection_of_bijective</span> := [splitbij of f].
<span class="kn">Lemma</span> <span class="nf">PbijTT</span> : {s : {splitbij [<span class="nb">set</span>: aT] &gt;-&gt; [<span class="nb">set</span>: rT]} | f = s}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [splitbij of f]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">PbijTT</span>.

<span class="kn">Lemma</span> <span class="nf">setTT_bijective</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">f</span> : aT -&gt; rT) :
  set_bij [<span class="nb">set</span>: aT] [<span class="nb">set</span>: rT] f = bijective f.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/propext; <span class="nb">split</span>=&gt; [[]|/PbijTT[{}f -&gt;]].
  <span class="nb">move</span>=&gt; _ fI /(_ _ I)-/(_ _)/cid2-/all_sig2[g _ gK].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">g</span> =&gt; // x; <span class="nb">apply</span>: fI; <span class="nb">rewrite</span> <span class="nl">?inE</span>.
<span class="bp">by</span> <span class="nb">split</span>=&gt; // [x y _ _ /&#39;inj_f//|y _]; <span class="kr">exists</span> (<span class="nv">f</span>^-<span class="mi">1</span> y) =&gt; //; <span class="nb">rewrite</span> funK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bijTT</span> {<span class="nv">aT</span> <span class="nv">rT</span>}  {<span class="nv">f</span> : {bij [<span class="nb">set</span>: aT] &gt;-&gt; [<span class="nb">set</span>: rT]}} : bijective f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -setTT_bijective. <span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">phant_bijTT</span> <span class="nv">aT</span> <span class="nv">rT</span> (<span class="nv">f</span> : {bij [<span class="nb">set</span>: aT] &gt;-&gt; [<span class="nb">set</span>: rT]})
   <span class="nv">of</span> <span class="nv">phantom</span> (<span class="nv">_</span> -&gt; _) <span class="nv">f</span> := @bijTT _ _ f.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;bijTT_&#39;  f&quot;</span> := (phant_bijTT (Phantom (_ -&gt; _) f)) : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (bijective _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: bijTT] : core.

<span class="sd">(*****************************)</span>
<span class="c">(* Patching and restrictions *)</span>
<span class="sd">(*****************************)</span>

<span class="kn">Section</span> <span class="nf">patch</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} (<span class="nv">d</span> : aT -&gt; rT) (<span class="nv">A</span> : <span class="nb">set</span> aT).
<span class="kn">Definition</span> <span class="nf">patch</span> (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">u</span> := <span class="kr">if</span> u \<span class="kr">in</span> A <span class="kr">then</span> f u <span class="kr">else</span> d u.

<span class="kn">Lemma</span> <span class="nf">patchT</span> <span class="nv">f</span> : {<span class="kr">in</span> A, patch f =<span class="mi">1</span> f}. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /patch =&gt; x -&gt;. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">patchN</span> <span class="nv">f</span> : {<span class="kr">in</span> [predC A], patch f =<span class="mi">1</span> d}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /patch =&gt; x /negPf/= -&gt;. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">patchC</span> <span class="nv">f</span> : {<span class="kr">in</span> ~` A, patch f =<span class="mi">1</span> d}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; u /set_mem/= NAu; <span class="nb">rewrite</span> patchN <span class="nl">?inE</span>//= notin_set. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> :=
  SurjFun.copy (patch f) [<span class="kr">fun</span> <span class="nv">patch</span> <span class="nv">f</span> <span class="nv">in</span> <span class="nv">A</span>].

<span class="kn">Section</span> <span class="nf">inj</span>.
<span class="kn">Context</span> (<span class="nv">f</span> : {inj A &gt;-&gt; rT}).
<span class="kn">Let</span> <span class="nf">g</span> := patch f.
<span class="kn">Lemma</span> <span class="nf">patch_inj_subproof</span> : Inj aT rT A g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x y xA yA; <span class="nb">rewrite</span> /g !patchT//; <span class="nb">apply</span>: inj. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := patch_inj_subproof.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Inject.copy (patch f) [<span class="kr">fun</span> <span class="nv">g</span> <span class="nv">in</span> <span class="nv">A</span>].
<span class="kn">End</span> <span class="nf">inj</span>.

<span class="kn">End</span> <span class="nf">patch</span>.
<span class="kn">Notation</span> <span class="nf">restrict</span> := (patch (<span class="kr">fun</span>=&gt; point)).
<span class="kn">Notation</span> <span class="s2">&quot;f \_ D&quot;</span> := (restrict D f) : fun_scope.

<span class="kn">Lemma</span> <span class="nf">patchE</span> <span class="nv">aT</span> (<span class="nv">rT</span> : pointedType) (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">B</span> : <span class="nb">set</span> aT) <span class="nv">x</span> :
  (f \_ B) x = <span class="kr">if</span> x \<span class="kr">in</span> B <span class="kr">then</span> f x <span class="kr">else</span> point.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">patch_pred</span> {<span class="nv">I</span> <span class="nv">T</span>} (<span class="nv">D</span> : {pred I}) (<span class="nv">d</span> <span class="nv">f</span> : I -&gt; T) :
  patch d D f = <span class="kr">fun</span> <span class="nv">i</span> =&gt; <span class="kr">if</span> D i <span class="kr">then</span> f i <span class="kr">else</span> d i.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; i; <span class="nb">rewrite</span> /patch mem_setE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">preimage_restrict</span> (<span class="nv">aT</span> : <span class="kt">Type</span>) (<span class="nv">rT</span> : pointedType)
     (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) :
  (f \_ D) @^-<span class="mi">1</span>` B = (<span class="kr">if</span> point \<span class="kr">in</span> B <span class="kr">then</span> ~` D <span class="kr">else</span> set0) `|` D `&amp;` f @^-<span class="mi">1</span>` B.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /preimage/= /patch; <span class="nb">apply</span>/predeqP =&gt; x /=; <span class="nb">split</span>.
  <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> ?(inE, notin_set); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">right</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; NDx Bp; <span class="nb">rewrite</span> ifT <span class="nl">?inE</span>//=; <span class="nb">left</span>.
<span class="nb">move</span>=&gt; [|[Dx Bfx]]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ifT <span class="nl">?inE</span>.
<span class="bp">by</span> <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> // inE =&gt; Bp NDx; <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> // inE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">comp_patch</span> {<span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">sT</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : aT -&gt; rT) <span class="nv">D</span> (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">h</span> : rT -&gt; sT) :
  h \o patch g D f = patch (h \o g) D (h \o f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; x; <span class="nb">rewrite</span> /patch/=; <span class="nb">case</span>: ifP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">patch_setI</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : aT -&gt; rT) <span class="nv">D</span> <span class="nv">D&#39;</span> (<span class="nv">f</span> : aT -&gt; rT) :
   patch g (D `&amp;` D&#39;) f = patch g D (patch g D&#39; f).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/funext =&gt; x; <span class="nb">rewrite</span> /patch/= in_setI.
<span class="bp">by</span> <span class="nb">case</span>: (x \<span class="kr">in</span> D) (x \<span class="kr">in</span> D&#39;) =&gt; [] [].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">patch_set0</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : aT -&gt; rT) (<span class="nv">f</span> : aT -&gt; rT) :
  patch g set0 f = g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; x; <span class="nb">rewrite</span> /patch in_set0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">patch_setT</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : aT -&gt; rT) (<span class="nv">f</span> : aT -&gt; rT) :
  patch g setT f = f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; x; <span class="nb">rewrite</span> /patch in_setT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">restrict_comp</span> {<span class="nv">aT</span>} {<span class="nv">rT</span> <span class="nv">sT</span> : pointedType} (<span class="nv">h</span> : rT -&gt; sT) (<span class="nv">f</span> : aT -&gt; rT) <span class="nv">D</span> :
  h point = point -&gt; (h \o f) \_ D = h \o (f \_ D).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; hp; <span class="nb">apply</span>/funext =&gt; x; <span class="nb">rewrite</span> /patch/=; <span class="nb">case</span>: ifP. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> restrict_comp {aT rT sT} h f D.

<span class="kn">Lemma</span> <span class="nf">trivIset_restr</span> (<span class="nv">T</span> <span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">D</span> <span class="nv">D&#39;</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
    trivIset D&#39; (F \_ D) = trivIset (D `&amp;` D&#39;) F.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/propext; <span class="nb">split</span>=&gt; FDtriv i j.
  <span class="nb">move</span>=&gt; [Di D&#39;i] [Dj D&#39;j] [x [Fix Fjx]]; <span class="nb">apply</span>: FDtriv =&gt; //.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span> =&gt; /=; <span class="nb">rewrite</span> <span class="nl">?patchT</span> <span class="nl">?in_setE</span>.
<span class="nb">move</span>=&gt; D&#39;i D&#39;j [x []]; <span class="nb">rewrite</span> /patch.
<span class="kp">do</span> <span class="mi">2</span>![<span class="nb">case</span>: ifPn =&gt; //]; <span class="nb">rewrite</span> !in_setE =&gt; Di Dj Fix Fjx.
<span class="bp">by</span> <span class="nb">apply</span>: FDtriv =&gt; //; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="kn">Qed</span>.


<span class="sd">(**************************************)</span>
<span class="c">(* Restriction of domain and codomain *)</span>
<span class="sd">(**************************************)</span>

<span class="kn">Section</span> <span class="nf">RestrictionLeft</span>.
<span class="kn">Context</span> {<span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} (<span class="nv">v</span> : V) {<span class="nv">A</span> : <span class="nb">set</span> U} {<span class="nv">B</span> : <span class="nb">set</span> V}.

<span class="kn">Local Notation</span> <span class="nf">restrict</span> := (patch (<span class="kr">fun</span>=&gt; v) A).

<span class="kn">Definition</span> <span class="nf">sigL</span> (<span class="nv">f</span> : U -&gt; V) : A -&gt; V := f \o set_val.

<span class="kn">Lemma</span> <span class="nf">sigL_isfun</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) : IsFun _ _ [<span class="nb">set</span>: A] B (sigL f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x _; <span class="nb">apply</span>: funS. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) := sigL_isfun f.

<span class="kn">Definition</span> <span class="nf">sigLfun</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) := [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">sigL</span> <span class="nv">f</span>].
<span class="kn">Definition</span> <span class="nf">valL_</span> (<span class="nv">f</span> : A -&gt; V) : U -&gt; V := ((@oapp _ _)^~ v) f \o &#39;oinv_set_val.

<span class="kn">Lemma</span> <span class="nf">valL_isfun</span> (<span class="nv">f</span> : {<span class="kr">fun</span> [<span class="nb">set</span>: A] &gt;-&gt; B}) :
  IsFun _ _ A B (valL_ (f : _ -&gt; _)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x Ax; <span class="nb">apply</span>: funS. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {<span class="kr">fun</span> [<span class="nb">set</span>: A] &gt;-&gt; B}) := valL_isfun f.
<span class="kn">Definition</span> <span class="nf">valLfun_</span> (<span class="nv">f</span> : {<span class="kr">fun</span> [<span class="nb">set</span>: A] &gt;-&gt; B}) := [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">valL_</span> <span class="nv">f</span>].

<span class="kn">Lemma</span> <span class="nf">sigLE</span> (<span class="nv">f</span> : U -&gt; V) <span class="nv">x</span> (<span class="nv">xA</span> : x \<span class="kr">in</span> A) :
  sigL f (SigSub xA) = f x.
<span class="kn">Proof</span>. <span class="bp">done</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_sigLP</span> (<span class="nv">f</span> <span class="nv">g</span> : U -&gt; V):
  {<span class="kr">in</span> A, f =<span class="mi">1</span> g} &lt;-&gt; sigL f = sigL g.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [eq_f_g | Rfg u uA]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; -[x]; <span class="nb">apply</span>: eq_f_g.
<span class="bp">by</span> <span class="nb">have</span> := congr1 (@^~ (exist _ u uA)) Rfg.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_sigLfunP</span> (<span class="nv">f</span> <span class="nv">g</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) :
  {<span class="kr">in</span> A, f =<span class="mi">1</span> g} &lt;-&gt; sigLfun f = sigLfun g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> eq_sigLP funP funeqP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigLK</span> : valL_ \o sigL = restrict.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeq2E =&gt; f u; <span class="nb">rewrite</span> /valL_ /sigL /restrict.
<span class="bp">by</span> <span class="nb">rewrite</span> oinv_set_val/=; <span class="nb">case</span>: ifPn =&gt; uA; [<span class="nb">rewrite</span> insubT|<span class="nb">rewrite</span> insubN].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valLK</span> : cancel valL_ sigL.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f; <span class="nb">rewrite</span> /valL_ /sigL /restrict oinv_set_val.
<span class="nb">apply</span>/funext=&gt; a /=; <span class="nb">have</span> aA : set_val a \<span class="kr">in</span> A <span class="bp">by</span> <span class="nb">apply</span>: valP.
<span class="bp">by</span> <span class="nb">rewrite</span> insubT//=; <span class="nb">congr</span> f; <span class="nb">apply</span>/val_inj.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valLfunK</span> : cancel valLfun_ sigLfun.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f; <span class="nb">apply</span>/funP/funeqP; <span class="bp">exact</span>: valLK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigL_valL</span> : sigL \o valL_ = id.
<span class="kn">Proof</span>. <span class="bp">exact</span>/funext/valLK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigL_valLfun</span> : sigLfun \o valLfun_ = id.
<span class="kn">Proof</span>. <span class="bp">exact</span>/funext/valLfunK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigL_restrict</span> : sigL \o restrict = sigL.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeq2E =&gt; f -[u Au] /=.
<span class="bp">by</span> <span class="nb">rewrite</span> /sigL /restrict /valL_ /patch /= Au.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">image_sigL</span>  : range sigL = setT.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; //= f _; <span class="kr">exists</span> (<span class="nv">valL_</span> <span class="nv">f</span>)=&gt;//.
<span class="bp">exact</span>: valLK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_restrictP</span> (<span class="nv">f</span> <span class="nv">g</span> : U -&gt; V): {<span class="kr">in</span> A, f =<span class="mi">1</span> g} &lt;-&gt; restrict f = restrict g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> eq_sigLP -sigLK/=; <span class="nb">split</span> =&gt; [-&gt;//|/(can_inj valLK)]. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">RestrictionLeft</span>.
<span class="kn">Arguments</span> sigL {U V} A f u /.
<span class="kn">Arguments</span> sigLE {U V} A f x.
<span class="kn">Arguments</span> valL_ {U V} v {A} f u /.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;valL_&#39; v&quot;</span> := (valL_ v) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;valLfun_&#39; v&quot;</span> := (valLfun_ v) : form_scope.
<span class="kn">Notation</span> <span class="nf">valL</span> := (valL_ point).

<span class="kn">Section</span> <span class="nf">RestrictionRight</span>.
<span class="kn">Context</span> {<span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> V}.

<span class="kn">Definition</span> <span class="nf">sigR</span> (<span class="nv">f</span> : {<span class="kr">fun</span> [<span class="nb">set</span>: U] &gt;-&gt; A}) (<span class="nv">u</span> : U) : A :=
  SigSub (mem_set (&#39;funS_f I) : f u \<span class="kr">in</span> A).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := Fun.copy (sigR f) (totalfun _).

<span class="kn">Definition</span> <span class="nf">valR</span> (<span class="nv">f</span> : U -&gt; A) := set_val \o totalfun f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := Fun.on (valR f).

<span class="kn">Definition</span> <span class="nf">valR_fun</span> (<span class="nv">f</span> : U -&gt; A) : {<span class="kr">fun</span> [<span class="nb">set</span>: U] &gt;-&gt; A} := [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">valR</span> <span class="nv">f</span>].

<span class="kn">Lemma</span> <span class="nf">sigRK</span> (<span class="nv">f</span> : {<span class="kr">fun</span> [<span class="nb">set</span>: U] &gt;-&gt; A}) : valR (sigR f) = f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigR_funK</span> (<span class="nv">f</span> : {<span class="kr">fun</span> [<span class="nb">set</span>: U] &gt;-&gt; A}) : valR_fun (sigR f) = f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/funP/funeqP; <span class="nb">apply</span>: sigRK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valRP</span> (<span class="nv">f</span> : U -&gt; A) <span class="nv">x</span> : A (valR f x). <span class="kn">Proof</span>. <span class="bp">exact</span>: set_valP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valRK</span> : cancel valR_fun sigR.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f; <span class="nb">apply</span>/funext =&gt; x; <span class="nb">apply</span>/val_inj. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">RestrictionRight</span>.
<span class="kn">Arguments</span> sigR {U V A} f u /.

<span class="kn">Section</span> <span class="nf">RestrictionLeftInv</span>.
<span class="kn">Context</span> {<span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} (<span class="nv">v</span> : V) {<span class="nv">A</span> : <span class="nb">set</span> U} {<span class="nv">B</span> : <span class="nb">set</span> V}.
<span class="kn">Local Notation</span> <span class="nf">rl</span> := (sigL A).
<span class="kn">Local Notation</span> <span class="nf">rr</span> := sigR.
<span class="kn">Local Notation</span> <span class="nf">el</span> := &#39;valL_v.
<span class="kn">Local Notation</span> <span class="nf">er</span> := valR.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinv U &gt;-&gt; V}) :=
  @OInv.Build _ _ (rl f) (obind insub \o &#39;oinv_f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinvfun A &gt;-&gt; B}) := Fun.on (rl f).

<span class="kn">Lemma</span> <span class="nf">oinv_sigL</span> (<span class="nv">f</span> : {oinv U &gt;-&gt; V}) : &#39;oinv_(rl f) = obind insub \o &#39;oinv_f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigL_inj_subproof</span> (<span class="nv">f</span> : {inj A &gt;-&gt; V}) : @OInv_Can _ _ setT (rl f).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>=&gt; x _; <span class="nb">rewrite</span> oinv_sigL/= funoK//= [insub _]&#39;funoK_val <span class="nl">?inE</span>.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := sigL_inj_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) := Fun.on (rl f).

<span class="kn">Lemma</span> <span class="nf">sigL_surj_subproof</span> (<span class="nv">f</span> : {surj A &gt;-&gt; B}) : @OInv_CanV _ _ setT B (rl f).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [b|b /set_mem] Bb; <span class="nb">rewrite</span> <span class="nl">?oinv_sigL</span>/=.
   <span class="nb">have</span> [x /mem_set Ax &lt;-]/= := &#39;oinvS_f Bb; <span class="kr">exists</span> (<span class="nv">SigSub</span> <span class="nv">Ax</span>) =&gt; //=.
   <span class="nb">case</span>: insubP =&gt; [a Aa/= eqx|]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> Ax.
   <span class="bp">by</span> <span class="nb">congr</span> Some; <span class="nb">apply</span>/val_inj.
<span class="bp">by</span> <span class="nb">rewrite</span> /rl/= oapp_comp/= -oinv_val -inv_omap/= invK <span class="nl">?oinvK</span> <span class="nl">?mem_fun</span> <span class="nl">?inE</span>.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := sigL_surj_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; B}) := Fun.on (rl f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) := Fun.on (rl f).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinvfun [<span class="nb">set</span>: V] &gt;-&gt; A}) :=
  @OInv.Build _ _ (rr f) (rl &#39;oinv_f).

<span class="kn">Lemma</span> <span class="nf">oinv_sigR</span> (<span class="nv">f</span> : {oinvfun [<span class="nb">set</span>: V] &gt;-&gt; A}) :
  &#39;oinv_(rr f) = (rl &#39;oinv_f).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigR_inj_subproof</span> (<span class="nv">f</span> : {injfun [<span class="nb">set</span>: V] &gt;-&gt; A}) :
   @OInv_Can _ _ setT (rr f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x _; <span class="nb">rewrite</span> oinv_sigR/= set_valE/= funoK <span class="nl">?inE</span>. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := sigR_inj_subproof f.

<span class="kn">Lemma</span> <span class="nf">sigR_surj_subproof</span> (<span class="nv">f</span> : {surjfun [<span class="nb">set</span>: V] &gt;-&gt; A}) :
  @OInv_CanV _ _ setT setT (rr f).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; a _; <span class="nb">rewrite</span> <span class="nl">?oinv_sigL</span>/=.
  <span class="bp">by</span> <span class="nb">have</span> [x _ xeq] := &#39;oinvS_f (set_valP a); <span class="kr">exists</span> <span class="nv">x</span>.
<span class="nb">apply</span>/val_inj=&gt; /=; <span class="nb">rewrite</span> oinv_sigR/=.
<span class="bp">by</span> <span class="nb">case</span>: oinvP=&gt; //=; <span class="nb">apply</span>: set_valP.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := sigR_surj_subproof f.

<span class="kn">Lemma</span> <span class="nf">sigR_some_inv</span> (<span class="nv">f</span> : {invfun [<span class="nb">set</span>: V] &gt;-&gt; A}) :
  olift (rl f^-<span class="mi">1</span>) = &#39;oinv_(rr f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> oinv_sigR olift_comp oliftV. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij [<span class="nb">set</span>: V] &gt;-&gt; A}) := Fun.on (rr f).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {invfun [<span class="nb">set</span>: V] &gt;-&gt; A}) :=
   @OInv_Inv.Build _ _ (rr f) (rl f^-<span class="mi">1</span>) (sigR_some_inv f).

<span class="kn">Lemma</span> <span class="nf">inv_sigR</span> (<span class="nv">f</span> : {invfun [<span class="nb">set</span>: V] &gt;-&gt; A}) : (rr f)^-<span class="mi">1</span> = (rl f^-<span class="mi">1</span>).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinjfun [<span class="nb">set</span>: V] &gt;-&gt; A}) := Inject.on (rr f).
<span class="c">(* HB Bug, if Fun.on instead of Surject.on *)</span>
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurjfun [<span class="nb">set</span>: V] &gt;-&gt; A}) := Surject.on (rr f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitbij [<span class="nb">set</span>: V] &gt;-&gt; A}) := Fun.on (rr f).

<span class="kn">Lemma</span> <span class="nf">sigL_some_inv</span> (<span class="nv">f</span> : {splitbij A &gt;-&gt; [<span class="nb">set</span>: V]}) :
  olift (rr [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">f</span>^-<span class="mi">1</span>]) = &#39;oinv_(rl f).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/funext=&gt; x /=; <span class="nb">rewrite</span> oinv_sigL /= /sigR/= /olift/=.
<span class="nb">case</span>: oinvP =&gt; //= u Au _; <span class="nb">rewrite</span> insubT <span class="nl">?inE</span>// =&gt; memAu.
<span class="bp">by</span> <span class="nb">congr</span> (Some _); <span class="nb">apply</span>/val_inj=&gt; /=; <span class="nb">rewrite</span> funK.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitbij A &gt;-&gt; [<span class="nb">set</span>: V]}) :=
  OInv_Inv.Build _ _ (rl f) (sigL_some_inv f).

<span class="kn">Lemma</span> <span class="nf">inv_sigL</span>  (<span class="nv">f</span> : {splitbij A &gt;-&gt; [<span class="nb">set</span>: V]}) :
  (rl f)^-<span class="mi">1</span> = (rr [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">f</span>^-<span class="mi">1</span>]).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinv A &gt;-&gt; V}) :=
  @OInv.Build _ _ (el f) (omap set_val \o &#39;oinv_f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinvfun [<span class="nb">set</span>: A] &gt;-&gt; B}) := Fun.on (el f).

<span class="kn">Lemma</span> <span class="nf">oinv_valL</span> (<span class="nv">f</span> : {oinv A &gt;-&gt; V}) :
  &#39;oinv_(el f) = omap set_val \o &#39;oinv_f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">oapp_comp_x</span> {<span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">sT</span>} (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">g</span> : rT -&gt; sT) (<span class="nv">x</span> : rT) <span class="nv">y</span> :
  oapp (g \o f) (g x) y = g (oapp f x y).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: y. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valL_inj_subproof</span> (<span class="nv">f</span> : {inj [<span class="nb">set</span>: A] &gt;-&gt; V}) : @OInv_Can _ _ A (el f).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; x /set_mem xA; <span class="nb">rewrite</span> oinv_valL/= -oapp_comp_x.
<span class="bp">by</span> <span class="nb">case</span>: oinvP=&gt; //= a _ _; <span class="nb">rewrite</span> funoK <span class="nl">?inE</span>.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := valL_inj_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun [<span class="nb">set</span>: A] &gt;-&gt; B}) := Inject.on (el f).

<span class="kn">Lemma</span> <span class="nf">valL_surj_subproof</span> (<span class="nv">f</span> : {surj [<span class="nb">set</span>: A] &gt;-&gt; B}) : @OInv_CanV _ _ A B (el f).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [b|b /set_mem] Bb; <span class="nb">rewrite</span> <span class="nl">?oinv_valL</span>/=.
  <span class="bp">by</span> <span class="nb">case</span>: oinvP =&gt; // =&gt; a; <span class="kr">exists</span> (<span class="nv">set_val</span> <span class="nv">a</span>) =&gt; //; <span class="nb">apply</span>: set_valP.
<span class="bp">by</span> <span class="nb">case</span>: oinvP =&gt; //= a _ _; <span class="nb">rewrite</span> funoK// inE.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := valL_surj_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun [<span class="nb">set</span>: A] &gt;-&gt; B}) := Surject.on (el f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij [<span class="nb">set</span>: A] &gt;-&gt; B}) := Surject.on (el f).

<span class="kn">Lemma</span> <span class="nf">valL_some_inv</span> (<span class="nv">f</span> : {inv A &gt;-&gt; V}) : olift (er f^-<span class="mi">1</span>) = &#39;oinv_(el f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> oinv_valL/= olift_comp -oliftV. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inv A &gt;-&gt; V}) :=
  OInv_Inv.Build _ _ (el f) (valL_some_inv f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {invfun [<span class="nb">set</span>: A] &gt;-&gt; B}) := Fun.on (el f).

<span class="kn">Lemma</span> <span class="nf">inv_valL</span> (<span class="nv">f</span> : {inv A &gt;-&gt; V}) : (el f)^-<span class="mi">1</span> = er f^-<span class="mi">1</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinj [<span class="nb">set</span>: A] &gt;-&gt; V}) := Inject.on (el f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitinjfun [<span class="nb">set</span>: A] &gt;-&gt; B}) := Fun.on (el f).
<span class="c">(* HB Bug, if Fun.on instead of Surject.on *)</span>
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurj [<span class="nb">set</span>: A] &gt;-&gt; B}) := Surject.on (el f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitsurjfun [<span class="nb">set</span>: A] &gt;-&gt; B}) := Fun.on (el f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {splitbij [<span class="nb">set</span>: A] &gt;-&gt; B}) := Fun.on (el f).

<span class="kn">Lemma</span> <span class="nf">sigL_injP</span> (<span class="nv">f</span> : U -&gt; V) :
  injective (rl f) &lt;-&gt; {<span class="kr">in</span> A &amp;, injective f}.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [f_inj x y Ax Ay|/Pinj[{}f-&gt; //]]; <span class="nb">last first</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; eqfxy; <span class="nb">suff</span> [-&gt;] : SigSub Ax = SigSub Ay <span class="bp">by</span> []; <span class="nb">apply</span>: f_inj.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigL_surjP</span> (<span class="nv">f</span> : U -&gt; V) :
  set_surj [<span class="nb">set</span>: A] B (rl f) &lt;-&gt; set_surj A B f.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [fsurj b Bb/=|/Psurj[{}f-&gt;]//].
<span class="bp">by</span> <span class="nb">have</span> [a _ &lt;-] := fsurj _ Bb; <span class="kr">exists</span> (<span class="nv">set_val</span> <span class="nv">a</span>) =&gt; //; <span class="nb">apply</span>: set_valP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigL_funP</span> (<span class="nv">f</span> : U -&gt; V) :
  set_fun [<span class="nb">set</span>: A] B (rl f) &lt;-&gt; set_fun A B f.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [ffun u Au/=|/Pfun[{}f-&gt;]//].
<span class="bp">exact</span>: (ffun (SigSub (mem_set Au))).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigL_bijP</span> (<span class="nv">f</span> : U -&gt; V) :
  set_bij [<span class="nb">set</span>: A] B (rl f) &lt;-&gt; set_bij A B f.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [[F /in2TT I S]|/Pbij[{}f-&gt;]//].
<span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">exact</span>/sigL_funP|<span class="bp">exact</span>/sigL_injP|<span class="bp">exact</span>/sigL_surjP].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valL_injP</span> (<span class="nv">f</span> : A -&gt; V) : {<span class="kr">in</span> A &amp;, injective (el f)} &lt;-&gt; injective f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -sigL_injP valLK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valL_surjP</span> (<span class="nv">f</span> : A -&gt; V) :
  set_surj A B (el f) &lt;-&gt; set_surj setT B f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -sigL_surjP valLK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valLfunP</span> (<span class="nv">f</span> : A -&gt; V) :
  set_fun A B (el f) &lt;-&gt; set_fun setT B f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -sigL_funP valLK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valL_bijP</span> (<span class="nv">f</span> : A -&gt; V) :
  set_bij A B (el f) &lt;-&gt; set_bij setT B f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -sigL_bijP valLK. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">RestrictionLeftInv</span>.

<span class="kn">Section</span> <span class="nf">ExtentionLeftInv</span>.
<span class="kn">Context</span> {<span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} {<span class="nv">A</span> : <span class="nb">set</span> U} {<span class="nv">B</span> : <span class="nb">set</span> V}.
<span class="kn">Local Notation</span> <span class="nf">el</span> := &#39;valL_None.
<span class="kn">Local Notation</span> <span class="nf">er</span> := valR.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinv V &gt;-&gt; A}) :=
  @OInv.Build _ _ (er f) (el &#39;oinv_f).

<span class="kn">Lemma</span> <span class="nf">oinv_valR</span> (<span class="nv">f</span> : {oinv V &gt;-&gt; A}) : &#39;oinv_(er f) = (el &#39;oinv_f).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valR_inj_subproof</span> (<span class="nv">f</span> : {inj [<span class="nb">set</span>: V] &gt;-&gt; A}) :
   @OInv_Can _ _ setT (er f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x _; <span class="nb">rewrite</span> /er oinv_valR/= funoK/= <span class="nl">?funoK</span> <span class="nl">?inE</span>. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := valR_inj_subproof f.

<span class="kn">Lemma</span> <span class="nf">valR_surj_subproof</span> (<span class="nv">f</span> : {surj [<span class="nb">set</span>: V] &gt;-&gt; [<span class="nb">set</span>: A]}) :
  @OInv_CanV _ _ setT A (er f).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [a|a /set_mem] Aa; <span class="nb">rewrite</span> <span class="nl">?oinv_valR</span>/= oinv_set_val.
  <span class="bp">by</span> <span class="nb">rewrite</span> insubT <span class="nl">?inE</span>// =&gt; memaA /=; <span class="nb">case</span>: oinvP =&gt; //= x; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="nb">rewrite</span> insubT <span class="nl">?inE</span>// =&gt; memaA/=; <span class="nb">case</span>: oinvP =&gt; //= x _.
<span class="bp">by</span> <span class="nb">rewrite</span> /er/= /totalfun =&gt; -&gt;.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := valR_surj_subproof f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij [<span class="nb">set</span>: V] &gt;-&gt; [<span class="nb">set</span>: A]}) := Fun.on (er f).

<span class="kn">End</span> <span class="nf">ExtentionLeftInv</span>.

<span class="kn">Section</span> <span class="nf">Restrictions2</span>.
<span class="kn">Context</span> {<span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} (<span class="nv">v</span> : V) {<span class="nv">A</span> : <span class="nb">set</span> U} {<span class="nv">B</span> : <span class="nb">set</span> V}.

<span class="kn">Local Notation</span> <span class="nf">valL</span> := &#39;valL_v.
<span class="kn">Local Notation</span> <span class="nf">valLfun</span> := &#39;valLfun_v.

<span class="kn">Definition</span> <span class="nf">sigLR</span> := sigR \o (@sigLfun U V A B).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) :=
  Fun.copy (sigLR f) (totalfun _).

<span class="kn">Definition</span> <span class="nf">valLR</span> : (A -&gt; B) -&gt; U -&gt; V := valL \o valR_fun.
<span class="kn">Definition</span> <span class="nf">valLRfun</span> : (A -&gt; B) -&gt; {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B} := valLfun \o valR_fun.

<span class="kn">Lemma</span> <span class="nf">valLRE</span> (<span class="nv">f</span> : A -&gt; B) : valLR f = valL (valR f). <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">valLRfunE</span> (<span class="nv">f</span> : A -&gt; B) : valLRfun f = [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">valLR</span> <span class="nv">f</span>]. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigL2K</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) : {<span class="kr">in</span> A, valLR (sigLR f) =<span class="mi">1</span> f}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/eq_sigLP; <span class="nb">rewrite</span> valLK sigR_funK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valLRK</span> : cancel valLRfun sigLR.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f; <span class="nb">rewrite</span> /sigLR /valLR /= valLfunK valRK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valLRfun_inj</span> : injective valLRfun.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f g eqefg; <span class="nb">rewrite</span> -[LHS]valLRK eqefg valLRK. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinvfun A &gt;-&gt; B}) := OInversible.on (sigLR f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {injfun A &gt;-&gt; B}) := Inject.on (sigLR f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surjfun A &gt;-&gt; B}) := Surject.on (sigLR f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) := Fun.on (sigLR f).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {oinv A &gt;-&gt; B}) := OInvFun.on (valLR f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {inj [<span class="nb">set</span>: A] &gt;-&gt; B}) := Inject.on (valLR f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {surj [<span class="nb">set</span>: A] &gt;-&gt; [<span class="nb">set</span>: B]}) := Surject.on (valLR f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">f</span> : {bij [<span class="nb">set</span>: A] &gt;-&gt; [<span class="nb">set</span>: B]}) := Fun.on (valLR f).

<span class="kn">Lemma</span> <span class="nf">sigLR_injP</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) :
  injective (sigLR f) &lt;-&gt; {<span class="kr">in</span> A &amp;, injective f}.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [f_inj x y Ax Ay|/funPinj[{}f-&gt; //]]; <span class="nb">last first</span>.
<span class="nb">move</span>=&gt; eqfxy; <span class="nb">suff</span> [-&gt;] : SigSub Ax = SigSub Ay <span class="bp">by</span> [].
<span class="bp">by</span> <span class="nb">apply</span>: f_inj; <span class="nb">apply</span>/val_inj.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valLR_injP</span> (<span class="nv">f</span> : A -&gt; B) :
  {<span class="kr">in</span> A &amp;, injective (valLR f)} &lt;-&gt; injective f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -sigLR_injP valLRK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigLR_surjP</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) :
  set_surj setT setT (sigLR f) &lt;-&gt; set_surj A B f.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [fsurj b Bb/=|/funPsurj[{}f-&gt;]//].
<span class="nb">have</span> [x _ /(congr1 val)/= &lt;-] := fsurj (SigSub (mem_set Bb)) I.
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">set_val</span> <span class="nv">x</span>) =&gt; //; <span class="nb">apply</span>: set_valP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valLR_surjP</span> (<span class="nv">f</span> : A -&gt; B) :
  set_surj A B (valLR f) &lt;-&gt; set_surj setT setT f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -sigLR_surjP valLRK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigLR_bijP</span> (<span class="nv">f</span> : U -&gt; V) :
  set_bij A B f &lt;-&gt;
  <span class="kr">exists</span> (<span class="nv">fAB</span> : {homo f : x / A x &gt;-&gt; B x}),
    bijective (sigLR [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">mkfun</span> <span class="nv">fAB</span>]).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [[F I S]|[fAB]].
  <span class="kr">exists</span> <span class="nv">F</span>; <span class="nb">rewrite</span> -setTT_bijective.
  <span class="bp">by</span> <span class="nb">split</span>; [|<span class="nb">apply</span>: in2W; <span class="nb">apply</span>/sigLR_injP|<span class="nb">apply</span>/sigLR_surjP].
<span class="nb">rewrite</span> -setTT_bijective /set_bij.
<span class="nb">set</span> g := [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">mkfun</span> <span class="nv">fAB</span>] =&gt; -[_ /in2TT I S]; <span class="nb">pose</span> h : _ -&gt; _ := g.
<span class="nb">rewrite</span> -[f]/h {}/h; <span class="nb">move</span>: g =&gt; g <span class="kr">in</span> I S *.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span>/image_subP|<span class="nb">apply</span>/sigLR_injP|<span class="nb">apply</span>/sigLR_surjP].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigLRfun_bijP</span> <span class="nv">f</span> : bijective (sigLR f) &lt;-&gt; set_bij A B f.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> sigLR_bijP; <span class="nb">split</span>=&gt; [fbij|[fAB]]; [<span class="kr">exists</span> <span class="nv">funS</span>|];
<span class="bp">by</span> <span class="nb">rewrite</span> (_ : [<span class="kr">fun</span> <span class="nv">of</span> <span class="nv">_</span>] = f)//; <span class="nb">apply</span>/funP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">valLR_bijP</span> <span class="nv">f</span> : set_bij A B (valLR f) &lt;-&gt; bijective f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -sigLRfun_bijP valLRK. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Restrictions2</span>.

<span class="kn">Lemma</span> <span class="nf">subsetP</span> {<span class="nv">T</span>} {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T} : {subset A &lt;= B} &lt;-&gt; (A `&lt;=` B).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span> =&gt; + x =&gt; /(_ x); <span class="nb">rewrite</span> <span class="nl">?inE</span>. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">set_bij_basic_lemmas</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>}.
<span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : aT -&gt; rT).

<span class="kn">Lemma</span> <span class="nf">eq_set_bijRL</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> <span class="nv">g</span> : {<span class="kr">in</span> A, f =<span class="mi">1</span> g} -&gt; set_bij A B f -&gt; set_bij A B g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /eq_sigLP + /sigL_bijP =&gt; -&gt; /sigL_bijP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_set_bijLR</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> <span class="nv">g</span> : {<span class="kr">in</span> A, f =<span class="mi">1</span> g} -&gt; set_bij A B g -&gt; set_bij A B f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /eq_sigLP + /sigL_bijP =&gt; &lt;- /sigL_bijP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_set_bij</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> <span class="nv">g</span> : {<span class="kr">in</span> A, f =<span class="mi">1</span> g} -&gt; set_bij A B f = set_bij A B g.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; eqfg; <span class="nb">apply</span>/propeqP; <span class="nb">split</span>; [<span class="nb">apply</span>: eq_set_bijRL | <span class="nb">apply</span>: eq_set_bijLR].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bij_omap</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> :
  set_bij (some @` A) (some @` B) (omap f) &lt;-&gt; set_bij A B f.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [/Pbij[b mapfb]|/Pbij[{}f-&gt;//]].
<span class="nb">suff</span> -&gt; : f = unbind f (b \o some) :&gt; (_ -&gt; _) <span class="bp">by</span> [].
<span class="bp">by</span> <span class="nb">apply</span>/funext=&gt; x; <span class="nb">rewrite</span> -mapfb.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bij_olift</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> : set_bij A (some @` B) (olift f) &lt;-&gt; set_bij A B f.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [/Pbij[b liftfb]|/Pbij[{}f-&gt;//]].
<span class="nb">suff</span> -&gt; : f = unbind f b :&gt; (_ -&gt; _) <span class="bp">by</span> [].
<span class="bp">by</span> <span class="nb">apply</span>/funext=&gt; x; <span class="nb">rewrite</span> -liftfb.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">set_bij_basic_lemmas</span>.

<span class="kn">Lemma</span> <span class="nf">bij_sub_sym</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> <span class="nv">C</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> <span class="nv">D</span> : <span class="nb">set</span> rT}
    (<span class="nv">f</span> : {bij A &gt;-&gt; B}) : C `&lt;=` A -&gt; D `&lt;=` B -&gt;
  set_bij D (some @` C) &#39;oinv_f &lt;-&gt; set_bij C D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; CA DB; <span class="nb">gen have</span> oinv_bij : aT rT A C B D CA DB f /
    set_bij C D f -&gt; set_bij D (some @` C) &#39;oinv_f; <span class="nb">last first</span>.
  <span class="nb">split</span>=&gt; bij_oinv; <span class="nb">last</span> <span class="bp">exact</span>: oinv_bij.
  <span class="bp">by</span> <span class="nb">apply</span>/bij_omap; <span class="nb">rewrite</span> -oinvV; <span class="nb">apply</span>: oinv_bij =&gt; //; <span class="nb">apply</span>: image_subset.
<span class="nb">move</span>=&gt; /Pbij[fC ffC]; <span class="nb">suff</span> /eq_set_bij-&gt; : {<span class="kr">in</span> D, &#39;oinv_f =<span class="mi">1</span> &#39;oinv_fC} <span class="bp">by</span> [].
<span class="nb">move</span>=&gt; x xD; <span class="nb">apply</span>: &#39;inj_(oapp f x); <span class="nb">rewrite</span> <span class="nl">?mem_fun</span>//=.
- <span class="bp">by</span> <span class="nb">apply</span>/subsetP : x xD.
- <span class="bp">by</span> <span class="nb">have</span> := mem_set ((image_subset CA) _ (&#39;oinvS_fC (set_mem xD))).
<span class="bp">by</span> <span class="nb">rewrite</span> oinvK <span class="nl">?ffC</span> <span class="nl">?oinvK</span>// ?(subsetP.<span class="mi">2</span> _ _ xD).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">splitbij_sub_sym</span> {<span class="nv">aT</span> <span class="nv">rT</span>} {<span class="nv">A</span> <span class="nv">C</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> <span class="nv">D</span> : <span class="nb">set</span> rT}
    (<span class="nv">f</span> : {splitbij A &gt;-&gt; B}) : C `&lt;=` A -&gt; D `&lt;=` B -&gt;
  set_bij D C f^-<span class="mi">1</span> &lt;-&gt; set_bij C D f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; CA DB; <span class="nb">rewrite</span> -bij_sub_sym// -oliftV bij_olift. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">set_bij_lemmas</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>}.
<span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : aT -&gt; rT).

<span class="kn">Lemma</span> <span class="nf">set_bij00</span> <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">f</span> : T -&gt; U) : set_bij set0 set0 f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; [_ []//|x y|//]; <span class="nb">rewrite</span> inE. <span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> set_bij00 : core.

<span class="kn">Lemma</span> <span class="nf">inj_bij</span> <span class="nv">A</span> <span class="nv">f</span> : {<span class="kr">in</span> A &amp;, injective f} -&gt; set_bij A (f @` A) f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /Pinj[{}f-&gt;]; <span class="nb">apply</span>: &#39;bij_[<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">in</span> <span class="nv">A</span>]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bij_subl</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) : C `&lt;=` A -&gt; f @` C = D -&gt;
  set_bij C D f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /homo_setP CA &lt;-; <span class="nb">split</span>=&gt; // x y /CA + /CA +; <span class="nb">apply</span>: inj. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">set_bij_lemmas</span>.

<span class="kn">Section</span> <span class="nf">set_bij_lemmas</span>.
<span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>}.
<span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> aT) (<span class="nv">B</span> : <span class="nb">set</span> rT) (<span class="nv">f</span> : aT -&gt; rT).

<span class="kn">Lemma</span> <span class="nf">bij_subr</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) : C = A `&amp;` (f @^-<span class="mi">1</span>` D) -&gt; D `&lt;=` B -&gt;
  set_bij C D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; -&gt; DB; <span class="nb">apply</span>/bij_sub_sym=&gt; //; <span class="nb">apply</span>: bij_subl =&gt; //=.
<span class="bp">by</span> <span class="nb">rewrite</span> oinv_sub_image.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bij_sub</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> (<span class="nv">f</span> : {bij A &gt;-&gt; B}) : C `&lt;=` A -&gt; D `&lt;=` B -&gt;
    {homo f : x / C x &gt;-&gt; D x} -&gt;
    {homo &#39;oinv_f : x / D x &gt;-&gt; (some @` C) x} -&gt;
  set_bij C D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; CA DB fCD fDC; <span class="nb">apply</span>: bij_subl =&gt; //; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">apply</span>/image_subP.
<span class="nb">move</span>=&gt; y /[dup]/[dup] Dy /DB By /fDC [x Cx]/= xfy; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; <span class="nb">move</span>: xfy.
<span class="bp">by</span> <span class="nb">case</span>: oinvP =&gt; // a Aa _ [-&gt;].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">splitbij_sub</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> (<span class="nv">f</span> : {splitbij A &gt;-&gt; B}) : C `&lt;=` A -&gt; D `&lt;=` B -&gt;
    {homo f : x / C x &gt;-&gt; D x} -&gt;
    {homo f^-<span class="mi">1</span> : x / D x &gt;-&gt; C x} -&gt;
  set_bij C D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; CA DB /(bij_sub CA DB) /[<span class="nb">swap</span>] fDC; <span class="nb">apply</span>=&gt; x Dx.
<span class="bp">by</span> <span class="nb">rewrite</span> -some_inv/=; <span class="kr">exists</span> (<span class="nv">f</span>^-<span class="mi">1</span> x) =&gt; //; <span class="nb">apply</span>: fDC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">can2_bij</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) (<span class="nv">g</span> : {<span class="kr">fun</span> <span class="nv">B</span> &gt;-&gt; A}) :
  {<span class="kr">in</span> A, cancel f g} -&gt; {<span class="kr">in</span> B, cancel g f} -&gt; set_bij A B f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /can_in_inj finj /can_surj gK; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: gK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bij_sub_setUrl</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> <span class="nv">f</span> : [disjoint B &amp; B&#39;] -&gt;
  set_bij A (B `|` B&#39;) f -&gt; set_bij (A `\` f @^-<span class="mi">1</span>` B&#39;) B f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /disj_setPS BB&#39; /Pbij[{}f-&gt;]; <span class="nb">apply</span>: bij_subr; <span class="nb">last</span> <span class="bp">exact</span>: subsetUl.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; x /= [Ax Bfx]; <span class="nb">split</span>=&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">have</span> [] := &#39;funS_f Ax.
<span class="bp">by</span> <span class="nb">move</span>=&gt; B&#39;fx; <span class="nb">apply</span>: (BB&#39; (f x)).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bij_sub_setUrr</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> <span class="nv">f</span> : [disjoint B &amp; B&#39;] -&gt;
  set_bij A (B `|` B&#39;) f -&gt; set_bij (A `\` f @^-<span class="mi">1</span>` B) B&#39; f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> setUC disj_set_sym; <span class="nb">apply</span>: bij_sub_setUrl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bij_sub_setUll</span> <span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">f</span> : [disjoint A &amp; A&#39;] -&gt;
  set_bij (A `|` A&#39;) B f -&gt; set_bij A (B `\` f @` A&#39;) f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /disj_setPS AA&#39; /Pbij[{}f-&gt;].
<span class="nb">apply</span>: bij_sub =&gt; [|? []//||]; <span class="kp">first</span> <span class="bp">exact</span>: subsetUl.
  <span class="nb">move</span>=&gt; x Ax /=; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: funS; <span class="nb">left</span>.
  <span class="nb">move</span>=&gt; [y] A&#39;y /inj; <span class="nb">rewrite</span> !inE/= =&gt;yx; <span class="nb">apply</span>: (AA&#39; x).
  <span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">rewrite</span> -yx //; [<span class="nb">right</span>|<span class="nb">left</span>].
<span class="nb">move</span>=&gt; z [Bz /= /not_exists2P /contrapT] A&#39;fxz.
<span class="nb">case</span>: oinvP=&gt; // x AA&#39;x fxz; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //.
<span class="bp">by</span> <span class="nb">have</span> := A&#39;fxz x; <span class="nb">rewrite</span> fxz =&gt; -[|//]; <span class="nb">case</span>: AA&#39;x.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bij_sub_setUlr</span> <span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">f</span> : [disjoint A &amp; A&#39;] -&gt;
  set_bij (A `|` A&#39;) B f -&gt; set_bij A&#39; (B `\` f @` A) f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> setUC disj_set_sym; <span class="nb">apply</span>: bij_sub_setUll. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">set_bij_lemmas</span>.

<span class="kn">Lemma</span> <span class="nf">bij_II_D1</span> <span class="nv">T</span> <span class="nv">n</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : nat -&gt; T) :
  set_bij `I_n.+<span class="mi">1</span> A f -&gt; set_bij `I_n (A `\ f n) f.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> IIS -image_set1; <span class="nb">apply</span>: bij_sub_setUll.
<span class="bp">by</span> <span class="nb">apply</span>/disj_setPS =&gt; i [/= /[<span class="nb">swap</span>]-&gt;]; <span class="nb">rewrite</span> ltnn.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">set_bij_comp</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> (<span class="nv">A</span> : <span class="nb">set</span> T1) (<span class="nv">B</span> : <span class="nb">set</span> T2) (<span class="nv">C</span> : <span class="nb">set</span> T3) <span class="nv">f</span> <span class="nv">g</span> :
  set_bij A B f -&gt; set_bij B C g -&gt; set_bij A C (g \o f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /Pbij[{}f-&gt;] /Pbij[{}g-&gt;]; <span class="nb">apply</span>: &#39;bij_(g \o f). <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">pointed_inverse</span>.
<span class="kn">Context</span> {<span class="nv">T</span> <span class="nv">U</span>} (<span class="nv">dflt</span> : U -&gt; T) (<span class="nv">A</span> : <span class="nb">set</span> T).
<span class="kn">Implicit Types</span> (<span class="nv">f</span> : T -&gt; U) (<span class="nv">i</span> : {inj A &gt;-&gt; U}).

<span class="kn">Definition</span> <span class="nf">pinv_</span> <span class="nv">f</span> := (&#39;split_dflt [<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">in</span> <span class="nv">A</span>])^-<span class="mi">1</span>.
<span class="kn">Local Notation</span> <span class="nf">pinv</span> := pinv_.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := Inv.Build _ _ (pinv f) f.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := Fun.on (pinv f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> := SplitInjFun.on (pinv f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">i</span> := SplitBij.on (pinv i).

<span class="kn">Lemma</span> <span class="nf">pinvK</span> <span class="nv">f</span> : {<span class="kr">in</span> f @` A, cancel (pinv f) f}.
<span class="kn">Proof</span>. <span class="bp">exact</span>: &#39;funK_(pinv f). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pinvKV</span> <span class="nv">f</span> : {<span class="kr">in</span> A &amp;, injective f} -&gt; {<span class="kr">in</span> A, cancel f (pinv f)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /Pinj[{}f-&gt;]; <span class="nb">apply</span>: funK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">injpinv_surj</span> <span class="nv">f</span> : {<span class="kr">in</span> A &amp;, injective f} -&gt;
  set_surj (f @` A) A (pinv f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /Pinj[{}f-&gt;]; <span class="nb">apply</span>: surj. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">injpinv_image</span> <span class="nv">f</span> : {<span class="kr">in</span> A &amp;, injective f} -&gt;
  pinv f @` (f @` A) = A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /Pinj[{}f-&gt;]; <span class="nb">rewrite</span> image_eq. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">injpinv_bij</span> <span class="nv">f</span> : {<span class="kr">in</span> A &amp;, injective f} -&gt;
  set_bij (f @` A) A (pinv f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /Pinj[{}f-&gt;]; <span class="nb">apply</span>: bij. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surjpK</span> <span class="nv">B</span> <span class="nv">f</span> : set_surj A B f -&gt; {<span class="kr">in</span> B, cancel (pinv f) f}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /homo_setP BfA; <span class="nb">move</span>=&gt; x /BfA xfA; <span class="nb">rewrite</span> pinvK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surjpinv_image_sub</span> <span class="nv">B</span> <span class="nv">f</span> : set_surj A B f -&gt; pinv f @` B `&lt;=` A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fsurj; <span class="nb">apply</span>: (subset_trans (image_subset fsurj)). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surjpinv_inj</span> <span class="nv">B</span> <span class="nv">f</span> : set_surj A B f -&gt; {<span class="kr">in</span> B &amp;, injective (pinv f)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /homo_setP/sub_in2; <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">surjpinv_bij</span> <span class="nv">B</span> <span class="nv">f</span> (<span class="nv">g</span> := pinv f) : set_surj A B f -&gt;
  set_bij B (g @` B) g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f_surj; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: surjpinv_inj. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bijpinv_bij</span> <span class="nv">B</span> <span class="nv">f</span> : set_bij A B f -&gt; set_bij B A (pinv f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /Pbij[{}f-&gt;]; <span class="nb">have</span> /= := &#39;bij_(pinv f); <span class="nb">rewrite</span> image_eq. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">pPbij</span>.
<span class="kn">Context</span> {<span class="nv">B</span>: <span class="nb">set</span> U} {<span class="nv">f</span> : T -&gt; U} (<span class="nv">fbij</span> : set_bij A B f).
<span class="kn">Lemma</span> <span class="nf">pPbij_</span> : {s : {splitbij A &gt;-&gt; B} | f = s}.
<span class="kn">Proof</span>.
<span class="nb">pose</span> h := [splitbij of &#39;split_dflt [<span class="kr">fun</span> <span class="nv">fbij</span> <span class="nv">in</span> <span class="nv">A</span>]]; <span class="nb">have</span> : f = h <span class="bp">by</span> [].
<span class="bp">by</span> <span class="nb">move</span>: h; <span class="nb">rewrite</span> /= (image_eq fbij) =&gt; h; <span class="kr">exists</span> <span class="nv">h</span>.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">pPbij</span>.

<span class="kn">Section</span> <span class="nf">pPinj</span>.
<span class="kn">Context</span> {<span class="nv">f</span> : T -&gt; U} (<span class="nv">finj</span> : {<span class="kr">in</span> A &amp;, injective f}).
<span class="kn">Lemma</span> <span class="nf">pPinj_</span> : {i : {splitinj A &gt;-&gt; U} | f = i}.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>: finj =&gt; /Pinj[g -&gt;]; <span class="kr">exists</span> [splitinj of &#39;split_dflt [<span class="kr">fun</span> <span class="nv">g</span> <span class="nv">in</span> <span class="nv">A</span>]].
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">pPinj</span>.

<span class="kn">Section</span> <span class="nf">injpPfun</span>.
<span class="kn">Context</span> {<span class="nv">B</span> : <span class="nb">set</span> U} {<span class="nv">f</span> : {inj A &gt;-&gt; U}} (<span class="nv">ffun</span> : {homo f : x / A x &gt;-&gt; B x}).
<span class="kn">Let</span> <span class="nf">g</span> : _ -&gt; _ := f.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := SplitInj.copy g (&#39;split_dflt [<span class="kr">fun</span> <span class="nv">g</span> <span class="nv">in</span> <span class="nv">A</span>]).
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := IsFun.Build _ _ _ _ g ffun.
<span class="kn">Lemma</span> <span class="nf">injpPfun_</span> : {i : {splitinjfun A &gt;-&gt; B} | f = i :&gt; (_ -&gt; _)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> [splitinjfun of g]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">injpPfun</span>.

<span class="kn">Section</span> <span class="nf">funpPinj</span>.
<span class="kn">Context</span> {<span class="nv">B</span> : <span class="nb">set</span> U} {<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}} (<span class="nv">finj</span> : {<span class="kr">in</span> A &amp;, injective f}).
<span class="kn">Lemma</span> <span class="nf">funpPinj_</span> : {i : {splitinjfun A &gt;-&gt; B} | f = i :&gt; (_ -&gt; _)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>: finj &#39;funS_f =&gt; /pPinj_[g -&gt;]/injpPfun_. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">funpPinj</span>.

<span class="kn">End</span> <span class="nf">pointed_inverse</span>.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;pinv_&#39; dflt&quot;</span> := (pinv_ dflt) : form_scope.
<span class="kn">Notation</span> <span class="nf">pinv</span> := &#39;pinv_point.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;pPbij_&#39; dflt&quot;</span> := (pPbij_ dflt) : form_scope.
<span class="kn">Notation</span> <span class="nf">pPbij</span> := &#39;pPbij_point.
<span class="kn">Notation</span> <span class="nf">selfPbij</span> := &#39;pPbij_id.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;pPinj_&#39; dflt&quot;</span> := (pPinj_ dflt) : form_scope.
<span class="kn">Notation</span> <span class="nf">pPinj</span> := &#39;pPinj_point.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;injpPfun_&#39; dflt&quot;</span> := (injpPfun_ dflt) : form_scope.
<span class="kn">Notation</span> <span class="nf">injpPfun</span> := &#39;injpPfun_point.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;funpPinj_&#39; dflt&quot;</span> := (funpPinj_ dflt) : form_scope.
<span class="kn">Notation</span> <span class="nf">funpPinj</span> := &#39;funpPinj_point.

<span class="kn">Section</span> <span class="nf">function_space</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.
<span class="kn">Import</span> GRing.Theory.

<span class="kn">Definition</span> <span class="nf">cst</span> {<span class="nv">T</span> <span class="nv">T&#39;</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : T&#39;) : T -&gt; T&#39; := <span class="kr">fun</span>=&gt; x.

<span class="kn">Lemma</span> <span class="nf">preimage_cst</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : aT) (<span class="nv">A</span> : <span class="nb">set</span> aT) :
  @cst rT _ a @^-<span class="mi">1</span>` A = <span class="kr">if</span> a \<span class="kr">in</span> A <span class="kr">then</span> setT <span class="kr">else</span> set0.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/seteqP; <span class="nb">rewrite</span> /preimage; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> mem_set.
<span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; [/[!inE] ?//|_]; <span class="bp">exact</span>: sub0set.
<span class="kn">Qed</span>.

<span class="kn">Obligation Tactic</span> := <span class="kp">idtac</span>.

<span class="kn">Program Definition</span> <span class="nf">fct_zmodMixin</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">M</span> : zmodType) :=
  @ZmodMixin (T -&gt; M) \<span class="mi">0</span> (<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">x</span> =&gt; - f x) (<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; f \+ g) _ _ _ _.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f g h; <span class="nb">rewrite</span> funeqE=&gt; x /=; <span class="nb">rewrite</span> addrA. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f g; <span class="nb">rewrite</span> funeqE=&gt; x /=; <span class="nb">rewrite</span> addrC. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f; <span class="nb">rewrite</span> funeqE=&gt; x /=; <span class="nb">rewrite</span> add0r. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f; <span class="nb">rewrite</span> funeqE=&gt; x /=; <span class="nb">rewrite</span> addNr. <span class="kn">Qed</span>.
<span class="kn">Canonical</span> <span class="nf">fct_zmodType</span> T (M : zmodType) := ZmodType (T -&gt; M) (fct_zmodMixin T M).

<span class="kn">Program Definition</span> <span class="nf">fct_ringMixin</span> (<span class="nv">T</span> : pointedType) (<span class="nv">M</span> : ringType) :=
  @RingMixin [zmodType of T -&gt; M] (cst <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; f \* g)
             _ _ _ _ _ _.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f g h; <span class="nb">rewrite</span> funeqE=&gt; x /=; <span class="nb">rewrite</span> mulrA. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f; <span class="nb">rewrite</span> funeqE=&gt; x /=; <span class="nb">rewrite</span> mul1r. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f; <span class="nb">rewrite</span> funeqE=&gt; x /=; <span class="nb">rewrite</span> mulr1. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f g h; <span class="nb">rewrite</span> funeqE=&gt; x/=; <span class="nb">rewrite</span> mulrDl. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f g h; <span class="nb">rewrite</span> funeqE=&gt; x/=; <span class="nb">rewrite</span> mulrDr. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; T M ; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> funeqE =&gt; /(_ point) /eqP; <span class="nb">rewrite</span> oner_eq0.
<span class="kn">Qed</span>.
<span class="kn">Canonical</span> <span class="nf">fct_ringType</span> (T : pointedType) (M : ringType) :=
  RingType (T -&gt; M) (fct_ringMixin T M).

Program <span class="kn">Canonical</span> <span class="nf">fct_comRingType</span> (T : pointedType) (M : comRingType) :=
  ComRingType (T -&gt; M) _.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; T M f g; <span class="nb">rewrite</span> funeqE =&gt; x/=; <span class="nb">rewrite</span> mulrC. <span class="kn">Qed</span>.

<span class="kn">Program Definition</span> <span class="nf">fct_lmodMixin</span> (<span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : ringType) (<span class="nv">V</span> : lmodType R)
  := @LmodMixin R [zmodType of U -&gt; V] (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">f</span> =&gt; k \*: f) _ _ _ _.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; U R V k f v; <span class="nb">rewrite</span> funeqE=&gt; x; <span class="bp">exact</span>: scalerA. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; U R V f; <span class="nb">rewrite</span> funeqE=&gt; x /=; <span class="nb">rewrite</span> scale1r. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; U R V f g h; <span class="nb">rewrite</span> funeqE =&gt; x /=; <span class="nb">rewrite</span> scalerDr.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; U R V f g h; <span class="nb">rewrite</span> funeqE =&gt; x /=; <span class="nb">rewrite</span> scalerDl.
<span class="kn">Qed</span>.
<span class="kn">Canonical</span> <span class="nf">fct_lmodType</span> U (R : ringType) (V : lmodType R) :=
  LmodType _ (U -&gt; V) (fct_lmodMixin U V).

<span class="kn">Lemma</span> <span class="nf">fct_sumE</span> (<span class="nv">I</span> <span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">M</span> : zmodType) <span class="nv">r</span> (<span class="nv">P</span> : {pred I}) (<span class="nv">f</span> : I -&gt; T -&gt; M)
    (<span class="nv">x</span> : T) :
  (\sum_(i &lt;- r | P i) f i) x = \sum_(i &lt;- r | P i) f i x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">elim</span>/big_rec2: _ =&gt; //= i y ? Pi &lt;-. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">function_space</span>.

<span class="kn">Section</span> <span class="nf">function_space_lemmas</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.
<span class="kn">Import</span> GRing.Theory.

<span class="kn">Lemma</span> <span class="nf">addrfctE</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">K</span> : zmodType) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; K) :
  f + g = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x + g x).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">opprfctE</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">K</span> : zmodType) (<span class="nv">f</span> : T -&gt; K) : - f = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; - f x).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mulrfctE</span> (<span class="nv">T</span> : pointedType) (<span class="nv">K</span> : ringType) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; K) :
  f * g = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x * g x).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">scalrfctE</span> (<span class="nv">T</span> : pointedType) (<span class="nv">K</span> : ringType) (<span class="nv">L</span> : lmodType K)
    <span class="nv">k</span> (<span class="nv">f</span> : T -&gt; L) :
  k *: f = (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; k *: f x).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cstE</span> (<span class="nv">T</span> <span class="nv">T&#39;</span>: <span class="kt">Type</span>) (<span class="nv">x</span> : T) : cst x = <span class="kr">fun</span> <span class="nv">_</span>: T&#39; =&gt; x.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">exprfctE</span> (<span class="nv">T</span> : pointedType) (<span class="nv">K</span> : ringType) (<span class="nv">f</span> : T -&gt; K) <span class="nv">n</span> :
  f ^+ n = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x ^+ n).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">elim</span>: n =&gt; [|n h]; <span class="nb">rewrite</span> funeqE=&gt; ?; <span class="nb">rewrite</span> <span class="nl">?expr0</span> <span class="nl">?exprS</span> <span class="nl">?h</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">compE</span> (<span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : T1 -&gt; T2) (<span class="nv">g</span> : T2 -&gt; T3) :
  g \o f = <span class="kr">fun</span> <span class="nv">x</span> =&gt; g (f x).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">fctE</span> :=
  (cstE, compE, opprfctE, addrfctE, mulrfctE, scalrfctE, exprfctE).

<span class="kn">End</span> <span class="nf">function_space_lemmas</span>.

<span class="kn">Lemma</span> <span class="nf">inv_funK</span> <span class="nv">T</span> (<span class="nv">R</span> : unitRingType) (<span class="nv">f</span> : T -&gt; R) : f\^-<span class="mi">1</span>\^-<span class="mi">1</span>%R = f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/funeqP =&gt; x; <span class="nb">rewrite</span> /inv_fun/= GRing.invrK. <span class="kn">Qed</span>.</span></pre></article></body></html>