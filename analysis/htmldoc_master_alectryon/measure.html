<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>measure.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect all_algebra finmap.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predI _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predU _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predD _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predC _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ preim _ of _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closedM;
                   GRing.smulr_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedM; GRing.smulr_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed.
New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.sdivr_closed_div;
                   GRing.divr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.sdivr_closedM; GRing.smulr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subalg_closedBM;
                   GRing.subring_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subalg_closedZ; GRing.submod_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divring_closed_div;
                   GRing.sdivr_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divring_closedBM; GRing.subring_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divalg_closedBdiv;
                   GRing.divring_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divalg_closedZ; GRing.subalg_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.Pred.subring_smul;
                   GRing.Pred.smul_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.Pred.subring_semi; GRing.Pred.semiring_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> boolp classical_sets functions.
<span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> cardinality fsbigop mathcomp_extra.
<span class="kn">Require Import</span> reals ereal signed topology normedtype sequences esum numfun.
<span class="kn">From</span> HB <span class="kn">Require Import</span> structures.

<span class="sd">(******************************************************************************)</span>
<span class="c">(*                            Measure Theory                                  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* This files provides a formalization of the basics of measure theory. This  *)</span>
<span class="c">(* includes the formalization of mathematical structures for measure theory   *)</span>
<span class="c">(* and of measures, as well as standard theorems such as the Boole            *)</span>
<span class="c">(* inequality, Caratheodory&#39;s theorem, the Hahn extension, etc.               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* Main references:                                                           *)</span>
<span class="c">(* - Daniel Li, Int√©gration et applications, 2016                             *)</span>
<span class="c">(* - Achim Klenke, Probability Theory 2nd edition, 2014                       *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*      setI_closed G == the set of sets G is closed under finite             *)</span>
<span class="c">(*                       intersection                                         *)</span>
<span class="c">(*      setU_closed G == the set of sets G is closed under finite union       *)</span>
<span class="c">(*      setC_closed G == the set of sets G is closed under complement         *)</span>
<span class="c">(*      setD_closed G == the set of sets G is closed under difference         *)</span>
<span class="c">(*     ndseq_closed G == the set of sets G is closed under non-decreasing     *)</span>
<span class="c">(*                       countable union                                      *)</span>
<span class="c">(*  trivIset_closed G == the set of sets G is closed under pairwise-disjoint  *)</span>
<span class="c">(*                       countable union                                      *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*               setring G == the set of sets G contains the empty set, is    *)</span>
<span class="c">(*                            closed by union, and difference                 *)</span>
<span class="c">(*                &lt;&lt;r G &gt;&gt; := smallest setring G                              *)</span>
<span class="c">(*       sigma_algebra D G == the set of sets G forms a sigma algebra on D    *)</span>
<span class="c">(*             &lt;&lt;s D, G &gt;&gt; == sigma-algebra generated by G on D               *)</span>
<span class="c">(*                         := smallest (sigma_algebra D) G                    *)</span>
<span class="c">(*                &lt;&lt;s G &gt;&gt; := &lt;&lt;s setT, G &gt;&gt;                                  *)</span>
<span class="c">(*      monotone_class D G == G is a monotone class of subsets of D           *)</span>
<span class="c">(*             &lt;&lt;m D, G &gt;&gt; == monotone class generated by G on D              *)</span>
<span class="c">(*                &lt;&lt;m G &gt;&gt; := &lt;&lt;m setT, G &gt;&gt;                                  *)</span>
<span class="c">(*                dynkin G == G is a set of sets that form a Dynkin           *)</span>
<span class="c">(*                            (or a lambda) system                            *)</span>
<span class="c">(*                &lt;&lt;d G &gt;&gt; == Dynkin system generated by G, i.e.,             *)</span>
<span class="c">(*                            smallest dynkin G                               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Mathematical structures for measure theory:                              *)</span>
<span class="c">(*      semiRingOfSetsType == the type of semirings of sets;                  *)</span>
<span class="c">(*                            the carrier is a set of sets A such that        *)</span>
<span class="c">(*                            &quot;measurable A&quot; holds;                           *)</span>
<span class="c">(*                            &quot;measurable A&quot; is printed as &quot;d.-measurable A&quot;  *)</span>
<span class="c">(*                            where d is a &quot;display parameter&quot; whose purpose  *)</span>
<span class="c">(*                            is to distinguish different measurable&#39;s within *)</span>
<span class="c">(*                            the same context                                *)</span>
<span class="c">(*          ringOfSetsType == the type of rings of sets                      *)</span>
<span class="c">(*                            &lt;&lt;r G &gt;&gt; is equipped with a canonical structure *)</span>
<span class="c">(*                            of ring of sets                                 *)</span>
<span class="c">(*   G.-ring.-measurable A == A is measurable for the ring of sets &lt;&lt;r G &gt;&gt;   *)</span>
<span class="c">(*       algebraOfSetsType == the type of algebras of sets                    *)</span>
<span class="c">(*          measurableType == the type of sigma-algebras                      *)</span>
<span class="c">(*                            &lt;&lt;s G &gt;&gt; is equipped with a canonical structure *)</span>
<span class="c">(*                            of measurableType                               *)</span>
<span class="c">(*  G.-sigma.-measurable A == A is measurable for the sigma-algebra &lt;&lt;s G &gt;&gt;  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* discrete_measurable_unit == the measurableType corresponding to            *)</span>
<span class="c">(*                             [set: set unit]                                *)</span>
<span class="c">(* discrete_measurable_bool == the measurableType corresponding to            *)</span>
<span class="c">(*                             [set: set bool]                                *)</span>
<span class="c">(*  discrete_measurable_nat == the measurableType corresponding to            *)</span>
<span class="c">(*                             [set: set nat]                                 *)</span>
<span class="c">(*          salgebraType G == the measurableType corresponding to &lt;&lt;s G &gt;&gt;    *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*      measurable_fun D f == the function f with domain D is measurable      *)</span>
<span class="c">(*    preimage_class D f G == class of the preimages by f of sets in G        *)</span>
<span class="c">(*       image_class D f G == class of the sets with a preimage by f in G     *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Measures:                                                                *)</span>
<span class="c">(*  {content set T -&gt; \bar R} == type of a function over sets of elements of  *)</span>
<span class="c">(*                   type T where R is expected to be a numFieldType such     *)</span>
<span class="c">(*                   that this function maps set0 to 0, is non-negative over  *)</span>
<span class="c">(*                   measurable sets, and is semi-additive                    *)</span>
<span class="c">(*     isContent == corresponding mixin                                       *)</span>
<span class="c">(*     Content == corresponding structure                                     *)</span>
<span class="c">(*  {measure set T -&gt; \bar R} == type of a function over sets of elements     *)</span>
<span class="c">(*                   of type T where R is expected to be a numFieldType such  *)</span>
<span class="c">(*                   that this function maps set0 to 0, is non-negative over  *)</span>
<span class="c">(*                   measurable sets and is semi-sigma-additive               *)</span>
<span class="c">(*     isMeasure0 == mixin that extends a content to a measure with the proof *)</span>
<span class="c">(*                   that it is semi_sigma_additive                           *)</span>
<span class="c">(*     isMeasure == factory corresponding to the type of measures             *)</span>
<span class="c">(*     Measure == structure corresponding to measures                         *)</span>
<span class="c">(*     finite_measure mu == the measure mu is finite                          *)</span>
<span class="c">(*  {sigma_finite_content set T -&gt; \bar R} == contents that are also sigma    *)</span>
<span class="c">(*                                            finite                          *)</span>
<span class="c">(*  {sigma_finite_measure set T -&gt; \bar R} ==                                 *)</span>
<span class="c">(*                    measures that are also sigma finite                     *)</span>
<span class="c">(*     isSigmaFinite == factory corresponding to sigma finiteness             *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*  pushforward mf m == pushforward/image measure of m by f, where mf is a    *)</span>
<span class="c">(*                      proof that f is measurable                            *)</span>
<span class="c">(*              \d_a == Dirac measure                                         *)</span>
<span class="c">(*         msum mu n == the measure corresponding to the sum of the measures  *)</span>
<span class="c">(*                      mu_0, ..., mu_{n-1}                                   *)</span>
<span class="c">(*        @mzero T R == the zero measure                                      *)</span>
<span class="c">(* measure_add m1 m2 == the measure corresponding to the sum of the           *)</span>
<span class="c">(*                      measures m1 and m2                                    *)</span>
<span class="c">(*        mscale r m == the measure of corresponding to fun A =&gt; r * m A      *)</span>
<span class="c">(*                      where r has type {nonneg R}                           *)</span>
<span class="c">(*      mseries mu n == the measure corresponding to the sum of the           *)</span>
<span class="c">(*                      measures mu_n, mu_{n+1}, ...                          *)</span>
<span class="c">(*      mrestr mu mD == restriction of the measure mu to a set D; mD is a     *)</span>
<span class="c">(*                      proof that D is measurable                            *)</span>
<span class="c">(*      counting T R == counting measure                                      *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*   sigma_finite A f == the measure f is sigma-finite on A : set T with      *)</span>
<span class="c">(*                       T : ringOfSetsType.                                  *)</span>
<span class="c">(*   mu.-negligible A == A is mu negligible                                   *)</span>
<span class="c">(*   {ae mu, forall x, P x} == P holds almost everywhere for the measure mu   *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*  {outer_measure set T -&gt; \bar R} == type of an outer measure over sets     *)</span>
<span class="c">(*                   of elements of type T where R is expected to be a        *)</span>
<span class="c">(*                   numFieldType                                             *)</span>
<span class="c">(*     isOuterMeasure == corresponding mixin                                  *)</span>
<span class="c">(*     OuterMeasure == corresponding structure                                *)</span>
<span class="c">(*   mu.-measurable A == A is Caratheodory measurable for the outer measure   *)</span>
<span class="c">(*                   mu, i.e.,                                                *)</span>
<span class="c">(*                   forall B, mu A = mu (A `&amp;` B) + mu (A `&amp;` ~` B)          *)</span>
<span class="c">(*   measure_is_complete mu == the measure mu is complete                     *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Caratheodory theorem (from an outer measure to a measure):               *)</span>
<span class="c">(*    caratheodory_type mu := T, where mu : {outer_measure set T -&gt; \bar R}   *)</span>
<span class="c">(*                         it is a canonical mesurableType copy of T          *)</span>
<span class="c">(*                         the restriction of the outer measure mu to the     *)</span>
<span class="c">(*                         sigma algebra of Caratheodory measurable sets is a *)</span>
<span class="c">(*                         measure                                            *)</span>
<span class="c">(*                         Remark: sets that are negligible for               *)</span>
<span class="c">(*                         this measure are Caratheodory measurable           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Caratheodory theorem (from a premeasure to an outer measure):            *)</span>
<span class="c">(*   measurable_cover X == the set of sequences F such that                   *)</span>
<span class="c">(*                         - forall k, F k is measurable                      *)</span>
<span class="c">(*                         - X `&lt;=` \bigcup_k (F k)                           *)</span>
<span class="c">(*                 mu^* == extension of the measure mu over a semiring of     *)</span>
<span class="c">(*                         sets; it is an outer measure, declared as; we have *)</span>
<span class="c">(*                         the notation [the outer_measure of mu^*])          *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Hahn Extension:                                                          *)</span>
<span class="c">(*          Hahn_ext mu == extension of the content mu over a semiring of     *)</span>
<span class="c">(*                         sets to a measure over the generated sigma algebra *)</span>
<span class="c">(*                         (requires a proof of sigma-sub-additivity)         *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Product of measurable spaces:                                            *)</span>
<span class="c">(*   preimage_classes f1 f2 == sigma-algebra generated by the union of the    *)</span>
<span class="c">(*                             preimages by f1 and the preimages by f2 with   *)</span>
<span class="c">(*                             f1 : T -&gt; T1 and f : T -&gt; T2, T1 and T2 being  *)</span>
<span class="c">(*                             measurableType&#39;s                               *)</span>
<span class="c">(*   (d1, d2).-prod.-measurable A == A is measurable for the sigma-algebra    *)</span>
<span class="c">(*                             generated from T1 x T2, with T1 and T2         *)</span>
<span class="c">(*                             measurableType&#39;s with resp. display d1 and d2  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*      probability T R == probability measure over the measurableType T with *)</span>
<span class="c">(*                         value in R : realType                              *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="kn">Set Implicit Arguments</span>.
<span class="kn">Unset Strict Implicit</span>.
<span class="kn">Unset Printing Implicit Defensive</span>.
<span class="kn">Import</span> Order.TTheory GRing.Theory Num.Def Num.Theory.

<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;s&lt;|&#39; D , G &#39;|&gt;&#39;&quot;</span> (<span class="kn">at level</span> <span class="mi">40</span>, G, D <span class="kn">at next level</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;s&lt;&lt;&#39; A &#39;&gt;&gt;&#39;&quot;</span>.
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;d&lt;&lt;&#39; D &#39;&gt;&gt;&#39;&quot;</span>.
<span class="kn">Reserved Notation</span> <span class="s2">&quot;mu .-negligible&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;mu .-negligible&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;ae&#39; m , P }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;ae&#39;  m ,  P }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;mu .-measurable&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;mu .-measurable&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;\d_&#39; a&quot;</span> (<span class="kn">at level</span> <span class="mi">8</span>, a <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;\d_&#39; a&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;G .-sigma&quot;</span> (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">format</span> <span class="s2">&quot;G .-sigma&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;G .-sigma.-measurable&quot;</span>
 (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;G .-sigma.-measurable&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;d .-ring&quot;</span> (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">format</span> <span class="s2">&quot;d .-ring&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;d .-ring.-measurable&quot;</span>
 (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;d .-ring.-measurable&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;mu .-cara&quot;</span> (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">format</span> <span class="s2">&quot;mu .-cara&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;mu .-cara.-measurable&quot;</span>
 (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;mu .-cara.-measurable&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;mu .-caratheodory&quot;</span>
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;mu .-caratheodory&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&lt;&lt;m&#39; D , G &#39;&gt;&gt;&#39;&quot;</span>
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&lt;&lt;m&#39;  D ,  G  &#39;&gt;&gt;&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&lt;&lt;m&#39; G &#39;&gt;&gt;&#39;&quot;</span>
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&lt;&lt;m&#39;  G  &#39;&gt;&gt;&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&lt;&lt;d&#39; G &#39;&gt;&gt;&#39;&quot;</span>
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&lt;&lt;d&#39;  G &#39;&gt;&gt;&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&lt;&lt;s&#39; D , G &#39;&gt;&gt;&#39;&quot;</span>
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&lt;&lt;s&#39;  D ,  G  &#39;&gt;&gt;&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&lt;&lt;s&#39; G &#39;&gt;&gt;&#39;&quot;</span>
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&lt;&lt;s&#39;  G  &#39;&gt;&gt;&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;&lt;&lt;r&#39; G &#39;&gt;&gt;&#39;&quot;</span>
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&lt;&lt;r&#39;  G &#39;&gt;&gt;&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;content&#39; fUV }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;content&#39;  fUV }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;content&#39; &#39;of&#39; f &#39;as&#39; g ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;content&#39;  &#39;of&#39;  f  &#39;as&#39;  g ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;content&#39; &#39;of&#39; f ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;content&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;measure&#39; fUV }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;measure&#39;  fUV }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;measure&#39; &#39;of&#39; f &#39;as&#39; g ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;measure&#39;  &#39;of&#39;  f  &#39;as&#39;  g ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;measure&#39; &#39;of&#39; f ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;measure&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;outer_measure&#39; fUV }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;outer_measure&#39;  fUV }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;outer_measure&#39; &#39;of&#39; f &#39;as&#39; g ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;outer_measure&#39;  &#39;of&#39;  f  &#39;as&#39;  g ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;outer_measure&#39; &#39;of&#39; f ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;outer_measure&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;p .-prod&quot;</span> (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">format</span> <span class="s2">&quot;p .-prod&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;p .-prod.-measurable&quot;</span>
 (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;p .-prod.-measurable&quot;</span>).

<span class="kn">Inductive</span> <span class="nf">measure_display</span> := default_measure_display.
<span class="kn">Declare Scope</span> measure_display_scope.
<span class="kn">Delimit Scope</span> measure_display_scope <span class="kr">with</span> mdisp.
<span class="kn">Bind Scope</span> measure_display_scope <span class="kr">with</span> measure_display.

<span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.

<span class="kn">Section</span> <span class="nf">classes</span>.
<span class="kn">Context</span> {<span class="nv">T</span>} (<span class="nv">C</span> : <span class="nb">set</span> (<span class="nb">set</span> T) -&gt; <span class="kt">Prop</span>) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)).

<span class="kn">Definition</span> <span class="nf">setC_closed</span> := <span class="kr">forall</span> <span class="nv">A</span>, G A -&gt; G (~` A).
<span class="kn">Definition</span> <span class="nf">setI_closed</span> := <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, G A -&gt; G B -&gt; G (A `&amp;` B).
<span class="kn">Definition</span> <span class="nf">setU_closed</span> := <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, G A -&gt; G B -&gt; G (A `|` B).
<span class="kn">Definition</span> <span class="nf">setD_closed</span> := <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, B `&lt;=` A -&gt; G A -&gt; G B -&gt; G (A `\` B).
<span class="kn">Definition</span> <span class="nf">setDI_closed</span> := <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, G A -&gt; G B -&gt; G (A `\` B).

<span class="kn">Definition</span> <span class="nf">fin_bigcap_closed</span> :=
    <span class="kr">forall</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) <span class="nv">A_</span>, finite_set D -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; G (A_ i)) -&gt;
  G (\bigcap_(i <span class="kr">in</span> D) (A_ i)).

<span class="kn">Definition</span> <span class="nf">finN0_bigcap_closed</span> :=
    <span class="kr">forall</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) <span class="nv">A_</span>, finite_set D -&gt; D !=set0 -&gt;
    (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; G (A_ i)) -&gt;
  G (\bigcap_(i <span class="kr">in</span> D) (A_ i)).

<span class="kn">Definition</span> <span class="nf">fin_bigcup_closed</span> :=
    <span class="kr">forall</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) <span class="nv">A_</span>, finite_set D -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; G (A_ i)) -&gt;
  G (\bigcup_(i <span class="kr">in</span> D) (A_ i)).

<span class="kn">Definition</span> <span class="nf">semi_setD_closed</span> := <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, G A -&gt; G B -&gt; <span class="kr">exists</span> <span class="nv">D</span>,
  [/\ finite_set D, D `&lt;=` G, A `\` B = \bigcup_(X <span class="kr">in</span> D) X &amp; trivIset D id].

<span class="kn">Definition</span> <span class="nf">ndseq_closed</span> :=
 <span class="kr">forall</span> <span class="nv">F</span>, nondecreasing_seq F -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, G (F i)) -&gt; G (\bigcup_i (F i)).

<span class="kn">Definition</span> <span class="nf">trivIset_closed</span> :=
  <span class="kr">forall</span> <span class="nv">F</span> : (<span class="nb">set</span> T)^nat, trivIset setT F -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, G (F n)) -&gt;
                    G (\bigcup_k F k).

<span class="kn">Definition</span> <span class="nf">fin_trivIset_closed</span> :=
  <span class="kr">forall</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T), finite_set D -&gt; trivIset D F -&gt;
   (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; G (F i)) -&gt; G (\bigcup_(k <span class="kr">in</span> D) F k).

<span class="kn">Definition</span> <span class="nf">setring</span> := [/\ G set0, setU_closed &amp; setDI_closed].

<span class="kn">Definition</span> <span class="nf">sigma_algebra</span> :=
  [/\ G set0, (<span class="kr">forall</span> <span class="nv">A</span>, G A -&gt; G (D `\` A)) &amp;
     (<span class="kr">forall</span> <span class="nv">A</span> : (<span class="nb">set</span> T)^nat, (<span class="kr">forall</span> <span class="nv">n</span>, G (A n)) -&gt; G (\bigcup_k A k))].

<span class="kn">Definition</span> <span class="nf">dynkin</span> := [/\ G setT, setC_closed &amp; trivIset_closed].

<span class="kn">Definition</span> <span class="nf">monotone_class</span> :=
  [/\ <span class="kr">forall</span> <span class="nv">A</span>, G A -&gt; A `&lt;=` D, G D, setD_closed &amp; ndseq_closed].

<span class="kn">End</span> <span class="nf">classes</span>.

<span class="kn">Notation</span> <span class="s2">&quot;&#39;&lt;&lt;m&#39; D , G &#39;&gt;&gt;&#39;&quot;</span> := (smallest (monotone_class D) G) :
  classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&lt;&lt;m&#39; G &#39;&gt;&gt;&#39;&quot;</span> := (&lt;&lt;m setT, G&gt;&gt;) : classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&lt;&lt;d&#39; G &#39;&gt;&gt;&#39;&quot;</span> := (smallest dynkin G) : classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&lt;&lt;s&#39; D , G &#39;&gt;&gt;&#39;&quot;</span> := (smallest (sigma_algebra D) G) :
  classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&lt;&lt;s&#39; G &#39;&gt;&gt;&#39;&quot;</span> := (&lt;&lt;s setT, G&gt;&gt;) : classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;&lt;&lt;r&#39; G &#39;&gt;&gt;&#39;&quot;</span> := (smallest setring G) : classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">fin_bigcup_closedP</span> <span class="nv">T</span> (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  (G set0 /\ setU_closed G) &lt;-&gt; fin_bigcup_closed G.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [[G0 GU] I D A DF GA|GU]; <span class="nb">last first</span>.
  <span class="nb">have</span> G0 : G set0 <span class="bp">by</span> <span class="nb">have</span> := GU void set0 point; <span class="nb">rewrite</span> bigcup0//; <span class="nb">apply</span>.
  <span class="bp">by</span> <span class="nb">split</span>=&gt; // A B GA GB; <span class="nb">rewrite</span> -bigcup2inE; <span class="nb">apply</span>: GU =&gt; // -[|[|[]]].
<span class="nb">elim</span>/Pchoice: I =&gt; I <span class="kr">in</span> D DF A GA *; <span class="nb">rewrite</span> -bigsetU_fset_set// big_seq.
<span class="bp">by</span> <span class="nb">elim</span>/big_ind: _ =&gt; // i; <span class="nb">rewrite</span> in_fset_set// inE =&gt; /GA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">finN0_bigcap_closedP</span> <span class="nv">T</span> (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  setI_closed G &lt;-&gt; finN0_bigcap_closed G.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [GI I D A DF [i Di] GA|GI A B GA GB]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -bigcap2inE; <span class="nb">apply</span>: GI =&gt; // [|[|[|[]]]]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>%N.
<span class="nb">elim</span>/Pchoice: I =&gt; I <span class="kr">in</span> D DF i Di A GA *.
<span class="nb">have</span> finDDi : finite_set (D `\ i) <span class="bp">by</span> <span class="bp">exact</span>: finite_setD.
<span class="nb">rewrite</span> (bigcap_setD1 i)// -bigsetI_fset_set// big_seq.
<span class="nb">elim</span>/big_rec: _ =&gt; // [|j B]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> setIT; <span class="nb">apply</span>: GA.
<span class="nb">rewrite</span> in_fset_set// inE =&gt; -[Dj /eqP nij] GAB.
<span class="bp">by</span> <span class="nb">rewrite</span> setICA; <span class="nb">apply</span>: GI =&gt; //; <span class="nb">apply</span>: GA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sedDI_closedP</span> <span class="nv">T</span> (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  setDI_closed G &lt;-&gt; (setI_closed G /\ setD_closed G).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [GDI|[GI GD]].
  <span class="bp">by</span> <span class="nb">split</span>=&gt; A B =&gt; [|AB] =&gt; GA GB; <span class="nb">rewrite</span> -<span class="nl">?setDD</span>//; <span class="kp">do</span> <span class="nl">?apply</span>: (GDI).
<span class="nb">move</span>=&gt; A B GA GB; <span class="nb">suff</span> &lt;- : A `\` (A `&amp;` B) = A `\` B.
  <span class="bp">by</span> <span class="nb">apply</span>: GD =&gt; //; <span class="nb">apply</span>: GI.
<span class="bp">by</span> <span class="nb">rewrite</span> setDE setCI setIUr -setDE setDv set0U.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebra_bigcap</span> <span class="nv">T</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> T)
    (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">J</span> : <span class="nb">set</span> I) :
  (<span class="kr">forall</span> <span class="nv">n</span>, J n -&gt; sigma_algebra D (F n)) -&gt;
  sigma_algebra D (\bigcap_(i <span class="kr">in</span> J) F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mG; <span class="nb">split</span>=&gt; [i Ji|A AJ i Ji|H GH i Ji]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">have</span> [] := mG i.
- <span class="bp">by</span> <span class="nb">have</span> [_ mGiC _] := mG i Ji; <span class="bp">exact</span>/mGiC/AJ.
- <span class="bp">by</span> <span class="nb">have</span> [_ _ mGiU] := mG i Ji; <span class="nb">apply</span>: mGiU =&gt; j; <span class="bp">exact</span>: GH.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebraP</span> <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">C</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  (<span class="kr">forall</span> <span class="nv">X</span>, C X -&gt; X `&lt;=` U) -&gt;
  sigma_algebra U C &lt;-&gt;
  [/\ C U, setD_closed C, ndseq_closed C &amp; setI_closed C].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; C_subU; <span class="nb">split</span> =&gt; [[C0 CD CU]|[DT DC DU DI]]; <span class="nb">split</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> -(setD0 U); <span class="nb">apply</span>: CD.
- <span class="nb">move</span>=&gt; A B BA CA CB; <span class="nb">rewrite</span> (_ : A `\` B = U `\` ((U `\` A) `|` B)).
    <span class="bp">by</span> <span class="nb">apply</span> CD; <span class="nb">rewrite</span> -bigcup2E; <span class="nb">apply</span>: CU =&gt; -[|[|[|]]] //=; <span class="bp">exact</span>: CD.
  <span class="nb">rewrite</span> setDUr setDD [<span class="kr">in</span> RHS]setDE setIACA setIid -setDE setIidr//.
  <span class="bp">by</span> <span class="nb">rewrite</span> setDE; <span class="nb">apply</span>: subIset; <span class="nb">left</span>; <span class="nb">apply</span>: C_subU.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; F ndF DF; <span class="bp">exact</span>: CU.
- <span class="nb">move</span>=&gt; A B DA DB; <span class="nb">rewrite</span> (_ : A `&amp;` B = U `\` ((U `\` A) `|` (U `\` B))).
    <span class="bp">by</span> <span class="nb">apply</span> CD; <span class="nb">rewrite</span> -bigcup2E; <span class="nb">apply</span>: CU =&gt; -[|[|[|]]] //; <span class="bp">exact</span>: CD.
  <span class="nb">rewrite</span> setDUr !setDD setIACA setIid (@setIidr _ U)//.
  <span class="bp">by</span> <span class="nb">apply</span>: subIset; <span class="nb">left</span>; <span class="bp">exact</span>: C_subU.
- <span class="bp">by</span> <span class="nb">rewrite</span> -(setDv U); <span class="bp">exact</span>: DC.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; A CA; <span class="nb">apply</span>: DC =&gt; //; <span class="bp">exact</span>: C_subU.
- <span class="nb">move</span>=&gt; F DF.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> C X](_ : _ = \bigcup_i \big[setU/set0]_(j &lt; i.+<span class="mi">1</span>) F j).
    <span class="nb">apply</span>: DU; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>/subsetPset/subset_bigsetU.
    <span class="nb">elim</span>=&gt; [|n ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr /= big_ord0 set0U; <span class="bp">exact</span>: DF.
    <span class="nb">have</span> CU : setU_closed C.
      <span class="nb">move</span>=&gt; A B DA DB; <span class="nb">rewrite</span> (_ : A `|` B = U `\` ((U `\` A) `&amp;` (U `\` B))).
        <span class="nb">apply</span> DC =&gt; //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: DI; <span class="nb">apply</span>: DC =&gt; //; <span class="bp">exact</span>: C_subU.
        <span class="bp">by</span> <span class="nb">apply</span>: subIset; <span class="nb">left</span>; <span class="nb">apply</span>: subIset; <span class="nb">left</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> setDIr// !setDD (setIidr (C_subU _ DA)) (setIidr (C_subU _ _)).
    <span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr; <span class="bp">exact</span>: CU.
  <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; [[n _ Fnx]|[n _]].
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; //; <span class="nb">rewrite</span> big_ord_recr /=; <span class="nb">right</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_mkord =&gt; -[m /=]; <span class="nb">rewrite</span> ltnS =&gt; _ Fmx; <span class="kr">exists</span> <span class="nv">m</span>.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">generated_sigma_algebra</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)).
<span class="kn">Implicit Types</span> (<span class="nv">M</span> : <span class="nb">set</span> (<span class="nb">set</span> T)).

<span class="kn">Lemma</span> <span class="nf">smallest_sigma_algebra</span> : sigma_algebra D &lt;&lt;s D, G &gt;&gt;.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [|A GA|A GA] P [[P0 PD PU]] GP //.
  <span class="bp">by</span> <span class="nb">apply</span>: (PD); <span class="nb">apply</span>: GA.
<span class="bp">by</span> <span class="nb">apply</span>: (PU) =&gt; n; <span class="nb">apply</span>: GA.
<span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> smallest_sigma_algebra : core.

<span class="kn">Lemma</span> <span class="nf">sub_sigma_algebra2</span> <span class="nv">M</span> : M `&lt;=` G -&gt; &lt;&lt;s D, M &gt;&gt; `&lt;=` &lt;&lt;s D, G &gt;&gt;.
<span class="kn">Proof</span>. <span class="bp">exact</span>: sub_smallest2r. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebra_id</span> : sigma_algebra D G -&gt; &lt;&lt;s D, G &gt;&gt; = G.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /smallest_id-&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_sigma_algebra</span> : G `&lt;=` &lt;&lt;s D, G &gt;&gt;. <span class="kn">Proof</span>. <span class="bp">exact</span>: sub_smallest. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebra0</span> : &lt;&lt;s D, G &gt;&gt; set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: smallest_sigma_algebra. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebraCD</span> : <span class="kr">forall</span> <span class="nv">A</span>, &lt;&lt;s D, G &gt;&gt; A -&gt; &lt;&lt;s D, G &gt;&gt; (D `\` A).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: smallest_sigma_algebra. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebra_bigcup</span> (<span class="nv">A</span> : (<span class="nb">set</span> T)^nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, &lt;&lt;s D, G &gt;&gt; (A i)) -&gt;  &lt;&lt;s D, G &gt;&gt; (\bigcup_i (A i)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: smallest_sigma_algebra A. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">generated_sigma_algebra</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> smallest_sigma_algebra : core.

<span class="kn">Section</span> <span class="nf">generated_setring</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)).
<span class="kn">Implicit Types</span> (<span class="nv">M</span> : <span class="nb">set</span> (<span class="nb">set</span> T)).

<span class="kn">Lemma</span> <span class="nf">smallest_setring</span> : setring &lt;&lt;r G &gt;&gt;.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [|A B GA GB|A B GA GB] P [[P0 PU PDI]] GP //.
  <span class="bp">by</span> <span class="nb">apply</span>: (PU); [<span class="nb">apply</span>: GA|<span class="nb">apply</span>: GB].
<span class="bp">by</span> <span class="nb">apply</span>: (PDI); [<span class="nb">apply</span>: GA|<span class="nb">apply</span>: GB].
<span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> smallest_setring : core.

<span class="kn">Lemma</span> <span class="nf">sub_setring2</span> <span class="nv">M</span> : M `&lt;=` G -&gt; &lt;&lt;r M &gt;&gt; `&lt;=` &lt;&lt;r G &gt;&gt;.
<span class="kn">Proof</span>. <span class="bp">exact</span>: sub_smallest2r. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">setring_id</span> : setring G -&gt; &lt;&lt;r G &gt;&gt; = G.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /smallest_id-&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_setring</span> : G `&lt;=` &lt;&lt;r G &gt;&gt;. <span class="kn">Proof</span>. <span class="bp">exact</span>: sub_smallest. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">setring0</span> : &lt;&lt;r G &gt;&gt; set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: smallest_setring. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">setringDI</span> : setDI_closed &lt;&lt;r G&gt;&gt;.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: smallest_setring. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">setringU</span> : setU_closed &lt;&lt;r G&gt;&gt;.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: smallest_setring. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">setring_fin_bigcup</span> : fin_bigcup_closed &lt;&lt;r G&gt;&gt;.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>/fin_bigcup_closedP; <span class="nb">split</span>; [<span class="nb">apply</span>: setring0|<span class="nb">apply</span>: setringU].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">generated_setring</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> smallest_setring setring0 : core.

<span class="kn">Lemma</span> <span class="nf">monotone_class_g_salgebra</span> <span class="nv">T</span> (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">D</span> : <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">X</span>, &lt;&lt;s D, G &gt;&gt; X -&gt; X `&lt;=` D) -&gt; G D -&gt;
  monotone_class D (&lt;&lt;s D, G &gt;&gt;).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; sDGD GD; <span class="nb">have</span> := smallest_sigma_algebra D G.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /(sigma_algebraP sDGD) [sT sD snd sI]; <span class="nb">split</span>.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">smallest_monotone_classE</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">setIG</span> : setI_closed G).
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">GD</span> : G D).
<span class="kn">Variables</span> (<span class="nv">H</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">monoH</span> : monotone_class D H) (<span class="nv">GH</span> : G `&lt;=` H).

<span class="kn">Lemma</span> <span class="nf">smallest_monotone_classE</span> : (<span class="kr">forall</span> <span class="nv">X</span>, &lt;&lt;s D, G &gt;&gt; X -&gt; X `&lt;=` D) -&gt;
  (<span class="kr">forall</span> <span class="nv">E</span>, monotone_class D E -&gt; G `&lt;=` E -&gt; H `&lt;=` E) -&gt;
  H = &lt;&lt;s D, G &gt;&gt;.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; sDGD smallestH; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.
  <span class="nb">apply</span>: (smallestH _ _ (@sub_sigma_algebra _ D G)).
  <span class="bp">exact</span>: monotone_class_g_salgebra.
<span class="nb">suff</span>: setI_closed H.
  <span class="nb">move</span>=&gt; IH; <span class="nb">apply</span>: smallest_sub =&gt; //.
  <span class="bp">by</span> <span class="nb">apply</span>/sigma_algebraP; <span class="bp">by</span> <span class="nb">case</span>: monoH.
<span class="nb">pose</span> H_ A := [<span class="nb">set</span> X | H X /\ H (X `&amp;` A)].
<span class="nb">have</span> setDH_ A : setD_closed (H_ A).
  <span class="nb">move</span>=&gt; X Y XY [HX HXA] [HY HYA]; <span class="nb">case</span>: monoH =&gt; h _ setDH _; <span class="nb">split</span>.
    <span class="bp">exact</span>: setDH.
  <span class="nb">rewrite</span> (_ : _ `&amp;` _ = (X `&amp;` A) `\` (Y `&amp;` A)); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [[[? ?] ?]|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">split</span> =&gt; // -[].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; [[? ?] YAx]; <span class="nb">split</span> =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: contra_not YAx.
  <span class="bp">by</span> <span class="nb">apply</span>: setDH =&gt; //; <span class="bp">exact</span>: setSI.
<span class="nb">have</span> ndH_ A : ndseq_closed (H_ A).
  <span class="nb">move</span>=&gt; F ndF H_AF; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">case</span>: monoH =&gt; h _ _; <span class="nb">apply</span> =&gt; // =&gt; n; <span class="nb">have</span> [] := H_AF n.
  <span class="nb">rewrite</span> setI_bigcupl; <span class="nb">case</span>: monoH =&gt; h _ _; <span class="nb">apply</span> =&gt; //.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>/subsetPset; <span class="nb">apply</span>: setSI; <span class="nb">apply</span>/subsetPset/ndF.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">have</span> [] := H_AF n.
<span class="nb">have</span> GGH_ X : G X -&gt; G `&lt;=` H_ X.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">split</span>; [<span class="bp">exact</span>: GH | <span class="nb">apply</span>: GH; <span class="bp">exact</span>: setIG].
<span class="nb">have</span> GHH_ X : G X -&gt; H `&lt;=` H_ X.
  <span class="nb">move</span>=&gt; CX; <span class="nb">apply</span>: smallestH; [<span class="nb">split</span> =&gt; //; <span class="nb">last</span> <span class="bp">exact</span>: GGH_|<span class="bp">exact</span>: GGH_].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [? ?]; <span class="nb">case</span>: monoH =&gt; + _ _ _; <span class="bp">exact</span>.
<span class="nb">have</span> HGH_ X : H X -&gt; G `&lt;=` H_ X.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">split</span>; [<span class="bp">exact</span>: GH|<span class="nb">rewrite</span> setIC; <span class="nb">apply</span> GHH_].
<span class="nb">have</span> HHH_ X : H X -&gt; H `&lt;=` H_ X.
  <span class="nb">move</span>=&gt; HX; <span class="nb">apply</span>: (smallestH _ _ (HGH_ _ HX)); <span class="nb">split</span>=&gt; //.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [? ?]; <span class="nb">case</span>: monoH =&gt; + _ _ _; <span class="bp">exact</span>.
  - <span class="bp">exact</span>: HGH_.
<span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">apply</span> HHH_.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">smallest_monotone_classE</span>.

<span class="kn">Section</span> <span class="nf">monotone_class_subset</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">setIG</span> : setI_closed G).
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">GD</span> : G D).
<span class="kn">Variables</span> (<span class="nv">H</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">monoH</span> : monotone_class D H) (<span class="nv">GH</span> : G `&lt;=` H).

<span class="kn">Lemma</span> <span class="nf">monotone_class_subset</span> : (<span class="kr">forall</span> <span class="nv">X</span>, (&lt;&lt;s D, G &gt;&gt;) X -&gt; X `&lt;=` D) -&gt;
  &lt;&lt;s D, G &gt;&gt; `&lt;=` H.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; sDGD; <span class="nb">set</span> M := &lt;&lt;m D, G &gt;&gt;.
<span class="nb">rewrite</span> -(@smallest_monotone_classE _ _ setIG _ _ M) //.
- <span class="bp">exact</span>: smallest_sub.
- <span class="nb">split</span> =&gt; [A MA | E [monoE] | A B BA MA MB E [[EsubD ED setDE ndE] GE] |].
  + <span class="bp">by</span> <span class="nb">case</span>: monoH =&gt; + _ _ _; <span class="nb">apply</span>; <span class="bp">exact</span>: MA.
  + <span class="bp">exact</span>.
  + <span class="bp">by</span> <span class="nb">apply</span> setDE =&gt; //; [<span class="bp">exact</span>: MA|<span class="bp">exact</span>: MB].
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; F ndF MF E [[EsubD ED setDE ndE] CE]; <span class="nb">apply</span> ndE=&gt; // n; <span class="bp">exact</span>: MF.
- <span class="bp">exact</span>: sub_smallest.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; <span class="bp">exact</span>: smallest_sub.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">monotone_class_subset</span>.

<span class="kn">Section</span> <span class="nf">dynkin</span>.
<span class="kn">Variable</span> <span class="nv">T</span> : <span class="kt">Type</span>.
<span class="kn">Implicit Types</span> <span class="nv">G</span> <span class="nv">D</span> : <span class="nb">set</span> (<span class="nb">set</span> T).

<span class="kn">Lemma</span> <span class="nf">dynkinT</span> <span class="nv">G</span> : dynkin G -&gt; G setT. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dynkinC</span> <span class="nv">G</span> : dynkin G -&gt; setC_closed G. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dynkinU</span> <span class="nv">G</span> : dynkin G -&gt; (<span class="kr">forall</span> <span class="nv">F</span> : (<span class="nb">set</span> T)^nat, trivIset setT F -&gt;
  (<span class="kr">forall</span> <span class="nv">n</span>, G (F n)) -&gt; G (\bigcup_k F k)). <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">dynkin</span>.

<span class="kn">Section</span> <span class="nf">dynkin_lemmas</span>.
<span class="kn">Variable</span> <span class="nv">T</span> : <span class="kt">Type</span>.
<span class="kn">Implicit Types</span> <span class="nv">D</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T).

<span class="kn">Lemma</span> <span class="nf">dynkin_monotone</span> <span class="nv">G</span> : dynkin G &lt;-&gt; monotone_class setT G.
<span class="kn">Proof</span>.
<span class="nb">split</span> =&gt; [[GT setCG trG]|[_ GT setDG ndG]]; <span class="nb">split</span> =&gt; //.
- <span class="nb">move</span>=&gt; A B BA GA GB; <span class="nb">rewrite</span> setDE -(setCK (_ `&amp;` _)) setCI; <span class="nb">apply</span>: (setCG).
  <span class="nb">rewrite</span> setCK -bigcup2E; <span class="nb">apply</span> trG.
  + <span class="bp">by</span> <span class="nb">rewrite</span> -trivIset_bigcup2 setIC; <span class="nb">apply</span> subsets_disjoint.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; [|[//|n]]; [<span class="bp">exact</span>: setCG|<span class="nb">rewrite</span> /bigcup2 -setCT; <span class="nb">apply</span>: setCG].
- <span class="nb">move</span>=&gt; F ndF GF; <span class="nb">rewrite</span> eq_bigcup_seqD; <span class="nb">apply</span>: (trG).
    <span class="bp">exact</span>: trivIset_seqD.
  <span class="nb">move</span>=&gt; [/=|n]; <span class="kp">first</span> <span class="bp">exact</span>: GF.
  <span class="nb">rewrite</span> /seqD setDE -(setCK (_ `&amp;` _)) setCI; <span class="nb">apply</span>: (setCG).
  <span class="nb">rewrite</span> setCK -bigcup2E; <span class="nb">apply</span>: trG.
  + <span class="nb">rewrite</span> -trivIset_bigcup2 setIC; <span class="nb">apply</span> subsets_disjoint.
    <span class="bp">exact</span>/subsetPset/ndF/ltnW.
  + <span class="nb">move</span>=&gt; [|[|]]; <span class="nb">rewrite</span> /bigcup2 /=; [<span class="bp">exact</span>/setCG/GF|<span class="bp">exact</span>/GF|].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> -setCT; <span class="nb">apply</span>: setCG.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; A B; <span class="nb">rewrite</span> -setTD; <span class="nb">apply</span>: setDG.
- <span class="nb">move</span>=&gt; F tF GF; <span class="nb">pose</span> A i := \big[setU/set0]_(k &lt; i.+<span class="mi">1</span>) F k.
  <span class="nb">rewrite</span> (_ : bigcup _ _ = \bigcup_i A i); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [[n _ Fn]|[n _]].
      <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; //; <span class="nb">rewrite</span> /A -bigcup_mkord; <span class="kr">exists</span> <span class="nv">n</span>=&gt; //=; <span class="nb">rewrite</span> ltnS.
    <span class="bp">by</span> <span class="nb">rewrite</span> /A -bigcup_mkord =&gt; -[m /=]; <span class="nb">rewrite</span> ltnS =&gt; mn Fmt; <span class="kr">exists</span> <span class="nv">m</span>.
  <span class="nb">apply</span>: ndG; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; a b ab; <span class="bp">exact</span>/subsetPset/subset_bigsetU.
  <span class="nb">elim</span>=&gt; /= =&gt; [|n ih].
    <span class="bp">by</span> <span class="nb">rewrite</span> /A big_ord_recr /= big_ord0 set0U; <span class="bp">exact</span>: GF.
  <span class="nb">rewrite</span> /A /= big_ord_recr /= -/(A n).
  <span class="nb">rewrite</span> (_ : _ `|` _ = ~` (~` A n `\` F n.+<span class="mi">1</span>)); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> setDE setCI !setCK.
  <span class="nb">rewrite</span> -setTD; <span class="nb">apply</span>: (setDG) =&gt; //; <span class="nb">apply</span>: (setDG) =&gt; //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -setTD; <span class="nb">apply</span>: setDG.
  <span class="nb">apply</span>/disjoints_subset; <span class="nb">rewrite</span> setIC.
  <span class="bp">by</span> <span class="nb">apply</span>: (@trivIset_bigsetUI _ predT) =&gt; //; <span class="nb">rewrite</span> /predT /= trueE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dynkin_g_dynkin</span> <span class="nv">G</span> : dynkin (&lt;&lt;d G &gt;&gt;).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [D /= [] []//| | ].
- <span class="bp">by</span> <span class="nb">move</span>=&gt; Y sGY D /= [dD GD]; <span class="bp">exact</span>/(dynkinC dD)/(sGY D).
- <span class="bp">by</span> <span class="nb">move</span>=&gt; F tF gGF D /= [dD GD]; <span class="nb">apply</span> dD =&gt; // k; <span class="bp">exact</span>: gGF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebra_dynkin</span> <span class="nv">G</span> : sigma_algebra setT G -&gt; dynkin G.
<span class="kn">Proof</span>.
<span class="nb">case</span>=&gt; ? DC DU; <span class="nb">split</span> =&gt; [| |? ? ?]; <span class="nb">last</span> <span class="bp">exact</span>: DU.
- <span class="bp">by</span> <span class="nb">rewrite</span> -setC0 -setTD; <span class="bp">exact</span>: DC.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; A GA; <span class="nb">rewrite</span> -setTD; <span class="nb">apply</span>: DC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dynkin_setI_bigsetI</span> <span class="nv">G</span> (<span class="nv">F</span> : (<span class="nb">set</span> T)^nat) : dynkin G -&gt; setI_closed G -&gt;
  (<span class="kr">forall</span> <span class="nv">n</span>, G (F n)) -&gt; <span class="kr">forall</span> <span class="nv">n</span>, G (\big[setI/setT]_(i &lt; n) F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; dG GI GF; <span class="nb">elim</span> =&gt; [|n ih]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr /=; <span class="nb">apply</span>: GI.
<span class="bp">by</span> <span class="nb">rewrite</span> big_ord0; <span class="bp">exact</span>: (dynkinT dG).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dynkin_setI_sigma_algebra</span> <span class="nv">G</span> : dynkin G -&gt; setI_closed G -&gt;
  sigma_algebra setT G.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; dG GI; <span class="nb">split</span> =&gt; [|//|F DF].
- <span class="bp">by</span> <span class="nb">rewrite</span> -setCT; <span class="bp">exact</span>/(dynkinC dG)/(dynkinT dG).
- <span class="bp">by</span> <span class="nb">move</span>=&gt; A GA; <span class="nb">rewrite</span> setTD; <span class="bp">exact</span>: (dynkinC dG).
- <span class="nb">rewrite</span> seqDU_bigcup_eq; <span class="nb">apply</span>/(dynkinU dG) =&gt; //.
  <span class="nb">move</span>=&gt; n; <span class="nb">rewrite</span> /seqDU setDE; <span class="nb">apply</span> GI =&gt; //.
  <span class="nb">rewrite</span> -bigcup_mkord setC_bigcup bigcap_mkord.
  <span class="bp">by</span> <span class="nb">apply</span>: (@dynkin_setI_bigsetI _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ~` F x)) =&gt; // ?; <span class="bp">exact</span>/(dynkinC dG).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">setI_closed_gdynkin_salgebra</span> <span class="nv">G</span> : setI_closed G -&gt; &lt;&lt;d G &gt;&gt; = &lt;&lt;s G &gt;&gt;.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; GI; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: sub_smallest2l; <span class="nb">apply</span>: sigma_algebra_dynkin.
<span class="nb">pose</span> delta (D : <span class="nb">set</span> T) := [<span class="nb">set</span> E | &lt;&lt;d G &gt;&gt; (E `&amp;` D)].
<span class="nb">have</span> ddelta (D : <span class="nb">set</span> T) : &lt;&lt;d G &gt;&gt; D -&gt; dynkin (delta D).
  <span class="nb">move</span>=&gt; dGD; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /delta /= setTI.
  - <span class="nb">move</span>=&gt; E DE; <span class="nb">rewrite</span> /delta /=.
    <span class="nb">have</span> -&gt; : (~` E) `&amp;` D = ~` ((E `&amp;` D) `|` (~` D)).
      <span class="bp">by</span> <span class="nb">rewrite</span> -[LHS]setU0 -(setICl D) -setIUl -setCI -{<span class="mi">2</span>}(setCK D) -setCU.
    <span class="nb">have</span> : &lt;&lt;d G &gt;&gt; ((E `&amp;` D) `|` ~` D).
      <span class="nb">rewrite</span> -bigcup2E =&gt; S [dS GS]; <span class="nb">apply</span>: (dynkinU dS).
        <span class="nb">move</span>=&gt; [|[|i]] [|[|j]] =&gt; // _ _; <span class="nb">rewrite</span> /bigcup2 /=.
        + <span class="bp">by</span> <span class="nb">rewrite</span> -setIA setICr setI0 =&gt; /set0P; <span class="nb">rewrite</span> eqxx.
        + <span class="bp">by</span> <span class="nb">rewrite</span> setI0 =&gt; /set0P; <span class="nb">rewrite</span> eqxx.
        + <span class="bp">by</span> <span class="nb">rewrite</span> setICA setICl setI0 =&gt; /set0P; <span class="nb">rewrite</span> eqxx.
        + <span class="bp">by</span> <span class="nb">rewrite</span> setI0 =&gt; /set0P; <span class="nb">rewrite</span> eqxx.
        + <span class="bp">by</span> <span class="nb">rewrite</span> set0I =&gt; /set0P; <span class="nb">rewrite</span> eqxx.
        + <span class="bp">by</span> <span class="nb">rewrite</span> set0I =&gt; /set0P; <span class="nb">rewrite</span> eqxx.
        + <span class="bp">by</span> <span class="nb">rewrite</span> set0I =&gt; /set0P; <span class="nb">rewrite</span> eqxx.
      <span class="nb">move</span>=&gt; [|[|n]] //; <span class="nb">rewrite</span> /bigcup2 /=; [<span class="bp">exact</span>: DE| |].
      + <span class="nb">suff</span>: &lt;&lt;d G &gt;&gt; (~` D) <span class="bp">by</span> <span class="bp">exact</span>.
        <span class="bp">by</span> <span class="nb">move</span>=&gt; F [dF GF]; <span class="nb">apply</span>: (dynkinC dF) =&gt; //; <span class="bp">exact</span>: dGD.
      + <span class="bp">by</span> <span class="nb">rewrite</span> -setCT; <span class="nb">apply</span>/(dynkinC dS)/(dynkinT dS).
    <span class="bp">by</span> <span class="nb">move</span>=&gt; dGEDD S /= [+ GS] =&gt; dS; <span class="nb">apply</span>/(dynkinC dS); <span class="bp">exact</span>: dGEDD.
  - <span class="nb">move</span>=&gt; F tF deltaDF; <span class="nb">rewrite</span> /delta /= =&gt; S /= [dS GS].
    <span class="nb">rewrite</span> setI_bigcupl; <span class="nb">apply</span>: (dynkinU dS) =&gt; //.
      <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> setIC; <span class="bp">exact</span>: trivIset_setIl.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>: deltaDF.
<span class="nb">have</span> GdG : G `&lt;=` &lt;&lt;d G &gt;&gt; <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ? [_]; <span class="nb">apply</span>.
<span class="nb">have</span> Gdelta A : G A -&gt; G `&lt;=` delta A.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; <span class="nb">rewrite</span> /delta /= =&gt; ? [?]; <span class="nb">apply</span>; <span class="bp">exact</span>/GI.
<span class="nb">have</span> GdGdelta A : G A -&gt; &lt;&lt;d G &gt;&gt; `&lt;=` delta A.
  <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: smallest_sub =&gt; //; <span class="nb">last</span> <span class="bp">exact</span>: Gdelta.
  <span class="bp">by</span> <span class="nb">apply</span>/ddelta; <span class="bp">exact</span>: GdG.
<span class="nb">have</span> dGGI A B : &lt;&lt;d G &gt;&gt; A -&gt; G B -&gt; &lt;&lt;d G &gt;&gt; (A `&amp;` B).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: GdGdelta.
<span class="nb">have</span> dGGdelta A : &lt;&lt;d G &gt;&gt; A -&gt; G `&lt;=` delta A.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; <span class="nb">rewrite</span> /delta /= setIC; <span class="bp">exact</span>: dGGI.
<span class="nb">have</span> dGdGdelta A : &lt;&lt;d G &gt;&gt; A -&gt; &lt;&lt;d G &gt;&gt; `&lt;=` delta A.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: smallest_sub (ddelta _ _) (dGGdelta _ _).
<span class="nb">have</span> dGdGdG A B : &lt;&lt;d G &gt;&gt; A -&gt; &lt;&lt;d G &gt;&gt; B -&gt; &lt;&lt;d G &gt;&gt; (A `&amp;` B).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="bp">exact</span>: dGdGdelta.
<span class="nb">apply</span>: smallest_sub =&gt; //; <span class="nb">apply</span>: dynkin_setI_sigma_algebra =&gt; //.
<span class="bp">exact</span>: dynkin_g_dynkin.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">dynkin_lemmas</span>.

HB.mixin <span class="kn">Record</span> <span class="nf">isSemiRingOfSets</span> (<span class="nv">d</span> : measure_display) <span class="nv">T</span> := {
  ptclass : Pointed.class_of T;
  measurable : <span class="nb">set</span> (<span class="nb">set</span> T) ;
  measurable0 : measurable set0 ;
  measurableI : setI_closed measurable;
  semi_measurableD : semi_setD_closed measurable;
}.

#[short(type=semiRingOfSetsType)]
HB.structure <span class="kn">Definition</span> <span class="nf">SemiRingOfSets</span> <span class="nv">d</span> := {T of isSemiRingOfSets d T}.

<span class="kn">Canonical</span> <span class="nf">semiRingOfSets_eqType</span> d (T : semiRingOfSetsType d) := EqType T ptclass.
<span class="kn">Canonical</span> <span class="nf">semiRingOfSets_choiceType</span> d (T : semiRingOfSetsType d) :=
  ChoiceType T ptclass.
<span class="kn">Canonical</span> <span class="nf">semiRingOfSets_ptType</span> d (T : semiRingOfSetsType d) :=
  PointedType T ptclass.

<span class="kn">Lemma</span> <span class="nf">measurable_curry</span> (<span class="nv">T1</span> <span class="nv">T2</span> : <span class="kt">Type</span>) <span class="nv">d</span> (<span class="nv">T</span> : semiRingOfSetsType d)
    (<span class="nv">G</span> : T1 * T2 -&gt; <span class="nb">set</span> T) (<span class="nv">x</span> : T1 * T2) :
  measurable (G x) &lt;-&gt; measurable (curry G x.<span class="mi">1</span> x.<span class="mi">2</span>).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: x. <span class="kn">Qed</span>.

<span class="kn">Notation</span> <span class="s2">&quot;d .-measurable&quot;</span> := (@measurable d%mdisp) : classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;measurable&quot;</span> :=
  (@measurable default_measure_display) : classical_set_scope.

HB.mixin <span class="kn">Record</span> <span class="nf">RingOfSets_from_semiRingOfSets</span> <span class="nv">d</span> <span class="nv">T</span> <span class="nv">of</span> <span class="nv">isSemiRingOfSets</span> <span class="nv">d</span> <span class="nv">T</span> := {
  measurableU : setU_closed (@measurable d [the semiRingOfSetsType d of T]) }.

#[short(type=ringOfSetsType)]
HB.structure <span class="kn">Definition</span> <span class="nf">RingOfSets</span> <span class="nv">d</span> :=
  {T of RingOfSets_from_semiRingOfSets d T &amp; SemiRingOfSets d T}.

<span class="kn">Canonical</span> <span class="nf">ringOfSets_eqType</span> d (T : ringOfSetsType d) := EqType T ptclass.
<span class="kn">Canonical</span> <span class="nf">ringOfSets_choiceType</span> d (T : ringOfSetsType d) := ChoiceType T ptclass.
<span class="kn">Canonical</span> <span class="nf">ringOfSets_ptType</span> d (T : ringOfSetsType d) := PointedType T ptclass.

HB.mixin <span class="kn">Record</span> <span class="nf">AlgebraOfSets_from_RingOfSets</span> <span class="nv">d</span> <span class="nv">T</span> <span class="nv">of</span> <span class="nv">RingOfSets</span> <span class="nv">d</span> <span class="nv">T</span> := {
  measurableT : measurable [<span class="nb">set</span>: T]
}.

#[short(type=algebraOfSetsType)]
HB.structure <span class="kn">Definition</span> <span class="nf">AlgebraOfSets</span> <span class="nv">d</span> :=
  {T of AlgebraOfSets_from_RingOfSets d T &amp; RingOfSets d T}.

<span class="kn">Canonical</span> <span class="nf">algebraOfSets_eqType</span> d (T : algebraOfSetsType d) := EqType T ptclass.
<span class="kn">Canonical</span> <span class="nf">algebraOfSets_choiceType</span> d (T : algebraOfSetsType d) :=
  ChoiceType T ptclass.
<span class="kn">Canonical</span> <span class="nf">algebraOfSets_ptType</span> d (T : algebraOfSetsType d) :=
  PointedType T ptclass.

HB.mixin <span class="kn">Record</span> <span class="nf">Measurable_from_algebraOfSets</span> <span class="nv">d</span> <span class="nv">T</span> <span class="nv">of</span> <span class="nv">AlgebraOfSets</span> <span class="nv">d</span> <span class="nv">T</span> := {
  bigcupT_measurable : <span class="kr">forall</span> <span class="nv">F</span> : (<span class="nb">set</span> T)^nat, (<span class="kr">forall</span> <span class="nv">i</span>, measurable (F i)) -&gt;
    measurable (\bigcup_i (F i))
}.

#[short(type=measurableType)]
HB.structure <span class="kn">Definition</span> <span class="nf">Measurable</span> <span class="nv">d</span> :=
  {T of Measurable_from_algebraOfSets d T &amp; AlgebraOfSets d T}.

<span class="kn">Canonical</span> <span class="nf">measurable_eqType</span> d (T : measurableType d) := EqType T ptclass.
<span class="kn">Canonical</span> <span class="nf">measurable_choiceType</span> d (T : measurableType d) := ChoiceType T ptclass.
<span class="kn">Canonical</span> <span class="nf">measurable_ptType</span> d (T : measurableType d) := PointedType T ptclass.

HB.factory <span class="kn">Record</span> <span class="nf">isRingOfSets</span> (<span class="nv">d</span> : measure_display) <span class="nv">T</span> := {
  ptclass : Pointed.class_of T;
  measurable : <span class="nb">set</span> (<span class="nb">set</span> T) ;
  measurable0 : measurable set0 ;
  measurableU : setU_closed measurable;
  measurableD : setDI_closed measurable;
}.

HB.builders <span class="kn">Context</span> <span class="nv">d</span> <span class="nv">T</span> <span class="nv">of</span> <span class="nv">isRingOfSets</span> <span class="nv">d</span> <span class="nv">T</span>.
<span class="kn">Implicit Types</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="nb">set</span> T).

<span class="kn">Lemma</span> <span class="nf">mI</span> : setI_closed measurable.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; A B mA mB; <span class="nb">rewrite</span> -setDD; <span class="kp">do</span> <span class="nl">?apply</span>: measurableD. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mD</span> : semi_setD_closed measurable.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A B Am Bm; <span class="kr">exists</span> [<span class="nb">set</span> A `\` B]; <span class="nb">split</span>; <span class="nb">rewrite</span> <span class="nl">?bigcup_set1</span>//.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; C -&gt;; <span class="nb">apply</span>: measurableD.
<span class="bp">by</span> <span class="nb">move</span>=&gt; X Y -&gt; -&gt;.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">T_isSemiRingOfSets</span> :=
  @isSemiRingOfSets.Build d T ptclass measurable measurable0 mI mD.

HB.instance <span class="kn">Definition</span> <span class="nf">T_isRingOfSets</span> :=
  RingOfSets_from_semiRingOfSets.Build d T measurableU.

HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">isAlgebraOfSets</span> (<span class="nv">d</span> : measure_display) <span class="nv">T</span> := {
  ptclass : Pointed.class_of T;
  measurable : <span class="nb">set</span> (<span class="nb">set</span> T) ;
  measurable0 : measurable set0 ;
  measurableU : setU_closed measurable;
  measurableC : setC_closed measurable
}.

HB.builders <span class="kn">Context</span> <span class="nv">d</span> <span class="nv">T</span> <span class="nv">of</span> <span class="nv">isAlgebraOfSets</span> <span class="nv">d</span> <span class="nv">T</span>.

<span class="kn">Lemma</span> <span class="nf">mD</span> : setDI_closed measurable.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A B mA mB; <span class="nb">rewrite</span> setDE -[A]setCK -setCU.
<span class="bp">by</span> <span class="kp">do</span> ?[<span class="nb">apply</span>: measurableU | <span class="nb">apply</span>: measurableC].
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">T_isRingOfSets</span> := @isRingOfSets.Build d T ptclass
  measurable measurable0 measurableU mD.

<span class="kn">Lemma</span> <span class="nf">measurableT</span> : measurable [<span class="nb">set</span>: T].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -setC0; <span class="nb">apply</span>: measurableC; <span class="bp">exact</span>: measurable0. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">T_isAlgebraOfSets</span> : AlgebraOfSets_from_RingOfSets d T :=
  AlgebraOfSets_from_RingOfSets.Build d T measurableT.

HB.<span class="kr">end</span>.

HB.factory <span class="kn">Record</span> <span class="nf">isMeasurable</span> (<span class="nv">d</span> : measure_display) <span class="nv">T</span> := {
  ptclass : Pointed.class_of T;
  measurable : <span class="nb">set</span> (<span class="nb">set</span> T) ;
  measurable0 : measurable set0 ;
  measurableC : <span class="kr">forall</span> <span class="nv">A</span>, measurable A -&gt; measurable (~` A) ;
  measurable_bigcup : <span class="kr">forall</span> <span class="nv">F</span> : (<span class="nb">set</span> T)^nat, (<span class="kr">forall</span> <span class="nv">i</span>, measurable (F i)) -&gt;
    measurable (\bigcup_i (F i))
}.

HB.builders <span class="kn">Context</span> <span class="nv">d</span> <span class="nv">T</span> <span class="nv">of</span> <span class="nv">isMeasurable</span> <span class="nv">d</span> <span class="nv">T</span>.

<span class="kn">Obligation Tactic</span> := <span class="kp">idtac</span>.

<span class="kn">Lemma</span> <span class="nf">mU</span> : setU_closed measurable.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A B mA mB; <span class="nb">rewrite</span> -bigcup2E.
<span class="bp">by</span> <span class="nb">apply</span>: measurable_bigcup =&gt; -[//|[//|i]]; <span class="bp">exact</span>: measurable0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mC</span> : setC_closed measurable. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">apply</span>: measurableC. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">T_isAlgebraOfSets</span> :=
  @isAlgebraOfSets.Build d T ptclass measurable measurable0 mU mC.

HB.instance <span class="kn">Definition</span> <span class="nf">T_isMeasurable</span> :=
  @Measurable_from_algebraOfSets.Build d T measurable_bigcup.

HB.<span class="kr">end</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (measurable set0) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: measurable0] : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (measurable setT) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: measurableT] : core.

<span class="kn">Section</span> <span class="nf">ringofsets_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : ringOfSetsType d).
<span class="kn">Implicit Types</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T.

<span class="kn">Lemma</span> <span class="nf">bigsetU_measurable</span> <span class="nv">I</span> <span class="nv">r</span> (<span class="nv">P</span> : pred I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; measurable (F i)) -&gt;
  measurable (\big[setU/set0]_(i &lt;- r | P i) F i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mF; <span class="nb">elim</span>/big_ind : _ =&gt; //; <span class="bp">exact</span>: measurableU. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fin_bigcup_measurable</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
    finite_set D -&gt;
    (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; measurable (F i)) -&gt;
  measurable (\bigcup_(i <span class="kr">in</span> D) F i).
<span class="kn">Proof</span>.
<span class="nb">elim</span>/Pchoice: I =&gt; I <span class="kr">in</span> D F * =&gt; Dfin Fm.
<span class="nb">rewrite</span> -bigsetU_fset_set// big_seq; <span class="nb">apply</span>: bigsetU_measurable =&gt; i.
<span class="bp">by</span> <span class="nb">rewrite</span> in_fset_set <span class="nl">?inE</span>// =&gt; *; <span class="nb">apply</span>: Fm.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurableD</span> : setDI_closed (@measurable d T).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A B mA mB; <span class="nb">case</span>: (semi_measurableD A B) =&gt; // [D [Dfin Dl -&gt; _]].
<span class="bp">by</span> <span class="nb">apply</span>: fin_bigcup_measurable.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ringofsets_lemmas</span>.

<span class="kn">Section</span> <span class="nf">algebraofsets_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : algebraOfSetsType d).
<span class="kn">Implicit Types</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T.

<span class="kn">Lemma</span> <span class="nf">measurableC</span> <span class="nv">A</span> : measurable A -&gt; measurable (~` A).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mA; <span class="nb">rewrite</span> -setTD; <span class="bp">exact</span>: measurableD. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigsetI_measurable</span> <span class="nv">I</span> <span class="nv">r</span> (<span class="nv">P</span> : pred I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; measurable (F i)) -&gt;
  measurable (\big[setI/setT]_(i &lt;- r | P i) F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF; <span class="nb">rewrite</span> -[X <span class="kr">in</span> measurable X]setCK setC_bigsetI; <span class="nb">apply</span>: measurableC.
<span class="bp">by</span> <span class="nb">apply</span>: bigsetU_measurable =&gt; i Pi; <span class="nb">apply</span>/measurableC/mF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fin_bigcap_measurable</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
    finite_set D -&gt;
    (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; measurable (F i)) -&gt;
  measurable (\bigcap_(i <span class="kr">in</span> D) F i).
<span class="kn">Proof</span>.
<span class="nb">elim</span>/Pchoice: I =&gt; I <span class="kr">in</span> D F * =&gt; Dfin Fm.
<span class="nb">rewrite</span> -bigsetI_fset_set// big_seq; <span class="nb">apply</span>: bigsetI_measurable =&gt; i.
<span class="bp">by</span> <span class="nb">rewrite</span> in_fset_set <span class="nl">?inE</span>// =&gt; *; <span class="nb">apply</span>: Fm.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">algebraofsets_lemmas</span>.

<span class="kn">Section</span> <span class="nf">measurable_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d).
<span class="kn">Implicit Types</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) (<span class="nv">F</span> : (<span class="nb">set</span> T)^nat) (<span class="nv">P</span> : <span class="nb">set</span> nat).

<span class="kn">Lemma</span> <span class="nf">sigma_algebra_measurable</span> : sigma_algebra setT (@measurable d T).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; // [A|]; [<span class="bp">exact</span>: measurableD|<span class="bp">exact</span>: bigcupT_measurable]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigcup_measurable</span> <span class="nv">F</span> <span class="nv">P</span> :
  (<span class="kr">forall</span> <span class="nv">k</span>, P k -&gt; measurable (F k)) -&gt; measurable (\bigcup_(i <span class="kr">in</span> P) F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; PF; <span class="nb">rewrite</span> bigcup_mkcond; <span class="nb">apply</span>: bigcupT_measurable =&gt; k.
<span class="bp">by</span> <span class="nb">case</span>: ifP =&gt; //; <span class="nb">rewrite</span> inE; <span class="bp">exact</span>: PF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigcap_measurable</span> <span class="nv">F</span> <span class="nv">P</span> :
  (<span class="kr">forall</span> <span class="nv">k</span>, P k -&gt; measurable (F k)) -&gt; measurable (\bigcap_(i <span class="kr">in</span> P) F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; PF; <span class="nb">rewrite</span> -[X <span class="kr">in</span> measurable X]setCK setC_bigcap; <span class="nb">apply</span>: measurableC.
<span class="bp">by</span> <span class="nb">apply</span>: bigcup_measurable =&gt; k Pk; <span class="bp">exact</span>/measurableC/PF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigcapT_measurable</span> <span class="nv">F</span> : (<span class="kr">forall</span> <span class="nv">i</span>, measurable (F i)) -&gt;
  measurable (\bigcap_i (F i)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: bigcap_measurable. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measurable_lemmas</span>.

<span class="kn">Lemma</span> <span class="nf">bigcupT_measurable_rat</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">F</span> : rat -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span>, measurable (F i)) -&gt; measurable (\bigcup_i F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Fm; <span class="nb">have</span> /ppcard_eqP[f] := card_rat.
<span class="bp">by</span> <span class="nb">rewrite</span> (reindex_bigcup f^-<span class="mi">1</span>%FUN setT)//=; <span class="bp">exact</span>: bigcupT_measurable.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">discrete_measurable_unit</span>.

<span class="kn">Definition</span> <span class="nf">discrete_measurable_unit</span> : <span class="nb">set</span> (<span class="nb">set</span> unit) := [<span class="nb">set</span>: <span class="nb">set</span> unit].

<span class="kn">Let</span> <span class="nf">discrete_measurable0</span> : discrete_measurable_unit set0. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">discrete_measurableC</span> <span class="nv">X</span> :
  discrete_measurable_unit X -&gt; discrete_measurable_unit (~` X).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">discrete_measurableU</span> (<span class="nv">F</span> : (<span class="nb">set</span> unit)^nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, discrete_measurable_unit (F i)) -&gt;
  discrete_measurable_unit (\bigcup_i F i).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := @isMeasurable.Build default_measure_display unit
  (Pointed.class _) discrete_measurable_unit discrete_measurable0
  discrete_measurableC discrete_measurableU.

<span class="kn">End</span> <span class="nf">discrete_measurable_unit</span>.

<span class="kn">Section</span> <span class="nf">discrete_measurable_bool</span>.

<span class="kn">Definition</span> <span class="nf">discrete_measurable_bool</span> : <span class="nb">set</span> (<span class="nb">set</span> bool) := [<span class="nb">set</span>: <span class="nb">set</span> bool].

<span class="kn">Let</span> <span class="nf">discrete_measurable0</span> : discrete_measurable_bool set0. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">discrete_measurableC</span> <span class="nv">X</span> :
  discrete_measurable_bool X -&gt; discrete_measurable_bool (~` X).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">discrete_measurableU</span> (<span class="nv">F</span> : (<span class="nb">set</span> bool)^nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, discrete_measurable_bool (F i)) -&gt;
  discrete_measurable_bool (\bigcup_i F i).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := @isMeasurable.Build default_measure_display bool
  (Pointed.class _) discrete_measurable_bool discrete_measurable0
  discrete_measurableC discrete_measurableU.

<span class="kn">End</span> <span class="nf">discrete_measurable_bool</span>.

<span class="kn">Section</span> <span class="nf">discrete_measurable_nat</span>.

<span class="kn">Definition</span> <span class="nf">discrete_measurable_nat</span> : <span class="nb">set</span> (<span class="nb">set</span> nat) := [<span class="nb">set</span>: <span class="nb">set</span> nat].

<span class="kn">Let</span> <span class="nf">discrete_measurable_nat0</span> : discrete_measurable_nat set0. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">discrete_measurable_natC</span> <span class="nv">X</span> :
  discrete_measurable_nat X -&gt; discrete_measurable_nat (~` X).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">discrete_measurable_natU</span> (<span class="nv">F</span> : (<span class="nb">set</span> nat)^nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, discrete_measurable_nat (F i)) -&gt;
  discrete_measurable_nat (\bigcup_i F i).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := @isMeasurable.Build default_measure_display nat
  (Pointed.class _) discrete_measurable_nat discrete_measurable_nat0
  discrete_measurable_natC discrete_measurable_natU.

<span class="kn">End</span> <span class="nf">discrete_measurable_nat</span>.

<span class="kn">Definition</span> <span class="nf">sigma_display</span> {<span class="nv">T</span>} : <span class="nb">set</span> (<span class="nb">set</span> T) -&gt; measure_display.
<span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">salgebraType</span> {<span class="nv">T</span>} (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) := T.

<span class="kn">Section</span> <span class="nf">g_salgebra_instance</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : pointedType) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)).

<span class="kn">Lemma</span> <span class="nf">sigma_algebraC</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : &lt;&lt;s G &gt;&gt; A -&gt; &lt;&lt;s G &gt;&gt; (~` A).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; sGA; <span class="nb">rewrite</span> -setTD; <span class="bp">exact</span>: sigma_algebraCD. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">salgebraType_eqType</span> := EqType (salgebraType G) (Equality.class T).
<span class="kn">Canonical</span> <span class="nf">salgebraType_choiceType</span> := ChoiceType (salgebraType G) (Choice.class T).
<span class="kn">Canonical</span> <span class="nf">salgebraType_ptType</span> := PointedType (salgebraType G) (Pointed.class T).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := @isMeasurable.Build (sigma_display G)
  (salgebraType G) (Pointed.class T)
  &lt;&lt;s G &gt;&gt; (@sigma_algebra0 _ setT G) (@sigma_algebraC)
  (@sigma_algebra_bigcup _ setT G).

<span class="kn">End</span> <span class="nf">g_salgebra_instance</span>.

<span class="kn">Notation</span> <span class="s2">&quot;G .-sigma&quot;</span> := (sigma_display G) : measure_display_scope.
<span class="kn">Notation</span> <span class="s2">&quot;G .-sigma.-measurable&quot;</span> :=
  (measurable : <span class="nb">set</span> (<span class="nb">set</span> (salgebraType G))) : classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">measurable_g_measurableTypeE</span> (<span class="nv">T</span> : pointedType) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  sigma_algebra setT G -&gt; G.-sigma.-measurable = G.
<span class="kn">Proof</span>. <span class="bp">exact</span>: sigma_algebra_id. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">measurable_fun</span> <span class="nv">d</span> <span class="nv">d&#39;</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">U</span> : measurableType d&#39;)
    (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; U) :=
  measurable D -&gt; <span class="kr">forall</span> <span class="nv">Y</span>, measurable Y -&gt; measurable (D `&amp;` f @^-<span class="mi">1</span>` Y).

<span class="kn">Section</span> <span class="nf">measurable_fun</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> <span class="nv">d3</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2)
        (<span class="nv">T3</span> : measurableType d3).
<span class="kn">Implicit Type</span> <span class="nf">D</span> E : <span class="nb">set</span> T1.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_id</span> <span class="nv">D</span> : measurable_fun D id.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mD A mA; <span class="nb">apply</span>: measurableI. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_comp</span> <span class="nv">F</span> (<span class="nv">f</span> : T2 -&gt; T3) <span class="nv">E</span> (<span class="nv">g</span> : T1 -&gt; T2) :
  measurable F -&gt; g @` E `&lt;=` F -&gt;
  measurable_fun F f -&gt; measurable_fun E g -&gt; measurable_fun E (f \o g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF FgE mf mg /= mE A mA.
<span class="nb">rewrite</span> comp_preimage.
<span class="nb">rewrite</span> (_ : _ `&amp;` _ = E `&amp;` g @^-<span class="mi">1</span>` (F `&amp;` f @^-<span class="mi">1</span>` A)); <span class="nb">last first</span>.
  <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [|? [?] []//].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x/= [Ex Afgx]; <span class="nb">split</span> =&gt; //; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: FgE.
<span class="bp">by</span> <span class="nb">apply</span>/mg =&gt; //; <span class="bp">exact</span>: mf.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_funT_comp</span> (<span class="nv">f</span> : T2 -&gt; T3) <span class="nv">E</span> (<span class="nv">g</span> : T1 -&gt; T2) :
  measurable_fun setT f -&gt; measurable_fun E g -&gt; measurable_fun E (f \o g).
<span class="kn">Proof</span>. <span class="bp">exact</span>: measurable_fun_comp. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_measurable_fun</span> <span class="nv">D</span> (<span class="nv">f</span> <span class="nv">g</span> : T1 -&gt; T2) :
  {<span class="kr">in</span> D, f =<span class="mi">1</span> g} -&gt; measurable_fun D f -&gt; measurable_fun D g.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dfg Df mD A mA; <span class="nb">rewrite</span> (_ : D `&amp;` _ = D `&amp;` f @^-<span class="mi">1</span>` A); <span class="kp">first</span> <span class="bp">exact</span>: Df.
<span class="nb">apply</span>/seteqP; <span class="nb">rewrite</span> /preimage; <span class="nb">split</span> =&gt; [x /= [Dx Agx]|x /= [Dx Afx]].
  <span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">rewrite</span> Dfg// inE.
<span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">rewrite</span> -Dfg// inE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_cst</span> <span class="nv">D</span> (<span class="nv">r</span> : T2) : measurable_fun D (cst r : T1 -&gt; _).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mD /= Y mY; <span class="nb">rewrite</span> preimage_cst; <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> <span class="nl">?setIT</span> <span class="nl">?setI0</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_funU</span> <span class="nv">D</span> <span class="nv">E</span> (<span class="nv">f</span> : T1 -&gt; T2) :
  measurable D -&gt; measurable E -&gt;
  measurable_fun (D `|` E) f &lt;-&gt; measurable_fun D f /\ measurable_fun E f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD mE; <span class="nb">split</span>=&gt; [mDEf|[mDf mEf] mDE A mA]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> setIUl; <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>: mDf|<span class="bp">exact</span>: mEf].
<span class="nb">split</span>.
- <span class="nb">move</span>=&gt; {}mD A /mDEf =&gt; /(_ (measurableU _ _ mD mE))/(measurableI D)-/(_ mD).
  <span class="bp">by</span> <span class="nb">rewrite</span> setICA setIA setUK.
- <span class="nb">move</span>=&gt; {}mE A /mDEf =&gt; /(_ (measurableU _ _ mD mE))/(measurableI E)-/(_ mE).
 <span class="bp">by</span> <span class="nb">rewrite</span> setICA setIA setUC setUK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_funS</span> <span class="nv">E</span> <span class="nv">D</span> (<span class="nv">f</span> : T1 -&gt; T2) :
    measurable E -&gt; D `&lt;=` E -&gt; measurable_fun E f -&gt;
  measurable_fun D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mE DE mf mD; <span class="nb">have</span> mC : measurable (E `\` D) <span class="bp">by</span> <span class="bp">exact</span>: measurableD.
<span class="nb">move</span>: (mD).
<span class="nb">have</span> := measurable_funU f mD mC.
<span class="nb">suff</span> -&gt; : D `|` (E `\` D) = E <span class="bp">by</span> <span class="nb">move</span>=&gt; [[]] //.
<span class="bp">by</span> <span class="nb">rewrite</span> setDUK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_funTS</span> <span class="nv">D</span> (<span class="nv">f</span> : T1 -&gt; T2) :
  measurable_fun setT f -&gt; measurable_fun D f.
<span class="kn">Proof</span>. <span class="bp">exact</span>: measurable_funS. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_ext</span> <span class="nv">D</span> (<span class="nv">f</span> <span class="nv">g</span> : T1 -&gt; T2) :
  {<span class="kr">in</span> D, f =<span class="mi">1</span> g} -&gt; measurable_fun D f -&gt; measurable_fun D g.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; fg mf mD A mA; <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = D `&amp;` f @^-<span class="mi">1</span>` A);
  [<span class="bp">exact</span>: mf|<span class="bp">exact</span>/esym/eq_preimage].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_restrict</span> <span class="nv">D</span> <span class="nv">E</span> (<span class="nv">f</span> : T1 -&gt; T2) :
  measurable D -&gt; measurable E -&gt; D `&lt;=` E -&gt;
  measurable_fun D f &lt;-&gt; measurable_fun E (f \_ D).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD mE DE; <span class="nb">split</span> =&gt; mf _ /= X mX.
- <span class="nb">rewrite</span> preimage_restrict; <span class="nb">apply</span>/measurableI =&gt; //.
  <span class="bp">by</span> <span class="nb">apply</span>/measurableU/mf =&gt; //; <span class="nb">case</span>: ifP =&gt; // _; <span class="nb">apply</span>: measurableC.
- <span class="nb">have</span> := mf mE _ mX; <span class="nb">rewrite</span> preimage_restrict.
  <span class="nb">case</span>: ifP =&gt; ptX; <span class="nb">last first</span>.
    <span class="nb">rewrite</span> set0U =&gt; /(measurableI _ _ mD).
    <span class="bp">by</span> <span class="nb">rewrite</span> (setIA D) (setIidl DE) setIA setIid.
  <span class="nb">rewrite</span> setUIr setvU setTI =&gt; /(measurableI _ _ mD).
  <span class="bp">by</span> <span class="nb">rewrite</span> setIA (setIidl DE) setIUr setICr set0U.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_if</span> (<span class="nv">g</span> <span class="nv">h</span> : T1 -&gt; T2) <span class="nv">D</span> (<span class="nv">mD</span> : measurable D)
    (<span class="nv">f</span> : T1 -&gt; bool) (<span class="nv">mf</span> : measurable_fun D f) :
  measurable_fun (D `&amp;` (f @^-<span class="mi">1</span>` [<span class="nb">set</span> true])) g -&gt;
  measurable_fun (D `&amp;` (f @^-<span class="mi">1</span>` [<span class="nb">set</span> false])) h -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">t</span> =&gt; <span class="kr">if</span> f t <span class="kr">then</span> g t <span class="kr">else</span> h t).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mx my /= _ B mB; <span class="nb">rewrite</span> (_ : _ @^-<span class="mi">1</span>` B =
  ((f @^-<span class="mi">1</span>` [<span class="nb">set</span> true]) `&amp;` (g @^-<span class="mi">1</span>` B) `&amp;` (f @^-<span class="mi">1</span>` [<span class="nb">set</span> true])) `|`
  ((f @^-<span class="mi">1</span>` [<span class="nb">set</span> false]) `&amp;` (h @^-<span class="mi">1</span>` B) `&amp;` (f @^-<span class="mi">1</span>` [<span class="nb">set</span> false]))).
  <span class="nb">rewrite</span> setIUr; <span class="nb">apply</span>: measurableU.
  - <span class="bp">by</span> <span class="nb">rewrite</span> setIAC setIid setIA; <span class="nb">apply</span>: mx =&gt; //; <span class="bp">exact</span>: mf.
  - <span class="bp">by</span> <span class="nb">rewrite</span> setIAC setIid setIA; <span class="nb">apply</span>: my =&gt; //; <span class="bp">exact</span>: mf.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [t /=| t]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; ft; [<span class="nb">left</span>|<span class="nb">right</span>].
<span class="bp">by</span> <span class="nb">move</span>=&gt; /= [|]; <span class="nb">case</span>: ifPn =&gt; ft; <span class="nb">case</span>=&gt; -[].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_ifT</span> (<span class="nv">g</span> <span class="nv">h</span> : T1 -&gt; T2) (<span class="nv">f</span> : T1 -&gt; bool)
    (<span class="nv">mf</span> : measurable_fun setT f) :
  measurable_fun setT g -&gt; measurable_fun setT h -&gt;
  measurable_fun setT (<span class="kr">fun</span> <span class="nv">t</span> =&gt; <span class="kr">if</span> f t <span class="kr">then</span> g t <span class="kr">else</span> h t).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mx my; <span class="nb">apply</span>: measurable_fun_if =&gt; //;
  [<span class="bp">exact</span>: measurable_funS mx|<span class="bp">exact</span>: measurable_funS my].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_bool</span> <span class="nv">D</span> (<span class="nv">f</span> : T1 -&gt; bool) <span class="nv">b</span> :
  measurable (f @^-<span class="mi">1</span>` [<span class="nb">set</span> b]) -&gt; measurable_fun D f.
<span class="kn">Proof</span>.
<span class="nb">have</span> FNT : [<span class="nb">set</span> false] = [<span class="nb">set</span>~ true] <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; -[]//=.
<span class="nb">wlog</span> {b}-&gt; : b / b = true.
  <span class="nb">case</span>: b =&gt; [|h]; <span class="kp">first</span> <span class="bp">exact</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> FNT -preimage_setC =&gt; /measurableC; <span class="nb">rewrite</span> setCK; <span class="bp">exact</span>: h.
<span class="nb">move</span>=&gt; mfT mD /= Y; <span class="nb">have</span> := @subsetT _ Y; <span class="nb">rewrite</span> setT_bool =&gt; YT.
<span class="nb">have</span> [-&gt; _|-&gt; _|-&gt; _ |-&gt; _] := subset_set2 YT.
- <span class="bp">by</span> <span class="nb">rewrite</span> preimage0 <span class="nl">?setI0</span>.
- <span class="bp">by</span> <span class="nb">apply</span>: measurableI =&gt; //; <span class="bp">exact</span>: mfT.
- <span class="nb">rewrite</span> -[X <span class="kr">in</span> measurable X]setCK; <span class="nb">apply</span>: measurableC; <span class="nb">rewrite</span> setCI.
  <span class="nb">apply</span>: measurableU; <span class="kp">first</span> <span class="bp">exact</span>: measurableC.
  <span class="bp">by</span> <span class="nb">rewrite</span> FNT preimage_setC setCK; <span class="bp">exact</span>: mfT.
- <span class="bp">by</span> <span class="nb">rewrite</span> -setT_bool preimage_setT setIT.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measurable_fun</span>.
<span class="kn">Arguments</span> measurable_fun_ext {d1 d2 T1 T2 D} f {g}.
<span class="kn">Arguments</span> measurable_fun_bool {d1 T1 D f} b.

<span class="kn">Section</span> <span class="nf">measurability</span>.

<span class="kn">Definition</span> <span class="nf">preimage_class</span> (<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT)
    (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> rT)) : <span class="nb">set</span> (<span class="nb">set</span> aT) :=
  [<span class="nb">set</span> D `&amp;` f @^-<span class="mi">1</span>` B | B <span class="kr">in</span> G].

<span class="c">(* f is measurable on the sigma-algebra generated by itself *)</span>
<span class="kn">Lemma</span> <span class="nf">preimage_class_measurable_fun</span> <span class="nv">d</span> (<span class="nv">aT</span> : pointedType) (<span class="nv">rT</span> : measurableType d)
  (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT) :
  measurable_fun (D : <span class="nb">set</span> (salgebraType (preimage_class D f measurable))) f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mD A mA; <span class="nb">apply</span>: sub_sigma_algebra; <span class="kr">exists</span> <span class="nv">A</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebra_preimage_class</span> (<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> rT))
    (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT) :
  sigma_algebra setT G -&gt; sigma_algebra D (preimage_class D f G).
<span class="kn">Proof</span>.
<span class="nb">case</span>=&gt; h0 hC hU; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">set0</span> =&gt; //; <span class="nb">rewrite</span> preimage_set0 setI0.
- <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> /preimage_class /= =&gt; -[B mB &lt;-{A}].
  <span class="kr">exists</span> (~` B); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -setTD; <span class="bp">exact</span>: hC.
  <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [[Dx Bfx]|[Dx]]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">split</span> =&gt; // -[] _ /Bfx.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /not_andP[].
- <span class="nb">move</span>=&gt; F; <span class="nb">rewrite</span> /preimage_class /= =&gt; mF.
  <span class="nb">have</span> {}mF n : <span class="kr">exists</span> <span class="nv">x</span>, G x /\ D `&amp;` f @^-<span class="mi">1</span>` x = F n.
    <span class="bp">by</span> <span class="nb">have</span> := mF n =&gt; -[B mB &lt;-]; <span class="kr">exists</span> <span class="nv">B</span>.
  <span class="nb">have</span> [F&#39; mF&#39;] := @choice _ _ (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; G y /\ D `&amp;` f @^-<span class="mi">1</span>` y = F x) mF.
  <span class="kr">exists</span> (\bigcup_k (F&#39; k)); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: hU =&gt; n; <span class="bp">exact</span>: (mF&#39; n).<span class="mi">1</span>.
  <span class="nb">rewrite</span> preimage_bigcup setI_bigcupr; <span class="nb">apply</span>: eq_bigcupr =&gt; i _.
  <span class="bp">exact</span>: (mF&#39; i).<span class="mi">2</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">image_class</span> (<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT)
    (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> aT)) : <span class="nb">set</span> (<span class="nb">set</span> rT) :=
  [<span class="nb">set</span> B : <span class="nb">set</span> rT | G (D `&amp;` f @^-<span class="mi">1</span>` B)].

<span class="kn">Lemma</span> <span class="nf">sigma_algebra_image_class</span> (<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT)
    (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> aT)) :
  sigma_algebra D G -&gt; sigma_algebra setT (image_class D f G).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [G0 GC GU]; <span class="nb">split</span>; <span class="nb">rewrite</span> /image_class.
- <span class="bp">by</span> <span class="nb">rewrite</span> /= preimage_set0 setI0.
- <span class="nb">move</span>=&gt; A /= GfAD; <span class="nb">rewrite</span> setTD -preimage_setC -setDE.
  <span class="nb">rewrite</span> (_ : _ `\` _ = D `\` (D `&amp;` f @^-<span class="mi">1</span>` A)); <span class="kp">first</span> <span class="bp">exact</span>: GC.
  <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [[Dx fAx]|[Dx fADx]].
    <span class="bp">by</span> <span class="nb">split</span> =&gt; // -[] _ /fAx.
  <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: contra_not fADx.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; F /= mF; <span class="nb">rewrite</span> preimage_bigcup setI_bigcupr; <span class="bp">exact</span>: GU.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebra_preimage_classE</span> <span class="nv">aT</span> (<span class="nv">rT</span> : pointedType) (<span class="nv">D</span> : <span class="nb">set</span> aT)
    (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">G&#39;</span> : <span class="nb">set</span> (<span class="nb">set</span> rT)) :
  &lt;&lt;s D, preimage_class D f G&#39; &gt;&gt; =
    preimage_class D f (G&#39;.-sigma.-measurable).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.
  <span class="nb">have</span> mG : sigma_algebra D
      (preimage_class D f (G&#39;.-sigma.-measurable)).
    <span class="bp">exact</span>/sigma_algebra_preimage_class/sigma_algebra_measurable.
  <span class="nb">have</span> subset_preimage : preimage_class D f G&#39; `&lt;=`
                         preimage_class D f (G&#39;.-sigma.-measurable).
    <span class="bp">by</span> <span class="nb">move</span>=&gt; A [B CCB &lt;-{A}]; <span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="nb">apply</span>: sub_sigma_algebra.
  <span class="bp">exact</span>: smallest_sub.
<span class="nb">have</span> G&#39;pre A&#39; : G&#39; A&#39; -&gt; (preimage_class D f G&#39;) (D `&amp;` f @^-<span class="mi">1</span>` A&#39;).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="kr">exists</span> <span class="nv">A&#39;</span>.
<span class="nb">pose</span> I : <span class="nb">set</span> (<span class="nb">set</span> aT) := &lt;&lt;s D, preimage_class D f G&#39; &gt;&gt;.
<span class="nb">have</span> G&#39;sfun : G&#39; `&lt;=` image_class D f I.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; A&#39; /G&#39;pre[B G&#39;B h]; <span class="nb">apply</span>: sub_sigma_algebra; <span class="kr">exists</span> <span class="nv">B</span>.
<span class="nb">have</span> sG&#39;sfun : &lt;&lt;s G&#39; &gt;&gt; `&lt;=` image_class D f I.
  <span class="nb">apply</span>: smallest_sub =&gt; //; <span class="nb">apply</span>: sigma_algebra_image_class.
  <span class="bp">exact</span>: smallest_sigma_algebra.
<span class="bp">by</span> <span class="nb">move</span>=&gt; _ [B mB &lt;-]; <span class="bp">exact</span>: sG&#39;sfun.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurability</span> <span class="nv">d</span> <span class="nv">d&#39;</span> (<span class="nv">aT</span> : measurableType d) (<span class="nv">rT</span> : measurableType d&#39;)
    (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT)
    (<span class="nv">G&#39;</span> : <span class="nb">set</span> (<span class="nb">set</span> rT)) :
  @measurable _ rT = &lt;&lt;s G&#39; &gt;&gt; -&gt; preimage_class D f G&#39; `&lt;=` @measurable _ aT -&gt;
  measurable_fun D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; sG_rT fG_aT mD.
<span class="nb">suff</span> h : preimage_class D f (@measurable _ rT) `&lt;=` @measurable _ aT.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; A mA; <span class="nb">apply</span>: h; <span class="kr">exists</span> <span class="nv">A</span>.
<span class="nb">have</span> -&gt; : preimage_class D f (@measurable _ rT) =
         &lt;&lt;s D , (preimage_class D f G&#39;)&gt;&gt;.
  <span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> LHS]sG_rT [<span class="kr">in</span> RHS]sigma_algebra_preimage_classE.
<span class="nb">apply</span>: smallest_sub =&gt; //; <span class="nb">split</span> =&gt; //.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; A mA; <span class="bp">exact</span>: measurableD.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; F h; <span class="bp">exact</span>: bigcupT_measurable.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measurability</span>.

<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Section</span> <span class="nf">additivity</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : semiRingOfSetsType d)
        (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R).

<span class="kn">Definition</span> <span class="nf">semi_additive2</span> := <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, measurable A -&gt; measurable B -&gt;
  measurable (A `|` B) -&gt;
  A `&amp;` B = set0 -&gt; mu (A `|` B) = mu A + mu B.

<span class="kn">Definition</span> <span class="nf">semi_additive</span> := <span class="kr">forall</span> <span class="nv">F</span> <span class="nv">n</span>,
 (<span class="kr">forall</span> <span class="nv">k</span> : nat, measurable (F k)) -&gt; trivIset setT F -&gt;
  measurable (\big[setU/set0]_(k &lt; n) F k) -&gt;
  mu (\big[setU/set0]_(i &lt; n) F i) = \sum_(i &lt; n) mu (F i).

<span class="kn">Definition</span> <span class="nf">semi_sigma_additive</span> :=
  <span class="kr">forall</span> <span class="nv">F</span>, (<span class="kr">forall</span> <span class="nv">i</span> : nat, measurable (F i)) -&gt; trivIset setT F -&gt;
  measurable (\bigcup_n F n) -&gt;
  (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n) mu (F i)) --&gt; mu (\bigcup_n F n).

<span class="kn">Definition</span> <span class="nf">additive2</span> := <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, measurable A -&gt; measurable B -&gt;
  A `&amp;` B = set0 -&gt; mu (A `|` B) = mu A + mu B.

<span class="kn">Definition</span> <span class="nf">additive</span> :=
  <span class="kr">forall</span> <span class="nv">F</span>, (<span class="kr">forall</span> <span class="nv">i</span> : nat, measurable (F i)) -&gt; trivIset setT F -&gt;
  <span class="kr">forall</span> <span class="nv">n</span>, mu (\big[setU/set0]_(i &lt; n) F i) = \sum_(i &lt; n) mu (F i).

<span class="kn">Definition</span> <span class="nf">sigma_additive</span> :=
  <span class="kr">forall</span> <span class="nv">F</span>, (<span class="kr">forall</span> <span class="nv">i</span> : nat, measurable (F i)) -&gt; trivIset setT F -&gt;
  (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n) mu (F i)) --&gt; mu (\bigcup_n F n).

<span class="kn">Definition</span> <span class="nf">sub_additive</span> := <span class="kr">forall</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">F</span> : nat -&gt; <span class="nb">set</span> T) <span class="nv">n</span>,
 (<span class="kr">forall</span> <span class="nv">k</span>, `I_n k -&gt; measurable (F k)) -&gt; measurable A -&gt;
  A `&lt;=` \big[setU/set0]_(k &lt; n) F k -&gt;
  mu A &lt;= \sum_(k &lt; n) mu (F k).

<span class="kn">Definition</span> <span class="nf">sigma_sub_additive</span> := <span class="kr">forall</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">F</span> : nat -&gt; <span class="nb">set</span> T),
 (<span class="kr">forall</span> <span class="nv">n</span>, measurable (F n)) -&gt; measurable A -&gt;
  A `&lt;=` \bigcup_n F n -&gt;
  mu A &lt;= \sum_(n &lt;oo) mu (F n).

<span class="kn">Definition</span> <span class="nf">sigma_finite</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) :=
  <span class="kr">exists2</span> F : (<span class="nb">set</span> T)^nat,  A = \bigcup_(i : nat) F i &amp;
      <span class="kr">forall</span> <span class="nv">i</span>, measurable (F i) /\ mu (F i) &lt; +oo.

<span class="kn">Lemma</span> <span class="nf">semi_additiveW</span> : mu set0 = <span class="mi">0</span> -&gt; semi_additive -&gt; semi_additive2.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mu0 amx A B mA mB + AB; <span class="nb">rewrite</span> -bigcup2inE bigcup_mkord.
<span class="nb">move</span>=&gt; /(amx (bigcup2 A B))-&gt;.
- <span class="bp">by</span> <span class="nb">rewrite</span> !(big_ord_recl, big_ord0)/= adde0.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; [|[|[]]]//=.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; [|[|i]] [|[|j]]/= _ _; <span class="nb">rewrite</span> ?(AB, setI0, set0I, setIC) =&gt; -[].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">additivity</span>.

<span class="kn">Section</span> <span class="nf">ring_additivity</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : ringOfSetsType d) (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R).

<span class="kn">Lemma</span> <span class="nf">semi_additiveE</span> : semi_additive mu = additive mu.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [sa A mA tA n|+ A m mA tA UAm]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>-&gt;.
<span class="bp">by</span> <span class="nb">rewrite</span> sa //; <span class="bp">exact</span>: bigsetU_measurable.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">semi_additive2E</span> : semi_additive2 mu = additive2 mu.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [amu A B ? ? ?|amu A B ? ? _ ?]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> amu.
<span class="bp">by</span> <span class="nb">rewrite</span> amu //; <span class="bp">exact</span>: measurableU.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">additive2P</span> : mu set0 = <span class="mi">0</span> -&gt; semi_additive mu &lt;-&gt; additive2 mu.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mu0; <span class="nb">rewrite</span> -semi_additive2E; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: semi_additiveW.
<span class="nb">rewrite</span> semi_additiveE semi_additive2E =&gt; muU A Am Atriv n.
<span class="nb">elim</span>: n =&gt; [|n IHn]; <span class="nb">rewrite</span> ?(big_ord_recr, big_ord0) <span class="nl">?mu0</span>//=.
<span class="nb">rewrite</span> muU <span class="nl">?IHn</span>//=; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: bigsetU_measurable.
<span class="nb">rewrite</span> -bigcup_mkord -subset0 =&gt; x [[/= m + Amx] Anx].
<span class="bp">by</span> <span class="nb">rewrite</span> (Atriv m n) <span class="nl">?ltnn</span>//=; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ring_additivity</span>.

<span class="kn">Lemma</span> <span class="nf">semi_sigma_additive_is_additive</span> <span class="nv">d</span>
  (<span class="nv">R</span> : realFieldType (*TODO: numFieldType <span class="kr">if</span> possible?*))
  (<span class="nv">X</span> : semiRingOfSetsType d) (<span class="nv">mu</span> : <span class="nb">set</span> X -&gt; \bar R) :
  mu set0 = <span class="mi">0</span> -&gt; semi_sigma_additive mu -&gt; semi_additive mu.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mu0 samu A n Am Atriv UAm.
<span class="nb">have</span> := samu (<span class="kr">fun</span> <span class="nv">i</span> =&gt; <span class="kr">if</span> (i &lt; n)%N <span class="kr">then</span> A i <span class="kr">else</span> set0).
<span class="nb">rewrite</span> (bigcup_splitn n) bigcup0 <span class="nl">?setU0</span>; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i _; <span class="nb">rewrite</span> -ltn_subRL subnn.
<span class="nb">under</span> eq_bigr <span class="kp">do</span> <span class="nb">rewrite</span> ltn_ord.
<span class="nb">move</span>=&gt; /(_ _ _ UAm)/(@cvg_lim _) &lt;-//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">case</span>: ifP.
- <span class="nb">move</span>=&gt; i j _ _; <span class="kp">do</span> <span class="mi">2</span>![<span class="nb">case</span>: ifP] =&gt; ? ?; <span class="kp">do</span> <span class="nl">?by</span> <span class="nb">rewrite</span> (setI0, set0I) =&gt; -[].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /Atriv; <span class="nb">apply</span>.
<span class="nb">apply</span>: lim_near_cst =&gt; //=; near=&gt; i.
<span class="nb">have</span> /subnKC&lt;- : (n &lt;= i)%N <span class="bp">by</span> near: i; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="nb">transitivity</span> (\sum_(j &lt; n + (i - n)) mu (<span class="kr">if</span> (j &lt; n)%N <span class="kr">then</span> A j <span class="kr">else</span> set0)).
  <span class="bp">by</span> <span class="nb">rewrite</span> big_mkord.
<span class="nb">rewrite</span> big_split_ord/=; <span class="nb">under</span> eq_bigr <span class="kp">do</span> <span class="nb">rewrite</span> ltn_ord.
<span class="bp">by</span> <span class="nb">rewrite</span> [X <span class="kr">in</span> _ + X]big1 <span class="nl">?adde0</span>// =&gt; ?; <span class="nb">rewrite</span> -ltn_subRL subnn.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">semi_sigma_additiveE</span>
  (<span class="nv">R</span> : numFieldType) <span class="nv">d</span> (<span class="nv">X</span> : measurableType d) (<span class="nv">mu</span> : <span class="nb">set</span> X -&gt; \bar R) :
  semi_sigma_additive mu = sigma_additive mu.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [amu A mA tA|amu A mA tA mbigcupA]; <span class="nb">last</span> <span class="bp">exact</span>: amu.
<span class="bp">by</span> <span class="nb">apply</span>: amu =&gt; //; <span class="bp">exact</span>: bigcupT_measurable.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_additive_is_additive</span>
  (<span class="nv">R</span> : realFieldType) <span class="nv">d</span> (<span class="nv">X</span> : measurableType d) (<span class="nv">mu</span> : <span class="nb">set</span> X -&gt; \bar R) :
  mu set0 = <span class="mi">0</span> -&gt; sigma_additive mu -&gt; additive mu.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mu0; <span class="nb">rewrite</span> -semi_sigma_additiveE -semi_additiveE.
<span class="bp">exact</span>: semi_sigma_additive_is_additive.
<span class="kn">Qed</span>.

HB.mixin <span class="kn">Record</span> <span class="nf">isContent</span> <span class="nv">d</span>
    (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : semiRingOfSetsType d) (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) := {
  measure_ge0 : <span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= mu x ;
  measure_semi_additive : semi_additive mu }.

HB.structure <span class="kn">Definition</span> <span class="nf">Content</span> <span class="nv">d</span>
    (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : semiRingOfSetsType d) := {
  mu &amp; isContent d R T mu }.

<span class="kn">Notation</span> <span class="nf">content</span> := Content.type.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;content&#39; &#39;set&#39; T &#39;-&gt;&#39; &#39;\bar&#39; R }&quot;</span> :=
  (content R T) (<span class="kn">at level</span> <span class="mi">36</span>, T, R <span class="kn">at next level</span>,
    <span class="kn">format</span> <span class="s2">&quot;{ &#39;content&#39;  &#39;set&#39;  T  &#39;-&gt;&#39;  &#39;\bar&#39;  R }&quot;</span>) : ring_scope.

<span class="kn">Arguments</span> measure_ge0 {d R T} _.

<span class="kn">Section</span> <span class="nf">content_signed</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : semiRingOfSetsType d).

<span class="kn">Variable</span> <span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">content_snum_subproof</span> <span class="nv">S</span> : Signed.spec <span class="mi">0</span> ?=<span class="mi">0</span> &gt;=<span class="mi">0</span> (mu S).
<span class="kn">Proof</span>. <span class="bp">exact</span>: measure_ge0. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">content_snum</span> S := Signed.mk (content_snum_subproof S).

<span class="kn">End</span> <span class="nf">content_signed</span>.

<span class="kn">Section</span> <span class="nf">content_on_semiring_of_sets</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : semiRingOfSetsType d)
        (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">measure0</span> : mu set0 = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">have</span> /[!big_ord0] -&gt;// := @measure_semi_additive _ _ _ mu (<span class="kr">fun</span>=&gt; set0) <span class="mi">0</span>%N.
<span class="bp">exact</span>: trivIset_set0.
<span class="kn">Qed</span>.

<span class="kn">Hint Resolve</span> measure0 : core.

<span class="kn">Hint Resolve</span> measure_ge0 : core.

<span class="kn">Hint Resolve</span> measure_semi_additive : core.

<span class="kn">Lemma</span> <span class="nf">measure_semi_additive_ord</span> (<span class="nv">n</span> : nat) (<span class="nv">F</span> : &#39;I_n -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> (<span class="nv">k</span> : &#39;I_n), measurable (F k)) -&gt;
  trivIset setT F -&gt;
  measurable (\big[setU/set0]_(k &lt; n) F k) -&gt;
  mu (\big[setU/set0]_(i &lt; n) F i) = \sum_(i &lt; n) mu (F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF tF mUF; <span class="nb">pose</span> F&#39; (i : nat) := oapp F set0 (insub i).
<span class="nb">have</span> FE (i : &#39;I_n) : F i = (F&#39; \o val) i <span class="bp">by</span> <span class="nb">rewrite</span> /F&#39;/= valK/=.
<span class="nb">rewrite</span> (eq_bigr (F&#39; \o val))// (eq_bigr (mu \o F&#39; \o val))//; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i _; <span class="nb">rewrite</span> FE.
<span class="nb">rewrite</span> -measure_semi_additive//.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">rewrite</span> /F&#39;; <span class="nb">case</span>: insubP =&gt; /=.
- <span class="nb">apply</span>/trivIsetP=&gt; i j _ _; <span class="nb">rewrite</span> /F&#39;.
  <span class="kp">do</span> <span class="mi">2</span>?[<span class="nb">case</span>: insubP; <span class="nb">rewrite</span> ?(set0I, setI0)//= =&gt; ? _ &lt;-].
  <span class="bp">by</span> <span class="nb">move</span>/trivIsetP: tF; <span class="nb">apply</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> (eq_bigr (F&#39; \o val)) <span class="kr">in</span> mUF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_semi_additive_ord_I</span> (<span class="nv">F</span> : nat -&gt; <span class="nb">set</span> T) (<span class="nv">n</span> : nat) :
  (<span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%N -&gt; measurable (F k)) -&gt;
  trivIset `I_n F -&gt;
  measurable (\big[setU/set0]_(k &lt; n) F k) -&gt;
  mu (\big[setU/set0]_(i &lt; n) F i) = \sum_(i &lt; n) mu (F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF tF; <span class="nb">apply</span>: measure_semi_additive_ord.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">apply</span>: mF.
<span class="bp">by</span> <span class="nb">rewrite</span> trivIset_comp// ?(image_eq [surjfun of val])//; <span class="nb">apply</span>: &#39;inj_val.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">content_fin_bigcup</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
    finite_set D -&gt;
    trivIset D F -&gt;
    (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; measurable (F i)) -&gt;
    measurable (\bigcup_(i <span class="kr">in</span> D) F i) -&gt;
  mu (\bigcup_(i <span class="kr">in</span> D) F i) = \sum_(i \<span class="kr">in</span> D) mu (F i).
<span class="kn">Proof</span>.
<span class="nb">elim</span>/choicePpointed: I =&gt; I <span class="kr">in</span> D F *.
  <span class="bp">by</span> <span class="nb">rewrite</span> !emptyE =&gt; *; <span class="nb">rewrite</span> fsbig_set0 bigcup0.
<span class="nb">move</span>=&gt; [n /ppcard_eqP[f]] Ftriv Fm UFm.
<span class="nb">rewrite</span> -(image_eq [surjfun of f^-<span class="mi">1</span>%FUN])/= <span class="kr">in</span> UFm Ftriv *.
<span class="nb">rewrite</span> bigcup_image fsbig_image//= bigcup_mkord -fsbig_ord/= <span class="kr">in</span> UFm *.
<span class="nb">rewrite</span> (@measure_semi_additive_ord_I (F \o f^-<span class="mi">1</span>))//= <span class="mi">1</span><span class="nl">?trivIset_comp</span>//.
<span class="bp">by</span> <span class="nb">move</span>=&gt; k kn; <span class="nb">apply</span>: Fm; <span class="bp">exact</span>: funS.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_semi_additive2</span> : semi_additive2 mu.
<span class="kn">Proof</span>. <span class="bp">exact</span>/semi_additiveW. <span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> measure_semi_additive2 : core.

<span class="kn">End</span> <span class="nf">content_on_semiring_of_sets</span>.
<span class="kn">Arguments</span> measure0 {d R T} _.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span>
  (is_true (<span class="mi">0</span> &lt;= (_ : {content <span class="nb">set</span> _ -&gt; \bar _}) _)%E) =&gt;
  <span class="kp">solve</span> [<span class="nb">apply</span>: measure_ge0] : core.

#[<span class="kn">global</span>]
<span class="kn">Hint Resolve</span> measure0 measure_semi_additive2 measure_semi_additive : core.

<span class="kn">Section</span> <span class="nf">content_on_ring_of_sets</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType)(<span class="nv">T</span> : ringOfSetsType d)
        (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">measureU</span> : additive2 mu.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -semi_additive2E. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_bigsetU</span> : additive mu.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -semi_additiveE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_fin_bigcup</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
    finite_set D -&gt;
    trivIset D F -&gt;
    (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; measurable (F i)) -&gt;
  mu (\bigcup_(i <span class="kr">in</span> D) F i) = \sum_(i \<span class="kr">in</span> D) mu (F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dfin Ftriv Fm; <span class="nb">rewrite</span> content_fin_bigcup//.
<span class="bp">exact</span>: fin_bigcup_measurable.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_bigsetU_ord_cond</span> <span class="nv">n</span> (<span class="nv">P</span> : {pred &#39;I_n}) (<span class="nv">F</span> : &#39;I_n -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span> : &#39;I_n, P i -&gt; measurable (F i)) -&gt; trivIset P F -&gt;
  mu (\big[setU/set0]_(i &lt; n | P i) F i) = (\sum_(i &lt; n | P i) mu (F i))%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF tF; <span class="nb">rewrite</span> !(big_mkcond P)/= measure_semi_additive_ord//.
- <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> (fun_if mu) measure0.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">case</span>: ifP =&gt; //; <span class="nb">apply</span>: mF.
- <span class="bp">by</span> <span class="nb">rewrite</span> -patch_pred trivIset_restr setIT.
- <span class="bp">by</span> <span class="nb">apply</span>: bigsetU_measurable=&gt; k _; <span class="nb">case</span>: ifP =&gt; //; <span class="nb">apply</span>: mF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_bigsetU_ord</span> <span class="nv">n</span> (<span class="nv">P</span> : {pred &#39;I_n}) (<span class="nv">F</span> : &#39;I_n -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span> : &#39;I_n, measurable (F i)) -&gt; trivIset setT F -&gt;
  mu (\big[setU/set0]_(i &lt; n | P i) F i) = (\sum_(i &lt; n | P i) mu (F i))%E.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mF tF; <span class="nb">rewrite</span> measure_bigsetU_ord_cond//; <span class="nb">apply</span>: sub_trivIset tF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_fbigsetU</span> (<span class="nv">I</span> : choiceType) (<span class="nv">A</span> : {fset I}) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span>, i \<span class="kr">in</span> A -&gt; measurable (F i)) -&gt; trivIset [<span class="nb">set</span>` A] F -&gt;
  mu (\big[setU/set0]_(i &lt;- A) F i) = (\sum_(i &lt;- A) mu (F i))%E.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mF tF; <span class="nb">rewrite</span> -bigcup_fset measure_fin_bigcup// -fsbig_seq.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">content_on_ring_of_sets</span>.

#[<span class="kn">global</span>]
<span class="kn">Hint Resolve</span> measureU measure_bigsetU : core.

HB.mixin <span class="kn">Record</span> <span class="nf">isMeasure0</span> <span class="nv">d</span>
    (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : semiRingOfSetsType d)
    <span class="nv">mu</span> <span class="nv">of</span> <span class="nv">isContent</span> <span class="nv">d</span> <span class="nv">R</span> <span class="nv">T</span> <span class="nv">mu</span> := {
  measure_semi_sigma_additive : semi_sigma_additive mu }.

#[short(type=<span class="kn">measure</span>)]
HB.structure <span class="kn">Definition</span> <span class="nf">Measure</span> <span class="nv">d</span>
    (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : semiRingOfSetsType d) :=
  {mu of isMeasure0 d R T mu &amp; Content d mu}.

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;measure&#39; &#39;set&#39; T &#39;-&gt;&#39; &#39;\bar&#39; R }&quot;</span> := (<span class="kn">measure</span> R T)
  (<span class="kn">at level</span> <span class="mi">36</span>, T, R <span class="kn">at next level</span>,
    <span class="kn">format</span> <span class="s2">&quot;{ &#39;measure&#39;  &#39;set&#39;  T  &#39;-&gt;&#39;  &#39;\bar&#39;  R }&quot;</span>) : ring_scope.

<span class="kn">Section</span> <span class="nf">measure_signed</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : semiRingOfSetsType d).

<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">measure_snum_subproof</span> <span class="nv">S</span> : Signed.spec <span class="mi">0</span> ?=<span class="mi">0</span> &gt;=<span class="mi">0</span> (mu S).
<span class="kn">Proof</span>. <span class="bp">exact</span>: measure_ge0. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">measure_snum</span> S := Signed.mk (measure_snum_subproof S).

<span class="kn">End</span> <span class="nf">measure_signed</span>.

HB.factory <span class="kn">Record</span> <span class="nf">isMeasure</span> <span class="nv">d</span>
    (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : semiRingOfSetsType d) (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) := {
  measure0 : mu set0 = <span class="mi">0</span> ;
  measure_ge0 : <span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= mu x ;
  measure_semi_sigma_additive : semi_sigma_additive mu }.

HB.builders <span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : semiRingOfSetsType d)
  (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) <span class="nv">of</span> <span class="nv">isMeasure</span> <span class="nv">d</span> <span class="nv">R</span> <span class="nv">T</span> <span class="nv">mu</span>.

<span class="kn">Let</span> <span class="nf">semi_additive_mu</span> : semi_additive mu.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: semi_sigma_additive_is_additive.
- <span class="bp">exact</span>: measure0.
- <span class="bp">exact</span>: measure_semi_sigma_additive.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isContent.Build d R T mu
  measure_ge0 semi_additive_mu.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure0.Build d R T mu measure_semi_sigma_additive.
HB.<span class="kr">end</span>.

<span class="kn">Lemma</span> <span class="nf">eq_measure</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
  (<span class="nv">m1</span> <span class="nv">m2</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) :
  (m1 = m2 :&gt; (<span class="nb">set</span> T -&gt; \bar R)) -&gt; m1 = m2.
<span class="kn">Proof</span>.
<span class="nb">move</span>: m1 m2 =&gt; [m1 [[m10 m1ge0 [m1sa]]]] [m2 [[+ + [+]]]] /= m1m2.
<span class="nb">rewrite</span> -{}m1m2 =&gt; m10&#39; m1ge0&#39; m1sa&#39;; <span class="nb">f_equal</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> (_ : m10&#39; = m10)// (_ : m1ge0&#39; = m1ge0)// (_ : m1sa&#39; = m1sa).
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">measure_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : semiRingOfSetsType d).

<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">measure_semi_bigcup</span> <span class="nv">A</span> : (<span class="kr">forall</span> <span class="nv">i</span> : nat, measurable (A i)) -&gt;
    trivIset setT A -&gt; measurable (\bigcup_n A n) -&gt;
  mu (\bigcup_n A n) = \sum_(i &lt;oo) mu (A i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Am Atriv /measure_semi_sigma_additive/cvg_lim&lt;-//. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measure_lemmas</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (_ set0 = <span class="mi">0</span>) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: measure0] : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="mi">0</span> &lt;= _)) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: measure_ge0] : core.

<span class="kn">Section</span> <span class="nf">measure_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : measurableType d).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">measure_sigma_additive</span> : sigma_additive mu.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -semi_sigma_additiveE //; <span class="nb">apply</span>: measure_semi_sigma_additive.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_bigcup</span> (<span class="nv">D</span> : <span class="nb">set</span> nat) <span class="nv">F</span> : (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; measurable (F i)) -&gt;
  trivIset D F -&gt; mu (\bigcup_(n <span class="kr">in</span> D) F n) = \sum_(i &lt;oo | i \<span class="kr">in</span> D) mu (F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF tF; <span class="nb">rewrite</span> bigcup_mkcond measure_semi_bigcup.
- <span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> RHS]eseries_mkcond; <span class="nb">apply</span>: eq_eseries =&gt; n _; <span class="nb">case</span>: ifPn.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">case</span>: ifPn =&gt; // /set_mem; <span class="bp">exact</span>: mF.
- <span class="bp">by</span> <span class="nb">move</span>/trivIset_mkcond : tF.
- <span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_mkcond; <span class="nb">apply</span>: bigcup_measurable.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measure_lemmas</span>.
<span class="kn">Arguments</span> measure_bigcup {d R T} _ _.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (sigma_additive _) =&gt;
  <span class="kp">solve</span> [<span class="nb">apply</span>: measure_sigma_additive] : core.

<span class="kn">Definition</span> <span class="nf">finite_measure</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : numDomainType)
    (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) :=
  mu setT &lt; +oo.

<span class="kn">Lemma</span> <span class="nf">finite_measure_sigma_finite</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realFieldType)
  (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) :
  finite_measure mu -&gt; sigma_finite setT mu.
<span class="kn">Proof</span>.
<span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> =&gt; <span class="kr">if</span> i \<span class="kr">in</span> [<span class="nb">set</span> <span class="mi">0</span>%N] <span class="kr">then</span> setT <span class="kr">else</span> set0).
  <span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_mkcondr setTI bigcup_const//; <span class="kr">exists</span> <span class="mi">0</span>%N.
<span class="nb">move</span>=&gt; n; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: ifPn.
<span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; // _; <span class="nb">rewrite</span> <span class="nl">?measure0</span>//; <span class="bp">exact</span>: finite_measure.
<span class="kn">Qed</span>.

HB.mixin <span class="kn">Record</span> <span class="nf">isSigmaFinite</span> <span class="nv">d</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : semiRingOfSetsType d)
    (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) := {
  sigma_finiteT : sigma_finite setT mu
}.

#[short(type=<span class="s2">&quot;sigma_finite_content&quot;</span>)]
HB.structure <span class="kn">Definition</span> <span class="nf">SigmaFiniteContent</span> <span class="nv">d</span> <span class="nv">R</span> <span class="nv">T</span> :=
  {mu of isSigmaFinite d R T mu &amp; @Content d R T mu}.
<span class="kn">Arguments</span> sigma_finiteT {d R T} s.

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;sigma_finite_content&#39; &#39;set&#39; T &#39;-&gt;&#39; &#39;\bar&#39; R }&quot;</span> :=
  (sigma_finite_content R T)
  (<span class="kn">at level</span> <span class="mi">36</span>, T, R <span class="kn">at next level</span>,
    <span class="kn">format</span> <span class="s2">&quot;{ &#39;sigma_finite_content&#39;  &#39;set&#39;  T  &#39;-&gt;&#39;  &#39;\bar&#39;  R }&quot;</span>)
  : ring_scope.

#[<span class="kn">global</span>]
<span class="kn">Hint Resolve</span> sigma_finiteT : core.

#[short(type=<span class="s2">&quot;sigma_finite_measure&quot;</span>)]
HB.structure <span class="kn">Definition</span> <span class="nf">SigmaFiniteMeasure</span> <span class="nv">d</span> <span class="nv">R</span> <span class="nv">T</span> :=
  {mu of isSigmaFinite d R T mu &amp; @Measure d R T mu}.

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;sigma_finite_measure&#39; &#39;set&#39; T &#39;-&gt;&#39; &#39;\bar&#39; R }&quot;</span> := (sigma_finite_measure R T)
  (<span class="kn">at level</span> <span class="mi">36</span>, T, R <span class="kn">at next level</span>,
    <span class="kn">format</span> <span class="s2">&quot;{ &#39;sigma_finite_measure&#39;  &#39;set&#39;  T  &#39;-&gt;&#39;  &#39;\bar&#39;  R }&quot;</span>) : ring_scope.

<span class="kn">Section</span> <span class="nf">pushforward_measure</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> <span class="nv">d&#39;</span> (<span class="nv">T1</span> : measurableType d) (<span class="nv">T2</span> : measurableType d&#39;) (<span class="nv">f</span> : T1 -&gt; T2).
<span class="kn">Variables</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">m</span> : {measure <span class="nb">set</span> T1 -&gt; \bar R}).

<span class="kn">Definition</span> <span class="nf">pushforward</span> (<span class="nv">mf</span> : measurable_fun setT f) <span class="nv">A</span> := m (f @^-<span class="mi">1</span>` A).

<span class="kn">Hypothesis</span> <span class="nv">mf</span> : measurable_fun setT f.

<span class="kn">Let</span> <span class="nf">pushforward0</span> : pushforward mf set0 = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /pushforward preimage_set0 measure0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">pushforward_ge0</span> <span class="nv">A</span> : <span class="mi">0</span> &lt;= pushforward mf A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: measure_ge0; <span class="nb">rewrite</span> -[X <span class="kr">in</span> measurable X]setIT; <span class="nb">apply</span>: mf. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">pushforward_sigma_additive</span> : semi_sigma_additive (pushforward mf).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mUF; <span class="nb">rewrite</span> /pushforward preimage_bigcup.
<span class="nb">apply</span>: measure_semi_sigma_additive.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">rewrite</span> -[X <span class="kr">in</span> measurable X]setTI; <span class="bp">exact</span>: mf.
- <span class="nb">apply</span>/trivIsetP =&gt; /= i j _ _ ij; <span class="nb">rewrite</span> -preimage_setI.
  <span class="bp">by</span> <span class="nb">move</span>/trivIsetP : tF =&gt; /(_ _ _ _ _ ij) -&gt;//; <span class="nb">rewrite</span> preimage_set0.
- <span class="bp">by</span> <span class="nb">rewrite</span> -preimage_bigcup -[X <span class="kr">in</span> measurable X]setTI; <span class="bp">exact</span>: mf.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _
  (pushforward mf) pushforward0 pushforward_ge0 pushforward_sigma_additive.

<span class="kn">End</span> <span class="nf">pushforward_measure</span>.

<span class="kn">Section</span> <span class="nf">dirac_measure</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">a</span> : T) (<span class="nv">R</span> : realFieldType).

<span class="kn">Definition</span> <span class="nf">dirac</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : \bar R := (\<span class="mi">1_</span>A a)%:E.

<span class="kn">Let</span> <span class="nf">dirac0</span> : dirac set0 = <span class="mi">0</span>. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /dirac indic0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">dirac_ge0</span> <span class="nv">B</span> : <span class="mi">0</span> &lt;= dirac B. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /dirac indicE. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">dirac_sigma_additive</span> : semi_sigma_additive dirac.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mUF; <span class="nb">rewrite</span> /dirac indicE; <span class="nb">have</span> [|aFn] /= := boolP (a \<span class="kr">in</span> _).
  <span class="nb">rewrite</span> inE =&gt; -[n _ Fna].
  <span class="nb">have</span> naF m : m != n -&gt; a \notin F m.
    <span class="nb">move</span>=&gt; mn; <span class="nb">rewrite</span> notin_set =&gt; Fma.
    <span class="nb">move</span>/trivIsetP : tF =&gt; /(_ _ _ Logic.I Logic.I mn).
    <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; /(_ a)[+ _]; <span class="bp">exact</span>.
  <span class="nb">apply</span>/cvg_ballP =&gt; _/posnumP[e]; near=&gt; m.
  <span class="nb">have</span> mn : (n &lt; m)%N <span class="bp">by</span> near: m; <span class="kr">exists</span> <span class="nv">n</span>.+<span class="mi">1</span>.
  <span class="nb">rewrite</span> big_mkord (bigID (xpred1 (Ordinal mn)))//= big_pred1_eq/= big1/=.
    <span class="bp">by</span> <span class="nb">rewrite</span> adde0 indicE mem_set//; <span class="bp">exact</span>: ballxx.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; j ij; <span class="nb">rewrite</span> indicE (negbTE (naF _ _)).
<span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ = cst <span class="mi">0</span>); <span class="kp">first</span> <span class="bp">exact</span>: cvg_cst.
<span class="nb">apply</span>/funext =&gt; n; <span class="nb">rewrite</span> big1// =&gt; i _; <span class="nb">rewrite</span> indicE; <span class="nb">apply</span>/eqP.
<span class="bp">by</span> <span class="nb">rewrite</span> eqe pnatr_eq0 eqb0; <span class="nb">apply</span>: contra aFn =&gt; /[!inE] aFn; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _
  dirac dirac0 dirac_ge0 dirac_sigma_additive.

<span class="kn">End</span> <span class="nf">dirac_measure</span>.
<span class="kn">Arguments</span> dirac {d T} _ {R}.

<span class="kn">Notation</span> <span class="s2">&quot;\d_ a&quot;</span> := (dirac a) : ring_scope.

<span class="kn">Section</span> <span class="nf">dirac_lemmas_realFieldType</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realFieldType).

<span class="kn">Lemma</span> <span class="nf">diracE</span> <span class="nv">a</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : \d_a A = (a \<span class="kr">in</span> A)%:R%:E :&gt; \bar R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /dirac indicE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dirac0</span> (<span class="nv">a</span> : T) : \d_a set0 = <span class="mi">0</span> :&gt; \bar R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> diracE in_set0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">diracT</span> (<span class="nv">a</span> : T) : \d_a setT = <span class="mi">1</span> :&gt; \bar R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> diracE in_setT. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">dirac_lemmas_realFieldType</span>.

<span class="kn">Section</span> <span class="nf">dirac_lemmas</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).

<span class="kn">Lemma</span> <span class="nf">finite_card_dirac</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : finite_set A -&gt;
  \esum_(i <span class="kr">in</span> A) \d_ i A = (#|` fset_set A|%:R)%:E :&gt; \bar R.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; finA; <span class="nb">rewrite</span> esum_fset// (eq_fsbigr (cst <span class="mi">1</span>))//.
  <span class="bp">by</span> <span class="nb">rewrite</span> card_fset_sum1// natr_sum -sumEFin fsbig_finite.
<span class="bp">by</span> <span class="nb">move</span>=&gt; i iA; <span class="nb">rewrite</span> diracE iA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">infinite_card_dirac</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : infinite_set A -&gt;
  \esum_(i <span class="kr">in</span> A) \d_ i A = +oo :&gt; \bar R.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; infA; <span class="nb">apply</span>/eqyP =&gt; r r0.
<span class="nb">have</span> [B BA Br] := infinite_set_fset `|ceil r| infA.
<span class="nb">apply</span>: esum_ge; <span class="kr">exists</span> [<span class="nb">set</span>` B] =&gt; //; <span class="nb">apply</span>: (@le_trans _ _ `|ceil r|%:R%:E).
  <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin natr_absz gtr0_norm <span class="nl">?ceil_gt0</span>// ceil_ge.
<span class="nb">move</span>: Br; <span class="nb">rewrite</span> -(@ler_nat R) -lee_fin =&gt; /le_trans; <span class="nb">apply</span>.
<span class="nb">rewrite</span> (eq_fsbigr (cst <span class="mi">1</span>))/=; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i /[!inE] /BA /mem_set iA; <span class="nb">rewrite</span> diracE iA.
<span class="bp">by</span> <span class="nb">rewrite</span> fsbig_finite//= card_fset_sum1 sumEFin natr_sum// set_fsetK.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">dirac_lemmas</span>.

<span class="kn">Section</span> <span class="nf">measure_sum</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">m</span> : {measure <span class="nb">set</span> T -&gt; \bar R}^nat) (<span class="nv">n</span> : nat).

<span class="kn">Definition</span> <span class="nf">msum</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : \bar R := \sum_(k &lt; n) m k A.

<span class="kn">Let</span> <span class="nf">msum0</span> : msum set0 = <span class="mi">0</span>. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /msum big1. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">msum_ge0</span> <span class="nv">B</span> : <span class="mi">0</span> &lt;= msum B. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /msum; <span class="nb">apply</span>: sume_ge0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">msum_sigma_additive</span> : semi_sigma_additive msum.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mUF; <span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ =
    lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n) msum (F i))).
  <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_ereal_nneg_natsum =&gt; k _; <span class="bp">exact</span>: sume_ge0.
<span class="nb">rewrite</span> nneseries_sum//; <span class="nb">apply</span>: eq_bigr =&gt; /= i _.
<span class="bp">exact</span>: measure_semi_bigcup.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ msum
  msum0 msum_ge0 msum_sigma_additive.

<span class="kn">End</span> <span class="nf">measure_sum</span>.
<span class="kn">Arguments</span> msum {d T R}.

<span class="kn">Section</span> <span class="nf">measure_zero</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).

<span class="kn">Definition</span> <span class="nf">mzero</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : \bar R := <span class="mi">0</span>.

<span class="kn">Let</span> <span class="nf">mzero0</span> : mzero set0 = <span class="mi">0</span>. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mzero_ge0</span> <span class="nv">B</span> : <span class="mi">0</span> &lt;= mzero B. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mzero_sigma_additive</span> : semi_sigma_additive mzero.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mUF; <span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ = cst <span class="mi">0</span>); <span class="kp">first</span> <span class="bp">exact</span>: cvg_cst.
<span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; n; <span class="nb">rewrite</span> big1.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ mzero
  mzero0 mzero_ge0 mzero_sigma_additive.

<span class="kn">End</span> <span class="nf">measure_zero</span>.
<span class="kn">Arguments</span> mzero {d T R}.

<span class="kn">Lemma</span> <span class="nf">msum_mzero</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">m_</span> : {measure <span class="nb">set</span> T -&gt; \bar R}^nat) :
  msum m_ <span class="mi">0</span> = mzero.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; A/=; <span class="nb">rewrite</span> /msum big_ord0. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">measure_add</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">m1</span> <span class="nv">m2</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Definition</span> <span class="nf">measure_add</span> := msum (<span class="kr">fun</span> <span class="nv">n</span> =&gt; <span class="kr">if</span> n <span class="kr">is</span> <span class="mi">0</span>%N <span class="kr">then</span> m1 <span class="kr">else</span> m2) <span class="mi">2</span>.

<span class="kn">Lemma</span> <span class="nf">measure_addE</span> <span class="nv">A</span> : measure_add A = m1 A + m2 A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /measure_add/= /msum <span class="mi">2</span>!big_ord_recl/= big_ord0 adde0. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measure_add</span>.

<span class="kn">Section</span> <span class="nf">measure_scale</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realFieldType).
<span class="kn">Variables</span> (<span class="nv">r</span> : {nonneg R}) (<span class="nv">m</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Definition</span> <span class="nf">mscale</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : \bar R := r%:num%:E * m A.

<span class="kn">Let</span> <span class="nf">mscale0</span> : mscale set0 = <span class="mi">0</span>. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /mscale measure0 mule0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mscale_ge0</span> <span class="nv">B</span> : <span class="mi">0</span> &lt;= mscale B.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /mscale mule_ge0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mscale_sigma_additive</span> : semi_sigma_additive mscale.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mUF; <span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ =
    (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (r%:num)%:E * \sum_(<span class="mi">0</span> &lt;= i &lt; n) m (F i))); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; k; <span class="nb">rewrite</span> ge0_sume_distrr.
<span class="nb">rewrite</span> /mscale; <span class="nb">have</span> [-&gt;|r0] := eqVneq r%:num <span class="mi">0</span>%R.
  <span class="nb">rewrite</span> mul0e [X <span class="kr">in</span> X --&gt; _](_ : _ = (<span class="kr">fun</span>=&gt; <span class="mi">0</span>)); <span class="kp">first</span> <span class="bp">exact</span>: cvg_cst.
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> mul0e.
<span class="bp">by</span> <span class="nb">apply</span>: cvgeMl =&gt; //; <span class="bp">exact</span>: measure_semi_sigma_additive.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ mscale
  mscale0 mscale_ge0 mscale_sigma_additive.

<span class="kn">End</span> <span class="nf">measure_scale</span>.
<span class="kn">Arguments</span> mscale {d T R}.

<span class="kn">Section</span> <span class="nf">measure_series</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">m</span> : {measure <span class="nb">set</span> T -&gt; \bar R}^nat) (<span class="nv">n</span> : nat).

<span class="kn">Definition</span> <span class="nf">mseries</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : \bar R := \sum_(n &lt;= k &lt;oo) m k A.

<span class="kn">Let</span> <span class="nf">mseries0</span> : mseries set0 = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /mseries ereal_series eseries0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mseries_ge0</span> <span class="nv">B</span> : <span class="mi">0</span> &lt;= mseries B.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> /mseries ereal_series nneseries_esum//; <span class="bp">exact</span>: esum_ge0.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mseries_sigma_additive</span> : semi_sigma_additive mseries.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mUF; <span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ =
  lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n) mseries (F i))); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> [<span class="kr">in</span> LHS]/mseries.
  <span class="nb">transitivity</span> (\sum_(n &lt;= k &lt;oo) \sum_(i &lt;oo) m k (F i)).
    <span class="nb">rewrite</span> <span class="mi">2</span>!ereal_series.
    <span class="nb">apply</span>: (@eq_eseries _ (<span class="kr">fun</span> <span class="nv">k</span> =&gt; m k (\bigcup_n0 F n0))) =&gt; i ni.
    <span class="bp">exact</span>: measure_semi_bigcup.
  <span class="nb">rewrite</span> ereal_series nneseries_interchange//.
  <span class="nb">apply</span>: (@eq_eseries R (<span class="kr">fun</span> <span class="nv">j</span> =&gt; \sum_(i &lt;oo | (n &lt;= i)%N) m i (F j))
                          (<span class="kr">fun</span> <span class="nv">i</span> =&gt; \sum_(n &lt;= k &lt;oo) m k (F i))).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i _; <span class="nb">rewrite</span> ereal_series.
<span class="nb">apply</span>: is_cvg_ereal_nneg_natsum =&gt; k _.
<span class="bp">by</span> <span class="nb">rewrite</span> /mseries ereal_series; <span class="bp">exact</span>: nneseries_ge0.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ mseries
  mseries0 mseries_ge0 mseries_sigma_additive.

<span class="kn">End</span> <span class="nf">measure_series</span>.
<span class="kn">Arguments</span> mseries {d T R}.

<span class="kn">Definition</span> <span class="nf">mrestr</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realFieldType) (<span class="nv">D</span> : <span class="nb">set</span> T)
  (<span class="nv">f</span> : <span class="nb">set</span> T -&gt; \bar R) (<span class="nv">mD</span> : measurable D) := <span class="kr">fun</span> <span class="nv">X</span> =&gt; f (X `&amp;` D).

<span class="kn">Section</span> <span class="nf">measure_restr</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realFieldType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).

<span class="kn">Local Notation</span> <span class="nf">restr</span> := (mrestr mu mD).

<span class="kn">Let</span> <span class="nf">restr0</span> : restr set0 = <span class="mi">0</span>%E. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /mrestr set0I measure0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">restr_ge0</span> (<span class="nv">A</span> : <span class="nb">set</span> _) : (<span class="mi">0</span> &lt;= restr A)%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /restr; <span class="nb">apply</span>: measure_ge0; <span class="bp">exact</span>: measurableI. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">restr_sigma_additive</span> : semi_sigma_additive restr.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mU; <span class="nb">pose</span> FD i := F i `&amp;` D.
<span class="nb">have</span> mFD i : measurable (FD i) <span class="bp">by</span> <span class="bp">exact</span>: measurableI.
<span class="nb">have</span> tFD : trivIset setT FD.
  <span class="nb">apply</span>/trivIsetP =&gt; i j _ _ ij.
  <span class="nb">move</span>/trivIsetP : tF =&gt; /(_ i j Logic.I Logic.I ij).
  <span class="bp">by</span> <span class="nb">rewrite</span> /FD setIACA =&gt; -&gt;; <span class="nb">rewrite</span> set0I.
<span class="bp">by</span> <span class="nb">rewrite</span> /restr setI_bigcupl; <span class="bp">exact</span>: measure_sigma_additive.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ restr
  restr0 restr_ge0 restr_sigma_additive.

<span class="kn">End</span> <span class="nf">measure_restr</span>.

<span class="kn">Section</span> <span class="nf">measure_count</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).

<span class="kn">Definition</span> <span class="nf">counting</span> (<span class="nv">X</span> : <span class="nb">set</span> T) : \bar R :=
  <span class="kr">if</span> `[&lt; finite_set X &gt;] <span class="kr">then</span> (#|` fset_set X |)%:R%:E <span class="kr">else</span> +oo.

<span class="kn">Let</span> <span class="nf">counting0</span> : counting set0 = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /counting asboolT// fset_set0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">counting_ge0</span> (<span class="nv">A</span> : <span class="nb">set</span> _) : <span class="mi">0</span> &lt;= counting A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /counting; <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> <span class="nl">?lee_fin</span>// lee_pinfty. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">counting_sigma_additive</span> : semi_sigma_additive counting.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mU.
<span class="nb">have</span> [[i Fi]|infinF] := pselect (<span class="kr">exists</span> <span class="nv">k</span>, infinite_set (F k)).
  <span class="nb">have</span> -&gt; : counting (\bigcup_n F n) = +oo.
    <span class="nb">rewrite</span> /counting asboolF//.
    <span class="bp">by</span> <span class="nb">apply</span>: contra_not Fi; <span class="bp">exact</span>/sub_finite_set/bigcup_sup.
  <span class="nb">apply</span>/cvgeyPge =&gt; M; near=&gt; n.
  <span class="nb">have</span> ni : (i &lt; n)%N <span class="bp">by</span> near: n; <span class="kr">exists</span> <span class="nv">i</span>.+<span class="mi">1</span>.
  <span class="nb">rewrite</span> (bigID (xpred1 i))/= big_mkord (big_pred1 (Ordinal ni))//=.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> X + _]/counting asboolF// addye <span class="nl">?leey</span>//.
  <span class="bp">by</span> <span class="nb">rewrite</span> gt_eqF// (@lt_le_trans _ _ <span class="mi">0</span>)//; <span class="bp">exact</span>: sume_ge0.
<span class="nb">have</span> {infinF}finF : <span class="kr">forall</span> <span class="nv">i</span>, finite_set (F i) <span class="bp">by</span> <span class="bp">exact</span>/not_forallP.
<span class="nb">pose</span> u : nat^nat := <span class="kr">fun</span> <span class="nv">n</span> =&gt; #|` fset_set (F n) |.
<span class="nb">have</span> sumFE n : \sum_(i &lt; n) counting (F i) =
               #|` fset_set (\big[setU/set0]_(k &lt; n) F k) |%:R%:E.
  <span class="nb">rewrite</span> -trivIset_sum_card// natr_sum -sumEFin.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; // i _; <span class="nb">rewrite</span> /counting asboolT.
<span class="nb">have</span> [cvg_u|dvg_u] := pselect (cvg (nseries u)).
  <span class="nb">have</span> [N _ Nu] : \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, u n = <span class="mi">0</span>%N <span class="bp">by</span> <span class="nb">apply</span>: cvg_nseries_near.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ = \sum_(i &lt; N) counting (F i)); <span class="nb">last first</span>.
    <span class="nb">have</span> -&gt; : \bigcup_i (F i) = \big[setU/set0]_(i &lt; N) F i.
      <span class="nb">rewrite</span> (bigcupID (`I_N)) setTI bigcup_mkord.
      <span class="nb">rewrite</span> [X <span class="kr">in</span> _ `|` X](_ : _ = set0) <span class="nl">?setU0</span>// bigcup0// =&gt; i [_ /negP].
      <span class="bp">by</span> <span class="nb">rewrite</span> -leqNgt =&gt; /Nu/eqP/[!cardfs_eq0]/eqP/fset_set_set0 -&gt;.
    <span class="bp">by</span> <span class="nb">rewrite</span> /counting /= asboolT <span class="nl">?sumFE</span>// -bigcup_mkord; <span class="bp">exact</span>: bigcup_finite.
  <span class="nb">rewrite</span> -(cvg_shiftn N)/=.
  <span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; _) = (<span class="kr">fun</span>=&gt; \sum_(i &lt; N) counting (F i))).
    <span class="bp">exact</span>: cvg_cst.
  <span class="nb">apply</span>/funext =&gt; n; <span class="nb">rewrite</span> /index_iota subn0 (addnC n) iotaD big_cat/=.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ + X](_ : _ = <span class="mi">0</span>) <span class="nl">?adde0</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}(subn0 N) big_mkord.
  <span class="nb">rewrite</span> add0n big_seq big1// =&gt; i /[!mem_iota] =&gt; /andP[NI iNn].
  <span class="bp">by</span> <span class="nb">rewrite</span> /counting asboolT//= -/(u _) Nu.
<span class="nb">have</span> {dvg_u}cvg_F : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(i &lt; n) counting (F i)) --&gt; +oo.
  <span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; _) = [sequence (\sum_(<span class="mi">0</span> &lt;= i &lt; n) (u i))%:R%:E]_n).
    <span class="bp">exact</span>/cvgenyP/dvg_nseries.
  <span class="nb">apply</span>/funext =&gt; n /=; <span class="nb">under</span> eq_bigr.
    <span class="bp">by</span> <span class="nb">rewrite</span> /counting =&gt; i _; <span class="nb">rewrite</span> asboolT//; <span class="nb">over</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> sumEFin natr_sum big_mkord.
<span class="nb">have</span> [UFoo|/contrapT[k UFk]] := pselect (infinite_set (\bigcup_n F n)).
  <span class="nb">rewrite</span> /counting asboolF//.
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> big_mkord.
<span class="nb">suff</span>: false <span class="bp">by</span> [].
<span class="nb">move</span>: cvg_F =&gt;/cvgeyPge/(_ k.+<span class="mi">1</span>%:R) [K _] /(_ K (leqnn _)) /=; <span class="nb">apply</span>: contra_leT =&gt; _.
<span class="nb">rewrite</span> sumFE lte_fin ltr_nat ltnS.
<span class="nb">have</span> -&gt; : k = #|` fset_set (\bigcup_n F n) |.
  <span class="bp">by</span> <span class="nb">apply</span>/esym/card_eq_fsetP; <span class="nb">rewrite</span> fset_setK//; <span class="kr">exists</span> <span class="nv">k</span>.
<span class="nb">apply</span>/fsubset_leq_card; <span class="nb">rewrite</span> -fset_set_sub //.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; /= t; <span class="nb">rewrite</span> -bigcup_mkord =&gt; -[m _ Fmt]; <span class="kr">exists</span> <span class="nv">m</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_mkord; <span class="bp">exact</span>: bigcup_finite.
- <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ counting
  counting0 counting_ge0 counting_sigma_additive.

<span class="kn">End</span> <span class="nf">measure_count</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_finite_counting</span> (<span class="nv">R</span> : realType) :
  sigma_finite [<span class="nb">set</span>: nat] (counting R).
<span class="kn">Proof</span>.
<span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">n</span> =&gt; `I_n.+<span class="mi">1</span>); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; //x _; <span class="kr">exists</span> <span class="nv">x</span> =&gt; /=.
<span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> /counting/= asboolT// ltry.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">R</span> :=
  @isSigmaFinite.Build _ _ _ (counting R) (sigma_finite_counting R).

<span class="kn">Lemma</span> <span class="nf">big_trivIset</span> (<span class="nv">I</span> : choiceType) <span class="nv">D</span> <span class="nv">T</span> (<span class="nv">R</span> : <span class="kt">Type</span>) (<span class="nv">idx</span> : R)
   (<span class="nv">op</span> : Monoid.com_law idx) (<span class="nv">A</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">F</span> : <span class="nb">set</span> T -&gt; R) :
    finite_set D -&gt; trivIset D A -&gt; F set0 = idx -&gt;
  \big[op/idx]_(i &lt;- fset_set D) F (A i) =
  \big[op/idx]_(X &lt;- (A @` fset_set D)%fset) F X.
<span class="kn">Proof</span>.
<span class="nb">elim</span>/Pchoice: R =&gt; R <span class="kr">in</span> idx op F *.
<span class="nb">move</span>=&gt; Dfin Atriv F0; <span class="nb">symmetry</span>.
<span class="nb">pose</span> D&#39; := [fset i <span class="kr">in</span> fset_set D | A i != set0]%fset.
<span class="nb">transitivity</span> (\big[op/idx]_(X &lt;- (A @` D&#39;)%fset) F X).
  <span class="nb">apply</span>: perm_big_supp; <span class="nb">rewrite</span> uniq_perm <span class="nl">?filter_uniq</span>//=.
  <span class="nb">move</span>=&gt; X; <span class="nb">rewrite</span> !mem_filter; <span class="nb">case</span>: (eqVneq (F X) idx) =&gt; //= FXNidx.
  <span class="nb">apply</span>/imfsetP/imfsetP=&gt; -[i/=]; <span class="nb">rewrite</span> ?(inE, in_fset_set)//=.
    <span class="nb">move</span>=&gt; Di XAi; <span class="kr">exists</span> <span class="nv">i</span>; <span class="nb">rewrite</span> // !(inE, in_fset_set)//=.
    <span class="bp">by</span> <span class="nb">rewrite</span> (mem_set Di)/= -XAi; <span class="nb">apply</span>: contra_neq FXNidx =&gt; -&gt;.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /andP[Di AiN0] XAi; <span class="kr">exists</span> <span class="nv">i</span>; <span class="nb">rewrite</span> <span class="nl">?in_fset_set</span>.
<span class="nb">rewrite</span> big_imfset//=; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; i j; <span class="nb">rewrite</span> !(inE, in_fset_set)//= =&gt; /andP[+ +] /andP[+ +].
  <span class="nb">rewrite</span> !inE =&gt; Di /set0P[x Aix] Dj _ Aij.
  <span class="bp">by</span> <span class="nb">apply</span>: (Atriv _ _ Di Dj); <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>=&gt; //; <span class="nb">rewrite</span> -Aij.
<span class="nb">apply</span>: perm_big_supp; <span class="nb">rewrite</span> uniq_perm <span class="nl">?filter_uniq</span>//= =&gt; i.
<span class="nb">rewrite</span> !mem_filter; <span class="nb">case</span>: (eqVneq (F (A i)) idx) =&gt; //= FAiidx.
<span class="nb">rewrite</span> !(in_fset_set, inE)//=; <span class="nb">case</span>: (boolP (i \<span class="kr">in</span> D)) =&gt; //= Di.
<span class="bp">by</span> <span class="nb">apply</span>: contra_neq FAiidx =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">covering</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Implicit Type</span> (C : <span class="kr">forall</span> <span class="nv">I</span>, <span class="nb">set</span> (<span class="nb">set</span> I)).
<span class="kn">Implicit Type</span> (P : <span class="kr">forall</span> <span class="nv">I</span>, <span class="nb">set</span> I -&gt; <span class="nb">set</span> (I -&gt; <span class="nb">set</span> T)).

<span class="kn">Definition</span> <span class="nf">covered_by</span> <span class="nv">C</span> <span class="nv">P</span> :=
  [<span class="nb">set</span> X : <span class="nb">set</span> T | <span class="kr">exists</span> <span class="nv">I</span> <span class="nv">D</span> <span class="nv">A</span>, [/\ C I D, P I D A &amp; X = \bigcup_(i <span class="kr">in</span> D) A i]].

<span class="kn">Lemma</span> <span class="nf">covered_bySr</span> <span class="nv">C</span> <span class="nv">P</span> <span class="nv">P&#39;</span> : (<span class="kr">forall</span> <span class="nv">I</span> <span class="nv">D</span> <span class="nv">A</span>, P I D A -&gt; P&#39; I D A) -&gt;
  covered_by C P `&lt;=` covered_by C P&#39;.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; PP&#39; X [I [D [A [CX PX -&gt;]]]]; <span class="kr">exists</span> <span class="nv">I</span>, D, A; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: PP&#39;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">covered_byP</span> <span class="nv">C</span> <span class="nv">P</span> <span class="nv">I</span> <span class="nv">D</span> <span class="nv">A</span> : C I D -&gt; P I D A -&gt;
  covered_by C P (\bigcup_(i  <span class="kr">in</span> D) A i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; CID PIDA; <span class="kr">exists</span> <span class="nv">I</span>, D, A. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">covered_by_finite</span> <span class="nv">P</span> :
    (<span class="kr">forall</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) <span class="nv">A</span>, (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; A i = set0) -&gt; P I D A) -&gt;
    (<span class="kr">forall</span> (<span class="nv">I</span> : pointedType) <span class="nv">D</span> <span class="nv">A</span>, finite_set D -&gt; P I D A -&gt;
       P nat `I_#|` fset_set D| (A \o nth point (fset_set D))) -&gt;
  covered_by (@finite_set) P =
    [<span class="nb">set</span> X : <span class="nb">set</span> T | <span class="kr">exists</span> <span class="nv">n</span> <span class="nv">A</span>, [/\ P nat `I_n A &amp; X = \bigcup_(i &lt; n) A i]].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; P0 Pc; <span class="nb">apply</span>/predeqP=&gt; X; <span class="nb">rewrite</span> /covered_by /cover/=; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [n [A [Am -&gt;]]]; <span class="kr">exists</span> <span class="nv">nat</span>, `I_n, A; <span class="nb">split</span>.
<span class="nb">case</span>; <span class="nb">elim</span>/Ppointed=&gt; I [D [A [Dfin Am -&gt;]]].
  <span class="kr">exists</span> <span class="mi">0</span>%N, (<span class="kr">fun</span>=&gt; set0); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> II0; <span class="nb">apply</span>: P0.
  <span class="bp">by</span> <span class="nb">rewrite</span> //= emptyE II0 !bigcup0.
<span class="kr">exists</span> #|`fset_set D|, (A \o nth point (fset_set D)).
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: Pc.
<span class="bp">by</span> <span class="nb">rewrite</span> -bigsetU_fset_set// (big_nth point) big_mkord bigcup_mkord.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">covered_by_countable</span> <span class="nv">P</span> :
    (<span class="kr">forall</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) <span class="nv">A</span>, (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; A i = set0) -&gt; P I D A) -&gt;
    (<span class="kr">forall</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">A</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">f</span> : nat -&gt; I),
       set_surj [<span class="nb">set</span>: nat] D f -&gt;
       P I D A -&gt; P nat [<span class="nb">set</span>: nat] (A \o f)) -&gt;
  covered_by (@countable) P =
    [<span class="nb">set</span> X : <span class="nb">set</span> T | <span class="kr">exists</span> <span class="nv">A</span>, [/\ P nat [<span class="nb">set</span>: nat] A &amp; X = \bigcup_i A i]].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; P0 Pc; <span class="nb">apply</span>/predeqP=&gt; X; <span class="nb">rewrite</span> /covered_by /cover/=; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [A [Am -&gt;]]; <span class="kr">exists</span> <span class="nv">nat</span>, [<span class="nb">set</span>: nat], A; <span class="nb">split</span>.
<span class="nb">case</span>; <span class="nb">elim</span>/Ppointed=&gt; I [D [A [Dcnt Am -&gt;]]].
  <span class="kr">exists</span> (<span class="nv">fun</span>=&gt; set0); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: P0.
  <span class="bp">by</span> <span class="nb">rewrite</span> emptyE bigcup_set0 bigcup0.
<span class="nb">have</span> /pfcard_geP[-&gt;|[f]] := Dcnt.
  <span class="kr">exists</span> (<span class="nv">fun</span>=&gt; set0); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: P0.
  <span class="bp">by</span> <span class="nb">rewrite</span> !bigcup_set0 bigcup0.
<span class="nb">pose</span> g := [splitsurjfun of <span class="nb">split</span> f].
<span class="kr">exists</span> (<span class="nv">A</span> \o g); <span class="nb">split</span>=&gt; /=; <span class="kp">first</span> <span class="bp">exact</span>: Pc Am.
<span class="nb">apply</span>/predeqP=&gt; x; <span class="nb">split</span>=&gt; [[i Di Aix]|[n _ Afnx]].
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">g</span>^-<span class="mi">1</span>%FUN i) =&gt; //=; <span class="nb">rewrite</span> invK// inE.
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">g</span> <span class="nv">n</span>) =&gt; //; <span class="nb">apply</span>: funS.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">covering</span>.

<span class="kn">Module</span> <span class="nf">SetRing</span>.
<span class="kn">Definition</span> <span class="nf">type</span> (<span class="nv">T</span> : <span class="kt">Type</span>) := T.
<span class="kn">Definition</span> <span class="nf">display</span> : measure_display -&gt; measure_display. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">SetRing</span>.
<span class="kn">Context</span> <span class="nv">d</span> {<span class="nv">T</span> : semiRingOfSetsType d}.

<span class="kn">Notation</span> <span class="nf">rT</span> := (type T).
<span class="kn">Canonical</span> <span class="nf">ring_eqType</span> := EqType rT ptclass.
<span class="kn">Canonical</span> <span class="nf">ring_choiceType</span> := ChoiceType rT ptclass.
<span class="kn">Canonical</span> <span class="nf">ring_ptType</span> := PointedType rT ptclass.
#[export]
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isRingOfSets.Build (display d) rT ptclass
  (@setring0 T measurable) (@setringU T measurable) (@setringDI T measurable).

<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;d .-ring&quot;</span> := (display d) (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">format</span> <span class="s2">&quot;d .-ring&quot;</span>).
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;d .-ring.-measurable&quot;</span> :=
  ((d%mdisp.-<span class="bp">ring</span>).-measurable : <span class="nb">set</span> (<span class="nb">set</span> (type _))).

<span class="kn">Local Definition</span> <span class="nf">measurable_fin_trivIset</span> : <span class="nb">set</span> (<span class="nb">set</span> T) :=
  [<span class="nb">set</span> A | <span class="kr">exists</span> <span class="nv">B</span> : <span class="nb">set</span> (<span class="nb">set</span> T),
    [/\ A = \bigcup_(X <span class="kr">in</span> B) X, <span class="kr">forall</span> <span class="nv">X</span> : <span class="nb">set</span> T, B X -&gt; measurable X,
      finite_set B &amp; trivIset B id]].

<span class="kn">Lemma</span> <span class="nf">ring_measurableE</span> : d.-<span class="bp">ring</span>.-measurable = measurable_fin_trivIset.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; _ [B [-&gt; Bm Bfin Btriv]]; <span class="nb">apply</span>: fin_bigcup_measurable =&gt; //.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i Di; <span class="nb">apply</span>: sub_gen_smallest; <span class="nb">apply</span>: Bm.
<span class="nb">have</span> mdW A : measurable A -&gt; measurable_fin_trivIset A.
  <span class="nb">move</span>=&gt; Am; <span class="kr">exists</span> [<span class="nb">set</span> A]; <span class="nb">split</span>; <span class="kp">do</span> <span class="nl">?by</span> [<span class="nb">rewrite</span> bigcup_set1|<span class="nb">move</span>=&gt; ? -&gt;|].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? -&gt; -&gt;.
<span class="nb">have</span> mdI : setI_closed measurable_fin_trivIset.
  <span class="nb">move</span>=&gt; _ _ [A [-&gt; Am Afin Atriv]] [B [-&gt; Bm Bfin Btriv]].
  <span class="nb">rewrite</span> setI_bigcupl; <span class="nb">under</span> eq_bigcupr <span class="kp">do</span> <span class="nb">rewrite</span> setI_bigcupr.
  <span class="nb">rewrite</span> bigcup_bigcup -(bigcup_image _ _ id).
  <span class="nb">eexists</span>; <span class="nb">split</span>; [<span class="bp">reflexivity</span> | | <span class="bp">exact</span>/finite_image/finite_setM |].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [X [? ?] &lt;-]; <span class="nb">apply</span>: measurableI; [<span class="nb">apply</span>: Am|<span class="nb">apply</span>: Bm].
  <span class="nb">apply</span>: trivIset_sets =&gt; -[a b] [a&#39; b&#39;]/= [Xa Xb] [Xa&#39; Xb&#39;]; <span class="nb">rewrite</span> setIACA.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [x [Ax Bx]]; <span class="nb">rewrite</span> (Atriv a a&#39;) <span class="mi">1</span>?(Btriv b b&#39;)//; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="nb">have</span> mdisj_bigcap : finN0_bigcap_closed measurable_fin_trivIset.
   <span class="bp">exact</span>/finN0_bigcap_closedP/mdI.
<span class="nb">have</span> mDbigcup I (D : <span class="nb">set</span> I) (A : <span class="nb">set</span> T) (B : I -&gt; <span class="nb">set</span> T) : finite_set D -&gt;
    measurable A -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; measurable (B i)) -&gt;
    measurable_fin_trivIset (A `\` \bigcup_(i <span class="kr">in</span> D) B i).
  <span class="nb">have</span> [-&gt;|/set0P D0] := eqVneq D set0.
    <span class="bp">by</span> <span class="nb">rewrite</span> bigcup0// setD0 =&gt; *; <span class="nb">apply</span>: mdW.
  <span class="nb">move</span>=&gt; Dfin Am Bm; <span class="nb">rewrite</span> -bigcupDr//; <span class="nb">apply</span>: mdisj_bigcap=&gt; // i Di.
  <span class="bp">by</span> <span class="nb">have</span> [F [Ffin Fm -&gt; ?]] := semi_measurableD A (B i) Am (Bm _ Di); <span class="kr">exists</span> <span class="nv">F</span>.
<span class="nb">have</span> mdU : fin_trivIset_closed measurable_fin_trivIset.
  <span class="nb">elim</span>/Pchoice=&gt; I D F Dfin Ftriv Fm.
  <span class="nb">have</span> /(_ _ (set_mem _))/cid-/(all_sig_cond_dep (<span class="kr">fun</span>=&gt; set0))
       [G /(_ _ (mem_set _))GP] := Fm _ _.
  <span class="nb">under</span> eq_bigcupr =&gt; i Di <span class="kp">do</span> <span class="nb">case</span>: (GP i Di) =&gt; -&gt;.
  <span class="nb">rewrite</span> bigcup_bigcup_dep -(bigcup_image _ _ id); <span class="nb">eexists</span>; <span class="nb">split</span>=&gt; //.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [i [Di Gi] &lt;-]; <span class="nb">have</span> [_ + _ _] := GP i.<span class="mi">1</span> Di; <span class="nb">apply</span>.
  - <span class="bp">by</span> <span class="nb">apply</span>: finite_image; <span class="nb">apply</span>: finite_setMR=&gt; // i Di; <span class="nb">have</span> [] := GP i Di.
  <span class="nb">apply</span>: trivIset_sets =&gt; -[i X] [j Y] /= [Di Gi] [Dj Gj] XYN0.
  <span class="nb">suff</span> eqij : i = j.
    <span class="bp">by</span> <span class="nb">rewrite</span> {i}eqij <span class="kr">in</span> Di Gi *; <span class="nb">have</span> [_ _ _ /(_ _ _ _ _ XYN0)-&gt;] := GP j Dj.
  <span class="nb">apply</span>: Ftriv =&gt; //; <span class="nb">have</span> [-&gt; _ _ _] := GP j Dj; <span class="nb">have</span> [-&gt; _ _ _] := GP i Di.
  <span class="bp">by</span> <span class="nb">case</span>: XYN0 =&gt; [x [Xx Yx]]; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>; [<span class="kr">exists</span> <span class="nv">X</span>|<span class="kr">exists</span> <span class="nv">Y</span>].
<span class="nb">have</span> mdDI : setDI_closed measurable_fin_trivIset.
  <span class="nb">move</span>=&gt; A B mA mB; <span class="nb">have</span> [F [-&gt; Fm Ffin Ftriv]] := mA.
  <span class="nb">have</span> [F&#39; [-&gt; F&#39;m F&#39;fin F&#39;triv]] := mB.
  <span class="nb">have</span> [-&gt;|/set0P F&#39;N0] := eqVneq F&#39; set0.
    <span class="bp">by</span> <span class="nb">rewrite</span> bigcup_set0 setD0; <span class="kr">exists</span> <span class="nv">F</span>.
  <span class="nb">rewrite</span> setD_bigcupl; <span class="nb">apply</span>: mdU =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: trivIset_setIr.
  <span class="nb">move</span>=&gt; X DX; <span class="nb">rewrite</span> -bigcupDr//; <span class="nb">apply</span>: mdisj_bigcap =&gt; //.
  <span class="nb">move</span>=&gt; Y DY; <span class="nb">case</span>: (semi_measurableD X Y); [<span class="bp">exact</span>: Fm|<span class="bp">exact</span>: F&#39;m|].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; G [Gfin Gm -&gt; Gtriv]; <span class="kr">exists</span> <span class="nv">G</span>.
<span class="nb">apply</span>: smallest_sub =&gt; //; <span class="nb">split</span>=&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: mdW.
<span class="nb">move</span>=&gt; A B mA mB; <span class="nb">rewrite</span> -(setUIDK B A) setUA [X <span class="kr">in</span> X `|` _]setUidl//.
<span class="nb">rewrite</span> -bigcup2inE; <span class="nb">apply</span>: mdU =&gt; //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; [|[]]// _; <span class="nb">apply</span>: mdDI.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [|[]]// [|[]]//= _ _ []; <span class="nb">rewrite</span> setDE <span class="nl">?setIA</span> =&gt; X [] []//.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ring_finite_set</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) : measurable A -&gt; <span class="kr">exists</span> <span class="nv">B</span> : <span class="nb">set</span> (<span class="nb">set</span> T),
  [/\ finite_set B,
      (<span class="kr">forall</span> <span class="nv">X</span>, B X -&gt; X !=set0),
      trivIset B id,
      (<span class="kr">forall</span> <span class="nv">X</span> : <span class="nb">set</span> T, X \<span class="kr">in</span> B -&gt; measurable X) &amp;
      A = \bigcup_(X <span class="kr">in</span> B) X].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> ring_measurableE =&gt; -[B [-&gt; Bm Bfin Btriv]].
<span class="kr">exists</span> (<span class="nv">B</span> `&amp;` [<span class="nb">set</span> X | X != set0]); <span class="nb">split</span>.
- <span class="bp">by</span> <span class="nb">apply</span>: sub_finite_set Bfin; <span class="bp">exact</span>: subIsetl.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ?/= [_ /set0P].
- <span class="bp">by</span> <span class="nb">move</span>=&gt; X Y/= [XB _] [YB _]; <span class="bp">exact</span>: Btriv.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; X/= /[!inE] -[] /Bm.
<span class="nb">rewrite</span> bigcup_mkcondr; <span class="nb">apply</span>: eq_bigcupr =&gt; X Bx; <span class="nb">case</span>: ifPn =&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> notin_set/= =&gt; /negP/negPn/eqP.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">decomp</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) : <span class="nb">set</span> (<span class="nb">set</span> T) :=
  <span class="kr">if</span> A == set0 <span class="kr">then</span> [<span class="nb">set</span> set0] <span class="kr">else</span>
  <span class="kr">if</span> pselect (measurable A) <span class="kr">is</span> <span class="nb">left</span> mA <span class="kr">then</span> projT1 (cid (ring_finite_set mA))
  <span class="kr">else</span> [<span class="nb">set</span> A].

<span class="kn">Lemma</span> <span class="nf">decomp_finite_set</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) : finite_set (decomp A).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /decomp; <span class="nb">case</span>: ifPn =&gt; // A0; <span class="nb">case</span>: pselect =&gt; // X.
<span class="bp">by</span> <span class="nb">case</span>: cid =&gt; /= ? [].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">decomp_triv</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) : trivIset (decomp A) id.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /decomp; <span class="nb">case</span>: ifP =&gt; _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; i j/= -&gt; -&gt;.
<span class="nb">case</span>: pselect =&gt; // Am; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: cid =&gt; //= ? [].
<span class="bp">by</span> <span class="nb">move</span>=&gt; i j /= -&gt; -&gt;.
<span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> decomp_triv : core.

<span class="kn">Lemma</span> <span class="nf">all_decomp_neq0</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) :
  A !=set0 -&gt; (<span class="kr">forall</span> <span class="nv">X</span>, decomp A X -&gt; X !=set0).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /set0P AN0; <span class="nb">rewrite</span> /decomp/= (negPf AN0).
<span class="nb">case</span>: pselect =&gt; //= Am; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: cid =&gt; //= ? [].
<span class="bp">by</span> <span class="nb">move</span>=&gt; X -&gt;; <span class="bp">exact</span>/set0P.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">decomp_neq0</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) <span class="nv">X</span> : A !=set0 -&gt; X \<span class="kr">in</span> decomp A -&gt; X !=set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /all_decomp_neq0/(_ X) /[!inE]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">decomp_measurable</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) (<span class="nv">X</span> : <span class="nb">set</span> T) :
  measurable A -&gt; X \<span class="kr">in</span> decomp A -&gt; measurable X.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /decomp; <span class="nb">case</span>: ifP =&gt; _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> inE =&gt; _ -&gt;.
<span class="bp">by</span> <span class="nb">case</span>: pselect =&gt; // Am _; <span class="nb">case</span>: cid =&gt; //= ? [_ _ _ + _]; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cover_decomp</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) : \bigcup_(X <span class="kr">in</span> decomp A) X = A.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /decomp; <span class="nb">case</span>: ifP =&gt; [/eqP-&gt;|_]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> bigcup0.
<span class="nb">case</span>: pselect =&gt; // Am; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: cid =&gt; //= ? [].
<span class="bp">by</span> <span class="nb">rewrite</span> bigcup_set1.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">decomp_sub</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) (<span class="nv">X</span> : <span class="nb">set</span> T) : X \<span class="kr">in</span> decomp A -&gt; X `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /decomp; <span class="nb">case</span>: ifP =&gt; _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> inE/= =&gt; -&gt;//.
<span class="nb">case</span>: pselect =&gt; //= Am; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> inE =&gt; -&gt;.
<span class="bp">by</span> <span class="nb">case</span>: cid =&gt; //= D [_ _ _ _ -&gt;] /[!inE] XD; <span class="nb">apply</span>: bigcup_sup.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">decomp_set0</span> : decomp set0 = [<span class="nb">set</span> set0].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /decomp eqxx. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">decompN0</span> (<span class="nv">A</span> : <span class="nb">set</span> rT) : decomp A != set0.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /decomp; <span class="nb">case</span>: ifPn =&gt; [_|AN0]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>/set0P; <span class="kr">exists</span> <span class="nv">set0</span>.
<span class="nb">case</span>: pselect=&gt; //= Am; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>/set0P; <span class="kr">exists</span> <span class="nv">A</span>.
<span class="nb">case</span>: cid=&gt; //= D [_ _ _ _ Aeq]; <span class="nb">apply</span>: contra_neq AN0; <span class="nb">rewrite</span> Aeq =&gt; -&gt;.
<span class="bp">by</span> <span class="nb">rewrite</span> bigcup_set0.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">measure</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R)
  (<span class="nv">A</span> : <span class="nb">set</span> rT) : \bar R := \sum_(X \<span class="kr">in</span> decomp A) mu X.

<span class="kn">Section</span> <span class="nf">content</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : realFieldType} (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}).
<span class="kn">Local Notation</span> <span class="nf">Rmu</span> := (<span class="kn">measure</span> mu).
<span class="kn">Arguments</span> big_trivIset {I D T R idx op} A F.

<span class="kn">Lemma</span> <span class="nf">Rmu_fin_bigcup</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
    finite_set D -&gt; trivIset D F -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, i \<span class="kr">in</span> D -&gt; measurable (F i)) -&gt;
  Rmu (\bigcup_(i <span class="kr">in</span> D) F i) = \sum_(i \<span class="kr">in</span> D) mu (F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dfin Ftriv Fm; <span class="nb">rewrite</span> /<span class="kn">measure</span>.
<span class="nb">have</span> mUD : measurable (\bigcup_(i <span class="kr">in</span> D) F i : <span class="nb">set</span> rT).
  <span class="nb">apply</span>: fin_bigcup_measurable =&gt; // *; <span class="nb">apply</span>: sub_gen_smallest.
  <span class="bp">exact</span>/Fm/mem_set.
<span class="nb">have</span> [-&gt;|/set0P[i0 Di0]] := eqVneq D set0.
  <span class="bp">by</span> <span class="nb">rewrite</span> bigcup_set0 decomp_set0 fsbig_set0 fsbig_set1.
<span class="nb">set</span> E := decomp _; <span class="nb">have</span> Em X := decomp_measurable mUD X.
<span class="nb">transitivity</span> (\sum_(X \<span class="kr">in</span> E) \sum_(i \<span class="kr">in</span> D) mu (X `&amp;` F i)).
  <span class="nb">apply</span>: eq_fsbigr =&gt; /= X XE; <span class="nb">have</span> XDF : X = \bigcup_(i <span class="kr">in</span> D) (X `&amp;` F i).
    <span class="bp">by</span> <span class="nb">rewrite</span> -setI_bigcupr setIidl//; <span class="bp">exact</span>: decomp_sub.
  <span class="nb">rewrite</span> [<span class="kr">in</span> LHS]XDF content_fin_bigcup//; <span class="kp">first</span> <span class="bp">exact</span>: trivIset_setIl.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; i /mem_set Di; <span class="nb">apply</span>: measurableI; [<span class="bp">exact</span>: Em|<span class="bp">exact</span>: Fm].
  - <span class="bp">by</span> <span class="nb">rewrite</span> -XDF; <span class="bp">exact</span>: Em.
<span class="nb">rewrite</span> exchange_fsbig //; <span class="nb">last</span> <span class="bp">exact</span>: decomp_finite_set.
<span class="nb">apply</span>: eq_fsbigr =&gt; i Di; <span class="nb">have</span> Feq : F i = \bigcup_(X <span class="kr">in</span> E) (X `&amp;` F i).
  <span class="nb">rewrite</span> -setI_bigcupl setIidr// cover_decomp.
  <span class="bp">by</span> <span class="nb">apply</span>/bigcup_sup; <span class="bp">exact</span>: set_mem.
<span class="nb">rewrite</span> -content_fin_bigcup -<span class="nl">?Feq</span>//; [<span class="bp">exact</span>/decomp_finite_set| | |<span class="bp">exact</span>/Fm].
- <span class="bp">exact</span>/trivIset_setIr/decomp_triv.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; X /= XE; <span class="nb">apply</span>: measurableI; [<span class="nb">apply</span>: Em; <span class="nb">rewrite</span> inE | <span class="bp">exact</span>: Fm].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">RmuE</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : measurable A -&gt; Rmu A = mu A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Am; <span class="nb">rewrite</span> -[A <span class="kr">in</span> LHS](@bigcup_set1 _ unit _ tt).
<span class="bp">by</span> <span class="nb">rewrite</span> Rmu_fin_bigcup// <span class="nl">?fsbig_set1</span>// =&gt; -[].
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">Rmu0</span> : Rmu set0 = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -(bigcup_set0 (<span class="kr">fun</span> <span class="nv">_</span> : void =&gt; set0)).
<span class="bp">by</span> <span class="nb">rewrite</span> Rmu_fin_bigcup// fsbig_set0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">Rmu_ge0</span> <span class="nv">A</span> : Rmu A &gt;= <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> sume_ge0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">Rmu_additive</span> : semi_additive Rmu.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/(additive2P Rmu0) =&gt; // A B /ring_finite_set[/= {}A [? _ Atriv Am -&gt;]].
<span class="nb">move</span>=&gt; /ring_finite_set[/= {}B [? _ Btriv Bm -&gt;]].
<span class="nb">rewrite</span> -subset0 =&gt; coverAB0.
<span class="nb">have</span> AUBfin : finite_set (A `|` B) <span class="bp">by</span> <span class="nb">rewrite</span> finite_setU.
<span class="nb">have</span> AUBtriv : trivIset (A `|` B) id.
  <span class="nb">move</span>=&gt; X Y [] ABX [] ABY; <span class="kp">do</span> <span class="nl">?by</span> [<span class="bp">exact</span>: Atriv|<span class="bp">exact</span>: Btriv].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; [u [Xu Yu]]; <span class="nb">case</span>: (coverAB0 u); <span class="nb">split</span>; [<span class="kr">exists</span> <span class="nv">X</span>|<span class="kr">exists</span> <span class="nv">Y</span>].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [u [Xu Yu]]; <span class="nb">case</span>: (coverAB0 u); <span class="nb">split</span>; [<span class="kr">exists</span> <span class="nv">Y</span>|<span class="kr">exists</span> <span class="nv">X</span>].
<span class="nb">rewrite</span> -bigcup_setU !Rmu_fin_bigcup//=.
- <span class="nb">rewrite</span> fsbigU//= =&gt; [X /= [XA XB]]; <span class="nb">have</span> [-&gt;//|/set0P[x Xx]] := eqVneq X set0.
  <span class="bp">by</span> <span class="nb">case</span>: (coverAB0 x); <span class="nb">split</span>; <span class="kr">exists</span> <span class="nv">X</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; X /set_mem [|] /mem_set ?; [<span class="bp">exact</span>: Am|<span class="bp">exact</span>: Bm].
<span class="kn">Qed</span>.

#[export]
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isContent.Build _ _ _ Rmu Rmu_ge0 Rmu_additive.

<span class="kn">End</span> <span class="nf">content</span>.

<span class="kn">End</span> <span class="nf">SetRing</span>.
<span class="kn">Module</span> <span class="nf">Exports</span>.
<span class="kn">Canonical</span> <span class="nf">ring_eqType</span>.
<span class="kn">Canonical</span> <span class="nf">ring_choiceType</span>.
<span class="kn">Canonical</span> <span class="nf">ring_ptType</span>.
HB.reexport SetRing.
<span class="kn">End</span> <span class="nf">Exports</span>.
<span class="kn">End</span> <span class="nf">SetRing</span>.
<span class="kn">Export</span> SetRing.Exports.

<span class="kn">Notation</span> <span class="s2">&quot;d .-ring&quot;</span> := (SetRing.display d)
  (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">format</span> <span class="s2">&quot;d .-ring&quot;</span>) : measure_display_scope.
<span class="kn">Notation</span> <span class="s2">&quot;d .-ring.-measurable&quot;</span> :=
  ((d%mdisp.-<span class="bp">ring</span>).-measurable : <span class="nb">set</span> (<span class="nb">set</span> (SetRing.type _))) : classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">le_measure</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : semiRingOfSetsType d)
    (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}) :
  {<span class="kr">in</span> measurable &amp;, {homo mu : A B / A `&lt;=` B &gt;-&gt; (A &lt;= B)%E}}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A B; <span class="nb">rewrite</span> <span class="nl">?inE</span> =&gt; mA mB AB; <span class="nb">have</span> [|muBfin] := leP +oo%E (mu B).
  <span class="bp">by</span> <span class="nb">rewrite</span> leye_eq =&gt; /eqP -&gt;; <span class="nb">rewrite</span> leey.
<span class="nb">rewrite</span> -[leRHS]SetRing.RmuE// -[B](setDUK AB) measureU/= <span class="nl">?setDIK</span>//.
- <span class="bp">by</span> <span class="nb">rewrite</span> SetRing.RmuE <span class="nl">?lee_addl</span>.
- <span class="bp">exact</span>: sub_gen_smallest.
- <span class="bp">by</span> <span class="nb">apply</span>: measurableD; <span class="bp">exact</span>: sub_gen_smallest.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_le0</span> <span class="nv">d</span> (<span class="nv">T</span> : semiRingOfSetsType d) (<span class="nv">R</span> : realFieldType)
  (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">A</span> : <span class="nb">set</span> T) :
  (mu A &lt;= <span class="mi">0</span>)%E = (mu A == <span class="mi">0</span>)%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: ltgtP (measure_ge0 mu A). <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">more_content_semiring_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : semiRingOfSetsType d).
<span class="kn">Variable</span> <span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">content_sub_additive</span> : sub_additive mu.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; X A n Am Xm XA; <span class="nb">pose</span> B i := A\_`I_n i `&amp;` X.
<span class="nb">have</span> XE : X = \big[setU/set0]_(i &lt; n) B i.
  <span class="nb">rewrite</span> -big_distrl/= setIidr// =&gt; x /XA/=.
  <span class="bp">by</span> <span class="nb">rewrite</span> -!bigcup_mkord =&gt; -[k nk Ax]; <span class="kr">exists</span> <span class="nv">k</span>; <span class="nb">rewrite</span> // patchT <span class="nl">?inE</span>.
<span class="nb">have</span> Bm i : measurable (B i).
  <span class="nb">case</span>: (ltnP i n) =&gt; ltin; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> /B patchC <span class="nl">?inE</span> <span class="nl">?set0I</span>//= leq_gtF.
  <span class="bp">by</span> <span class="nb">rewrite</span> /B <span class="nl">?patchT</span> <span class="nl">?inE</span>//; <span class="nb">apply</span>: measurableI =&gt; //; <span class="nb">apply</span>: Am.
<span class="nb">have</span> subBA i : B i `&lt;=` A i.
  <span class="bp">by</span> <span class="nb">rewrite</span> /B/patch; <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> // set0I//= =&gt; _ ?.
<span class="nb">have</span> subDUB i : seqDU B i `&lt;=` A i <span class="bp">by</span>  <span class="nb">move</span>=&gt; x [/subBA].
<span class="nb">have</span> DUBm i : measurable (seqDU B i : <span class="nb">set</span> (SetRing.type T)).
  <span class="nb">apply</span>: measurableD; <span class="kp">first</span> <span class="bp">exact</span>: sub_gen_smallest.
  <span class="bp">by</span> <span class="nb">apply</span>: bigsetU_measurable =&gt; ? _; <span class="nb">apply</span>: sub_gen_smallest.
<span class="nb">have</span> DU0 i : (i &gt;= n)%N -&gt; seqDU B i = set0.
  <span class="nb">move</span>=&gt; leni; <span class="nb">rewrite</span> -subset0 =&gt; x []; <span class="nb">rewrite</span> /B patchC <span class="nl">?inE</span>/= <span class="nl">?leq_gtF</span>//.
  <span class="bp">by</span> <span class="nb">case</span>.
<span class="nb">rewrite</span> -SetRing.RmuE// XE bigsetU_seqDU measure_bigsetU//.
<span class="nb">rewrite</span> [leRHS](big_ord_widen n (mu \o A))//= [leRHS]big_mkcond/=.
<span class="nb">rewrite</span> lee_sum =&gt; // i _; <span class="nb">case</span>: ltnP =&gt; ltin; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> DU0 <span class="nl">?measure0</span>.
<span class="nb">rewrite</span> -[leRHS]SetRing.RmuE; <span class="nb">last</span> <span class="bp">exact</span>: Am.
<span class="bp">by</span> <span class="nb">rewrite</span> le_measure <span class="nl">?inE</span>//=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: sub_gen_smallest; <span class="nb">apply</span>: Am.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">content_sub_fsum</span> (<span class="nv">I</span> : choiceType) <span class="nv">D</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">A_</span> : I -&gt; <span class="nb">set</span> T) :
  finite_set D -&gt;
  (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; measurable (A_ i)) -&gt;
  measurable A -&gt;
  A `&lt;=` \bigcup_(i <span class="kr">in</span> D) A_ i -&gt; mu A &lt;= \sum_(i \<span class="kr">in</span> D) mu (A_ i).
<span class="kn">Proof</span>.
<span class="nb">elim</span>/choicePpointed: I =&gt; I <span class="kr">in</span> A_ D *.
  <span class="nb">rewrite</span> !emptyE bigcup_set0// subset0 =&gt; _ _ _ -&gt;.
  <span class="bp">by</span> <span class="nb">rewrite</span> measure0 fsbig_set0.
<span class="nb">move</span>=&gt; Dfin A_m Am Asub; <span class="nb">have</span> [n /ppcard_eqP[f]] := Dfin.
<span class="nb">rewrite</span> (reindex_fsbig f^-<span class="mi">1</span>%FUN `I_n)//= -fsbig_ord.
<span class="nb">rewrite</span> (@content_sub_additive A (A_ \o f^-<span class="mi">1</span>%FUN))//=.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i ltin; <span class="nb">apply</span>: A_m; <span class="nb">apply</span>: funS.
<span class="nb">rewrite</span> (fsbig_ord _ _ (A_ \o f^-<span class="mi">1</span>%FUN))/= -(reindex_fsbig _ _ D)//=.
<span class="bp">by</span> <span class="nb">rewrite</span> fsbig_setU.
<span class="kn">Qed</span>.

<span class="c">(* (* alternative proof *) *)</span>
<span class="c">(* Theorem semi_Boole_inequality : sub_additive mu. *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move=&gt; X A n Am Xm Xsub; rewrite -SetRing.RmuE//. *)</span>
<span class="c">(* under eq_bigr =&gt; i do [rewrite -SetRing.RmuE; do ?by apply: Am=&gt; /=]. *)</span>
<span class="c">(* pose rT := SetRing.type T. *)</span>
<span class="c">(* have {}Am i : `I_n i -&gt; measurable (A i : set rT). *)</span>
<span class="c">(*   by move=&gt; *; apply/SetRing.measurableW/Am =&gt; /=. *)</span>
<span class="c">(* have {}Xm : measurable (X : set rT) by exact: SetRing.measurableW. *)</span>
<span class="c">(* pose ammu := [additive_measure of SetRing.measure mu]. *)</span>
<span class="c">(* rewrite (le_trans (le_measure ammu  _ _ Xsub)) ?inE// {Xsub}. *)</span>
<span class="c">(*   by rewrite -bigcup_mkord; apply: fin_bigcup_measurable. *)</span>
<span class="c">(* elim: n Am Xm =&gt; [|n IHn] Am Xm; first by rewrite !big_ord0 measure0. *)</span>
<span class="c">(* have Anm : measurable (A n : set rT) by apply: Am =&gt; /=. *)</span>
<span class="c">(* set B := \big[setU/set0]_(i &lt; n) A i. *)</span>
<span class="c">(* set C := \big[setU/set0]_(i &lt; n.+1) A i. *)</span>
<span class="c">(* have -&gt; : C = B `|` (A n `\` B). *)</span>
<span class="c">(*   suff -&gt; : A n `\` B = C `\` B by rewrite setDUK// /C big_ord_recr/=; left. *)</span>
<span class="c">(*   by rewrite /C big_ord_recr/= !setDE setIUl -!setDE setDv set0U. *)</span>
<span class="c">(* have Bm : measurable (B : set rT). *)</span>
<span class="c">(*   by rewrite -[B]bigcup_mkord; apply: fin_bigcup_measurable =&gt; //= i /ltnW/Am. *)</span>
<span class="c">(* rewrite measureU // ?setDIK//; last exact: measurableD. *)</span>
<span class="c">(* rewrite (@le_trans _ _ (ammu B + ammu (A n))) // ?lee_add2l //; last first. *)</span>
<span class="c">(*   by rewrite big_ord_recr /= lee_add2r// IHn// =&gt; i /ltnW/Am. *)</span>
<span class="c">(* by rewrite le_measure // ?inE// ?setDE//; exact: measurableD. *)</span>
<span class="c">(* Qed. *)</span>

<span class="kn">End</span> <span class="nf">more_content_semiring_lemmas</span>.

<span class="kn">Section</span> <span class="nf">content_ring_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : ringOfSetsType d).
<span class="kn">Variable</span> <span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">content_ring_sup_sigma_additive</span> (<span class="nv">A</span> : nat -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span>, measurable (A i)) -&gt; measurable (\bigcup_i A i) -&gt;
  trivIset [<span class="nb">set</span>: nat] A -&gt; \sum_(i &lt;oo) mu (A i) &lt;= mu (\bigcup_i A i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Am UAm At; <span class="nb">rewrite</span> lime_le//; <span class="kp">first</span> <span class="bp">exact</span>: is_cvg_nneseries.
near=&gt; n; <span class="nb">rewrite</span> big_mkord -measure_bigsetU//= le_measure <span class="nl">?inE</span>//=.
- <span class="bp">exact</span>: bigsetU_measurable.
- <span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_mkord; <span class="nb">apply</span>: bigcup_sub =&gt; i lein; <span class="nb">apply</span>: bigcup_sup.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">content_ring_sigma_additive</span> : sigma_sub_additive mu -&gt; semi_sigma_additive mu.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mu_sub A Am Atriv UAm.
<span class="nb">suff</span> &lt;- : \sum_(i &lt;oo) mu (A i) = mu (\bigcup_n A n) <span class="bp">by</span> <span class="bp">exact</span>: is_cvg_nneseries.
<span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le mu_sub// <span class="nl">?content_ring_sup_sigma_additive</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">content_ring_lemmas</span>.

<span class="kn">Section</span> <span class="nf">ring_sigma_sub_additive_content</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : semiRingOfSetsType d)
        (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}).
<span class="kn">Local Notation</span> <span class="nf">Rmu</span> := (SetRing.<span class="kn">measure</span> mu).
<span class="kn">Import</span> SetRing.

<span class="kn">Lemma</span> <span class="nf">ring_sigma_sub_additive</span> : sigma_sub_additive mu -&gt; sigma_sub_additive Rmu.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; muS; <span class="nb">move</span>=&gt; /= D A Am Dm Dsub.
<span class="nb">rewrite</span> /Rmu -(eq_eseries (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; esum_fset _ _))//; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: decomp_finite_set.
<span class="nb">rewrite</span> nneseries_esum <span class="nl">?esum_esum</span>//=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> esum_ge0.
<span class="nb">set</span> K := _ `*`` _.
<span class="nb">have</span> /ppcard_eqP[f] : (K #= [<span class="nb">set</span>: nat])%card.
  <span class="nb">apply</span>: cardMR_eq_nat =&gt; [|i].
    <span class="bp">by</span> <span class="nb">rewrite</span> (_ : [<span class="nb">set</span> _ | true] = setT)//; <span class="bp">exact</span>/predeqP.
  <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>/finite_set_countable; <span class="bp">exact</span>: decomp_finite_set.
  <span class="bp">exact</span>/set0P/decompN0.
<span class="nb">have</span> {Dsub} : D `&lt;=` \bigcup_(k <span class="kr">in</span> K) k.<span class="mi">2</span>.
  <span class="nb">apply</span>: (subset_trans Dsub); <span class="nb">apply</span>: bigcup_sub =&gt; i _.
  <span class="nb">rewrite</span> -[A i]cover_decomp; <span class="nb">apply</span>: bigcup_sub =&gt; X/= XAi.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x Xx; <span class="kr">exists</span> (<span class="nv">i</span>, X).
<span class="nb">rewrite</span> -(image_eq [bij of f^-<span class="mi">1</span>%FUN])/=.
<span class="nb">rewrite</span> (esum_set_image _ f^-<span class="mi">1</span>)//= bigcup_image =&gt; Dsub.
<span class="nb">have</span> DXsub X : X \<span class="kr">in</span> decomp D -&gt; X `&lt;=` \bigcup_i ((f^-<span class="mi">1</span>%FUN i).<span class="mi">2</span> `&amp;` X).
  <span class="nb">move</span>=&gt; XD; <span class="nb">rewrite</span> -setI_bigcupl -[Y <span class="kr">in</span> Y `&lt;=` _](setIidr (decomp_sub XD)).
  <span class="bp">by</span> <span class="nb">apply</span>: setSI.
<span class="nb">have</span> mf i : measurable ((f^-<span class="mi">1</span>)%function i).<span class="mi">2</span>.
  <span class="nb">have</span> [_ /mem_set/decomp_measurable] := &#39;invS_f (I : setT i).
  <span class="bp">by</span> <span class="nb">apply</span>; <span class="bp">exact</span>: Am.
<span class="nb">have</span> mfD i X : X \<span class="kr">in</span> decomp D -&gt; measurable (((f^-<span class="mi">1</span>)%FUN i).<span class="mi">2</span> `&amp;` X : <span class="nb">set</span> T).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; XD; <span class="nb">apply</span>: measurableI; [<span class="bp">exact</span>: mf|<span class="bp">exact</span>: (decomp_measurable _ XD)].
<span class="nb">apply</span>: (@le_trans _ _
    (\sum_(i &lt;oo) \sum_(X &lt;- fset_set (decomp D)) mu ((f^-<span class="mi">1</span>%FUN i).<span class="mi">2</span> `&amp;` X))).
  <span class="nb">rewrite</span> nneseries_sum// fsbig_finite/=; <span class="nb">last</span> <span class="bp">exact</span>: decomp_finite_set.
  <span class="nb">rewrite</span> [leLHS]big_seq_cond [leRHS]big_seq_cond.
  <span class="nb">rewrite</span> lee_sum// =&gt; X /[!(andbT,in_fset_set)]; <span class="nb">last</span> <span class="bp">exact</span>: decomp_finite_set.
  <span class="nb">move</span>=&gt; XD; <span class="nb">have</span> Xm := decomp_measurable Dm XD.
  <span class="bp">by</span> <span class="nb">apply</span>: muS =&gt; // [i|]; [<span class="bp">exact</span>: mfD|<span class="bp">exact</span>: DXsub].
<span class="nb">apply</span>: lee_lim =&gt; /=; <span class="kp">do</span> <span class="nl">?apply</span>: is_cvg_nneseries=&gt; //.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>: sume_ge0.
near=&gt; n; <span class="nb">rewrite</span> [n <span class="kr">in</span> _ &lt;= n]big_mkcond; <span class="nb">apply</span>: lee_sum =&gt; i _.
<span class="nb">rewrite</span> ifT <span class="nl">?inE</span>//.
<span class="nb">under</span> eq_big_seq.
  <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> in_fset_set=&gt; [xD|]; <span class="nb">last</span> <span class="bp">exact</span>: decomp_finite_set.
  <span class="nb">rewrite</span> -RmuE//; <span class="nb">last</span> <span class="bp">exact</span>: mfD.
  <span class="nb">over</span>.
<span class="nb">rewrite</span> -fsbig_finite/=; <span class="nb">last</span> <span class="bp">exact</span>: decomp_finite_set.
<span class="nb">rewrite</span> -measure_fin_bigcup//=.
- <span class="nb">rewrite</span> -setI_bigcupr (cover_decomp D) -[leRHS]RmuE// <span class="nl">?le_measure</span> <span class="nl">?inE</span>//.
    <span class="bp">by</span> <span class="nb">apply</span>: measurableI =&gt; //; <span class="nb">apply</span>: sub_gen_smallest; <span class="nb">apply</span>: mf.
  <span class="bp">by</span> <span class="nb">apply</span>: sub_gen_smallest; <span class="nb">apply</span>: mf.
- <span class="bp">exact</span>: decomp_finite_set.
- <span class="bp">by</span> <span class="nb">apply</span>: trivIset_setIl; <span class="nb">apply</span>: decomp_triv.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; X /= XD; <span class="nb">apply</span>: sub_gen_smallest; <span class="nb">apply</span>: mfD; <span class="nb">rewrite</span> inE.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ring_sigma_additive</span> : sigma_sub_additive mu -&gt; semi_sigma_additive Rmu.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mu_sub; <span class="nb">apply</span>: content_ring_sigma_additive.
<span class="bp">by</span> <span class="nb">apply</span>: ring_sigma_sub_additive.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ring_sigma_sub_additive_content</span>.

<span class="kn">Section</span> <span class="nf">more_premeasure_ring_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : semiRingOfSetsType d).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Import</span> SetRing.

<span class="kn">Lemma</span> <span class="nf">measure_sigma_sub_additive</span> : sigma_sub_additive mu.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; X A Am Xm XA; <span class="nb">pose</span> B i := A i `&amp;` X.
<span class="nb">have</span> XE : X = \bigcup_i B i <span class="bp">by</span> <span class="nb">rewrite</span> -setI_bigcupl setIidr.
<span class="nb">have</span> Bm i : measurable (B i) <span class="bp">by</span> <span class="nb">rewrite</span> /B; <span class="nb">apply</span>: measurableI.
<span class="nb">have</span> subBA i : B i `&lt;=` A i <span class="bp">by</span> <span class="nb">rewrite</span> /B.
<span class="nb">have</span> subDUB i : seqDU B i `&lt;=` A i <span class="bp">by</span>  <span class="nb">move</span>=&gt; x [/subBA].
<span class="nb">have</span> DUBm i : measurable (seqDU B i : <span class="nb">set</span> (SetRing.type T)).
  <span class="bp">by</span> <span class="nb">apply</span>: measurableD =&gt; //;
     <span class="kp">do</span> <span class="mi">1</span><span class="nl">?apply</span>: bigsetU_measurable =&gt; *; <span class="nb">apply</span>: sub_gen_smallest.
<span class="nb">rewrite</span> XE; <span class="nb">move</span>: (XE); <span class="nb">rewrite</span> seqDU_bigcup_eq.
<span class="nb">under</span> eq_bigcupr <span class="kp">do</span> <span class="nb">rewrite</span> -[seqDU B _]cover_decomp//.
<span class="nb">rewrite</span> bigcup_bigcup_dep; <span class="nb">set</span> K := _ `*`` _.
<span class="nb">have</span> /ppcard_eqP[f] : (K #= [<span class="nb">set</span>: nat])%card.
  <span class="nb">apply</span>: cardMR_eq_nat=&gt; // i; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>/set0P; <span class="nb">rewrite</span> decompN0.
  <span class="bp">exact</span>/finite_set_countable/decomp_finite_set.
<span class="nb">pose</span> f&#39; := f^-<span class="mi">1</span>%FUN; <span class="nb">rewrite</span> -(image_eq [bij of f&#39;])/= bigcup_image/=.
<span class="nb">pose</span> g n := (f&#39; n).<span class="mi">2</span>; <span class="nb">have</span> fVtriv : trivIset [<span class="nb">set</span>: nat] g.
  <span class="nb">move</span>=&gt; i j _ _; <span class="nb">rewrite</span> /g.
  <span class="nb">have</span> [/= _ f&#39;iB] : K (f&#39; i) <span class="bp">by</span> <span class="nb">apply</span>: funS.
  <span class="nb">have</span> [/= _ f&#39;jB] : K (f&#39; j) <span class="bp">by</span> <span class="nb">apply</span>: funS.
  <span class="nb">have</span> [f&#39;ij|f&#39;ij] := eqVneq (f&#39; i).<span class="mi">1</span> (f&#39; j).<span class="mi">1</span>.
    <span class="nb">move</span>=&gt; /(decomp_triv f&#39;iB)/=; <span class="nb">rewrite</span> f&#39;ij =&gt; /(_ f&#39;jB) f&#39;ij2.
    <span class="nb">apply</span>: &#39;inj_f&#39;; <span class="nb">rewrite</span> <span class="nl">?inE</span>//= -!/(f&#39; _); <span class="nb">move</span>: f&#39;ij f&#39;ij2.
    <span class="bp">by</span> <span class="nb">case</span>: (f&#39; i) (f&#39; j) =&gt; [? ?] [? ?]//= -&gt; -&gt;.
  <span class="nb">move</span>=&gt; [x [f&#39;ix f&#39;jx]]; <span class="nb">have</span> Bij := @trivIset_seqDU _ B (f&#39; i).<span class="mi">1</span> (f&#39; j).<span class="mi">1</span> I I.
  <span class="nb">rewrite</span> Bij <span class="nl">?eqxx</span>// <span class="kr">in</span> f&#39;ij; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>.
  - <span class="bp">by</span> <span class="nb">move</span>/mem_set : f&#39;iB =&gt; /decomp_sub; <span class="nb">apply</span>.
  - <span class="bp">by</span> <span class="nb">move</span>/mem_set : f&#39;jB =&gt; /decomp_sub; <span class="nb">apply</span>.
<span class="nb">have</span> g_inj : set_inj [<span class="nb">set</span> i | g i != set0] g.
  <span class="bp">by</span> <span class="nb">apply</span>: trivIset_inj=&gt; [i /set0P//|]; <span class="nb">apply</span>: sub_trivIset fVtriv.
<span class="nb">move</span>=&gt; XEbig; <span class="nb">rewrite</span> measure_semi_bigcup//= -<span class="nl">?XEbig</span>//; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; i; <span class="nb">have</span> [/= _ /mem_set] : K (f&#39; i) <span class="bp">by</span> <span class="nb">apply</span>: funS.
  <span class="bp">exact</span>: decomp_measurable.
<span class="nb">rewrite</span> [leLHS](_ : _ = \sum_(i &lt;oo | g i != set0) mu (g i)); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> !nneseries_esum// esum_mkcond [RHS]esum_mkcond; <span class="nb">apply</span>: eq_esum.
  <span class="nb">move</span>=&gt; i _; <span class="nb">rewrite</span> ifT <span class="nl">?inE</span>//=; <span class="nb">case</span>: ifPn =&gt; //.
  <span class="bp">by</span> <span class="nb">rewrite</span> notin_set /= -/(g _) =&gt; /negP/negPn/eqP -&gt;.
<span class="nb">rewrite</span> -(esum_pred_image mu g)//.
<span class="nb">rewrite</span> [leLHS](_ : _ = \esum_(X <span class="kr">in</span> range g) mu X); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> esum_mkcond [RHS]esum_mkcond; <span class="nb">apply</span>: eq_esum.
  <span class="nb">move</span>=&gt; Y _; <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> ?(inE, notin_set)/=.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; [i giN0 giY]; <span class="nb">rewrite</span> ifT// <span class="nl">?inE</span>//=; <span class="kr">exists</span> <span class="nv">i</span>.
  <span class="nb">move</span>=&gt; Ngx; <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> ?(inE, notin_set)//=.
  <span class="nb">move</span>=&gt; [i _ giY]; <span class="nb">apply</span>: contra_not_eq Ngx; <span class="nb">rewrite</span> -giY =&gt; mugi.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">apply</span>: contra_neq mugi =&gt; -&gt;; <span class="nb">rewrite</span> measure0.
<span class="nb">have</span> -&gt; : range g = \bigcup_i (decomp (seqDU B i)).
  <span class="nb">apply</span>/predeqP =&gt; /= Y; <span class="nb">split</span> =&gt; [[n _ gnY]|[n _ /= YBn]].
  <span class="nb">have</span> [/= _ f&#39;nB] : K (f&#39; n) <span class="bp">by</span> <span class="nb">apply</span>: funS.
    <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f&#39;</span> <span class="nv">n</span>).<span class="mi">1</span> =&gt; //=; <span class="nb">rewrite</span> -gnY.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f</span> (n, Y)) =&gt; //; <span class="nb">rewrite</span> /g /f&#39; funK//= inE.
<span class="nb">rewrite</span> esum_bigcup//; <span class="nb">last first</span>.
   <span class="nb">move</span>=&gt; i j /=.
   <span class="nb">have</span> [-&gt;|/set0P DUBiN0] := eqVneq (seqDU B i) set0.
     <span class="nb">rewrite</span> decomp_set0 <span class="nl">?set_fset1</span> =&gt; /negP[].
     <span class="nb">apply</span>/eqP/predeqP=&gt; x; <span class="nb">split</span>=&gt; [[Y/=-&gt;]|-&gt;]//; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> measure0.
     <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">set0</span>.
   <span class="nb">have</span> [-&gt;|/set0P DUBjN0] := eqVneq (seqDU B j) set0.
     <span class="nb">rewrite</span> decomp_set0 <span class="nl">?set_fset1</span> =&gt; _ /negP[].
     <span class="nb">apply</span>/eqP/predeqP=&gt; x; <span class="nb">split</span>=&gt; [[Y/=-&gt;]|-&gt;]//=; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> measure0.
     <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">set0</span>.
   <span class="nb">move</span>=&gt; _ _ [Y /= [/[dup] +]].
   <span class="nb">move</span>=&gt; /mem_set /decomp_sub YBi /mem_set + /mem_set /decomp_sub YBj.
   <span class="nb">move</span>=&gt; /(decomp_neq0 DUBiN0) [y Yy].
   <span class="nb">apply</span>: (@trivIset_seqDU _ B) =&gt; //; <span class="kr">exists</span> <span class="nv">y</span>.
   <span class="bp">by</span> <span class="nb">split</span> =&gt; //; [<span class="bp">exact</span>: YBi|<span class="bp">exact</span>: YBj].
<span class="nb">rewrite</span> nneseries_esum// set_true le_esum// =&gt; i _.
<span class="nb">rewrite</span> [leLHS](_ : _ = \sum_(j \<span class="kr">in</span> decomp (seqDU B i)) mu j); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> esum_fset//; <span class="bp">exact</span>: decomp_finite_set.
<span class="nb">rewrite</span> -SetRing.Rmu_fin_bigcup//=; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
  <span class="bp">exact</span>: decomp_finite_set.
  <span class="bp">exact</span>: decomp_triv.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: decomp_measurable.
<span class="nb">rewrite</span> -[leRHS]SetRing.RmuE// le_measure//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> cover_decomp.
- <span class="nb">rewrite</span> inE; <span class="nb">apply</span>: fin_bigcup_measurable; <span class="kp">first</span> <span class="bp">exact</span>: decomp_finite_set.
  <span class="nb">move</span>=&gt; j /mem_set jdec; <span class="nb">apply</span>: sub_gen_smallest.
  <span class="bp">exact</span>: decomp_measurable jdec.
- <span class="bp">by</span> <span class="nb">rewrite</span> inE; <span class="nb">apply</span>: sub_gen_smallest; <span class="bp">exact</span>: Am.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">more_premeasure_ring_lemmas</span>.

<span class="kn">Section</span> <span class="nf">ring_sigma_content</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : semiRingOfSetsType d)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).
<span class="kn">Local Notation</span> <span class="nf">Rmu</span> := (SetRing.<span class="kn">measure</span> mu).
<span class="kn">Import</span> SetRing.

<span class="kn">Let</span> <span class="nf">ring_sigma_content</span> : semi_sigma_additive Rmu.
<span class="kn">Proof</span>. <span class="bp">exact</span>/ring_sigma_additive/measure_sigma_sub_additive. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure0.Build _ _ _ Rmu
  ring_sigma_content.

<span class="kn">End</span> <span class="nf">ring_sigma_content</span>.

<span class="kn">Lemma</span> <span class="nf">measureIl</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : semiRingOfSetsType d)
    (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
  measurable A -&gt; measurable B -&gt; (mu (A `&amp;` B) &lt;= mu A)%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mA mB; <span class="nb">rewrite</span> le_measure <span class="nl">?inE</span>//; <span class="nb">apply</span>: measurableI. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measureIr</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : semiRingOfSetsType d)
    (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
  measurable A -&gt; measurable B -&gt; (mu (A `&amp;` B) &lt;= mu B)%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mA mB; <span class="nb">rewrite</span> le_measure <span class="nl">?inE</span>//; <span class="nb">apply</span>: measurableI. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subset_measure0</span> <span class="nv">d</span> (<span class="nv">T</span> : semiRingOfSetsType d) (<span class="nv">R</span> : realType)
  (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
  measurable A -&gt; measurable B -&gt; A `&lt;=` B -&gt;
  mu B = <span class="mi">0</span>%E -&gt; mu A = <span class="mi">0</span>%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB AB B0; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le measure_ge0// <span class="nl">?andbT</span> -<span class="nl">?B0</span>.
<span class="bp">by</span> <span class="nb">apply</span>: le_measure; <span class="nb">rewrite</span> <span class="nl">?inE</span>.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">measureD</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : ringOfSetsType d).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">measureDI</span> <span class="nv">A</span> <span class="nv">B</span> : measurable A -&gt; measurable B -&gt;
  mu A = mu (A `\` B) + mu (A `&amp;` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB; <span class="nb">rewrite</span> -measure_semi_additive2.
- <span class="bp">by</span> <span class="nb">rewrite</span> -setDDr setDv setD0.
- <span class="bp">exact</span>: measurableD.
- <span class="bp">exact</span>: measurableI.
- <span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>: measurableD |<span class="bp">exact</span>: measurableI].
- <span class="bp">by</span> <span class="nb">rewrite</span> setDE setIACA setICl setI0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measureD</span> <span class="nv">A</span> <span class="nv">B</span> : measurable A -&gt; measurable B -&gt;
  mu A &lt; +oo -&gt; mu (A `\` B) = mu A - mu (A `&amp;` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB mAoo.
<span class="nb">rewrite</span> (measureDI mA mB) addeK// fin_numE <span class="mi">1</span><span class="nl">?gt_eqF</span> <span class="mi">1</span><span class="nl">?lt_eqF</span>//.
- <span class="bp">by</span> <span class="nb">rewrite</span> (le_lt_trans _ mAoo)// le_measure // <span class="nl">?inE</span>//; <span class="bp">exact</span>: measurableI.
- <span class="bp">by</span> <span class="nb">rewrite</span> (lt_le_trans _ (measure_ge0 _ _)).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measureD</span>.

<span class="kn">Lemma</span> <span class="nf">measureUfinr</span> <span class="nv">d</span> (<span class="nv">T</span> : ringOfSetsType d) (<span class="nv">R</span> : realFieldType) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T)
   (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}):
    measurable A -&gt; measurable B -&gt; (mu B &lt; +oo)%E -&gt;
  mu (A `|` B) = (mu A + mu B - mu (A `&amp;` B))%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Am Bm mBfin; <span class="nb">rewrite</span> -[B <span class="kr">in</span> LHS](setDUK (@subIsetl _ _ A)) setUA.
<span class="nb">rewrite</span> [A `|` _]setUidl; <span class="nb">last</span> <span class="bp">exact</span>: subIsetr.
<span class="nb">rewrite</span> measureU//=; <span class="kp">do</span> <span class="nl">?by</span> <span class="nb">apply</span>:measurableD; <span class="kp">do</span> <span class="nl">?apply</span>: measurableI.
  <span class="nb">rewrite</span> measureD//; <span class="kp">do</span> <span class="nl">?exact</span>: measurableI.
  <span class="bp">by</span> <span class="nb">rewrite</span> addeA setIA setIid setIC.
<span class="bp">by</span> <span class="nb">rewrite</span> setDE setCI setIUr -!setDE setDv set0U setDIK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measureUfinl</span> <span class="nv">d</span> (<span class="nv">T</span> : ringOfSetsType d) (<span class="nv">R</span> : realFieldType) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T)
   (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}):
    measurable A -&gt; measurable B -&gt; (mu A &lt; +oo)%E -&gt;
  mu (A `|` B) = (mu A + mu B - mu (A `&amp;` B))%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> setUC measureUfinr// setIC [(mu B + _)%E]addeC. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_measureU</span> <span class="nv">d</span> (<span class="nv">T</span> : ringOfSetsType d) (<span class="nv">R</span> : realFieldType) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T)
   (<span class="nv">mu</span> <span class="nv">mu&#39;</span> : {measure <span class="nb">set</span> T -&gt; \bar R}):
    measurable A -&gt; measurable B -&gt;
  mu A = mu&#39; A -&gt; mu B = mu&#39; B -&gt; mu (A `&amp;` B) = mu&#39; (A `&amp;` B) -&gt;
  mu (A `|` B) = mu&#39; (A `|` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB muA muB muAB; <span class="nb">have</span> [mu&#39;ANoo|] := ltP (mu&#39; A) +oo.
  <span class="bp">by</span> <span class="nb">rewrite</span> !measureUfinl <span class="nl">?muA</span> <span class="nl">?muB</span> <span class="nl">?muAB</span>.
<span class="nb">rewrite</span> leye_eq =&gt; /eqP mu&#39;A; <span class="nb">transitivity</span> (+oo : \bar R); <span class="nb">apply</span>/eqP.
  <span class="bp">by</span> <span class="nb">rewrite</span> -leye_eq -mu&#39;A -muA le_measure <span class="nl">?inE</span>//=; <span class="nb">apply</span>: measurableU.
<span class="bp">by</span> <span class="nb">rewrite</span> eq_sym -leye_eq -mu&#39;A le_measure <span class="nl">?inE</span>//=; <span class="nb">apply</span>: measurableU.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">null_set_setU</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : ringOfSetsType d)
  (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
  measurable A -&gt; measurable B -&gt; mu A = <span class="mi">0</span>%E -&gt; mu B = <span class="mi">0</span>%E -&gt; mu (A `|` B) = <span class="mi">0</span>%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB A0 B0; <span class="nb">rewrite</span> measureUfinl <span class="nl">?A0</span>//= <span class="nl">?B0</span> <span class="nl">?add0e</span>.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> oppe_eq0 -measure_le0/=; <span class="kp">do</span> <span class="nl">?exact</span>: measurableI.
<span class="bp">by</span> <span class="nb">rewrite</span> -A0 measureIl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_cvg_mu</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : ringOfSetsType d)
  (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">F</span> : (<span class="nb">set</span> T) ^nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, measurable (F i)) -&gt; measurable (\bigcup_n F n) -&gt;
  nondecreasing_seq F -&gt;
  mu \o F --&gt; mu (\bigcup_n F n).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF mbigcupF ndF.
<span class="nb">have</span> Binter : trivIset setT (seqD F) := trivIset_seqD ndF.
<span class="nb">have</span> FBE : <span class="kr">forall</span> <span class="nv">n</span>, F n.+<span class="mi">1</span> = F n `|` seqD F n.+<span class="mi">1</span> := setU_seqD ndF.
<span class="nb">have</span> FE n : F n = \big[setU/set0]_(i &lt; n.+<span class="mi">1</span>) (seqD F) i := eq_bigsetU_seqD n ndF.
<span class="nb">rewrite</span> eq_bigcup_seqD.
<span class="nb">have</span> mB i : measurable (seqD F i) <span class="bp">by</span> <span class="nb">elim</span>: i =&gt; * //=; <span class="nb">apply</span>: measurableD.
<span class="nb">apply</span>: cvg_trans (measure_semi_sigma_additive _ mB Binter _); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -eq_bigcup_seqD.
<span class="nb">apply</span>: (@cvg_trans _ [filter of (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(i &lt; n.+<span class="mi">1</span>) mu (seqD F i))]).
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ = mu \o F) // funeqE =&gt; n.
  <span class="bp">by</span> <span class="nb">rewrite</span> -measure_semi_additive // -<span class="nl">?FE</span>// =&gt; -[|k].
<span class="nb">move</span>=&gt; S [n _] nS; <span class="kr">exists</span> <span class="nv">n</span> =&gt; // m nm.
<span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -(big_mkord predT (mu \o seqD F)).
<span class="bp">exact</span>/(nS m.+<span class="mi">1</span>)/(leq_trans nm).
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">boole_inequality</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : ringOfSetsType d).
<span class="kn">Variable</span> <span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Theorem</span> <span class="nf">Boole_inequality</span> (<span class="nv">A</span> : (<span class="nb">set</span> T) ^nat) <span class="nv">n</span> :
    (<span class="kr">forall</span> <span class="nv">i</span>, `I_n i -&gt; measurable (A i)) -&gt;
  mu (\big[setU/set0]_(i &lt; n) A i) &lt;= \sum_(i &lt; n) mu (A i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Am; <span class="nb">rewrite</span> content_sub_additive// -bigcup_mkord.
<span class="bp">exact</span>: fin_bigcup_measurable.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">boole_inequality</span>.
<span class="kn">Notation</span> <span class="nf">le_mu_bigsetU</span> := Boole_inequality.

<span class="kn">Section</span> <span class="nf">sigma_finite_lemma</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : ringOfSetsType d) (<span class="nv">A</span> : <span class="nb">set</span> T)
        (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">sigma_finiteP</span> : sigma_finite A mu -&gt;
  <span class="kr">exists2</span> F, A = \bigcup_i F i &amp;
    nondecreasing_seq F /\ <span class="kr">forall</span> <span class="nv">i</span>, measurable (F i) /\ mu (F i) &lt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [S AS moo]; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">n</span> =&gt; \big[setU/set0]_(i &lt; n.+<span class="mi">1</span>) S i).
  <span class="nb">rewrite</span> AS predeqE =&gt; t; <span class="nb">split</span> =&gt; [[i _ Sit]|[i _]].
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">rewrite</span> big_ord_recr /=; <span class="nb">right</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_mkord =&gt; -[j /= ji Sjt]; <span class="kr">exists</span> <span class="nv">j</span>.
<span class="nb">split</span>=&gt; [|i].
- <span class="nb">apply</span>/nondecreasing_seqP =&gt; i; <span class="nb">rewrite</span> [<span class="kr">in</span> leRHS]big_ord_recr /=.
  <span class="bp">by</span> <span class="nb">apply</span>/subsetPset; <span class="nb">left</span>.
- <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: bigsetU_measurable =&gt; j _; <span class="bp">exact</span>: (moo j).<span class="mi">1</span>.
  <span class="nb">rewrite</span> (@le_lt_trans _ _ (\sum_(j &lt; i.+<span class="mi">1</span>) mu (S j)))//.
    <span class="bp">by</span> <span class="nb">apply</span>: Boole_inequality =&gt; j _; <span class="bp">exact</span>: (moo j).<span class="mi">1</span>.
  <span class="bp">by</span> <span class="nb">apply</span>/lte_sum_pinfty =&gt; j _; <span class="bp">exact</span>: (moo j).<span class="mi">2</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sigma_finite_lemma</span>.

<span class="kn">Section</span> <span class="nf">generalized_boole_inequality</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : ringOfSetsType d).
<span class="kn">Variable</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Theorem</span> <span class="nf">generalized_Boole_inequality</span> (<span class="nv">A</span> : (<span class="nb">set</span> T) ^nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, measurable (A i)) -&gt; measurable (\bigcup_n A n) -&gt;
  mu (\bigcup_n A n) &lt;= \sum_(i &lt;oo) mu (A i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Am UAm; <span class="nb">rewrite</span> measure_sigma_sub_additive. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">generalized_boole_inequality</span>.
<span class="kn">Notation</span> <span class="nf">le_mu_bigcup</span> := generalized_Boole_inequality.

<span class="kn">Section</span> <span class="nf">negligible</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">T</span> : ringOfSetsType d).

<span class="kn">Definition</span> <span class="nf">negligible</span> (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) (<span class="nv">N</span> : <span class="nb">set</span> T) :=
  <span class="kr">exists</span> <span class="nv">A</span> : <span class="nb">set</span> T, [/\ measurable A, mu A = <span class="mi">0</span> &amp; N `&lt;=` A].

<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;mu .-negligible&quot;</span> := (negligible mu).

<span class="kn">Lemma</span> <span class="nf">negligibleP</span> (<span class="nv">mu</span> : {content <span class="nb">set</span> _ -&gt; \bar _}) <span class="nv">A</span> :
  measurable A -&gt; mu.-negligible A &lt;-&gt; mu A = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA; <span class="nb">split</span> =&gt; [[B [mB mB0 AB]]|mA0]; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span>; <span class="nb">split</span>.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le measure_ge0 // andbT -mB0.
<span class="bp">by</span> <span class="nb">apply</span>: (le_measure mu) =&gt; //; <span class="nb">rewrite</span> in_setE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">negligible_set0</span> (<span class="nv">mu</span> : {content <span class="nb">set</span> _ -&gt; \bar _}) : mu.-negligible set0.
<span class="kn">Proof</span>. <span class="bp">exact</span>/negligibleP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measure_negligible</span> (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">A</span> : <span class="nb">set</span> T) :
  measurable A -&gt; mu.-negligible A -&gt; mu A = <span class="mi">0</span>%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mA /negligibleP -&gt;. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">almost_everywhere</span> (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>)
     &amp; (phantom <span class="kt">Prop</span> (<span class="kr">forall</span> <span class="nv">x</span>, P x)) :=
   mu.-negligible (~` [<span class="nb">set</span> x | P x]).
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;{ &#39;ae&#39; m , P }&quot;</span> :=
  (almost_everywhere m (inPhantom P)) : type_scope.

<span class="kn">Lemma</span> <span class="nf">aeW</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> _ -&gt; \bar _}) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span>, P x) -&gt; {ae mu, <span class="kr">forall</span> <span class="nv">x</span>, P x}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; aP; <span class="nb">have</span> -&gt; : P = setT <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>.
<span class="bp">by</span> <span class="nb">apply</span>/negligibleP; [<span class="nb">rewrite</span> setCT|<span class="nb">rewrite</span> setCT measure0].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">negligible</span>.

<span class="kn">Notation</span> <span class="s2">&quot;mu .-negligible&quot;</span> := (negligible mu) : type_scope.

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;ae&#39; m , P }&quot;</span> := (almost_everywhere m (inPhantom P)) : type_scope.

<span class="kn">Definition</span> <span class="nf">sigma_subadditive</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : <span class="kt">Type</span>)
  (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) := <span class="kr">forall</span> (<span class="nv">F</span> : (<span class="nb">set</span> T) ^nat),
  mu (\bigcup_n (F n)) &lt;= \sum_(i &lt;oo) mu (F i).

HB.mixin <span class="kn">Record</span> <span class="nf">isOuterMeasure</span>
    (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) := {
  outer_measure0 : mu set0 = <span class="mi">0</span> ;
  outer_measure_ge0 : <span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= mu x ;
  le_outer_measure : {homo mu : A B / A `&lt;=` B &gt;-&gt; A &lt;= B} ;
  outer_measure_sigma_subadditive : sigma_subadditive mu }.

#[short(type=outer_measure)]
HB.structure <span class="kn">Definition</span> <span class="nf">OuterMeasure</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : <span class="kt">Type</span>) :=
  {mu &amp; isOuterMeasure R T mu}.

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;outer_measure&#39; &#39;set&#39; T &#39;-&gt;&#39; &#39;\bar&#39; R }&quot;</span> := (outer_measure R T)
  (<span class="kn">at level</span> <span class="mi">36</span>, T, R <span class="kn">at next level</span>,
    <span class="kn">format</span> <span class="s2">&quot;{ &#39;outer_measure&#39;  &#39;set&#39;  T  &#39;-&gt;&#39;  &#39;\bar&#39;  R }&quot;</span>) : ring_scope.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (_ set0 = <span class="mi">0</span>) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: outer_measure0] : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (sigma_subadditive _) =&gt;
  <span class="kp">solve</span> [<span class="nb">apply</span>: outer_measure_sigma_subadditive] : core.

<span class="kn">Arguments</span> outer_measure0 {R T} _.
<span class="kn">Arguments</span> outer_measure_ge0 {R T} _.
<span class="kn">Arguments</span> le_outer_measure {R T} _.
<span class="kn">Arguments</span> outer_measure_sigma_subadditive {R T} _.

<span class="kn">Lemma</span> <span class="nf">le_outer_measureIC</span> (<span class="nv">R</span> : realFieldType) <span class="nv">T</span>
  (<span class="nv">mu</span> : {outer_measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">A</span> <span class="nv">X</span> : <span class="nb">set</span> T) :
  mu X &lt;= mu (X `&amp;` A) + mu (X `&amp;` ~` A).
<span class="kn">Proof</span>.
<span class="nb">pose</span> B : (<span class="nb">set</span> T) ^nat := bigcup2 (X `&amp;` A) (X `&amp;` ~` A).
<span class="nb">have</span> cvg_mu : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(i &lt; n) mu (B i)) --&gt; mu (B <span class="mi">0</span>%N) + mu (B <span class="mi">1</span>%N).
  <span class="nb">rewrite</span> -<span class="mi">2</span>!cvg_shiftS /=.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ = (<span class="kr">fun</span>=&gt; mu (B <span class="mi">0</span>%N) + mu (B <span class="mi">1</span>%N))); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> funeqE =&gt; i; <span class="nb">rewrite</span> <span class="mi">2</span>!big_ord_recl /= big1 <span class="nl">?adde0</span> // =&gt; j _.
    <span class="bp">by</span> <span class="nb">rewrite</span> /B /bigcup2 /=.
  <span class="bp">exact</span>: cvg_cst.
<span class="nb">have</span> := outer_measure_sigma_subadditive mu B.
<span class="nb">suff</span> : \bigcup_n B n = X.
  <span class="nb">move</span>=&gt; -&gt; /le_trans; <span class="nb">apply</span>; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> big_mkord.
  <span class="bp">by</span> <span class="nb">rewrite</span> (cvg_lim _ cvg_mu).
<span class="nb">transitivity</span> (\big[setU/set0]_(i &lt; <span class="mi">2</span>) B i).
  <span class="bp">by</span> <span class="nb">rewrite</span> (bigcup_splitn <span class="mi">2</span>) // -bigcup_mkord setUidl// =&gt; t -[].
<span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span>!big_ord_recl big_ord0 setU0 /= -setIUr setUCr setIT.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">caratheodory_measurable</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : <span class="kt">Type</span>)
  (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) (<span class="nv">A</span> : <span class="nb">set</span> T) := <span class="kr">forall</span> <span class="nv">X</span>,
  mu X = mu (X `&amp;` A) + mu (X `&amp;` ~` A).

<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;mu .-caratheodory&quot;</span> :=
   (caratheodory_measurable mu) : classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">le_caratheodory_measurable</span> (<span class="nv">R</span> : realType) <span class="nv">T</span>
  (<span class="nv">mu</span> : {outer_measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">A</span> : <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">X</span>, mu (X `&amp;` A) + mu (X `&amp;` ~` A) &lt;= mu X) -&gt;
  mu.-caratheodory A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; suf X; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>;
  [<span class="bp">exact</span>: le_outer_measureIC | <span class="bp">exact</span>: suf].
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">caratheodory_theorem_sigma_algebra</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">mu</span> : {outer_measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">outer_measure_bigcup_lim</span> (<span class="nv">A</span> : (<span class="nb">set</span> T) ^nat) <span class="nv">X</span> :
  mu (X `&amp;` \bigcup_k A k) &lt;= \sum_(k &lt;oo) mu (X `&amp;` A k).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (le_trans _ (outer_measure_sigma_subadditive mu (<span class="kr">fun</span> <span class="nv">n</span> =&gt; X `&amp;` A n))).
<span class="bp">by</span> <span class="nb">apply</span>/le_outer_measure; <span class="nb">rewrite</span> setI_bigcupr.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">M</span> := mu.-caratheodory.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_set0</span> : M set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; X /=; <span class="nb">rewrite</span> setI0 outer_measure0 add0e setC0 setIT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_setC</span> <span class="nv">A</span> : M A -&gt; M (~` A).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; MA X; <span class="nb">rewrite</span> setCK addeC -MA. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_setU_le</span> (<span class="nv">X</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
  mu.-caratheodory A -&gt; mu.-caratheodory B -&gt;
  mu (X `&amp;` (A `|` B)) + mu (X `&amp;` ~` (A `|` B)) &lt;= mu X.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB; <span class="nb">pose</span> Y := X `&amp;` A `|` X `&amp;` B `&amp;` ~` A.
<span class="nb">have</span> /(lee_add2r (mu (X `&amp;` ~` (A `|` B)))) :
    mu Y &lt;= mu (X `&amp;` A) + mu (X `&amp;` B `&amp;` ~` A).
  <span class="nb">pose</span> Z := bigcup2 (X `&amp;` A) (X `&amp;` B `&amp;` ~` A).
  <span class="nb">have</span> -&gt; : Y = \bigcup_k Z k.
    <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [[?|?]|[]]; [<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">O</span>|<span class="bp">by</span> <span class="kr">exists</span> <span class="mi">1</span>%N|].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; [_ ?|[_ ?|//]]; [<span class="nb">left</span>|<span class="nb">right</span>].
  <span class="nb">rewrite</span> (le_trans (outer_measure_sigma_subadditive mu Z)) //.
  <span class="nb">suff</span> : ((<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(i &lt; n) mu (Z i)) --&gt;
      mu (X `&amp;` A) + mu (X `&amp;` B `&amp;` ~` A)).
    <span class="nb">move</span>/cvg_lim =&gt; /=; <span class="nb">under</span> [<span class="kr">in</span> leLHS]eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> big_mkord.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;.
  <span class="nb">rewrite</span> -(cvg_shiftn <span class="mi">2</span>) /=; <span class="nb">set</span> l := (X <span class="kr">in</span> _ --&gt; X).
  <span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ = cst l); <span class="kp">first</span> <span class="bp">exact</span>: cvg_cst.
  <span class="nb">rewrite</span> funeqE =&gt; i; <span class="nb">rewrite</span> addn2 <span class="mi">2</span>!big_ord_recl big1 <span class="nl">?adde0</span> //.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? _; <span class="bp">exact</span>: outer_measure0.
<span class="nb">have</span> /le_trans : mu (X `&amp;` (A `|` B)) + mu (X `&amp;` ~` (A `|` B)) &lt;=
    mu Y + mu (X `&amp;` ~` (A `|` B)).
  <span class="nb">rewrite</span> setIUr (_ : X `&amp;` A `|` X `&amp;` B = Y) //.
  <span class="nb">rewrite</span> /Y -[<span class="kr">in</span> LHS](setIT B) -(setUCr A) <span class="mi">2</span>!setIUr setUC -[<span class="kr">in</span> RHS]setIA.
  <span class="nb">rewrite</span> setUC setUA; <span class="nb">congr</span> (_ `|` _).
  <span class="bp">by</span> <span class="nb">rewrite</span> setUidPl setICA; <span class="nb">apply</span>: subIset; <span class="nb">right</span>.
<span class="nb">suff</span> -&gt; : mu (X `&amp;` A) + mu (X `&amp;` B `&amp;` ~` A) +
    mu (X `&amp;` (~` (A `|` B))) = mu X <span class="bp">by</span> <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> setCU setIA -(setIA X) setICA (setIC B) -addeA -mB -mA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_setU</span> <span class="nv">A</span> <span class="nv">B</span> : M A -&gt; M B -&gt; M (A `|` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB X; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le.
<span class="bp">by</span> <span class="nb">rewrite</span> le_outer_measureIC andTb caratheodory_measurable_setU_le.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_bigsetU</span> (<span class="nv">A</span> : (<span class="nb">set</span> T) ^nat) : (<span class="kr">forall</span> <span class="nv">n</span>, M (A n)) -&gt;
  <span class="kr">forall</span> <span class="nv">n</span>, M (\big[setU/set0]_(i &lt; n) A i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; MA; <span class="nb">elim</span>=&gt; [|n ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> big_ord0; <span class="bp">exact</span>: caratheodory_measurable_set0.
<span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr; <span class="nb">apply</span>: caratheodory_measurable_setU.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_setI</span> <span class="nv">A</span> <span class="nv">B</span> : M A -&gt; M B -&gt; M (A `&amp;` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB; <span class="nb">rewrite</span> -(setCK A) -(setCK B) -setCU.
<span class="bp">by</span> <span class="nb">apply</span>/caratheodory_measurable_setC/caratheodory_measurable_setU;
  <span class="bp">exact</span>/caratheodory_measurable_setC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_setD</span> <span class="nv">A</span> <span class="nv">B</span> : M A -&gt; M B -&gt; M (A `\` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB; <span class="nb">rewrite</span> setDE; <span class="nb">apply</span>: caratheodory_measurable_setI =&gt; //.
<span class="bp">exact</span>: caratheodory_measurable_setC.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">additive_ext_lemmas</span>.
<span class="kn">Variable</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T.
<span class="kn">Hypothesis</span> (<span class="nv">mA</span> : M A) (<span class="nv">mB</span> : M B).

<span class="kn">Let</span> <span class="nf">caratheodory_decomp</span> <span class="nv">X</span> :
  mu X = mu (X `&amp;` A `&amp;` B) + mu (X `&amp;` A `&amp;` ~` B) +
         mu (X `&amp;` ~` A `&amp;` B) + mu (X `&amp;` ~` A `&amp;` ~` B).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> mA mB [X <span class="kr">in</span> _ + _ + X = _]mB addeA. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">caratheorody_decompIU</span> <span class="nv">X</span> : mu (X `&amp;` (A `|` B)) =
  mu (X `&amp;` A `&amp;` B) + mu (X `&amp;` ~` A `&amp;` B) + mu (X `&amp;` A `&amp;` ~` B).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> caratheodory_decomp -!addeA; <span class="nb">congr</span> (mu _ + _).
  <span class="nb">rewrite</span> -!setIA; <span class="nb">congr</span> (_ `&amp;` _).
  <span class="bp">by</span> <span class="nb">rewrite</span> setIC; <span class="nb">apply</span>/setIidPl; <span class="nb">apply</span>: subIset; <span class="nb">left</span>; <span class="nb">left</span>.
<span class="nb">rewrite</span> addeA addeC [X <span class="kr">in</span> mu X + _](_ : _ = set0); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -setIA -setCU -setIA setICr setI0.
<span class="nb">rewrite</span> outer_measure0 add0e addeC -!setIA; <span class="nb">congr</span> (mu (X `&amp;` _) + mu (X `&amp;` _)).
<span class="bp">by</span> <span class="nb">rewrite</span> setIC; <span class="nb">apply</span>/setIidPl; <span class="nb">apply</span>: subIset; <span class="nb">right</span>; <span class="nb">right</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> setIC; <span class="nb">apply</span>/setIidPl; <span class="nb">apply</span>: subIset; <span class="nb">left</span>; <span class="nb">left</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">disjoint_caratheodoryIU</span> <span class="nv">X</span> : [disjoint A &amp; B] -&gt;
  mu (X `&amp;` (A `|` B)) = mu (X `&amp;` A) + mu (X `&amp;` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /eqP AB; <span class="nb">rewrite</span> caratheodory_decomp -setIA AB setI0 outer_measure0.
<span class="nb">rewrite</span> add0e addeC -setIA -setCU -setIA setICr setI0 outer_measure0 add0e.
<span class="nb">rewrite</span> -!setIA; <span class="nb">congr</span> (mu (X `&amp;` _ ) + mu (X `&amp;` _)).
<span class="nb">rewrite</span> (setIC A) setIA setIC; <span class="nb">apply</span>/setIidPl.
- <span class="bp">by</span> <span class="nb">rewrite</span> setIUl setICr setU0 subsetI; <span class="nb">move</span>/disjoints_subset <span class="kr">in</span> AB; <span class="nb">split</span>.
- <span class="nb">rewrite</span> setIA setIC; <span class="nb">apply</span>/setIidPl; <span class="nb">rewrite</span> setIUl setICr set0U.
  <span class="bp">by</span> <span class="nb">move</span>: AB; <span class="nb">rewrite</span> setIC =&gt; /disjoints_subset =&gt; AB; <span class="nb">rewrite</span> subsetI; <span class="nb">split</span>.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">additive_ext_lemmas</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_additive</span> (<span class="nv">A</span> : (<span class="nb">set</span> T) ^nat) : (<span class="kr">forall</span> <span class="nv">n</span>, M (A n)) -&gt;
  trivIset setT A -&gt; <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">X</span>,
    mu (X `&amp;` \big[setU/set0]_(i &lt; n) A i) = \sum_(i &lt; n) mu (X `&amp;` A i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; MA ta; <span class="nb">elim</span>=&gt; [|n ih] X; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> !big_ord0 setI0 outer_measure0.
<span class="nb">rewrite</span> big_ord_recr /= disjoint_caratheodoryIU // <span class="nl">?ih</span> <span class="nl">?big_ord_recr</span> //.
- <span class="bp">exact</span>: caratheodory_measurable_bigsetU.
- <span class="bp">by</span> <span class="nb">apply</span>/eqP/(@trivIset_bigsetUI _ predT) =&gt; //; <span class="nb">rewrite</span> /predT /= trueE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_lime_le</span> (<span class="nv">A</span> : (<span class="nb">set</span> T) ^nat) : (<span class="kr">forall</span> <span class="nv">n</span>, M (A n)) -&gt;
  trivIset setT A -&gt; <span class="kr">forall</span> <span class="nv">X</span>,
  \sum_(k &lt;oo) mu (X `&amp;` A k) + mu (X `&amp;` ~` \bigcup_k A k) &lt;= mu X.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; MA tA X.
<span class="nb">set</span> A&#39; := \bigcup_k A k; <span class="nb">set</span> B := <span class="kr">fun</span> <span class="nv">n</span> =&gt; \big[setU/set0]_(k &lt; n) (A k).
<span class="nb">suff</span> : <span class="kr">forall</span> <span class="nv">n</span>, \sum_(k &lt; n) mu (X `&amp;` A k) + mu (X `&amp;` ~` A&#39;) &lt;= mu X.
  <span class="nb">move</span>=&gt; XA; <span class="nb">rewrite</span> (_ : lim _ = ereal_sup
      ((<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(k &lt; n) mu (X `&amp;` A k)) @` setT)); <span class="nb">last first</span>.
    <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> big_mkord.
    <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>/ereal_nondecreasing_cvg.
    <span class="nb">apply</span>: (lee_sum_nneg_ord (<span class="kr">fun</span> <span class="nv">n</span> =&gt; mu (X `&amp;` A n)) xpredT) =&gt; n _.
    <span class="bp">exact</span>: outer_measure_ge0.
  <span class="nb">move</span> XAx : (mu (X `&amp;` ~` A&#39;)) =&gt; [x| |].
  - <span class="nb">rewrite</span> -lee_subr_addr //; <span class="nb">apply</span>: ub_ereal_sup =&gt; /= _ [n _] &lt;-.
    <span class="bp">by</span> <span class="nb">rewrite</span> EFinN lee_subr_addr // -XAx XA.
  - <span class="nb">suff</span> : mu X = +oo <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">rewrite</span> leey.
    <span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> -leye_eq -XAx le_outer_measure.
  - <span class="bp">by</span> <span class="nb">rewrite</span> addeC /= leNye.
<span class="nb">move</span>=&gt; n.
<span class="nb">apply</span>: (@le_trans _ _ (\sum_(k &lt; n) mu (X `&amp;` A k) + mu (X `&amp;` ~` B n))).
  <span class="nb">apply</span>/lee_add2l/le_outer_measure; <span class="nb">apply</span>: setIS; <span class="nb">apply</span>: subsetC =&gt; t.
  <span class="bp">by</span> <span class="nb">rewrite</span> /B -bigcup_mkord =&gt; -[i ? ?]; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="nb">rewrite</span> [<span class="kr">in</span> leRHS](caratheodory_measurable_bigsetU MA n) lee_add2r //.
<span class="bp">by</span> <span class="nb">rewrite</span> caratheodory_additive.
<span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
      note=<span class="s2">&quot;renamed `caratheodory_lime_le`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">caratheodory_lim_lee</span> := caratheodory_lime_le.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_trivIset_bigcup</span> (<span class="nv">A</span> : (<span class="nb">set</span> T) ^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, M (A n)) -&gt; trivIset setT A -&gt; M (\bigcup_k (A k)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; MA tA; <span class="nb">apply</span>: le_caratheodory_measurable =&gt; X /=.
<span class="nb">have</span> /(lee_add2r (mu (X `&amp;` ~` \bigcup_k A k))) := outer_measure_bigcup_lim A X.
<span class="bp">by</span> <span class="nb">move</span>/le_trans; <span class="nb">apply</span>; <span class="bp">exact</span>: caratheodory_lime_le.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_bigcup</span> (<span class="nv">A</span> : (<span class="nb">set</span> T) ^nat) : (<span class="kr">forall</span> <span class="nv">n</span>, M (A n)) -&gt;
  M (\bigcup_k (A k)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; MA; <span class="nb">rewrite</span> -eq_bigcup_seqD_bigsetU.
<span class="nb">apply</span>/caratheodory_measurable_trivIset_bigcup; <span class="nb">last first</span>.
  <span class="nb">apply</span>: (@trivIset_seqD _ (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \big[setU/set0]_(i &lt; n.+<span class="mi">1</span>) A i)).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; n m nm; <span class="bp">exact</span>/subsetPset/subset_bigsetU.
<span class="bp">by</span> <span class="nb">case</span>=&gt; [|n /=]; [| <span class="nb">apply</span>/caratheodory_measurable_setD =&gt; //];
  <span class="bp">exact</span>/caratheodory_measurable_bigsetU.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">caratheodory_theorem_sigma_algebra</span>.

<span class="kn">Definition</span> <span class="nf">caratheodory_type</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : <span class="kt">Type</span>)
  (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) := T.

<span class="kn">Definition</span> <span class="nf">caratheodory_display</span> <span class="nv">R</span> <span class="nv">T</span> : (<span class="nb">set</span> T -&gt; \bar R) -&gt; measure_display.
<span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">caratheodory_sigma_algebra</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : pointedType) (<span class="nv">mu</span> : {outer_measure <span class="nb">set</span> T -&gt; \bar R}).

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := @isMeasurable.Build (caratheodory_display mu)
  (caratheodory_type mu) (Pointed.class T) mu.-caratheodory
    (caratheodory_measurable_set0 mu)
    (@caratheodory_measurable_setC _ _ mu)
    (@caratheodory_measurable_bigcup _ _ mu).

<span class="kn">End</span> <span class="nf">caratheodory_sigma_algebra</span>.

<span class="kn">Notation</span> <span class="s2">&quot;mu .-cara&quot;</span> := (caratheodory_display mu) : measure_display_scope.
<span class="kn">Notation</span> <span class="s2">&quot;mu .-cara.-measurable&quot;</span> :=
  (measurable : <span class="nb">set</span> (<span class="nb">set</span> (caratheodory_type mu))) : classical_set_scope.

<span class="kn">Definition</span> <span class="nf">measure_is_complete</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : measurableType d)
    (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) :=
  <span class="kr">forall</span> <span class="nv">X</span>, mu.-negligible X -&gt; measurable X.

<span class="kn">Section</span> <span class="nf">caratheodory_measure</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : pointedType).
<span class="kn">Variable</span> (<span class="nv">mu</span> : {outer_measure <span class="nb">set</span> T -&gt; \bar R}).
<span class="kn">Let</span> <span class="nf">U</span> := caratheodory_type mu.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measure0</span> : mu (set0 : <span class="nb">set</span> U) = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">exact</span>: outer_measure0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measure_ge0</span> (<span class="nv">A</span> : <span class="nb">set</span> U) : <span class="mi">0</span> &lt;= mu A.
<span class="kn">Proof</span>. <span class="bp">exact</span>: outer_measure_ge0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measure_sigma_additive</span> :
  semi_sigma_additive (mu : <span class="nb">set</span> U -&gt; _).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A mA tA mbigcupA; <span class="nb">set</span> B := \bigcup_k A k.
<span class="nb">suff</span> : <span class="kr">forall</span> <span class="nv">X</span>, mu X = \sum_(k &lt;oo) mu (X `&amp;` A k) + mu (X `&amp;` ~` B).
  <span class="nb">move</span>/(_ B); <span class="nb">rewrite</span> setICr outer_measure0 adde0.
  <span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; _) = <span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(k &lt; n) mu (A k)); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> big_mkord; <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">congr</span> (mu _).
    <span class="bp">by</span> <span class="nb">rewrite</span> setIC; <span class="nb">apply</span>/setIidPl =&gt; t Ait; <span class="kr">exists</span> <span class="nv">i</span>.
  <span class="nb">move</span>=&gt; -&gt;; <span class="nb">have</span> := <span class="kr">fun</span> <span class="nv">n</span> (<span class="nv">_</span> : xpredT n) =&gt; outer_measure_ge0 mu (A n).
  <span class="nb">move</span>/is_cvg_nneseries =&gt; /cvg_ex[l] hl.
  <span class="nb">under</span> [<span class="kr">in</span> X <span class="kr">in</span> _ --&gt; X]eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -(big_mkord xpredT (mu \o A)).
  <span class="bp">by</span> <span class="nb">move</span>/(@cvg_lim _ (@ereal_hausdorff R)) : (hl) =&gt; -&gt;.
<span class="nb">move</span>=&gt; X.
<span class="nb">have</span> mB : mu.-cara.-measurable B := caratheodory_measurable_bigcup mA.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le (caratheodory_lime_le mA tA X) andbT.
<span class="nb">have</span> /(lee_add2r (mu (X `&amp;` ~` B))) := outer_measure_bigcup_lim mu A X.
<span class="bp">by</span> <span class="nb">rewrite</span> -le_caratheodory_measurable // =&gt; ?; <span class="nb">rewrite</span> -mB.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ (mu : <span class="nb">set</span> (caratheodory_type mu) -&gt; _)
  caratheodory_measure0 caratheodory_measure_ge0
  caratheodory_measure_sigma_additive.

<span class="kn">Lemma</span> <span class="nf">measure_is_complete_caratheodory</span> :
  measure_is_complete (mu : <span class="nb">set</span> (caratheodory_type mu) -&gt; _).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; B [A [mA muA0 BA]]; <span class="nb">apply</span>: le_caratheodory_measurable =&gt; X.
<span class="nb">suff</span> -&gt; : mu (X `&amp;` B) = <span class="mi">0</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> add0e le_outer_measure //; <span class="nb">apply</span>: subIset; <span class="nb">left</span>.
<span class="nb">have</span> muB0 : mu B = <span class="mi">0</span>.
  <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le outer_measure_ge0 andbT.
  <span class="bp">by</span> <span class="nb">apply</span>: (le_trans (le_outer_measure mu _ _ BA)); <span class="nb">rewrite</span> -muA0.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le outer_measure_ge0 andbT.
<span class="nb">have</span> : X `&amp;` B `&lt;=` B <span class="bp">by</span> <span class="nb">apply</span>: subIset; <span class="nb">right</span>.
<span class="bp">by</span> <span class="nb">move</span>/(le_outer_measure mu); <span class="nb">rewrite</span> muB0 =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">caratheodory_measure</span>.

<span class="kn">Lemma</span> <span class="nf">epsilon_trick</span> (<span class="nv">R</span> : realType) (<span class="nv">A</span> : (\bar R)^nat) <span class="nv">e</span>
    (<span class="nv">P</span> : pred nat) : (<span class="kr">forall</span> <span class="nv">n</span>, <span class="mi">0</span> &lt;= A n) -&gt; (<span class="mi">0</span> &lt;= e)%R -&gt;
  \sum_(i &lt;oo | P i) (A i + (e / (<span class="mi">2</span> ^ i.+<span class="mi">1</span>)%:R)%:E) &lt;=
  \sum_(i &lt;oo | P i) A i + e%:E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A0 /nonnegP[{}e].
<span class="nb">rewrite</span> (@le_trans _ _ (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (\sum_(<span class="mi">0</span> &lt;= i &lt; n | P i) A i) +
    \sum_(<span class="mi">0</span> &lt;= i &lt; n) (e%:num / (<span class="mi">2</span> ^ i.+<span class="mi">1</span>)%:R)%:E))) //.
  <span class="nb">rewrite</span> nneseriesD // limeD //.
  - <span class="nb">rewrite</span> lee_add2l //; <span class="nb">apply</span>: lee_lim =&gt; //.
    + <span class="bp">exact</span>: is_cvg_nneseries.
    + <span class="bp">exact</span>: is_cvg_nneseries.
    + <span class="bp">by</span> near=&gt; n; <span class="bp">exact</span>: lee_sum_nneg_subset.
  - <span class="bp">exact</span>: is_cvg_nneseries.
  - <span class="bp">exact</span>: is_cvg_nneseries.
  - <span class="bp">exact</span>: adde_def_nneseries.
<span class="nb">suff</span> cvggeo : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n) (e%:num / (<span class="mi">2</span> ^ i.+<span class="mi">1</span>)%:R)%:E) --&gt;
    e%:num%:E.
  <span class="nb">rewrite</span> limeD //.
  - <span class="bp">by</span> <span class="nb">rewrite</span> lee_add2l // (cvg_lim _ cvggeo).
  - <span class="bp">exact</span>: is_cvg_nneseries.
  - <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_nneseries =&gt; ?; <span class="nb">rewrite</span> lee_fin divr_ge0.
  - <span class="bp">by</span> <span class="nb">rewrite</span> (cvg_lim _ cvggeo) //= fin_num_adde_defl.
<span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; _) = EFin \o
    (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n) (e%:num / (<span class="mi">2</span> ^ (i + <span class="mi">1</span>))%:R))%R); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> funeqE =&gt; n /=; <span class="nb">rewrite</span> (@big_morph _ _ EFin <span class="mi">0</span> adde)//.
  <span class="bp">by</span> <span class="nb">under</span> [<span class="kr">in</span> RHS]eq_bigr <span class="kp">do</span> <span class="nb">rewrite</span> addn1.
<span class="nb">apply</span>: cvg_comp; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span> cvg_refl.
<span class="nb">have</span> := cvg_geometric_series_half e%:num O.
<span class="bp">by</span> <span class="nb">rewrite</span> expr0 divr1; <span class="nb">apply</span>: cvg_trans.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">measurable_cover</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : semiRingOfSetsType d).
<span class="kn">Implicit Types</span> (<span class="nv">X</span> : <span class="nb">set</span> T) (<span class="nv">F</span> : (<span class="nb">set</span> T)^nat).

<span class="kn">Definition</span> <span class="nf">measurable_cover</span> <span class="nv">X</span> := [<span class="nb">set</span> F : (<span class="nb">set</span> T)^nat |
  (<span class="kr">forall</span> <span class="nv">i</span>, measurable (F i)) /\ X `&lt;=` \bigcup_k (F k)].

<span class="kn">Lemma</span> <span class="nf">cover_measurable</span> <span class="nv">X</span> <span class="nv">F</span> : measurable_cover X F -&gt; <span class="kr">forall</span> <span class="nv">k</span>, measurable (F k).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; + k; <span class="nb">rewrite</span> /measurable_cover =&gt; -[] /(_ k). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cover_subset</span> <span class="nv">X</span> <span class="nv">F</span> : measurable_cover X F -&gt; X `&lt;=` \bigcup_k (F k).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measurable_cover</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_uncurry</span> (<span class="nv">T1</span> <span class="nv">T2</span> : <span class="kt">Type</span>) <span class="nv">d</span> (<span class="nv">T</span> : semiRingOfSetsType d)
    (<span class="nv">G</span> : T1 -&gt; T2 -&gt; <span class="nb">set</span> T) (<span class="nv">x</span> : T1 * T2) :
  measurable (G x.<span class="mi">1</span> x.<span class="mi">2</span>) &lt;-&gt; measurable (uncurry G x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: x. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">measure_extension</span>.
<span class="kn">Context</span> (<span class="nv">R</span> : realType) <span class="nv">d</span> (<span class="nv">T</span> : semiRingOfSetsType d).
<span class="kn">Variable</span> <span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R.
<span class="kn">Hypothesis</span> <span class="nv">measure0</span> : mu set0 = <span class="mi">0</span>.
<span class="kn">Hypothesis</span> <span class="nv">measure_ge0</span> : <span class="kr">forall</span> <span class="nv">X</span>, mu X &gt;= <span class="mi">0</span>.
<span class="kn">Hint Resolve</span> measure_ge0 measure0 : core.

<span class="kn">Definition</span> <span class="nf">mu_ext</span> (<span class="nv">X</span> : <span class="nb">set</span> T) : \bar R :=
  ereal_inf [<span class="nb">set</span> \sum_(i &lt;oo) mu (A i) | A <span class="kr">in</span> measurable_cover X].
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;mu^*&quot;</span> := mu_ext.

<span class="kn">Lemma</span> <span class="nf">le_mu_ext</span> : {homo mu^* : A B / A `&lt;=` B &gt;-&gt; A &lt;= B}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A B AB; <span class="nb">apply</span>/le_ereal_inf =&gt; x [B&#39; [mB&#39; BB&#39;]].
<span class="bp">by</span> <span class="nb">move</span>=&gt; &lt;-{x}; <span class="kr">exists</span> <span class="nv">B&#39;</span> =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: subset_trans AB BB&#39;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mu_ext_ge0</span> <span class="nv">A</span> : <span class="mi">0</span> &lt;= mu^* A.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: lb_ereal_inf =&gt; x [B [mB AB] &lt;-{x}]; <span class="nb">rewrite</span> lime_ge //=.
  <span class="bp">exact</span>: is_cvg_nneseries.
<span class="bp">by</span> near=&gt; n; <span class="nb">rewrite</span> sume_ge0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mu_ext0</span> : mu^* set0 = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>/mu_ext_ge0.
<span class="nb">rewrite</span> /mu_ext; <span class="nb">apply</span>: ereal_inf_lb; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">_</span> =&gt; set0); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">split</span>.
<span class="bp">by</span> <span class="nb">apply</span>: (@lim_near_cst _ _ _ _ _ <span class="mi">0</span>) =&gt; //; near=&gt; n =&gt; /=; <span class="nb">rewrite</span> big1.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mu_ext_sigma_subadditive</span> : sigma_subadditive mu^*.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A; <span class="nb">have</span> [[i ioo]|] := pselect (<span class="kr">exists</span> <span class="nv">i</span>, mu^* (A i) = +oo).
  <span class="nb">rewrite</span> (eseries_pinfty _ _ ioo)// <span class="nl">?leey</span>// =&gt; n _.
  <span class="bp">by</span> <span class="nb">rewrite</span> gt_eqF// (lt_le_trans _ (mu_ext_ge0 _)).
<span class="nb">rewrite</span> -forallNE =&gt; Aoo.
<span class="nb">suff</span> add2e : <span class="kr">forall</span> <span class="nv">e</span> : {posnum R},
    mu^* (\bigcup_n A n) &lt;= \sum_(i &lt;oo) mu^* (A i) + e%:num%:E.
  <span class="bp">by</span> <span class="nb">apply</span>: lee_adde =&gt; e.
<span class="nb">move</span>=&gt; e; <span class="nb">rewrite</span> (le_trans _ (epsilon_trick _ _ _))//; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>: mu_ext_ge0.
<span class="nb">pose</span> P n (B : (<span class="nb">set</span> T)^nat) := measurable_cover (A n) B /\
  \sum_(k &lt;oo) mu (B k) &lt;= mu^* (A n) + (e%:num / (<span class="mi">2</span> ^ n.+<span class="mi">1</span>)%:R)%:E.
<span class="nb">have</span> [G PG] : {G : ((<span class="nb">set</span> T)^nat)^nat &amp; <span class="kr">forall</span> <span class="nv">n</span>, P n (G n)}.
  <span class="nb">apply</span>: (@choice _ _ P) =&gt; n; <span class="nb">rewrite</span> /P /mu_ext.
  <span class="nb">set</span> S := (X <span class="kr">in</span> ereal_inf X); <span class="nb">move</span> infS : (ereal_inf S) =&gt; iS.
  <span class="nb">case</span>: iS infS =&gt; [r Sr|Soo|Soo].
  - <span class="nb">have</span> en1 : (<span class="mi">0</span> &lt; e%:num / (<span class="mi">2</span> ^ n.+<span class="mi">1</span>)%:R)%R.
      <span class="bp">by</span> <span class="nb">rewrite</span> divr_gt0 // ltr0n expn_gt0.
    <span class="nb">have</span> /(lb_ereal_inf_adherent en1) : ereal_inf S \<span class="kr">is</span> a fin_num <span class="bp">by</span> <span class="nb">rewrite</span> Sr.
    <span class="nb">move</span>=&gt; [x [B [mB AnB muBx] xS]].
    <span class="kr">exists</span> <span class="nv">B</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> muBx -Sr; <span class="nb">apply</span>/ltW.
    <span class="bp">by</span> <span class="nb">rewrite</span> (lt_le_trans xS) // lee_add2l //= lee_fin ler_pmul.
  - <span class="bp">by</span> <span class="nb">have</span> := Aoo n; <span class="nb">rewrite</span> /mu^* Soo.
  - <span class="nb">suff</span> : lbound S <span class="mi">0</span> <span class="bp">by</span> <span class="nb">move</span>/lb_ereal_inf; <span class="nb">rewrite</span> Soo.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; /= _ [B [mB AnB] &lt;-]; <span class="bp">exact</span>: nneseries_ge0.
<span class="nb">have</span> muG_ge0 x : <span class="mi">0</span> &lt;= (mu \o uncurry G) x <span class="bp">by</span> <span class="bp">exact</span>/measure_ge0.
<span class="nb">apply</span>: (@le_trans _ _ (\esum_(i <span class="kr">in</span> setT) (mu \o uncurry G) i)).
  <span class="nb">rewrite</span> /mu_ext; <span class="nb">apply</span>: ereal_inf_lb =&gt; /=.
  <span class="nb">have</span> /card_esym/ppcard_eqP[f] := card_nat2.
  <span class="kr">exists</span> (<span class="nv">uncurry</span> <span class="nv">G</span> \o f).
    <span class="nb">split</span> =&gt; [i|]; <span class="kp">first</span> <span class="bp">exact</span>/measurable_uncurry/(PG (f i).<span class="mi">1</span>).<span class="mi">1</span>.<span class="mi">1</span>.
    <span class="nb">apply</span>: (@subset_trans _  (\bigcup_n \bigcup_k G n k)) =&gt; [t [i _]|].
      <span class="bp">by</span> <span class="nb">move</span>=&gt; /(cover_subset (PG i).<span class="mi">1</span>) -[j _ ?]; <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="kr">exists</span> <span class="nv">j</span>.
    <span class="nb">move</span>=&gt; t [i _ [j _ Bijt]]; <span class="kr">exists</span> (<span class="nv">f</span>^-<span class="mi">1</span>%FUN (i, j)) =&gt; //=.
    <span class="bp">by</span> <span class="nb">rewrite</span> invK <span class="nl">?inE</span>.
  <span class="nb">rewrite</span> -(esum_pred_image (mu \o uncurry G) _ xpredT) ?[<span class="kr">fun</span>=&gt; _]set_true//.
  <span class="nb">congr</span> esum.
  <span class="bp">by</span> <span class="nb">rewrite</span> -[RHS](image_eq f)predeqE=&gt; -[a b]/=; <span class="nb">split</span>=&gt; -[n _ &lt;-]; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="nb">rewrite</span> (_ : esum _ _ = \sum_(i &lt;oo) \sum_(j &lt;oo ) mu (G i j)); <span class="nb">last first</span>.
  <span class="nb">pose</span> J : nat -&gt; <span class="nb">set</span> (nat * nat) := <span class="kr">fun</span> <span class="nv">i</span> =&gt; [<span class="nb">set</span> (i, j) | j <span class="kr">in</span> setT].
  <span class="nb">rewrite</span> (_ : setT = \bigcup_k J k); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; -[a b]; <span class="nb">split</span> =&gt; // _; <span class="kr">exists</span> <span class="nv">a</span> =&gt; //; <span class="kr">exists</span> <span class="nv">b</span>.
  <span class="nb">rewrite</span> esum_bigcupT /=; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    - <span class="nb">apply</span>/trivIsetP =&gt; i j _ _ ij.
      <span class="nb">rewrite</span> predeqE =&gt; -[n m] /=; <span class="nb">split</span> =&gt; //= -[] [_] _ [&lt;-{n} _].
      <span class="bp">by</span> <span class="nb">move</span>=&gt; [m&#39; _] [] /esym/eqP; <span class="nb">rewrite</span> (negbTE ij).
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; /= [n m]; <span class="nb">apply</span>/measure_ge0; <span class="bp">exact</span>: (cover_measurable (PG n).<span class="mi">1</span>).
  <span class="nb">rewrite</span> (_ : setT = id @` xpredT); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> image_id funeqE =&gt; x; <span class="nb">rewrite</span> trueE.
  <span class="nb">rewrite</span> esum_pred_image //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>: esum_ge0.
  <span class="nb">apply</span>: eq_eseries =&gt; /= j _.
  <span class="nb">rewrite</span> -(esum_pred_image (mu \o uncurry G) (pair j) predT)//=; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? _ _; <span class="bp">exact</span>: (@can_inj _ _ _ snd).
  <span class="bp">by</span> <span class="nb">congr</span> esum; <span class="nb">rewrite</span> predeqE =&gt; -[a b]; <span class="nb">split</span>; <span class="nb">move</span>=&gt; [i _ &lt;-]; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="nb">apply</span>: lee_lim.
- <span class="nb">apply</span>: is_cvg_nneseries =&gt; n _.
  <span class="bp">by</span> <span class="nb">apply</span>: nneseries_ge0 =&gt; m _; <span class="bp">exact</span>: (muG_ge0 (n, m)).
- <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_nneseries =&gt; n _; <span class="nb">apply</span>: adde_ge0 =&gt; //; <span class="bp">exact</span>: mu_ext_ge0.
- <span class="bp">by</span> near=&gt; n; <span class="nb">apply</span>: lee_sum =&gt; i _; <span class="bp">exact</span>: (PG i).<span class="mi">2</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measure_extension</span>.
<span class="kn">Declare Scope</span> measure_scope.
<span class="kn">Delimit Scope</span> measure_scope <span class="kr">with</span> mu.
<span class="kn">Notation</span> <span class="s2">&quot;mu ^*&quot;</span> := (mu_ext mu) : measure_scope.
<span class="kn">Local</span> <span class="kn">Open Scope</span> measure_scope.

<span class="kn">Section</span> <span class="nf">measure_extension</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : semiRingOfSetsType d).
<span class="kn">Variable</span> <span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isOuterMeasure.Build
  R T _ (@mu_ext0 _ _ _ _ (measure0 mu) (measure_ge0 mu))
      (mu_ext_ge0 (measure_ge0 mu))
      (le_mu_ext mu)
      (mu_ext_sigma_subadditive (measure_ge0 mu)).

<span class="kn">End</span> <span class="nf">measure_extension</span>.

<span class="kn">Section</span> <span class="nf">g_salgebra_measure_unique_trace</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : measurableType d).
<span class="kn">Variables</span> (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Let</span> <span class="nf">H</span> := [<span class="nb">set</span> X | G X /\ X `&lt;=` D] <span class="c">(* &quot;trace&quot; of G wrt D *)</span>.
<span class="kn">Hypotheses</span> (<span class="nv">Hm</span> : H `&lt;=` measurable) (<span class="nv">setIH</span> : setI_closed H) (<span class="nv">HD</span> : H D).
<span class="kn">Variables</span> <span class="nv">m1</span> <span class="nv">m2</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Hypotheses</span> (<span class="nv">m1m2</span> : <span class="kr">forall</span> <span class="nv">A</span>, H A -&gt; m1 A = m2 A) (<span class="nv">m1oo</span> : (m1 D &lt; +oo)%E).

<span class="kn">Lemma</span> <span class="nf">g_salgebra_measure_unique_trace</span> :
  (<span class="kr">forall</span> <span class="nv">X</span>, (&lt;&lt;s D, H &gt;&gt;) X -&gt; X `&lt;=` D) -&gt; <span class="kr">forall</span> <span class="nv">X</span>, &lt;&lt;s D, H &gt;&gt; X -&gt;
  m1 X = m2 X.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; sDHD; <span class="nb">set</span> E := [<span class="nb">set</span> A | [/\ measurable A, m1 A = m2 A &amp; A `&lt;=` D] ].
<span class="nb">have</span> HE : H `&lt;=` E.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; X HX; <span class="nb">rewrite</span> /E /=; <span class="nb">split</span>; [<span class="bp">exact</span>: Hm|<span class="bp">exact</span>: m1m2|<span class="nb">case</span>: HX].
<span class="nb">have</span> setDE : setD_closed E.
  <span class="nb">move</span>=&gt; A B BA [mA m1m2A AD] [mB m1m2B BD]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurableD.
  - <span class="nb">rewrite</span> measureD//; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> (le_lt_trans _ m1oo)//; <span class="nb">apply</span>: le_measure =&gt; // /[!inE].
    <span class="nb">rewrite</span> setIidr// m1m2A m1m2B measureD// <span class="nl">?setIidr</span>//.
    <span class="bp">by</span> <span class="nb">rewrite</span> (le_lt_trans _ m1oo)// -m1m2A; <span class="nb">apply</span>: le_measure =&gt; // /[!inE].
  - <span class="bp">by</span> <span class="nb">rewrite</span> setDE; <span class="nb">apply</span>: subIset; <span class="nb">left</span>.
<span class="nb">have</span> ndE : ndseq_closed E.
  <span class="nb">move</span>=&gt; A ndA EA; <span class="nb">split</span>; <span class="nb">have</span> mA n : measurable (A n) <span class="bp">by</span> <span class="nb">have</span> [] := EA n.
  - <span class="bp">exact</span>: bigcupT_measurable.
  - <span class="nb">transitivity</span> (lim (m1 \o A)).
      <span class="nb">apply</span>/esym/cvg_lim=&gt;//.
      <span class="bp">exact</span>/(nondecreasing_cvg_mu mA _ ndA)/bigcupT_measurable.
    <span class="nb">transitivity</span> (lim (m2 \o A)).
      <span class="bp">by</span> <span class="nb">congr</span> (lim _); <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">have</span> [] := EA n.
    <span class="nb">apply</span>/cvg_lim =&gt; //.
    <span class="bp">exact</span>/(nondecreasing_cvg_mu mA _ ndA)/bigcupT_measurable.
  - <span class="bp">by</span> <span class="nb">apply</span>: bigcup_sub =&gt; n; <span class="nb">have</span> [] := EA n.
<span class="nb">have</span> sDHE : &lt;&lt;s D, H &gt;&gt; `&lt;=` E.
  <span class="bp">by</span> <span class="nb">apply</span>: monotone_class_subset =&gt; //; <span class="nb">split</span> =&gt; //; [<span class="nb">move</span>=&gt; A []|<span class="bp">exact</span>/HE].
<span class="bp">by</span> <span class="nb">move</span>=&gt; X /sDHE[mX ?] _.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">g_salgebra_measure_unique_trace</span>.

<span class="kn">Section</span> <span class="nf">g_salgebra_measure_unique</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : measurableType d).
<span class="kn">Variable</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T).
<span class="kn">Hypothesis</span> <span class="nv">Gm</span> : G `&lt;=` measurable.
<span class="kn">Variable</span> <span class="nv">g</span> : (<span class="nb">set</span> T)^nat.
<span class="kn">Hypotheses</span> <span class="nv">Gg</span> : <span class="kr">forall</span> <span class="nv">i</span>, G (g i).
<span class="kn">Hypothesis</span> <span class="nv">g_cover</span> : \bigcup_k (g k) = setT.
<span class="kn">Variables</span> <span class="nv">m1</span> <span class="nv">m2</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">g_salgebra_measure_unique_cover</span> :
  (<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">A</span>, &lt;&lt;s G &gt;&gt; A -&gt; m1 (g n `&amp;` A) = m2 (g n `&amp;` A)) -&gt;
  <span class="kr">forall</span> <span class="nv">A</span>, &lt;&lt;s G &gt;&gt; A -&gt; m1 A = m2 A.
<span class="kn">Proof</span>.
<span class="nb">pose</span> GT := [the ringOfSetsType _ of salgebraType G].
<span class="nb">move</span>=&gt; sGm1m2; <span class="nb">pose</span> g&#39; k := \bigcup_(i &lt; k) g i.
<span class="nb">have</span> sGm := smallest_sub (@sigma_algebra_measurable _ T) Gm.
<span class="nb">have</span> Gg&#39; i : &lt;&lt;s G &gt;&gt; (g&#39; i).
  <span class="nb">apply</span>: (@fin_bigcup_measurable _ GT) =&gt; //.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="nb">apply</span>: sub_sigma_algebra.
<span class="nb">have</span> sG&#39;m1m2 n A : &lt;&lt;s G &gt;&gt; A -&gt; m1 (g&#39; n `&amp;` A) = m2 (g&#39; n `&amp;` A).
  <span class="nb">move</span>=&gt; sGA; <span class="nb">rewrite</span> setI_bigcupl bigcup_mkord.
  <span class="nb">elim</span>: n =&gt; [|n IHn] <span class="kr">in</span> A sGA *; <span class="nb">rewrite</span> (big_ord0, big_ord_recr) <span class="nl">?measure0</span>//=.
  <span class="nb">have</span> sGgA i : &lt;&lt;s G &gt;&gt; (g i `&amp;` A).
    <span class="bp">by</span> <span class="nb">apply</span>: (@measurableI _ GT) =&gt; //; <span class="bp">exact</span>: sub_sigma_algebra.
  <span class="nb">apply</span>: eq_measureU; <span class="nb">rewrite</span> <span class="nl">?sGm1m2</span> <span class="nl">?IHn</span>//; <span class="nb">last first</span>.
  - <span class="bp">by</span> <span class="nb">rewrite</span> -big_distrl -setIA big_distrl/= IHn// setICA setIid.
  - <span class="bp">exact</span>/sGm.
  - <span class="bp">by</span> <span class="nb">apply</span>: bigsetU_measurable =&gt; i _; <span class="nb">apply</span>/sGm.
<span class="nb">have</span> g&#39;_cover : \bigcup_k (g&#39; k) = setT.
  <span class="bp">by</span> <span class="nb">rewrite</span> -subTset -g_cover =&gt; x [k _ gx]; <span class="kr">exists</span> <span class="nv">k</span>.+<span class="mi">1</span> =&gt; //; <span class="kr">exists</span> <span class="nv">k</span> =&gt; /=.
<span class="nb">have</span> nd_g&#39; : nondecreasing_seq g&#39;.
  <span class="nb">move</span>=&gt; m n lemn; <span class="nb">rewrite</span> subsetEset =&gt; x [k km gx]; <span class="kr">exists</span> <span class="nv">k</span> =&gt; //=.
  <span class="bp">exact</span>: leq_trans lemn.
<span class="nb">move</span>=&gt; A gA.
<span class="nb">have</span> -&gt; : A = \bigcup_n (g&#39; n `&amp;` A) <span class="bp">by</span> <span class="nb">rewrite</span> -setI_bigcupl g&#39;_cover setTI.
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; m1 (g&#39; n `&amp;` A))).
  <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="nb">apply</span>: nondecreasing_cvg_mu.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>: measurableI; <span class="bp">exact</span>/sGm.
  - <span class="bp">by</span> <span class="nb">apply</span>: bigcupT_measurable =&gt; k; <span class="nb">apply</span>: measurableI; <span class="bp">exact</span>/sGm.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; <span class="nb">apply</span>/subsetPset; <span class="nb">apply</span>: setSI; <span class="bp">exact</span>/subsetPset/nd_g&#39;.
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; m2 (g&#39; n `&amp;` A))).
  <span class="bp">by</span> <span class="nb">congr</span> (lim _); <span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">apply</span>: sG&#39;m1m2 =&gt; //; <span class="bp">exact</span>/sGm.
<span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>: nondecreasing_cvg_mu.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">apply</span>: measurableI =&gt; //; <span class="bp">exact</span>/sGm.
- <span class="bp">by</span> <span class="nb">apply</span>: bigcupT_measurable =&gt; k; <span class="nb">apply</span>: measurableI; <span class="bp">exact</span>/sGm.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; a b ab; <span class="nb">apply</span>/subsetPset; <span class="nb">apply</span>: setSI; <span class="bp">exact</span>/subsetPset/nd_g&#39;.
<span class="kn">Qed</span>.

<span class="kn">Hypothesis</span> <span class="nv">setIG</span> : setI_closed G.
<span class="kn">Hypothesis</span> <span class="nv">m1m2</span> : <span class="kr">forall</span> <span class="nv">A</span>, G A -&gt; m1 A = m2 A.
<span class="kn">Hypothesis</span> <span class="nv">m1goo</span> : <span class="kr">forall</span> <span class="nv">k</span>, (m1 (g k) &lt; +oo)%E.

<span class="kn">Lemma</span> <span class="nf">g_salgebra_measure_unique</span> : <span class="kr">forall</span> <span class="nv">E</span>, &lt;&lt;s G &gt;&gt; E -&gt; m1 E = m2 E.
<span class="kn">Proof</span>.
<span class="nb">pose</span> G_ n := [<span class="nb">set</span> X | G X /\ X `&lt;=` g n]. <span class="c">(* &quot;trace&quot; *)</span>
<span class="nb">have</span> G_E n : G_ n = [<span class="nb">set</span> g n `&amp;` C | C <span class="kr">in</span> G].
  <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; X [GX Xgn] /=; <span class="kr">exists</span> <span class="nv">X</span> =&gt; //; <span class="nb">rewrite</span> setIidr.
  <span class="bp">by</span> <span class="nb">rewrite</span> /G_ =&gt; X [Y GY &lt;-{X}]; <span class="nb">split</span>; [<span class="bp">exact</span>: setIG|<span class="nb">apply</span>: subIset; <span class="nb">left</span>].
<span class="nb">have</span> gIsGE n : [<span class="nb">set</span> g n `&amp;` A | A <span class="kr">in</span> &lt;&lt;s G &gt;&gt;] =
               &lt;&lt;s g n, preimage_class (g n) id G &gt;&gt;.
  <span class="nb">rewrite</span> sigma_algebra_preimage_classE eqEsubset; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; _ /= [Y sGY &lt;-]; <span class="kr">exists</span> <span class="nv">Y</span> =&gt; //; <span class="nb">rewrite</span> preimage_id setIC.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [Y mY &lt;-] /=; <span class="kr">exists</span> <span class="nv">Y</span> =&gt; //; <span class="nb">rewrite</span> preimage_id setIC.
<span class="nb">have</span> preimg_gGE n : preimage_class (g n) id G = G_ n.
  <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [_ [Y GY &lt;-]|].
    <span class="bp">by</span> <span class="nb">rewrite</span> preimage_id G_E /=; <span class="kr">exists</span> <span class="nv">Y</span> =&gt; //; <span class="nb">rewrite</span> setIC.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; X [GX Xgn]; <span class="kr">exists</span> <span class="nv">X</span> =&gt; //; <span class="nb">rewrite</span> preimage_id setIidr.
<span class="nb">apply</span>: g_salgebra_measure_unique_cover =&gt; //.
<span class="nb">move</span>=&gt; n A sGA; <span class="nb">apply</span>: (@g_salgebra_measure_unique_trace _ _ _ G (g n)) =&gt; //.
- <span class="bp">exact</span>: Gm.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [? _]; <span class="bp">exact</span>/Gm.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? [? ?] [? ?]; <span class="nb">split</span>; [<span class="bp">exact</span>: setIG|<span class="nb">apply</span>: subIset; <span class="bp">tauto</span>].
- <span class="bp">by</span> <span class="nb">split</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [? ?]; <span class="bp">exact</span>: m1m2.
- <span class="nb">move</span>=&gt; X; <span class="nb">rewrite</span> -/(G_ n) -preimg_gGE -gIsGE.
  <span class="bp">by</span> <span class="nb">case</span>=&gt; B sGB &lt;-{X}; <span class="nb">apply</span>: subIset; <span class="nb">left</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> -/(G_ n) -preimg_gGE -gIsGE; <span class="kr">exists</span> <span class="nv">A</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">g_salgebra_measure_unique</span>.

<span class="kn">Section</span> <span class="nf">measure_unique</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : measurableType d).
<span class="kn">Variables</span>  (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">g</span> : (<span class="nb">set</span> T)^nat).
<span class="kn">Hypotheses</span> (<span class="nv">mG</span> : measurable = &lt;&lt;s G &gt;&gt;) (<span class="nv">setIG</span> : setI_closed G).
<span class="kn">Hypothesis</span> <span class="nv">Gg</span> : <span class="kr">forall</span> <span class="nv">i</span>, G (g i).
<span class="kn">Hypothesis</span> <span class="nv">g_cover</span> : \bigcup_k (g k) = setT.
<span class="kn">Variables</span> <span class="nv">m1</span> <span class="nv">m2</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Hypothesis</span> <span class="nv">m1m2</span> : <span class="kr">forall</span> <span class="nv">A</span>, G A -&gt; m1 A = m2 A.
<span class="kn">Hypothesis</span> <span class="nv">m1goo</span> : <span class="kr">forall</span> <span class="nv">k</span>, (m1 (g k) &lt; +oo)%E.

<span class="kn">Lemma</span> <span class="nf">measure_unique</span> <span class="nv">A</span> : measurable A -&gt; m1 A = m2 A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA; <span class="nb">apply</span>: (@g_salgebra_measure_unique _ _ _ G); <span class="nb">rewrite</span> -<span class="nl">?mG</span>//.
<span class="bp">by</span> <span class="nb">rewrite</span> mG; <span class="bp">exact</span>: sub_sigma_algebra.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measure_unique</span>.
<span class="kn">Arguments</span> measure_unique {d R T} G g.

<span class="kn">Lemma</span> <span class="nf">measurable_mu_extE</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : semiRingOfSetsType d)
    (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}) <span class="nv">X</span> :
  sigma_sub_additive mu -&gt;
  measurable X -&gt; mu^* X = mu X.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; muS mX; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
  <span class="nb">apply</span>: ereal_inf_lb; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">n</span> =&gt; <span class="kr">if</span> n <span class="kr">is</span> <span class="mi">0</span>%N <span class="kr">then</span> X <span class="kr">else</span> set0).
    <span class="bp">by</span> <span class="nb">split</span>=&gt; [[]// _|t Xt]; <span class="kr">exists</span> <span class="mi">0</span>%N.
  <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">rewrite</span> -cvg_shiftS.
  <span class="nb">rewrite</span> (_ : [sequence _]_n = cst (mu X)); <span class="kp">first</span> <span class="bp">exact</span>: cvg_cst.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n /=; <span class="nb">rewrite</span> big_nat_recl//= big1 <span class="nl">?adde0</span>.
<span class="nb">apply</span>/lb_ereal_inf =&gt; x [A [mA XA] &lt;-{x}].
<span class="nb">have</span> XUA : X = \bigcup_n (X `&amp;` A n).
  <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [Xt|[i _ []//]].
  <span class="bp">by</span> <span class="nb">have</span> [i _ Ait] := XA _ Xt; <span class="kr">exists</span> <span class="nv">i</span>; <span class="nb">split</span>.
<span class="nb">apply</span>: (@le_trans _ _ (\sum_(i &lt;oo) mu (X `&amp;` A i))).
  <span class="bp">by</span> <span class="nb">rewrite</span> muS//= -<span class="nl">?XUA</span> =&gt; // i; <span class="nb">apply</span>: measurableI.
<span class="nb">apply</span>: lee_lim; [<span class="bp">exact</span>: is_cvg_nneseries|<span class="bp">exact</span>: is_cvg_nneseries|].
<span class="nb">apply</span>: nearW =&gt; n; <span class="nb">apply</span>: lee_sum =&gt; i  _; <span class="nb">apply</span>: le_measure =&gt; // /[!inE]//=.
<span class="bp">exact</span>: measurableI.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">Rmu_ext</span>.
<span class="kn">Import</span> SetRing.

<span class="kn">Lemma</span> <span class="nf">Rmu_ext</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : semiRingOfSetsType d)
    (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}) :
  (<span class="kn">measure</span> mu)^* = mu^*.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/funeqP =&gt; /= X; <span class="nb">rewrite</span> /mu_ext/=; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le.
<span class="nb">rewrite</span> <span class="nl">?lb_ereal_inf</span>// =&gt; _ [F [Fm XS] &lt;-]; <span class="nb">rewrite</span> ereal_inf_lb//; <span class="nb">last first</span>.
  <span class="kr">exists</span> <span class="nv">F</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">split</span>=&gt; // i; <span class="nb">apply</span>: sub_gen_smallest.
  <span class="bp">by</span> <span class="nb">rewrite</span> (eq_eseries (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; RmuE _ (Fm _))).
<span class="nb">pose</span> K := [<span class="nb">set</span>: nat] `*`` <span class="kr">fun</span> <span class="nv">i</span> =&gt; decomp (F i).
<span class="nb">have</span> /ppcard_eqP[f] : (K #= [<span class="nb">set</span>: nat])%card.
  <span class="nb">apply</span>: cardMR_eq_nat =&gt; // i; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>/set0P; <span class="nb">rewrite</span> decompN0.
  <span class="bp">by</span> <span class="nb">apply</span>: finite_set_countable =&gt; //; <span class="bp">exact</span>: decomp_finite_set.
<span class="nb">pose</span> g i := (f^-<span class="mi">1</span>%FUN i).<span class="mi">2</span>; <span class="kr">exists</span> <span class="nv">g</span>; <span class="kp">first</span> <span class="nb">split</span>.
- <span class="nb">move</span>=&gt; k; <span class="nb">have</span> [/= _ /mem_set] : K (f^-<span class="mi">1</span>%FUN k) <span class="bp">by</span> <span class="nb">apply</span>: funS.
  <span class="bp">exact</span>: decomp_measurable.
- <span class="nb">move</span>=&gt; i /XS [k _]; <span class="nb">rewrite</span> -[F k]cover_decomp =&gt; -[D /= DFk Di].
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f</span> (k, D)) =&gt; //; <span class="nb">rewrite</span> /g invK// inE.
<span class="nb">rewrite</span> !nneseries_esum//= /<span class="kn">measure</span> <span class="nl">?set_true</span>.
<span class="nb">transitivity</span> (\esum_(i <span class="kr">in</span> setT) \sum_(X0 \<span class="kr">in</span> decomp (F i)) mu X0); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_esum =&gt; /= k _; <span class="nb">rewrite</span> fsbig_finite//; <span class="bp">exact</span>: decomp_finite_set.
<span class="nb">rewrite</span> -(eq_esum (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; esum_fset _ _))//; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? _; <span class="bp">exact</span>: decomp_finite_set.
<span class="nb">rewrite</span> esum_esum//= (reindex_esum K setT f) =&gt; //=.
<span class="bp">by</span> <span class="nb">apply</span>: eq_esum =&gt; i Ki; <span class="nb">rewrite</span> /g funK <span class="nl">?inE</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Rmu_ext</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_Rmu_extE</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : semiRingOfSetsType d)
    (<span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}) <span class="nv">X</span> :
  sigma_sub_additive mu -&gt;
  d.-<span class="bp">ring</span>.-measurable X -&gt; mu^* X = SetRing.<span class="kn">measure</span> mu X.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mu_sub Xm/=; <span class="nb">rewrite</span> -Rmu_ext/= measurable_mu_extE//.
<span class="bp">exact</span>: ring_sigma_sub_additive.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">Hahn_extension</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : semiRingOfSetsType d).
<span class="kn">Variable</span> <span class="nv">mu</span> : {content <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Hypothesis</span> <span class="nv">mu_sub</span> : sigma_sub_additive mu.
<span class="kn">Let</span> <span class="nf">Rmu</span> := SetRing.<span class="kn">measure</span> mu.
<span class="kn">Notation</span> <span class="nf">rT</span> := (SetRing.type T).

<span class="kn">Lemma</span> <span class="nf">sub_caratheodory</span> :
  (d.-measurable).-sigma.-measurable `&lt;=` mu^*.-cara.-measurable.
<span class="kn">Proof</span>.
<span class="nb">suff</span>: &lt;&lt;s d.-<span class="bp">ring</span>.-measurable &gt;&gt; `&lt;=` mu^*.-cara.-measurable.
   <span class="nb">apply</span>: subset_trans; <span class="nb">apply</span>: sub_smallest2r =&gt; //.
   <span class="bp">by</span> <span class="nb">apply</span>: sub_smallest.
<span class="nb">apply</span>: smallest_sub.
  <span class="nb">split</span> =&gt; //; [<span class="bp">by</span> <span class="nb">move</span>=&gt; X mX; <span class="nb">rewrite</span> setTD; <span class="bp">exact</span>: measurableC |
                <span class="bp">by</span> <span class="nb">move</span>=&gt; u_ mu_; <span class="bp">exact</span>: bigcupT_measurable].
<span class="nb">move</span>=&gt; A mA; <span class="nb">apply</span> le_caratheodory_measurable =&gt; // X.
<span class="nb">apply</span> lb_ereal_inf =&gt; _ [B [mB XB] &lt;-].
<span class="nb">rewrite</span> -(eq_eseries (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; SetRing.RmuE _ (mB _)))=&gt; //.
<span class="nb">have</span> RmB i : measurable (B i : <span class="nb">set</span> rT) <span class="bp">by</span> <span class="bp">exact</span>: sub_gen_smallest.
<span class="nb">set</span> BA := eseries (<span class="kr">fun</span> <span class="nv">n</span> =&gt; Rmu (B n `&amp;` A)).
<span class="nb">set</span> BNA := eseries (<span class="kr">fun</span> <span class="nv">n</span> =&gt; Rmu (B n `&amp;` ~` A)).
<span class="nb">apply</span>: (@le_trans _ _ (lim BA + lim BNA)); [<span class="nb">apply</span>: lee_add|].
  - <span class="nb">rewrite</span> (_ : BA = eseries (<span class="kr">fun</span> <span class="nv">n</span> =&gt; mu_ext mu (B n `&amp;` A))); <span class="nb">last first</span>.
      <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">apply</span>: eq_bigr =&gt; k _.
      <span class="bp">by</span> <span class="nb">rewrite</span> /= measurable_Rmu_extE //; <span class="bp">exact</span>: measurableI.
    <span class="nb">apply</span>: (@le_trans _ _ (mu_ext mu (\bigcup_k (B k `&amp;` A)))).
      <span class="bp">by</span> <span class="nb">apply</span>: le_mu_ext; <span class="nb">rewrite</span> -setI_bigcupl; <span class="bp">exact</span>: setISS.
    <span class="bp">exact</span>: outer_measure_sigma_subadditive.
  - <span class="nb">rewrite</span> (_ : BNA = eseries (<span class="kr">fun</span> <span class="nv">n</span> =&gt; mu_ext mu (B n `\` A))); <span class="nb">last first</span>.
      <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">apply</span>: eq_bigr =&gt; k _.
      <span class="nb">rewrite</span> /= measurable_Rmu_extE //; <span class="bp">exact</span>: measurableD.
    <span class="nb">apply</span>: (@le_trans _ _ (mu_ext mu (\bigcup_k (B k `\` A)))).
      <span class="bp">by</span> <span class="nb">apply</span>: le_mu_ext; <span class="nb">rewrite</span> -setI_bigcupl; <span class="bp">exact</span>: setISS.
    <span class="bp">exact</span>: outer_measure_sigma_subadditive.
<span class="nb">have</span> ? : cvg BNA.
  <span class="nb">apply</span>/is_cvg_nneseries =&gt; n _.
  <span class="bp">by</span> <span class="nb">rewrite</span> -setDE; <span class="nb">apply</span>: measure_ge0 =&gt; //; <span class="bp">exact</span>: measurableD.
<span class="nb">have</span> ? : cvg BA.
  <span class="bp">by</span> <span class="nb">apply</span>/is_cvg_nneseries =&gt; n _; <span class="nb">apply</span>: measure_ge0 =&gt;//; <span class="nb">apply</span>: measurableI.
<span class="nb">have</span> ? : cvg (eseries (Rmu \o B)) <span class="bp">by</span> <span class="bp">exact</span>/is_cvg_nneseries.
<span class="nb">have</span> [def|] := boolP (adde_def (lim BA) (lim BNA)); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> /adde_def negb_and !negbK=&gt; /orP[/andP[BAoo BNAoo]|/andP[BAoo BNAoo]].
  - <span class="nb">suff</span> -&gt; : lim (eseries (Rmu \o B)) = +oo <span class="bp">by</span> <span class="nb">rewrite</span> leey.
    <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> -leye_eq -(eqP BAoo); <span class="nb">apply</span>/lee_lim =&gt; //.
    near=&gt; n; <span class="nb">apply</span>: lee_sum =&gt; m _; <span class="nb">apply</span>: le_measure; <span class="nb">rewrite</span> /mkset; <span class="bp">by</span>
      [<span class="nb">rewrite</span> inE; <span class="bp">exact</span>: measurableI | <span class="nb">rewrite</span> inE | <span class="nb">apply</span>: subIset; <span class="nb">left</span>].
  - <span class="nb">suff</span> -&gt; : lim (eseries (Rmu \o B)) = +oo <span class="bp">by</span> <span class="nb">rewrite</span> leey.
    <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> -leye_eq -(eqP BNAoo); <span class="nb">apply</span>/lee_lim =&gt; //.
    <span class="bp">by</span> near=&gt; n; <span class="nb">apply</span>: lee_sum =&gt; m _; <span class="nb">rewrite</span> -setDE; <span class="nb">apply</span>: le_measure;
       <span class="nb">rewrite</span> /mkset <span class="nl">?inE</span>//; <span class="nb">apply</span>: measurableD.
<span class="nb">rewrite</span> -limeD // (_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) =
    eseries (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Rmu (B k `&amp;` A) + Rmu (B k `&amp;` ~` A))); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> -big_split /=; <span class="nb">apply</span>: eq_bigr.
<span class="nb">apply</span>/lee_lim =&gt; //.
  <span class="nb">apply</span>/is_cvg_nneseries =&gt; // n _; <span class="nb">apply</span>/adde_ge0.
  <span class="bp">by</span> <span class="nb">apply</span>: measure_ge0 =&gt; //; <span class="bp">exact</span>: measurableI.
  <span class="bp">by</span> <span class="nb">rewrite</span> -setDE; <span class="nb">apply</span>: measure_ge0; <span class="bp">exact</span>: measurableD.
near=&gt; n; <span class="nb">apply</span>: lee_sum =&gt; i _; <span class="nb">rewrite</span> -measure_semi_additive2.
- <span class="nb">apply</span>: le_measure; <span class="nb">rewrite</span> /mkset <span class="nl">?inE</span>//; [|<span class="bp">by</span> <span class="nb">rewrite</span> -setIUr setUCr setIT].
  <span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>:measurableI|<span class="nb">rewrite</span> -setDE; <span class="bp">exact</span>:measurableD].
- <span class="bp">exact</span>: measurableI.
- <span class="bp">by</span> <span class="nb">rewrite</span> -setDE; <span class="bp">exact</span>: measurableD.
- <span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>:measurableI|<span class="nb">rewrite</span> -setDE; <span class="bp">exact</span>:measurableD].
- <span class="bp">by</span> <span class="nb">rewrite</span> setIACA setICr setI0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">I</span> := [the measurableType _ of salgebraType (@measurable _ T)].

<span class="kn">Definition</span> <span class="nf">Hahn_ext</span> : <span class="nb">set</span> I -&gt; \bar R := mu^*.

<span class="kn">Local Lemma</span> <span class="nf">Hahn_ext0</span> : Hahn_ext set0 = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">exact</span>: mu_ext0. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">Hahn_ext_ge0</span> (<span class="nv">A</span> : <span class="nb">set</span> I) : <span class="mi">0</span> &lt;= Hahn_ext A.
<span class="kn">Proof</span>. <span class="bp">exact</span>: mu_ext_ge0. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">Hahn_ext_sigma_additive</span> : semi_sigma_additive Hahn_ext.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mUF; <span class="nb">rewrite</span> /Hahn_ext.
<span class="nb">apply</span>: caratheodory_measure_sigma_additive =&gt; //; <span class="nb">last first</span>.
  <span class="bp">exact</span>: sub_caratheodory.
<span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="bp">exact</span>: (sub_caratheodory (mF i)).
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ Hahn_ext
  Hahn_ext0 Hahn_ext_ge0 Hahn_ext_sigma_additive.

<span class="kn">Lemma</span> <span class="nf">Hahn_ext_sigma_finite</span> : @sigma_finite _ _ T setT mu -&gt;
  @sigma_finite _ _ _ setT Hahn_ext.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; -[S setTS mS]; <span class="kr">exists</span> <span class="nv">S</span> =&gt; //; <span class="nb">move</span>=&gt; i; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">have</span> := (mS i).<span class="mi">1</span>; <span class="bp">exact</span>: sub_sigma_algebra.
<span class="bp">by</span> <span class="nb">rewrite</span> /Hahn_ext /= measurable_mu_extE //;
  [<span class="bp">exact</span>: (mS i).<span class="mi">2</span> | <span class="bp">exact</span>: (mS i).<span class="mi">1</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">Hahn_ext_unique</span> : sigma_finite [<span class="nb">set</span>: T] mu -&gt;
  (<span class="kr">forall</span> <span class="nv">mu&#39;</span> : {<span class="kn">measure</span> <span class="nb">set</span> I -&gt; \bar R},
    (<span class="kr">forall</span> <span class="nv">X</span>, d.-measurable X -&gt; mu X = mu&#39; X) -&gt;
    (<span class="kr">forall</span> <span class="nv">X</span>, (d.-measurable).-sigma.-measurable X -&gt; Hahn_ext X = mu&#39; X)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [F TF /all_and2[Fm muF]] mu&#39; mu&#39;mu X mX.
<span class="nb">apply</span>: (@measure_unique _ _ [the measurableType _ of I] d.-measurable F) =&gt; //.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; A B Am Bm; <span class="nb">apply</span>: measurableI.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; A Am; <span class="nb">rewrite</span> /= /Hahn_ext measurable_mu_extE// mu&#39;mu.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">rewrite</span> /= /Hahn_ext measurable_mu_extE.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Hahn_extension</span>.

<span class="kn">Lemma</span> <span class="nf">caratheodory_measurable_mu_ext</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : measurableType d)
    (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) <span class="nv">A</span> :
  d.-measurable A -&gt; mu^*.-cara.-measurable A.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Am; <span class="nb">apply</span>: sub_caratheodory =&gt; //;
  [<span class="bp">exact</span>: measure_sigma_sub_additive|<span class="bp">exact</span>: sub_sigma_algebra].
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">preimage_classes</span> <span class="nv">d1</span> <span class="nv">d2</span>
    (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">T</span> : <span class="kt">Type</span>)
    (<span class="nv">f1</span> : T -&gt; T1) (<span class="nv">f2</span> : T -&gt; T2)  :=
  &lt;&lt;s preimage_class setT f1 measurable `|`
      preimage_class setT f2 measurable &gt;&gt;.

<span class="kn">Section</span> <span class="nf">product_lemma</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2).
<span class="kn">Variables</span> (<span class="nv">T</span> : pointedType) (<span class="nv">f1</span> : T -&gt; T1) (<span class="nv">f2</span> : T -&gt; T2).
<span class="kn">Variables</span> (<span class="nv">T3</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : T3 -&gt; T).

<span class="kn">Lemma</span> <span class="nf">preimage_classes_comp</span> : preimage_classes (f1 \o g) (f2 \o g) =
                              preimage_class setT g (preimage_classes f1 f2).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> {<span class="mi">1</span>}/preimage_classes -sigma_algebra_preimage_classE; <span class="nb">congr</span> (&lt;&lt;s _ &gt;&gt;).
<span class="nb">rewrite</span> predeqE =&gt; C; <span class="nb">split</span>.
- <span class="nb">move</span>=&gt; [[A mA &lt;-{C}]|[A mA &lt;-{C}]].
  + <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f1</span> @^-<span class="mi">1</span>` A) =&gt; //; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="nb">rewrite</span> setTI.
  + <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f2</span> @^-<span class="mi">1</span>` A) =&gt; //; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="nb">rewrite</span> setTI.
- <span class="nb">move</span>=&gt; [A [[B mB &lt;-{A} &lt;-{C}]|[B mB &lt;-{A} &lt;-{C}]]].
  + <span class="bp">by</span> <span class="nb">left</span>; <span class="nb">rewrite</span> !setTI; <span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="nb">rewrite</span> setTI.
  + <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">rewrite</span> !setTI; <span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="nb">rewrite</span> setTI.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">product_lemma</span>.

<span class="kn">Definition</span> <span class="nf">measure_prod_display</span> :
  (measure_display * measure_display) -&gt; measure_display.
<span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">product_salgebra_instance</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2).
<span class="kn">Let</span> <span class="nf">f1</span> := @fst T1 T2.
<span class="kn">Let</span> <span class="nf">f2</span> := @snd T1 T2.

<span class="kn">Lemma</span> <span class="nf">prod_salgebra_set0</span> : preimage_classes f1 f2 (set0 : <span class="nb">set</span> (T1 * T2)).
<span class="kn">Proof</span>. <span class="bp">exact</span>: sigma_algebra0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_salgebra_setC</span> <span class="nv">A</span> : preimage_classes f1 f2 A -&gt;
  preimage_classes f1 f2 (~` A).
<span class="kn">Proof</span>. <span class="bp">exact</span>: sigma_algebraC. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_salgebra_bigcup</span> (<span class="nv">F</span> : _^nat) : (<span class="kr">forall</span> <span class="nv">i</span>, preimage_classes f1 f2 (F i)) -&gt;
  preimage_classes f1 f2 (\bigcup_i (F i)).
<span class="kn">Proof</span>. <span class="bp">exact</span>: sigma_algebra_bigcup. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">prod_salgebra_mixin</span> :=
  @isMeasurable.Build (measure_prod_display (d1, d2))
    (T1 * T2)%type (Pointed.class _) (preimage_classes f1 f2)
    (prod_salgebra_set0) (prod_salgebra_setC) (prod_salgebra_bigcup).

<span class="kn">End</span> <span class="nf">product_salgebra_instance</span>.
<span class="kn">Notation</span> <span class="s2">&quot;p .-prod&quot;</span> := (measure_prod_display p) : measure_display_scope.
<span class="kn">Notation</span> <span class="s2">&quot;p .-prod.-measurable&quot;</span> :=
  ((p.-prod).-measurable : <span class="nb">set</span> (<span class="nb">set</span> (_ * _))) :
    classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">measurableM</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2)
    (<span class="nv">A</span> : <span class="nb">set</span> T1) (<span class="nv">B</span> : <span class="nb">set</span> T2) :
  measurable A -&gt; measurable B -&gt; measurable (A `*` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA mB.
<span class="nb">have</span> -&gt; : A `*` B = (A `*` setT) `&amp;` (setT `*` B) :&gt; <span class="nb">set</span> (T1 * T2).
  <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}(setIT A) -{<span class="mi">1</span>}(setTI B) setMI.
<span class="nb">rewrite</span> setMT setTM; <span class="nb">apply</span>: measurableI.
- <span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="nb">rewrite</span> setTI.
- <span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="nb">rewrite</span> setTI.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">product_salgebra_measurableType</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2).
<span class="kn">Let</span> <span class="nf">M1</span> := @measurable _ T1.
<span class="kn">Let</span> <span class="nf">M2</span> := @measurable _ T2.
<span class="kn">Let</span> <span class="nf">M1xM2</span> := [<span class="nb">set</span> A `*` B | A <span class="kr">in</span> M1 &amp; B <span class="kr">in</span> M2].

<span class="kn">Lemma</span> <span class="nf">measurable_prod_measurableType</span> :
  (d1, d2).-prod.-measurable = &lt;&lt;s M1xM2 &gt;&gt;.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.
  <span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
  <span class="nb">rewrite</span> subUset; <span class="nb">split</span>.
  - <span class="nb">have</span> /subset_trans : preimage_class setT fst M1 `&lt;=` M1xM2.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [X MX &lt;-]; <span class="kr">exists</span> <span class="nv">X</span>=&gt; //; <span class="kr">exists</span> <span class="nv">setT</span>; <span class="nb">rewrite</span> /M2 // setIC//.
    <span class="bp">by</span> <span class="nb">apply</span>; <span class="bp">exact</span>: sub_sigma_algebra.
  - <span class="nb">have</span> /subset_trans : preimage_class setT snd M2 `&lt;=` M1xM2.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [Y MY &lt;-]; <span class="kr">exists</span> <span class="nv">setT</span>; <span class="nb">rewrite</span> /M1 //; <span class="kr">exists</span> <span class="nv">Y</span>.
    <span class="bp">by</span> <span class="nb">apply</span>; <span class="bp">exact</span>: sub_sigma_algebra.
<span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
<span class="bp">by</span> <span class="nb">move</span>=&gt; _ [A MA] [B MB] &lt;-; <span class="nb">apply</span>: measurableM =&gt; //; <span class="bp">exact</span>: sub_sigma_algebra.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">product_salgebra_measurableType</span>.

<span class="kn">Section</span> <span class="nf">product_salgebra_g_measurableTypeR</span>.
<span class="kn">Context</span> <span class="nv">d1</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : pointedType) (<span class="nv">C2</span> : <span class="nb">set</span> (<span class="nb">set</span> T2)).
<span class="kn">Hypothesis</span> <span class="nv">setTC2</span> : setT `&lt;=` C2.

<span class="c">(* NB: useful? *)</span>
<span class="kn">Lemma</span> <span class="nf">measurable_prod_g_measurableTypeR</span> :
  @measurable _ [the measurableType _ of T1 * salgebraType C2 : <span class="kt">Type</span>]
  = &lt;&lt;s [<span class="nb">set</span> A `*` B | A <span class="kr">in</span> measurable &amp; B <span class="kr">in</span> C2] &gt;&gt;.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> measurable_prod_measurableType //; <span class="nb">congr</span> (&lt;&lt;s _ &gt;&gt;).
<span class="nb">rewrite</span> predeqE =&gt; X; <span class="nb">split</span>=&gt; [[A mA] [B mB] &lt;-{X}|[A C1A] [B C2B] &lt;-{X}].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="bp">exact</span>: setTC2.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="bp">exact</span>: sub_sigma_algebra.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">product_salgebra_g_measurableTypeR</span>.

<span class="kn">Section</span> <span class="nf">product_salgebra_g_measurableType</span>.
<span class="kn">Variables</span> (<span class="nv">T1</span> <span class="nv">T2</span> : pointedType) (<span class="nv">C1</span> : <span class="nb">set</span> (<span class="nb">set</span> T1)) (<span class="nv">C2</span> : <span class="nb">set</span> (<span class="nb">set</span> T2)).
<span class="kn">Hypotheses</span> (<span class="nv">setTC1</span> : setT `&lt;=` C1) (<span class="nv">setTC2</span> : setT `&lt;=` C2).

<span class="kn">Lemma</span> <span class="nf">measurable_prod_g_measurableType</span> :
  @measurable _ [the measurableType _ of salgebraType C1 * salgebraType C2 : <span class="kt">Type</span>]
  = &lt;&lt;s [<span class="nb">set</span> A `*` B | A <span class="kr">in</span> C1 &amp; B <span class="kr">in</span> C2] &gt;&gt;.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> measurable_prod_measurableType //; <span class="nb">congr</span> (&lt;&lt;s _ &gt;&gt;).
<span class="nb">rewrite</span> predeqE =&gt; X; <span class="nb">split</span>=&gt; [[A mA] [B mB] &lt;-{X}|[A C1A] [B C2B] &lt;-{X}].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span>; [<span class="bp">exact</span>: setTC1|<span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="bp">exact</span>: setTC2].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span>; [<span class="bp">exact</span>: sub_sigma_algebra|<span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="bp">exact</span>: sub_sigma_algebra].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">product_salgebra_g_measurableType</span>.

<span class="kn">Section</span> <span class="nf">prod_measurable_fun</span>.
<span class="kn">Context</span> <span class="nv">d</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">T1</span> : measurableType d1)
        (<span class="nv">T2</span> : measurableType d2).

<span class="kn">Lemma</span> <span class="nf">prod_measurable_funP</span> (<span class="nv">h</span> : T -&gt; T1 * T2) : measurable_fun setT h &lt;-&gt;
  measurable_fun setT (fst \o h) /\ measurable_fun setT (snd \o h).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (@iff_trans _ (preimage_classes (fst \o h) (snd \o h) `&lt;=` measurable)).
- <span class="nb">rewrite</span> preimage_classes_comp; <span class="nb">split</span>=&gt; [mf A [C HC &lt;-]|f12]; <span class="kp">first</span> <span class="bp">exact</span>: mf.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; _ A mA; <span class="nb">apply</span>: f12; <span class="kr">exists</span> <span class="nv">A</span>.
- <span class="nb">split</span> =&gt; [h12|[mf1 mf2]].
    <span class="nb">split</span> =&gt; _ A mA; <span class="nb">apply</span>: h12; <span class="nb">apply</span>: sub_sigma_algebra;
    <span class="bp">by</span> [<span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">A</span>|<span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">A</span>].
  <span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: sigma_algebra_measurable.
  <span class="bp">by</span> <span class="nb">rewrite</span> subUset; <span class="nb">split</span>=&gt; [|] A [C mC &lt;-]; [<span class="bp">exact</span>: mf1|<span class="bp">exact</span>: mf2].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_pair</span> (<span class="nv">f</span> : T -&gt; T1) (<span class="nv">g</span> : T -&gt; T2) :
  measurable_fun setT f -&gt; measurable_fun setT g -&gt;
  measurable_fun setT (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (f x, g x)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mf mg; <span class="nb">apply</span>/prod_measurable_funP. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">prod_measurable_fun</span>.

<span class="kn">Section</span> <span class="nf">prod_measurable_proj</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2).

<span class="kn">Lemma</span> <span class="nf">measurable_fun_fst</span> : measurable_fun setT (@fst T1 T2).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">have</span> /prod_measurable_funP[] :=
  @measurable_fun_id _ [the measurableType _ of (T1 * T2)%type] setT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_snd</span> : measurable_fun setT (@snd T1 T2).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">have</span> /prod_measurable_funP[] :=
  @measurable_fun_id _ [the measurableType _ of (T1 * T2)%type] setT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_swap</span> : measurable_fun [<span class="nb">set</span>: T1 * T2] (@<span class="nb">swap</span> T1 T2).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>/prod_measurable_funP =&gt; /=; <span class="nb">split</span>;
  [<span class="bp">exact</span>: measurable_fun_snd|<span class="bp">exact</span>: measurable_fun_fst].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">prod_measurable_proj</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_if_pair</span> <span class="nv">d</span> <span class="nv">d&#39;</span> (<span class="nv">X</span> : measurableType d)
    (<span class="nv">Y</span> : measurableType d&#39;) (<span class="nv">x</span> <span class="nv">y</span> : X -&gt; Y) :
  measurable_fun setT x -&gt; measurable_fun setT y -&gt;
  measurable_fun setT (<span class="kr">fun</span> <span class="nv">tb</span> =&gt; <span class="kr">if</span> tb.<span class="mi">2</span> <span class="kr">then</span> x tb.<span class="mi">1</span> <span class="kr">else</span> y tb.<span class="mi">1</span>).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mx my.
<span class="nb">have</span> {}mx : measurable_fun [<span class="nb">set</span>: X * bool] (x \o fst).
  <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_fun_fst.
<span class="nb">have</span> {}my : measurable_fun [<span class="nb">set</span>: X * bool] (y \o fst).
  <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_fun_fst.
<span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_ifT =&gt; //=; <span class="bp">exact</span>: measurable_fun_snd.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">partial_measurable_fun</span>.
<span class="kn">Context</span> <span class="nv">d</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">T1</span> : measurableType d1)
  (<span class="nv">T2</span> : measurableType d2).
<span class="kn">Variable</span> <span class="nv">f</span> : T1 * T2 -&gt; T.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_prod1</span> <span class="nv">x</span> :
  measurable_fun setT f -&gt; measurable_fun setT (<span class="kr">fun</span> <span class="nv">y</span> =&gt; f (x, y)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf; <span class="nb">pose</span> pairx := <span class="kr">fun</span> <span class="nv">y</span> : T2 =&gt; (x, y).
<span class="nb">have</span> m1pairx : measurable_fun setT (fst \o pairx) <span class="bp">by</span> <span class="bp">exact</span>/measurable_fun_cst.
<span class="nb">have</span> m2pairx : measurable_fun setT (snd \o pairx) <span class="bp">by</span> <span class="bp">exact</span>/measurable_fun_id.
<span class="nb">have</span> ? : measurable_fun setT pairx <span class="bp">by</span> <span class="bp">exact</span>/(proj2 (prod_measurable_funP _)).
<span class="bp">exact</span>: (measurable_fun_comp _ _ mf).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_prod2</span> <span class="nv">y</span> :
  measurable_fun setT f -&gt; measurable_fun setT (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f (x, y)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf; <span class="nb">pose</span> pairy := <span class="kr">fun</span> <span class="nv">x</span> : T1 =&gt; (x, y).
<span class="nb">have</span> m1pairy : measurable_fun setT (fst \o pairy) <span class="bp">by</span> <span class="bp">exact</span>/measurable_fun_id.
<span class="nb">have</span> m2pairy : measurable_fun setT (snd \o pairy) <span class="bp">by</span> <span class="bp">exact</span>/measurable_fun_cst.
<span class="nb">have</span> : measurable_fun setT pairy <span class="bp">by</span> <span class="bp">exact</span>/(proj2 (prod_measurable_funP _)).
<span class="bp">exact</span>: (measurable_fun_comp _ _ mf).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">partial_measurable_fun</span>.

HB.mixin <span class="kn">Record</span> <span class="nf">isProbability</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d)
  (<span class="nv">R</span> : realType) (<span class="nv">P</span> : <span class="nb">set</span> T -&gt; \bar R) <span class="nv">of</span> <span class="nv">isMeasure</span> <span class="nv">d</span> <span class="nv">R</span> <span class="nv">T</span> <span class="nv">P</span> :=
  { probability_setT : P setT = <span class="mi">1</span>%E }.

#[short(type=probability)]
HB.structure <span class="kn">Definition</span> <span class="nf">Probability</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType) :=
  {P of isProbability d T R P &amp; isMeasure d R T P }.

<span class="kn">Section</span> <span class="nf">probability_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType) (<span class="nv">P</span> : probability T R).

<span class="kn">Lemma</span> <span class="nf">probability_le1</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : measurable A -&gt; (P A &lt;= <span class="mi">1</span>)%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA; <span class="nb">rewrite</span> -(@probability_setT _ _ _ P).
<span class="bp">by</span> <span class="nb">apply</span>: le_measure =&gt; //; <span class="nb">rewrite</span> <span class="nl">?in_setE</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">probability_lemmas</span>.</span></pre></article></body></html>