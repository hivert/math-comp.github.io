<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>lebesgue_integral.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
<span class="kn">From</span> HB <span class="kn">Require Import</span> structures.
<span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect ssralg ssrnum ssrint interval finmap.
<span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> boolp classical_sets functions.
<span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> cardinality fsbigop mathcomp_extra.
<span class="kn">Require Import</span> signed reals ereal topology normedtype sequences esum <span class="kn">measure</span>.
<span class="kn">Require Import</span> lebesgue_measure numfun.

<span class="sd">(******************************************************************************)</span>
<span class="c">(*                            Lebesgue Integral                               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* This file contains a formalization of the Lebesgue integral. It starts     *)</span>
<span class="c">(* with simple functions and their integral, provides basic operations        *)</span>
<span class="c">(* (addition, etc.), and proves the properties of their integral              *)</span>
<span class="c">(* (semi-linearity, non-decreasingness). It then defines the integral of      *)</span>
<span class="c">(* measurable functions, proves the approximation theorem, the properties of  *)</span>
<span class="c">(* their integral (semi-linearity, non-decreasingness), the monotone          *)</span>
<span class="c">(* convergence theorem, and Fatou&#39;s lemma. Finally, it proves the linearity   *)</span>
<span class="c">(* properties of the integral, the dominated convergence theorem and Fubini&#39;s *)</span>
<span class="c">(* theorem.                                                                   *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* Main reference:                                                            *)</span>
<span class="c">(* - Daniel Li, Int√©gration et applications, 2016                             *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*         {mfun T &gt;-&gt; R} == type of real-valued measurable functions         *)</span>
<span class="c">(*         {sfun T &gt;-&gt; R} == type of simple functions                         *)</span>
<span class="c">(*       {nnsfun T &gt;-&gt; R} == type of non-negative simple functions            *)</span>
<span class="c">(*           cst_nnsfun r == constant simple function                         *)</span>
<span class="c">(*                nnsfun0 := cst_nnsfun 0                                     *)</span>
<span class="c">(*         sintegral mu f == integral of the function f with the measure mu   *)</span>
<span class="c">(*  \int[mu]_(x in D) f x == integral of the measurable function f over the   *)</span>
<span class="c">(*                           domain D with measure mu                         *)</span>
<span class="c">(*         \int[mu]_x f x := \int[mu]_(x in setT) f x                         *)</span>
<span class="c">(*         dyadic_itv n k == the interval                                     *)</span>
<span class="c">(*                           `[(k%:R * 2 ^- n), (k.+1%:R * 2 ^- n)[           *)</span>
<span class="c">(*             approx D f == nondecreasing sequence of functions that         *)</span>
<span class="c">(*                           approximates f over D using dyadic intervals     *)</span>
<span class="c">(*       Rintegral mu D f := fine (\int[mu]_(x in D) f x).                    *)</span>
<span class="c">(*     mu.-integrable D f == f is measurable over D and the integral of f     *)</span>
<span class="c">(*                           w.r.t. D is &lt; +oo                                *)</span>
<span class="c">(*            ae_eq D f g == f is equal to g almost everywhere                *)</span>
<span class="c">(*               m1 \x m2 == product measure over T1 * T2, m1 is a measure    *)</span>
<span class="c">(*                           measure over T1, and m2 is a sigma finite        *)</span>
<span class="c">(*                           measure over T2                                  *)</span>
<span class="c">(*              m1 \x^ m2 == product measure over T1 * T2, m2 is a measure    *)</span>
<span class="c">(*                           measure over T1, and m1 is a sigma finite        *)</span>
<span class="c">(*                           measure over T2                                  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="kn">Set Implicit Arguments</span>.
<span class="kn">Unset Strict Implicit</span>.
<span class="kn">Unset Printing Implicit Defensive</span>.
<span class="kn">Import</span> Order.TTheory GRing.Theory Num.Def Num.Theory.
<span class="kn">Import</span> numFieldTopology.Exports.

<span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.

<span class="kn">Reserved Notation</span> <span class="s2">&quot;\int [ mu ]_ ( i &#39;in&#39; D ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">36</span>, F <span class="kn">at level</span> <span class="mi">36</span>, mu <span class="kn">at level</span> <span class="mi">10</span>, i, D <span class="kn">at level</span> <span class="mi">50</span>,
  <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \int [ mu ]_ ( i  &#39;in&#39;  D ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;\int [ mu ]_ i F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">36</span>, F <span class="kn">at level</span> <span class="mi">36</span>, mu <span class="kn">at level</span> <span class="mi">10</span>, i <span class="kn">at level</span> <span class="mi">0</span>,
    <span class="kn">right associativity</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \int [ mu ]_ i &#39;/  &#39;  F &#39;]&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;mu .-integrable&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;mu .-integrable&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;m1 &#39;\x&#39; m2&quot;</span> (<span class="kn">at level</span> <span class="mi">40</span>, m2 <span class="kn">at next level</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;m1 &#39;\x^&#39; m2&quot;</span> (<span class="kn">at level</span> <span class="mi">40</span>, m2 <span class="kn">at next level</span>).

#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (measurable [<span class="nb">set</span> _]) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: measurable_set1] : core.

HB.mixin <span class="kn">Record</span> <span class="nf">isMeasurableFun</span> <span class="nv">d</span> (<span class="nv">aT</span> : measurableType d) (<span class="nv">rT</span> : realType)
    (<span class="nv">f</span> : aT -&gt; rT) := {
  measurable_funP : measurable_fun setT f
}.
HB.structure <span class="kn">Definition</span> <span class="nf">MeasurableFun</span> <span class="nv">d</span> <span class="nv">aT</span> <span class="nv">rT</span> :=
  {f of @isMeasurableFun d aT rT f}.
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;mfun&#39; aT &gt;-&gt; T }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;mfun&#39;  aT  &gt;-&gt;  T }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;mfun&#39; &#39;of&#39; f ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;mfun&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;mfun&#39; aT &gt;-&gt; T }&quot;</span> := (@MeasurableFun.type _ aT T) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;mfun&#39; &#39;of&#39; f ]&quot;</span> := [the {mfun _ &gt;-&gt; _} of f] : form_scope.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> measurable_funP : core.

HB.structure <span class="kn">Definition</span> <span class="nf">SimpleFun</span> <span class="nv">d</span> (<span class="nv">aT</span> : measurableType d) (<span class="nv">rT</span> : realType) :=
  {f of @isMeasurableFun d aT rT f &amp; @FiniteImage aT rT f}.
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;sfun&#39; aT &gt;-&gt; T }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;sfun&#39;  aT  &gt;-&gt;  T }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;sfun&#39; &#39;of&#39; f ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;sfun&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;sfun&#39; aT &gt;-&gt; T }&quot;</span> := (@SimpleFun.type _ aT T) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;sfun&#39; &#39;of&#39; f ]&quot;</span> := [the {sfun _ &gt;-&gt; _} of f] : form_scope.

<span class="kn">Lemma</span> <span class="nf">measurable_sfunP</span> {<span class="nv">d</span>} {<span class="nv">aT</span> : measurableType d} {<span class="nv">rT</span> : realType}
  (<span class="nv">f</span> : {mfun aT &gt;-&gt; rT}) (<span class="nv">Y</span> : <span class="nb">set</span> rT) : measurable Y -&gt; measurable (f @^-<span class="mi">1</span>` Y).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mY; <span class="nb">rewrite</span> -[f @^-<span class="mi">1</span>` _]setTI; <span class="bp">exact</span>: measurable_funP. <span class="kn">Qed</span>.

HB.structure <span class="kn">Definition</span> <span class="nf">NonNegSimpleFun</span>
    <span class="nv">d</span> (<span class="nv">aT</span> : measurableType d) (<span class="nv">rT</span> : realType) :=
  {f of @SimpleFun d _ _ f &amp; @NonNegFun aT rT f}.
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;nnsfun&#39; aT &gt;-&gt; T }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;nnsfun&#39;  aT  &gt;-&gt;  T }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;nnsfun&#39; &#39;of&#39; f ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;nnsfun&#39;  &#39;of&#39;  f ]&quot;</span>).
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;nnsfun&#39; aT &gt;-&gt; T }&quot;</span> := (@NonNegSimpleFun.type _ aT T) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;nnsfun&#39; &#39;of&#39; f ]&quot;</span> := [the {nnsfun _ &gt;-&gt; _} of f] : form_scope.

<span class="kn">Section</span> <span class="nf">mfun_pred</span>.
<span class="kn">Context</span> {<span class="nv">d</span>} {<span class="nv">aT</span> : measurableType d} {<span class="nv">rT</span> : realType}.
<span class="kn">Definition</span> <span class="nf">mfun</span> : {pred aT -&gt; rT} := mem [<span class="nb">set</span> f | measurable_fun setT f].
<span class="kn">Definition</span> <span class="nf">mfun_key</span> : pred_key mfun. <span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.
<span class="kn">Canonical</span> <span class="nf">mfun_keyed</span> := KeyedPred mfun_key.
<span class="kn">End</span> <span class="nf">mfun_pred</span>.

<span class="kn">Section</span> <span class="nf">mfun</span>.
<span class="kn">Context</span> {<span class="nv">d</span>} {<span class="nv">aT</span> : measurableType d} {<span class="nv">rT</span> : realType}.
<span class="kn">Notation</span> <span class="nf">T</span> := {mfun aT &gt;-&gt; rT}.
<span class="kn">Notation</span> <span class="nf">mfun</span> := (@mfun _ aT rT).
<span class="kn">Section</span> <span class="nf">Sub</span>.
<span class="kn">Context</span> (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">fP</span> : f \<span class="kr">in</span> mfun).
<span class="kn">Definition</span> <span class="nf">mfun_Sub_subproof</span> := @isMeasurableFun.Build d aT rT f (set_mem fP).
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := mfun_Sub_subproof.
<span class="kn">Definition</span> <span class="nf">mfun_Sub</span> := [mfun of f].
<span class="kn">End</span> <span class="nf">Sub</span>.

<span class="kn">Lemma</span> <span class="nf">mfun_rect</span> (<span class="nv">K</span> : T -&gt; <span class="kt">Type</span>) :
  (<span class="kr">forall</span> <span class="nv">f</span> (<span class="nv">Pf</span> : f \<span class="kr">in</span> mfun), K (mfun_Sub Pf)) -&gt; <span class="kr">forall</span> <span class="nv">u</span> : T, K u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Ksub [f [[Pf]]]/=.
<span class="bp">by</span> <span class="nb">suff</span> -&gt; : Pf = (set_mem (@mem_set _ [<span class="nb">set</span> f | _] f Pf)) <span class="bp">by</span> <span class="nb">apply</span>: Ksub.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mfun_valP</span> <span class="nv">f</span> (<span class="nv">Pf</span> : f \<span class="kr">in</span> mfun) : mfun_Sub Pf = f :&gt; (_ -&gt; _).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">mfun_subType</span> := SubType T _ _ mfun_rect mfun_valP.

<span class="kn">Lemma</span> <span class="nf">mfuneqP</span> (<span class="nv">f</span> <span class="nv">g</span> : {mfun aT &gt;-&gt; rT}) : f = g &lt;-&gt; f =<span class="mi">1</span> g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; [-&gt;//|fg]; <span class="nb">apply</span>/val_inj/funext. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">mfuneqMixin</span> := [eqMixin of {mfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">mfuneqType</span> := EqType {mfun aT &gt;-&gt; rT} mfuneqMixin.
<span class="kn">Definition</span> <span class="nf">mfunchoiceMixin</span> := [choiceMixin of {mfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">mfunchoiceType</span> := ChoiceType {mfun aT &gt;-&gt; rT} mfunchoiceMixin.

<span class="kn">Lemma</span> <span class="nf">cst_mfun_subproof</span> <span class="nv">x</span> : @isMeasurableFun d aT rT (cst x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>; <span class="nb">apply</span>: measurable_fun_cst. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">x</span> := @cst_mfun_subproof x.
<span class="kn">Definition</span> <span class="nf">cst_mfun</span> <span class="nv">x</span> := [the {mfun aT &gt;-&gt; rT} of cst x].

<span class="kn">Lemma</span> <span class="nf">mfun_cst</span> <span class="nv">x</span> : @cst_mfun x =<span class="mi">1</span> cst x. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">mfun</span>.

<span class="kn">Section</span> <span class="nf">ring</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">aT</span> : measurableType d) (<span class="nv">rT</span> : realType).

<span class="kn">Lemma</span> <span class="nf">mfun_subring_closed</span> : subring_closed (@mfun _ aT rT).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [|f g|f g]; <span class="nb">rewrite</span> !inE/=.
- <span class="bp">exact</span>: measurable_fun_cst.
- <span class="bp">exact</span>: measurable_funB.
- <span class="bp">exact</span>: measurable_funM.
<span class="kn">Qed</span>.
<span class="kn">Canonical</span> <span class="nf">mfun_add</span> := AddrPred mfun_subring_closed.
<span class="kn">Canonical</span> <span class="nf">mfun_zmod</span> := ZmodPred mfun_subring_closed.
<span class="kn">Canonical</span> <span class="nf">mfun_mul</span> := MulrPred mfun_subring_closed.
<span class="kn">Canonical</span> <span class="nf">mfun_subring</span> := SubringPred mfun_subring_closed.
<span class="kn">Definition</span> <span class="nf">mfun_zmodMixin</span> := [zmodMixin of {mfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">mfun_zmodType</span> := ZmodType {mfun aT &gt;-&gt; rT} mfun_zmodMixin.
<span class="kn">Definition</span> <span class="nf">mfun_ringMixin</span> := [ringMixin of {mfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">mfun_ringType</span> := RingType {mfun aT &gt;-&gt; rT} mfun_ringMixin.
<span class="kn">Definition</span> <span class="nf">mfun_comRingMixin</span> := [comRingMixin of {mfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">mfun_comRingType</span> := ComRingType {mfun aT &gt;-&gt; rT} mfun_comRingMixin.

<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : {mfun aT &gt;-&gt; rT}).

<span class="kn">Lemma</span> <span class="nf">mfun0</span> : (<span class="mi">0</span> : {mfun aT &gt;-&gt; rT}) =<span class="mi">1</span> cst <span class="mi">0</span> :&gt; (_ -&gt; _). <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mfun1</span> : (<span class="mi">1</span> : {mfun aT &gt;-&gt; rT}) =<span class="mi">1</span> cst <span class="mi">1</span> :&gt; (_ -&gt; _). <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mfunN</span> <span class="nv">f</span> : - f = \- f :&gt; (_ -&gt; _). <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mfunD</span> <span class="nv">f</span> <span class="nv">g</span> : f + g = f \+ g :&gt; (_ -&gt; _). <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mfunB</span> <span class="nv">f</span> <span class="nv">g</span> : f - g = f \- g :&gt; (_ -&gt; _). <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mfunM</span> <span class="nv">f</span> <span class="nv">g</span> : f * g = f \* g :&gt; (_ -&gt; _). <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mfun_sum</span> <span class="nv">I</span> <span class="nv">r</span> (<span class="nv">P</span> : {pred I}) (<span class="nv">f</span> : I -&gt; {mfun aT &gt;-&gt; rT}) (<span class="nv">x</span> : aT) :
  (\sum_(i &lt;- r | P i) f i) x = \sum_(i &lt;- r | P i) f i x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">elim</span>/big_rec2: _ =&gt; //= i y ? Pi &lt;-. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mfun_prod</span> <span class="nv">I</span> <span class="nv">r</span> (<span class="nv">P</span> : {pred I}) (<span class="nv">f</span> : I -&gt; {mfun aT &gt;-&gt; rT}) (<span class="nv">x</span> : aT) :
  (\sum_(i &lt;- r | P i) f i) x = \sum_(i &lt;- r | P i) f i x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">elim</span>/big_rec2: _ =&gt; //= i y ? Pi &lt;-. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mfunX</span> <span class="nv">f</span> <span class="nv">n</span> : f ^+ n = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x ^+ n) :&gt; (_ -&gt; _).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/funext=&gt; x; <span class="nb">elim</span>: n =&gt; [|n IHn]//; <span class="nb">rewrite</span> !exprS mfunM/= IHn. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := MeasurableFun.copy (f \+ g) (f + g).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := MeasurableFun.copy (\- f) (- f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := MeasurableFun.copy (f \- g) (f - g).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := MeasurableFun.copy (f \* g) (f * g).

<span class="kn">Definition</span> <span class="nf">mindic</span> (<span class="nv">D</span> : <span class="nb">set</span> aT) <span class="nv">of</span> <span class="nv">measurable</span> <span class="nv">D</span> : aT -&gt; rT := \<span class="mi">1_</span>D.
<span class="kn">Lemma</span> <span class="nf">mindicE</span> (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">mD</span> : measurable D) :
  mindic mD = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x \<span class="kr">in</span> D)%:R).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /mindic funeqE =&gt; t; <span class="nb">rewrite</span> indicE. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">mD</span> : measurable D) :
   @FImFun aT rT (mindic mD) := FImFun.on (mindic mD).
<span class="kn">Lemma</span> <span class="nf">indic_mfun_subproof</span> (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">mD</span> : measurable D) :
  @isMeasurableFun d aT rT (mindic mD).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; mA /= B mB; <span class="nb">rewrite</span> preimage_indic.
<span class="nb">case</span>: ifPn =&gt; B1; <span class="nb">case</span>: ifPn =&gt; B0 //.
- <span class="bp">by</span> <span class="nb">rewrite</span> setIT.
- <span class="bp">exact</span>: measurableI.
- <span class="bp">by</span> <span class="nb">apply</span>: measurableI =&gt; //; <span class="nb">apply</span>: measurableC.
- <span class="bp">by</span> <span class="nb">rewrite</span> setI0.
<span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">D</span> <span class="nv">mD</span> := @indic_mfun_subproof D mD.

<span class="kn">Definition</span> <span class="nf">indic_mfun</span> (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">mD</span> : measurable D) :=
  [the {mfun aT &gt;-&gt; rT} of mindic mD].

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">k</span> <span class="nv">f</span> := MeasurableFun.copy (k \o* f) (f * cst_mfun k).
<span class="kn">Definition</span> <span class="nf">scale_mfun</span> <span class="nv">k</span> <span class="nv">f</span> := [the {mfun aT &gt;-&gt; rT} of k \o* f].

<span class="kn">Lemma</span> <span class="nf">max_mfun_subproof</span> <span class="nv">f</span> <span class="nv">g</span> : @isMeasurableFun d aT rT (f \max g).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>; <span class="nb">apply</span>: measurable_fun_max. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := max_mfun_subproof f g.
<span class="kn">Definition</span> <span class="nf">max_mfun</span> <span class="nv">f</span> <span class="nv">g</span> := [the {mfun aT &gt;-&gt; _} of f \max g].

<span class="kn">End</span> <span class="nf">ring</span>.
<span class="kn">Arguments</span> indic_mfun {d aT rT} _.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_indic</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">D</span> <span class="nv">A</span> : <span class="nb">set</span> T) : measurable A -&gt;
  measurable_fun D (\<span class="mi">1_</span>A : T -&gt; R).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mA; <span class="nb">apply</span>/measurable_funTS; <span class="nb">rewrite</span> (_ : \<span class="mi">1__</span> = mindic R mA).
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">sfun_pred</span>.
<span class="kn">Context</span> {<span class="nv">d</span>} {<span class="nv">aT</span> : measurableType d} {<span class="nv">rT</span> : realType}.
<span class="kn">Definition</span> <span class="nf">sfun</span> : {pred _ -&gt; _} := [predI @mfun _ aT rT &amp; fimfun].
<span class="kn">Definition</span> <span class="nf">sfun_key</span> : pred_key sfun. <span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.
<span class="kn">Canonical</span> <span class="nf">sfun_keyed</span> := KeyedPred sfun_key.
<span class="kn">Lemma</span> <span class="nf">sub_sfun_mfun</span> : {subset sfun &lt;= mfun}. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x /andP[]. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">sub_sfun_fimfun</span> : {subset sfun &lt;= fimfun}. <span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x /andP[]. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">sfun_pred</span>.

<span class="kn">Section</span> <span class="nf">sfun</span>.
<span class="kn">Context</span> {<span class="nv">d</span>} {<span class="nv">aT</span> : measurableType d} {<span class="nv">rT</span> : realType}.
<span class="kn">Notation</span> <span class="nf">T</span> := {sfun aT &gt;-&gt; rT}.
<span class="kn">Notation</span> <span class="nf">sfun</span> := (@sfun _ aT rT).
<span class="kn">Section</span> <span class="nf">Sub</span>.
<span class="kn">Context</span> (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">fP</span> : f \<span class="kr">in</span> sfun).
<span class="kn">Definition</span> <span class="nf">sfun_Sub1_subproof</span> :=
  @isMeasurableFun.Build d aT rT f (set_mem (sub_sfun_mfun fP)).
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := sfun_Sub1_subproof.
<span class="kn">Definition</span> <span class="nf">sfun_Sub2_subproof</span> :=
  @FiniteImage.Build aT rT f (set_mem (sub_sfun_fimfun fP)).
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := sfun_Sub2_subproof.
<span class="kn">Definition</span> <span class="nf">sfun_Sub</span> := [sfun of f].
<span class="kn">End</span> <span class="nf">Sub</span>.

<span class="kn">Lemma</span> <span class="nf">sfun_rect</span> (<span class="nv">K</span> : T -&gt; <span class="kt">Type</span>) :
  (<span class="kr">forall</span> <span class="nv">f</span> (<span class="nv">Pf</span> : f \<span class="kr">in</span> sfun), K (sfun_Sub Pf)) -&gt; <span class="kr">forall</span> <span class="nv">u</span> : T, K u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Ksub [f [[Pf1] [Pf2]]]; <span class="nb">have</span> Pf : f \<span class="kr">in</span> sfun <span class="bp">by</span> <span class="nb">apply</span>/andP; <span class="nb">rewrite</span> <span class="nl">?inE</span>.
<span class="nb">have</span> -&gt; : Pf1 = (set_mem (sub_sfun_mfun Pf)) <span class="bp">by</span> [].
<span class="nb">have</span> -&gt; : Pf2 = (set_mem (sub_sfun_fimfun Pf)) <span class="bp">by</span> [].
<span class="bp">exact</span>: Ksub.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sfun_valP</span> <span class="nv">f</span> (<span class="nv">Pf</span> : f \<span class="kr">in</span> sfun) : sfun_Sub Pf = f :&gt; (_ -&gt; _).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">sfun_subType</span> := SubType T _ _ sfun_rect sfun_valP.

<span class="kn">Lemma</span> <span class="nf">sfuneqP</span> (<span class="nv">f</span> <span class="nv">g</span> : {sfun aT &gt;-&gt; rT}) : f = g &lt;-&gt; f =<span class="mi">1</span> g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; [-&gt;//|fg]; <span class="nb">apply</span>/val_inj/funext. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">sfuneqMixin</span> := [eqMixin of {sfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">sfuneqType</span> := EqType {sfun aT &gt;-&gt; rT} sfuneqMixin.
<span class="kn">Definition</span> <span class="nf">sfunchoiceMixin</span> := [choiceMixin of {sfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">sfunchoiceType</span> := ChoiceType {sfun aT &gt;-&gt; rT} sfunchoiceMixin.

<span class="c">(* TODO: BUG: HB *)</span>
<span class="c">(* HB.instance Definition _ (x : rT) := @cst_mfun_subproof aT rT x. *)</span>
<span class="kn">Definition</span> <span class="nf">cst_sfun</span> <span class="nv">x</span> := [the {sfun aT &gt;-&gt; rT} of cst x].

<span class="kn">Lemma</span> <span class="nf">cst_sfunE</span> <span class="nv">x</span> : @cst_sfun x =<span class="mi">1</span> cst x. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sfun</span>.

<span class="c">(* a better way to refactor function stuffs *)</span>
<span class="kn">Lemma</span> <span class="nf">fctD</span> (<span class="nv">T</span> : pointedType) (<span class="nv">K</span> : ringType) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; K) : f + g = f \+ g.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">fctN</span> (<span class="nv">T</span> : pointedType) (<span class="nv">K</span> : ringType) (<span class="nv">f</span> : T -&gt; K) : - f = \- f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">fctM</span> (<span class="nv">T</span> : pointedType) (<span class="nv">K</span> : ringType) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; K) : f * g = f \* g.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">fctZ</span> (<span class="nv">T</span> : pointedType) (<span class="nv">K</span> : ringType) (<span class="nv">L</span> : lmodType K) <span class="nv">k</span> (<span class="nv">f</span> : T -&gt; L) :
   k *: f = k \*: f.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> cst _ _ _ _ /.
<span class="kn">Definition</span> <span class="nf">fctWE</span> := (fctD, fctN, fctM, fctZ).

<span class="kn">Section</span> <span class="nf">ring</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">aT</span> : measurableType d) (<span class="nv">rT</span> : realType).

<span class="kn">Lemma</span> <span class="nf">sfun_subring_closed</span> : subring_closed (@sfun d aT rT).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>=&gt; [|f g|f g]; <span class="nb">rewrite</span> <span class="nl">?inE</span>/= <span class="nl">?rpred1</span>//;
   <span class="nb">move</span>=&gt; /andP[/= mf ff] /andP[/= mg fg]; <span class="nb">rewrite</span> !(rpredB, rpredM).
<span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">sfun_add</span> := AddrPred sfun_subring_closed.
<span class="kn">Canonical</span> <span class="nf">sfun_zmod</span> := ZmodPred sfun_subring_closed.
<span class="kn">Canonical</span> <span class="nf">sfun_mul</span> := MulrPred sfun_subring_closed.
<span class="kn">Canonical</span> <span class="nf">sfun_subring</span> := SubringPred sfun_subring_closed.
<span class="kn">Definition</span> <span class="nf">sfun_zmodMixin</span> := [zmodMixin of {sfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">sfun_zmodType</span> := ZmodType {sfun aT &gt;-&gt; rT} sfun_zmodMixin.
<span class="kn">Definition</span> <span class="nf">sfun_ringMixin</span> := [ringMixin of {sfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">sfun_ringType</span> := RingType {sfun aT &gt;-&gt; rT} sfun_ringMixin.
<span class="kn">Definition</span> <span class="nf">sfun_comRingMixin</span> := [comRingMixin of {sfun aT &gt;-&gt; rT} <span class="bp">by</span> &lt;:].
<span class="kn">Canonical</span> <span class="nf">sfun_comRingType</span> := ComRingType {sfun aT &gt;-&gt; rT} sfun_comRingMixin.

<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : {sfun aT &gt;-&gt; rT}).

<span class="kn">Lemma</span> <span class="nf">sfun0</span> : (<span class="mi">0</span> : {sfun aT &gt;-&gt; rT}) =<span class="mi">1</span> cst <span class="mi">0</span>. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">sfun1</span> : (<span class="mi">1</span> : {sfun aT &gt;-&gt; rT}) =<span class="mi">1</span> cst <span class="mi">1</span>. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">sfunN</span> <span class="nv">f</span> : - f =<span class="mi">1</span> \- f. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">sfunD</span> <span class="nv">f</span> <span class="nv">g</span> : f + g =<span class="mi">1</span> f \+ g. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">sfunB</span> <span class="nv">f</span> <span class="nv">g</span> : f - g =<span class="mi">1</span> f \- g. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">sfunM</span> <span class="nv">f</span> <span class="nv">g</span> : f * g =<span class="mi">1</span> f \* g. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">sfun_sum</span> <span class="nv">I</span> <span class="nv">r</span> (<span class="nv">P</span> : {pred I}) (<span class="nv">f</span> : I -&gt; {sfun aT &gt;-&gt; rT}) (<span class="nv">x</span> : aT) :
  (\sum_(i &lt;- r | P i) f i) x = \sum_(i &lt;- r | P i) f i x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">elim</span>/big_rec2: _ =&gt; //= i y ? Pi &lt;-. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">sfun_prod</span> <span class="nv">I</span> <span class="nv">r</span> (<span class="nv">P</span> : {pred I}) (<span class="nv">f</span> : I -&gt; {sfun aT &gt;-&gt; rT}) (<span class="nv">x</span> : aT) :
  (\sum_(i &lt;- r | P i) f i) x = \sum_(i &lt;- r | P i) f i x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">elim</span>/big_rec2: _ =&gt; //= i y ? Pi &lt;-. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">sfunX</span> <span class="nv">f</span> <span class="nv">n</span> : f ^+ n =<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x ^+ n).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">elim</span>: n =&gt; [|n IHn]//; <span class="nb">rewrite</span> !exprS sfunM/= IHn. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := MeasurableFun.copy (f \+ g) (f + g).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := MeasurableFun.copy (\- f) (- f).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := MeasurableFun.copy (f \- g) (f - g).
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := MeasurableFun.copy (f \* g) (f * g).

<span class="kn">Definition</span> <span class="nf">indic_sfun</span> (<span class="nv">D</span> : <span class="nb">set</span> aT) (<span class="nv">mD</span> : measurable D) :=
  [the {sfun aT &gt;-&gt; rT} of mindic rT mD].

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">k</span> <span class="nv">f</span> := MeasurableFun.copy (k \o* f) (f * cst_sfun k).
<span class="kn">Definition</span> <span class="nf">scale_sfun</span> <span class="nv">k</span> <span class="nv">f</span> := [the {sfun aT &gt;-&gt; rT} of k \o* f].

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">f</span> <span class="nv">g</span> := max_mfun_subproof f g.
<span class="kn">Definition</span> <span class="nf">max_sfun</span> <span class="nv">f</span> <span class="nv">g</span> := [the {sfun aT &gt;-&gt; _} of f \max g].

<span class="kn">End</span> <span class="nf">ring</span>.
<span class="kn">Arguments</span> indic_sfun {d aT rT} _.

<span class="kn">Lemma</span> <span class="nf">fset_set_comp</span> (<span class="nv">T1</span> : <span class="kt">Type</span>) (<span class="nv">T2</span> <span class="nv">T3</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> T1)
    (<span class="nv">f</span> : {fimfun T1 &gt;-&gt; T2}) (<span class="nv">g</span> : T2 -&gt; T3) :
  fset_set [<span class="nb">set</span> (g \o f) x | x <span class="kr">in</span> D] =
  [fset g x | x <span class="kr">in</span> fset_set [<span class="nb">set</span> f x | x <span class="kr">in</span> D]]%fset.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -(image_comp f g) fset_set_image. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">preimage_nnfun0</span> <span class="nv">T</span> (<span class="nv">R</span> : realDomainType) (<span class="nv">f</span> : {nnfun T &gt;-&gt; R}) <span class="nv">t</span> :
  t &lt; <span class="mi">0</span> -&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> t] = set0.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; t0.
<span class="bp">by</span> <span class="nb">apply</span>/preimage10 =&gt; -[x _]; <span class="nb">apply</span>: contraPnot t0 =&gt; &lt;-; <span class="nb">rewrite</span> le_gtF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">preimage_cstM</span> <span class="nv">T</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">x</span> <span class="nv">y</span> : R) (<span class="nv">f</span> : T -&gt; R) :
  x != <span class="mi">0</span> -&gt; (cst x \* f) @^-<span class="mi">1</span>` [<span class="nb">set</span> y] = f @^-<span class="mi">1</span>` [<span class="nb">set</span> y / x].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x0; <span class="nb">apply</span>/seteqP; <span class="nb">rewrite</span> /preimage; <span class="nb">split</span> =&gt; [z/= &lt;-|z/= -&gt;].
  <span class="bp">by</span> <span class="nb">rewrite</span> mulrAC divrr <span class="nl">?mul1r</span>// unitfE.
<span class="bp">by</span> <span class="nb">rewrite</span> mulrCA divrr <span class="nl">?mulr1</span>// unitfE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">preimage_add</span> <span class="nv">T</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; R) <span class="nv">z</span> :
  (f \+ g) @^-<span class="mi">1</span>` [<span class="nb">set</span> z] = \bigcup_(a <span class="kr">in</span> f @` setT)
    ((f @^-<span class="mi">1</span>` [<span class="nb">set</span> a]) `&amp;` (g @^-<span class="mi">1</span>` [<span class="nb">set</span> z - a])).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [x /= fgz|x [_ /= [y _ &lt;-]] []].
  <span class="nb">have</span> : z - f x \<span class="kr">in</span> g @` setT.
    <span class="bp">by</span> <span class="nb">rewrite</span> inE /=; <span class="kr">exists</span> <span class="nv">x</span>=&gt; //; <span class="nb">rewrite</span> -fgz addrC addKr.
  <span class="nb">rewrite</span> inE /= =&gt; -[x&#39; _ gzf]; <span class="kr">exists</span> (<span class="nv">z</span> - g x&#39;)%R =&gt; /=.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; <span class="nb">rewrite</span> gzf opprB addrC subrK.
  <span class="nb">rewrite</span> /preimage /=; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> gzf opprB addrC subrK.
  <span class="bp">by</span> <span class="nb">rewrite</span> gzf opprB addrC subrK -fgz addrC addKr.
<span class="nb">rewrite</span> /preimage /= =&gt; [fxfy gzf].
<span class="bp">by</span> <span class="nb">rewrite</span> gzf -fxfy addrC subrK.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">nnsfun_functions</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).

<span class="kn">Lemma</span> <span class="nf">cst_nnfun_subproof</span> (<span class="nv">x</span> : {nonneg R}) : @isNonNegFun T R (cst x%:num).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; /=. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">x</span> := @cst_nnfun_subproof x.

<span class="kn">Definition</span> <span class="nf">cst_nnsfun</span> (<span class="nv">r</span> : {nonneg R}) := [the {nnsfun T &gt;-&gt; R} of cst r%:num].

<span class="kn">Definition</span> <span class="nf">nnsfun0</span> : {nnsfun T &gt;-&gt; R} := cst_nnsfun <span class="mi">0</span>%R%:nng.

<span class="kn">Lemma</span> <span class="nf">indic_nnfun_subproof</span> (<span class="nv">D</span> : <span class="nb">set</span> T) : @isNonNegFun T R (\<span class="mi">1_</span>D).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; //=; <span class="nb">rewrite</span> /indic. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">D</span> := @indic_nnfun_subproof D.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> <span class="nv">D</span> (<span class="nv">mD</span> : measurable D) :
   @NonNegFun T R (mindic R mD) := NonNegFun.on (mindic R mD).

<span class="kn">End</span> <span class="nf">nnsfun_functions</span>.
<span class="kn">Arguments</span> nnsfun0 {d T R}.

<span class="kn">Section</span> <span class="nf">nnfun_bin</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : numDomainType) (<span class="nv">f</span> <span class="nv">g</span> : {nnfun T &gt;-&gt; R}).

<span class="kn">Lemma</span> <span class="nf">add_nnfun_subproof</span> : @isNonNegFun T R (f \+ g).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span> =&gt; x; <span class="nb">rewrite</span> addr_ge0//; <span class="nb">apply</span>/fun_ge0. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := add_nnfun_subproof.

<span class="kn">Lemma</span> <span class="nf">mul_nnfun_subproof</span> : @isNonNegFun T R (f \* g).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span> =&gt; x; <span class="nb">rewrite</span> mulr_ge0//; <span class="nb">apply</span>/fun_ge0. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := mul_nnfun_subproof.

<span class="kn">Lemma</span> <span class="nf">max_nnfun_subproof</span> : @isNonNegFun T R (f \max g).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span> =&gt; x /=; <span class="nb">rewrite</span> /maxr; <span class="nb">case</span>: ifPn =&gt; _; <span class="nb">apply</span>: fun_ge0. <span class="kn">Qed</span>.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := max_nnfun_subproof.

<span class="kn">End</span> <span class="nf">nnfun_bin</span>.

<span class="kn">Section</span> <span class="nf">nnsfun_bin</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> <span class="nv">f</span> <span class="nv">g</span> : {nnsfun T &gt;-&gt; R}.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := MeasurableFun.on (f \+ g).
<span class="kn">Definition</span> <span class="nf">add_nnsfun</span> := [the {nnsfun T &gt;-&gt; R} of f \+ g].

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := MeasurableFun.on (f \* g).
<span class="kn">Definition</span> <span class="nf">mul_nnsfun</span> := [the {nnsfun T &gt;-&gt; R} of f \* g].

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := MeasurableFun.on (f \max g).
<span class="kn">Definition</span> <span class="nf">max_nnsfun</span> := [the {nnsfun T &gt;-&gt; R} of f \max g].

<span class="kn">Definition</span> <span class="nf">indic_nnsfun</span> <span class="nv">A</span> (<span class="nv">mA</span> : measurable A) := [the {nnsfun T &gt;-&gt; R} of mindic R mA].

<span class="kn">End</span> <span class="nf">nnsfun_bin</span>.
<span class="kn">Arguments</span> add_nnsfun {d T R} _ _.
<span class="kn">Arguments</span> mul_nnsfun {d T R} _ _.
<span class="kn">Arguments</span> max_nnsfun {d T R} _ _.

<span class="kn">Section</span> <span class="nf">nnsfun_iter</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType) (<span class="nv">D</span> : <span class="nb">set</span> T).
<span class="kn">Variable</span> <span class="nv">f</span> : {nnsfun T &gt;-&gt; R}^nat.

<span class="kn">Definition</span> <span class="nf">sum_nnsfun</span> <span class="nv">n</span> := \big[add_nnsfun/nnsfun0]_(i &lt; n) f i.

<span class="kn">Lemma</span> <span class="nf">sum_nnsfunE</span> <span class="nv">n</span> <span class="nv">t</span> : sum_nnsfun n t = \sum_(i &lt; n) (f i t).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /sum_nnsfun; <span class="nb">elim</span>/big_ind2 : _ =&gt; [|x g y h &lt;- &lt;-|]. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">bigmax_nnsfun</span> <span class="nv">n</span> := \big[max_nnsfun/nnsfun0]_(i &lt; n) f i.

<span class="kn">Lemma</span> <span class="nf">bigmax_nnsfunE</span> <span class="nv">n</span> <span class="nv">t</span> : bigmax_nnsfun n t = \big[maxr/<span class="mi">0</span>]_(i &lt; n) (f i t).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /bigmax_nnsfun; <span class="nb">elim</span>/big_ind2 : _ =&gt; [|x g y h &lt;- &lt;-|]. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">nnsfun_iter</span>.

<span class="kn">Section</span> <span class="nf">nnsfun_cover</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">f</span> : {nnsfun T &gt;-&gt; R}.

<span class="kn">Lemma</span> <span class="nf">nnsfun_cover</span> :
  \big[setU/set0]_(i \<span class="kr">in</span> range f) (f @^-<span class="mi">1</span>` [<span class="nb">set</span> i]) = setT.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> fsbig_setU//= -subTset =&gt; x _; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">x</span>). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nnsfun_coverT</span> :
  \big[setU/set0]_(i \<span class="kr">in</span> [<span class="nb">set</span>: R]) (f @^-<span class="mi">1</span>` [<span class="nb">set</span> i]) = setT.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -(fsbig_widen (range f)) <span class="nl">?nnsfun_cover</span>//= =&gt; x [_ /= /preimage10-&gt;].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">nnsfun_cover</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (measurable (_ @^-<span class="mi">1</span>` [<span class="nb">set</span> _])) =&gt;
  <span class="kp">solve</span> [<span class="nb">apply</span>: measurable_sfunP; <span class="bp">exact</span>: measurable_set1] : core.

<span class="kn">Lemma</span> <span class="nf">measurable_sfun_inP</span> {<span class="nv">d</span>} {<span class="nv">aT</span> : measurableType d} {<span class="nv">rT</span> : realType}
   (<span class="nv">f</span> : {mfun aT &gt;-&gt; rT}) <span class="nv">D</span> (<span class="nv">y</span> : rT) :
  measurable D -&gt; measurable (D `&amp;` f @^-<span class="mi">1</span>` [<span class="nb">set</span> y]).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Dm; <span class="nb">apply</span>: measurableI. <span class="kn">Qed</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (measurable (_ `&amp;` _ @^-<span class="mi">1</span>` [<span class="nb">set</span> _])) =&gt;
  <span class="kp">solve</span> [<span class="nb">apply</span>: measurable_sfun_inP; <span class="bp">assumption</span>] : core.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (finite_set _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: fimfunP] : core.

<span class="kn">Section</span> <span class="nf">measure_fsbig</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">measure_fsbig</span> (<span class="nv">I</span> : choiceType) (<span class="nv">A</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
  finite_set A -&gt;
  (<span class="kr">forall</span> <span class="nv">i</span>, A i -&gt; measurable (F i)) -&gt; trivIset A F -&gt;
  m (\big[setU/set0]_(i \<span class="kr">in</span> A) F i) = \sum_(i \<span class="kr">in</span> A) m (F i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Afin Fm Ft.
<span class="bp">by</span> <span class="nb">rewrite</span> fsbig_finite// -measure_fin_bigcup// -bigsetU_fset_set.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">additive_nnsfunr</span> (<span class="nv">g</span> <span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) <span class="nv">x</span> :
  \sum_(i \<span class="kr">in</span> range g) m (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x] `&amp;` (g @^-<span class="mi">1</span>` [<span class="nb">set</span> i])) =
  m (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x] `&amp;` \big[setU/set0]_(i \<span class="kr">in</span> range g) (g @^-<span class="mi">1</span>` [<span class="nb">set</span> i])).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -<span class="nl">?measure_fsbig</span>//.
- <span class="bp">by</span> <span class="nb">rewrite</span> !fsbig_finite//= big_distrr//.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; i Ai; <span class="nb">apply</span>: measurableI =&gt; //.
- <span class="bp">exact</span>/trivIset_setIl/trivIset_preimage1.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">additive_nnsfunl</span> (<span class="nv">g</span> <span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) <span class="nv">x</span> :
  \sum_(i \<span class="kr">in</span> range g) m (g @^-<span class="mi">1</span>` [<span class="nb">set</span> i] `&amp;` (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x])) =
  m (\big[setU/set0]_(i \<span class="kr">in</span> range g) (g @^-<span class="mi">1</span>` [<span class="nb">set</span> i]) `&amp;` f @^-<span class="mi">1</span>` [<span class="nb">set</span> x]).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">under</span> eq_fsbigr <span class="kp">do</span> <span class="nb">rewrite</span> setIC; <span class="nb">rewrite</span> setIC additive_nnsfunr. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measure_fsbig</span>.

<span class="kn">Section</span> <span class="nf">mulem_ge0</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Let</span> <span class="nf">mulef_ge0</span> (<span class="nv">R</span> : realDomainType) <span class="nv">x</span> (<span class="nv">f</span> : R -&gt; \bar R) :
  <span class="mi">0</span> &lt;= f x -&gt; ((x &lt; <span class="mi">0</span>)%R -&gt; f x = <span class="mi">0</span>) -&gt; <span class="mi">0</span> &lt;= x%:E * f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A0 xA /=; <span class="nb">have</span> [x0|x0] := ltP x <span class="mi">0</span>%R; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> (xA x0) mule0.
<span class="bp">by</span> <span class="nb">rewrite</span> mule_ge0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nnfun_muleindic_ge0</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realDomainType)
  (<span class="nv">f</span> : {nnfun T &gt;-&gt; R}) <span class="nv">r</span> <span class="nv">z</span> : <span class="mi">0</span> &lt;= r%:E * (\<span class="mi">1_</span>(f @^-<span class="mi">1</span>` [<span class="nb">set</span> r]) z)%:E.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (@mulef_ge0 _ _ (<span class="kr">fun</span> <span class="nv">r</span> =&gt; (\<span class="mi">1_</span>(f @^-<span class="mi">1</span>` [<span class="nb">set</span> r]) z)%:E)).
  <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin// indicE.
<span class="bp">by</span> <span class="nb">move</span>=&gt; r0; <span class="nb">rewrite</span> preimage_nnfun0// indic0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mulemu_ge0</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) <span class="nv">x</span> (<span class="nv">A</span> : R -&gt; <span class="nb">set</span> T) :
  ((x &lt; <span class="mi">0</span>)%R -&gt; A x = set0) -&gt; <span class="mi">0</span> &lt;= x%:E * mu (A x).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; xA; <span class="nb">rewrite</span> (@mulef_ge0 _ _ (mu \o _))//= =&gt; /xA -&gt;; <span class="nb">rewrite</span> measure0.
<span class="kn">Qed</span>.
<span class="kn">Global</span> <span class="kn">Arguments</span> mulemu_ge0 {d T R mu x} A.

<span class="kn">Lemma</span> <span class="nf">nnsfun_mulemu_ge0</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) <span class="nv">x</span> :
  <span class="mi">0</span> &lt;= x%:E * mu (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x]).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>: (mulemu_ge0 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> x])); <span class="bp">exact</span>: preimage_nnfun0.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">mulem_ge0</span>.

<span class="sd">(**********************************)</span>
<span class="c">(* Definition of Simple Integrals *)</span>
<span class="sd">(**********************************)</span>

<span class="kn">Section</span> <span class="nf">simple_fun_raw_integral</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : numDomainType) (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) (<span class="nv">f</span> : T -&gt; R).

<span class="kn">Definition</span> <span class="nf">sintegral</span> := \sum_(x \<span class="kr">in</span> [<span class="nb">set</span>: R]) x%:E * mu (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x]).

<span class="kn">Lemma</span> <span class="nf">sintegralET</span> :
  sintegral = \sum_(x \<span class="kr">in</span> [<span class="nb">set</span>: R]) x%:E * mu (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x]).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">simple_fun_raw_integral</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="mi">0</span> &lt;= (_ : {<span class="kn">measure</span> <span class="nb">set</span> _ -&gt; \bar _}) _)%E) =&gt;
  <span class="kp">solve</span> [<span class="nb">apply</span>: measure_ge0] : core.

<span class="kn">Section</span> <span class="nf">sintegral_lemmas</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">sintegralE</span> <span class="nv">f</span> :
  sintegral mu f = \sum_(x \<span class="kr">in</span> range f) x%:E * mu (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x]).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (fsbig_widen (range f) setT)//= =&gt; x [_ Nfx] /=.
<span class="bp">by</span> <span class="nb">rewrite</span> preimage10// measure0 mule0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sintegral0</span> : sintegral mu (cst <span class="mi">0</span>%R) = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> sintegralE fsbig1// =&gt; r _; <span class="nb">rewrite</span> preimage_cst.
<span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; [/[!inE] &lt;-|]; <span class="nb">rewrite</span> <span class="nl">?mul0e</span>// measure0 mule0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sintegral_ge0</span> (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) : <span class="mi">0</span> &lt;= sintegral mu f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> sintegralE fsume_ge0// =&gt; r _; <span class="bp">exact</span>: nnsfun_mulemu_ge0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sintegral_indic</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : sintegral mu \<span class="mi">1_</span>A = mu A.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> sintegralE (fsbig_widen _ [<span class="nb">set</span> <span class="mi">0</span>%R; <span class="mi">1</span>%R]) =&gt; //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="bp">exact</span>: image_indic_sub.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; t [[] -&gt; /= /preimage10-&gt;]; <span class="nb">rewrite</span> measure0 mule0.
<span class="nb">have</span> N01 : (<span class="mi">0</span> &lt;&gt; <span class="mi">1</span>:&gt; R)%R <span class="bp">by</span> <span class="nb">move</span>=&gt; /esym/eqP; <span class="nb">rewrite</span> oner_eq0.
<span class="nb">rewrite</span> fsbigU//=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; t [-&gt;]//.
<span class="nb">rewrite</span> !fsbig_set1 mul0e add0e mul1e.
<span class="bp">by</span> <span class="nb">rewrite</span> preimage_indic ifT <span class="nl">?inE</span>// ifN <span class="nl">?notin_set</span>.
<span class="kn">Qed</span>.

<span class="c">(* NB: not used *)</span>
<span class="kn">Lemma</span> <span class="nf">sintegralEnnsfun</span> (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) : sintegral mu f =
  (\sum_(x \<span class="kr">in</span> [<span class="nb">set</span> r | r &gt; <span class="mi">0</span>]%R) (x%:E * mu (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x])))%E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (fsbig_widen _ setT) <span class="nl">?sintegralET</span>//.
<span class="nb">move</span>=&gt; x [_ /=]; <span class="nb">case</span>: ltgtP =&gt; //= [xlt0 _|&lt;-]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> mul0e.
<span class="nb">rewrite</span> preimage10 <span class="nl">?measure0</span> <span class="nl">?mule0</span>//= =&gt; -[t _].
<span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">apply</span>: contra_ltN xlt0 =&gt; /eqP&lt;-.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sintegral_lemmas</span>.

<span class="kn">Lemma</span> <span class="nf">eq_sintegral</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : numDomainType)
     (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) <span class="nv">g</span> <span class="nv">f</span> :
   f =<span class="mi">1</span> g -&gt; sintegral mu f = sintegral mu g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /funext-&gt;. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> eq_sintegral {d T R mu} g.

<span class="kn">Section</span> <span class="nf">sintegralrM</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">m</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">r</span> : R) (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}).

<span class="kn">Lemma</span> <span class="nf">sintegralrM</span> : sintegral m (cst r \* f)%R = r%:E * sintegral m f.
<span class="kn">Proof</span>.
<span class="nb">have</span> [-&gt;|r0] := eqVneq r <span class="mi">0</span>%R.
  <span class="bp">by</span> <span class="nb">rewrite</span> mul0e (eq_sintegral (cst <span class="mi">0</span>%R)) <span class="nl">?sintegral0</span>// =&gt; x/=; <span class="nb">rewrite</span> mul0r.
<span class="nb">rewrite</span> !sintegralET.
<span class="nb">transitivity</span> (\sum_(x \<span class="kr">in</span> [<span class="nb">set</span>: R]) x%:E * m (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x / r])).
  <span class="bp">by</span> <span class="nb">under</span> eq_fsbigr <span class="kp">do</span> <span class="nb">rewrite</span> preimage_cstM//.
<span class="nb">transitivity</span> (\sum_(x \<span class="kr">in</span> [<span class="nb">set</span>: R]) r%:E * (x%:E * m (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x]))).
  <span class="nb">rewrite</span> (reindex_fsbigT (<span class="kr">fun</span> <span class="nv">x</span> =&gt; r * x)%R)//; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="kr">exists</span> ( *%R r ^-<span class="mi">1</span>)%R; [<span class="bp">exact</span>: mulKf|<span class="bp">exact</span>: mulVKf].
  <span class="bp">by</span> <span class="nb">apply</span>: eq_fsbigr =&gt; x; <span class="nb">rewrite</span> mulrAC divrr <span class="nl">?unitfE</span>// mul1r muleA EFinM.
<span class="bp">by</span> <span class="nb">rewrite</span> ge0_mule_fsumr// =&gt; x; <span class="bp">exact</span>: nnsfun_mulemu_ge0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sintegralrM</span>.

<span class="kn">Section</span> <span class="nf">sintegralD</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">m</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">f</span> <span class="nv">g</span> : {nnsfun T &gt;-&gt; R}).

<span class="kn">Lemma</span> <span class="nf">sintegralD</span> : sintegral m (f \+ g)%R = sintegral m f + sintegral m g.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> !sintegralE; <span class="nb">set</span> F := f @` _; <span class="nb">set</span> G := g @` _; <span class="nb">set</span> FG := _ @` _.
<span class="nb">pose</span> pf x := f @^-<span class="mi">1</span>` [<span class="nb">set</span> x]; <span class="nb">pose</span> pg y := g @^-<span class="mi">1</span>` [<span class="nb">set</span> y].
<span class="nb">transitivity</span> (\sum_(z \<span class="kr">in</span> FG) z%:E * \sum_(a \<span class="kr">in</span> F) m (pf a `&amp;` pg (z - a)%R)).
  <span class="nb">apply</span>: eq_fsbigr =&gt; z _; <span class="nb">rewrite</span> preimage_add -fsbig_setU// measure_fsbig//.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; x Fx; <span class="bp">exact</span>: measurableI.
  <span class="bp">exact</span>/trivIset_setIr/trivIset_preimage1.
<span class="nb">under</span> eq_fsbigr <span class="kp">do</span> <span class="nb">rewrite</span> ge0_mule_fsumr//; <span class="nb">rewrite</span> exchange_fsbig//.
<span class="nb">transitivity</span> (\sum_(x \<span class="kr">in</span> F) \sum_(y \<span class="kr">in</span> G) (x + y)%:E * m (pf x `&amp;` pg y)).
  <span class="nb">apply</span>: eq_fsbigr =&gt; x _; <span class="nb">rewrite</span> /pf /pg (fsbig_widen G setT)//=; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; y [_ /= /preimage10-&gt;]; <span class="nb">rewrite</span> setI0 measure0 mule0.
  <span class="nb">rewrite</span> (fsbig_widen FG setT)//=; <span class="nb">last first</span>.
    <span class="nb">move</span>=&gt; z [_ /= FGz]; <span class="nb">rewrite</span> [X <span class="kr">in</span> m X](_ : _ = set0) <span class="nl">?measure0</span> <span class="nl">?mule0</span>//.
    <span class="nb">rewrite</span> -subset0 =&gt; //= {x}i /= [&lt;-] /(canLR (@addrNK _ _)).
    <span class="bp">by</span> <span class="nb">apply</span>: contra_not FGz =&gt; &lt;-; <span class="kr">exists</span> <span class="nv">i</span>; <span class="nb">rewrite</span> //= addrC.
  <span class="nb">rewrite</span> (reindex_fsbigT (+%R x))//=.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_fsbigr =&gt; y; <span class="nb">rewrite</span> addrC addrK.
<span class="nb">transitivity</span> (\sum_(x \<span class="kr">in</span> F) \sum_(y \<span class="kr">in</span> G) x%:E * m (pf x `&amp;` pg y) +
              \sum_(x \<span class="kr">in</span> F) \sum_(y \<span class="kr">in</span> G) y%:E * m (pf x `&amp;` pg y)).
  <span class="kp">do</span> <span class="mi">2</span>![<span class="nb">rewrite</span> -fsbig_split//; <span class="nb">apply</span>: eq_fsbigr =&gt; _ /set_mem [? _ &lt;-]].
  <span class="bp">by</span> <span class="nb">rewrite</span> EFinD ge0_muleDl// <span class="nl">?lee_fin</span>.
<span class="nb">congr</span> (_ + _)%E; <span class="nb">last</span> <span class="nb">rewrite</span> exchange_fsbig//; <span class="nb">apply</span>: eq_fsbigr =&gt; x _.
  <span class="bp">by</span> <span class="nb">rewrite</span> -ge0_mule_fsumr// additive_nnsfunr nnsfun_cover setIT.
<span class="bp">by</span> <span class="nb">rewrite</span> -ge0_mule_fsumr// additive_nnsfunl nnsfun_cover setTI.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sintegralD</span>.

<span class="kn">Section</span> <span class="nf">le_sintegral</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType) (<span class="nv">m</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).
<span class="kn">Variables</span> <span class="nv">f</span> <span class="nv">g</span> : {nnsfun T &gt;-&gt; R}.
<span class="kn">Hypothesis</span> <span class="nv">fg</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x &lt;= g x.

<span class="kn">Let</span> <span class="nf">fgnn</span> : @isNonNegFun T R (g \- f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; x; <span class="nb">rewrite</span> subr_ge0 fg. <span class="kn">Qed</span>.
#[local] HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := fgnn.

<span class="kn">Lemma</span> <span class="nf">le_sintegral</span> : (sintegral m f &lt;= sintegral m g)%E.
<span class="kn">Proof</span>.
<span class="nb">have</span> gfgf : g =<span class="mi">1</span> f \+ (g \- f) <span class="bp">by</span> <span class="nb">move</span>=&gt; x /=; <span class="nb">rewrite</span> addrC subrK.
<span class="bp">by</span> <span class="nb">rewrite</span> (eq_sintegral _ _ gfgf) sintegralD// lee_addl // sintegral_ge0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">le_sintegral</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_sintegral</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
  (<span class="nv">m</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}^nat) :
  (<span class="kr">forall</span> <span class="nv">x</span>, nondecreasing_seq (f ^~ x)) -&gt; cvg (sintegral m \o f).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; nd_f; <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="nb">apply</span>/ereal_nondecreasing_cvg =&gt; a b ab.
<span class="bp">by</span> <span class="nb">apply</span>: le_sintegral =&gt; // =&gt; x; <span class="bp">exact</span>/nd_f.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">proj_nnsfun</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">mA</span> : measurable A) :=
  mul_nnsfun f (indic_nnsfun R mA).

<span class="kn">Definition</span> <span class="nf">mrestrict</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType) (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R})
  <span class="nv">A</span> (<span class="nv">mA</span> : measurable A) : f \_ A = proj_nnsfun f mA.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/funext =&gt; x /=; <span class="nb">rewrite</span> /patch mindicE.
<span class="bp">by</span> <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> (mulr0, mulr1).
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">scale_nnsfun</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) (<span class="nv">k</span> : R) (<span class="nv">k0</span> : <span class="mi">0</span> &lt;= k) :=
  mul_nnsfun (cst_nnsfun T (NngNum k0)) f.

<span class="kn">Section</span> <span class="nf">sintegral_nondecreasing_limit_lemma</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Variables</span> (<span class="nv">g</span> : {nnsfun T &gt;-&gt; R}^nat) (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}).
<span class="kn">Hypothesis</span> <span class="nv">nd_g</span> : <span class="kr">forall</span> <span class="nv">x</span>, nondecreasing_seq (g^~ x).
<span class="kn">Hypothesis</span> <span class="nv">gf</span> : <span class="kr">forall</span> <span class="nv">x</span>, cvg (g^~ x) -&gt; f x &lt;= lim (g^~ x).

<span class="kn">Let</span> <span class="nf">fleg</span> <span class="nv">c</span> : (<span class="nb">set</span> T)^nat := <span class="kr">fun</span> <span class="nv">n</span> =&gt; [<span class="nb">set</span> x | c * f x &lt;= g n x].

<span class="kn">Let</span> <span class="nf">nd_fleg</span> <span class="nv">c</span> : {homo fleg c : n m / (n &lt;= m)%N &gt;-&gt; (n &lt;= m)%O}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; n m nm; <span class="nb">rewrite</span> /fleg; <span class="nb">apply</span>/subsetPset =&gt; x /= cfg.
<span class="bp">by</span> <span class="nb">move</span>: cfg =&gt; /le_trans; <span class="nb">apply</span>; <span class="bp">exact</span>: nd_g.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mfleg</span> <span class="nv">c</span> <span class="nv">n</span> : measurable (fleg c n).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /fleg [X <span class="kr">in</span> _ X](_ : _ = \big[setU/set0]_(y &lt;- fset_set (range f))
    \big[setU/set0]_(x &lt;- fset_set (range (g n)) | c * y &lt;= x)
      (f @^-<span class="mi">1</span>` [<span class="nb">set</span> y] `&amp;` (g n @^-<span class="mi">1</span>` [<span class="nb">set</span> x]))).
  <span class="nb">apply</span>: bigsetU_measurable =&gt; r _; <span class="nb">apply</span>: bigsetU_measurable =&gt; r&#39; crr&#39;.
  <span class="bp">exact</span>/measurableI/measurable_sfunP.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [/= cfgn|].
- <span class="nb">rewrite</span> -bigcup_set; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">t</span>); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /= in_fset_set//= mem_set.
  <span class="nb">rewrite</span> -bigcup_set_cond; <span class="kr">exists</span> (<span class="nv">g</span> <span class="nv">n</span> <span class="nv">t</span>) =&gt; //=.
  <span class="bp">by</span> <span class="nb">rewrite</span> in_fset_set// mem_set.
- <span class="nb">rewrite</span> bigsetU_fset_set// =&gt; -[r [x _ fxr]].
  <span class="nb">rewrite</span> bigsetU_fset_set_cond// =&gt; -[r&#39; [[x&#39; _ gnx&#39;r&#39;] crr&#39;]].
  <span class="bp">by</span> <span class="nb">rewrite</span> /preimage/= =&gt; -[-&gt; -&gt;].
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">g1</span> <span class="nv">c</span> <span class="nv">n</span> : {nnsfun T &gt;-&gt; R} := proj_nnsfun f (mfleg c n).

<span class="kn">Let</span> <span class="nf">le_ffleg</span> <span class="nv">c</span> : {homo (<span class="kr">fun</span> <span class="nv">p</span> <span class="nv">x</span> =&gt; g1 c p x): m n / (m &lt;= n)%N &gt;-&gt; (m &lt;= n)%O}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>/asboolP =&gt; t; <span class="nb">rewrite</span> /g1/= ler_pmul// <span class="mi">2</span>!mindicE/= ler_nat.
<span class="nb">have</span> [|//] := boolP (t \<span class="kr">in</span> fleg c m); <span class="nb">rewrite</span> inE =&gt; cnt.
<span class="bp">by</span> <span class="nb">have</span> := nd_fleg c mn =&gt; /subsetPset/(_ _ cnt) cmt; <span class="nb">rewrite</span> mem_set.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">bigcup_fleg</span> <span class="nv">c</span> : c &lt; <span class="mi">1</span> -&gt; \bigcup_n fleg c n = setT.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; c1; <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; // _.
<span class="nb">have</span> := @fun_ge0 _ _ f x; <span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[|] gx0.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">O</span> =&gt; //; <span class="nb">rewrite</span> /fleg /=; <span class="nb">rewrite</span> -gx0 mulr0 fun_ge0.
<span class="nb">have</span> [cf|df] := pselect (cvg (g^~ x)).
  <span class="nb">have</span> cfg : lim (g^~ x) &gt; c * f x.
    <span class="bp">by</span> <span class="nb">rewrite</span> (lt_le_trans _ (gf cf)) // gtr_pmull.
  <span class="nb">suff</span> [n cfgn] : <span class="kr">exists</span> <span class="nv">n</span>, g n x &gt;= c * f x <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.
  <span class="nb">move</span>/(@lt_lim _ _ _ (nd_g x) cf) : cfg =&gt; [n _ nf].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>; <span class="nb">apply</span>: nf =&gt; /=.
<span class="nb">have</span> /cvgryPge/(_ (c * f x))[n _ ncfgn]:= nondecreasing_dvg_lt (nd_g x) df.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; //; <span class="nb">rewrite</span> /fleg /=; <span class="nb">apply</span>: ncfgn =&gt; /=.
<span class="kn">Qed</span>.

<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">nd_sintegral_lim_lemma</span> : sintegral mu f &lt;= lim (sintegral mu \o g).
<span class="kn">Proof</span>.
<span class="nb">suff</span> ? : <span class="kr">forall</span> <span class="nv">c</span>, (<span class="mi">0</span> &lt; c &lt; <span class="mi">1</span>)%R -&gt;
    c%:E * sintegral mu f &lt;= lim (sintegral mu \o g).
  <span class="bp">by</span> <span class="nb">apply</span>/lee_mul01Pr =&gt; //; <span class="bp">exact</span>: sintegral_ge0.
<span class="nb">move</span>=&gt; c /andP[c0 c1].
<span class="nb">have</span> cg1g n : c%:E * sintegral mu (g1 c n) &lt;= sintegral mu (g n).
  <span class="nb">rewrite</span> -sintegralrM (_ : (_ \* _)%R = scale_nnsfun (g1 c n) (ltW c0)) //.
  <span class="nb">apply</span>: le_sintegral =&gt; // t.
  <span class="nb">suff</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">x</span>, (c * g1 c m x &lt;= g m x)%R <span class="bp">by</span> <span class="nb">move</span>=&gt; /(_ n t).
  <span class="nb">move</span>=&gt; m x; <span class="nb">rewrite</span> /g1 /proj_nnsfun/= mindicE.
  <span class="bp">by</span> <span class="nb">have</span> [|] := boolP (_ \<span class="kr">in</span> _); [<span class="nb">rewrite</span> inE mulr1|<span class="nb">rewrite</span> <span class="mi">2</span>!mulr0 fun_ge0].
<span class="nb">suff</span> {cg1g}&lt;- : lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; sintegral mu (g1 c n)) = sintegral mu f.
  <span class="nb">have</span> is_cvg_g1 : cvg (<span class="kr">fun</span> <span class="nv">n</span> =&gt; sintegral mu (g1 c n)).
    <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sintegral =&gt; //= x m n /(le_ffleg c)/lefP/(_ x).
  <span class="nb">rewrite</span> -limeMl // lee_lim//; <span class="kp">first</span> <span class="bp">exact</span>: is_cvgeMl.
  - <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sintegral =&gt; // m n mn; <span class="nb">apply</span>/lefP =&gt; t; <span class="nb">apply</span>: nd_g.
  - <span class="bp">by</span> <span class="nb">apply</span>: nearW; <span class="bp">exact</span>: cg1g.
<span class="nb">suff</span> : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; sintegral mu (g1 c n)) --&gt; sintegral mu f <span class="bp">by</span> <span class="nb">apply</span>/cvg_lim.
<span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ = <span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(x &lt;- fset_set (range f))
    x%:E * mu (f @^-<span class="mi">1</span>` [<span class="nb">set</span> x] `&amp;` fleg c n)); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> sintegralE.
  <span class="nb">transitivity</span> (\sum_(x \<span class="kr">in</span> range f) x%:E * mu (g1 c n @^-<span class="mi">1</span>` [<span class="nb">set</span> x])).
    <span class="nb">apply</span>: eq_fbigl =&gt; r.
    <span class="kp">do</span> <span class="mi">2</span> (<span class="nb">rewrite</span> in_finite_support; <span class="nb">last</span> <span class="bp">exact</span>/finite_setIl).
    <span class="nb">apply</span>/idP/idP.
      <span class="nb">rewrite</span> in_setI =&gt; /andP[]; <span class="nb">rewrite</span> inE/= =&gt; -[x _]; <span class="nb">rewrite</span> mindicE.
      <span class="nb">have</span> [_|xcn] := boolP (_ \<span class="kr">in</span> _).
        <span class="bp">by</span> <span class="nb">rewrite</span> mulr1 =&gt; &lt;-; <span class="nb">rewrite</span> !inE/= =&gt; ?; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">x</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> mulr0 =&gt; /esym -&gt;; <span class="nb">rewrite</span> !inE/= mul0e.
    <span class="nb">rewrite</span> in_setI =&gt; /andP[]; <span class="nb">rewrite</span> inE =&gt; -[x _ &lt;-].
    <span class="nb">rewrite</span> !inE/= =&gt; h; <span class="nb">split</span>=&gt; //; <span class="nb">move</span>: h; <span class="nb">rewrite</span> mindicE =&gt; /eqP.
    <span class="nb">rewrite</span> mule_eq0 negb_or =&gt; /andP[_]; <span class="nb">set</span> S := (X <span class="kr">in</span> mu X) =&gt; mS0.
    <span class="nb">suff</span> : S !=set0 <span class="bp">by</span> <span class="nb">move</span>=&gt; [y yx]; <span class="kr">exists</span> <span class="nv">y</span>.
    <span class="bp">by</span> <span class="nb">apply</span>/set0P; <span class="nb">apply</span>: contra mS0 =&gt; /eqP -&gt;; <span class="nb">rewrite</span> measure0.
  <span class="nb">rewrite</span> fsbig_finite//=; <span class="nb">apply</span>: eq_fbigr =&gt; r.
  <span class="nb">rewrite</span> in_fset_set// inE =&gt; -[t _ ftr _].
  <span class="nb">have</span> [-&gt;|r0] := eqVneq r <span class="mi">0</span>%R; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span>!mul0e.
  <span class="nb">congr</span> (_ * mu _); <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; x.
    <span class="nb">rewrite</span> /preimage/= mindicE.
    <span class="nb">have</span> [|_] := boolP (_ \<span class="kr">in</span> _); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> mulr1 inE.
    <span class="bp">by</span> <span class="nb">rewrite</span> mulr0 =&gt; /esym/eqP; <span class="nb">rewrite</span> (negbTE r0).
  <span class="bp">by</span> <span class="nb">rewrite</span> /preimage/= =&gt; -[fxr cnx]; <span class="nb">rewrite</span> mindicE mem_set// mulr1.
<span class="nb">rewrite</span> sintegralE fsbig_finite//=.
<span class="nb">apply</span>: cvg_nnesum=&gt; [r _|r _].
  near=&gt; A; <span class="nb">apply</span>: (mulemu_ge0 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> x] `&amp;` fleg c A)) =&gt; r0.
  <span class="bp">by</span> <span class="nb">rewrite</span> preimage_nnfun0// set0I.
<span class="nb">apply</span>: cvgeMl =&gt; //=; <span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ =
    mu (\bigcup_n (f @^-<span class="mi">1</span>` [<span class="nb">set</span> r] `&amp;` fleg c n))); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -setI_bigcupr bigcup_fleg// setIT.
<span class="nb">have</span> ? k i : measurable (f @^-<span class="mi">1</span>` [<span class="nb">set</span> k] `&amp;` fleg c i) <span class="bp">by</span> <span class="bp">exact</span>: measurableI.
<span class="nb">apply</span>: nondecreasing_cvg_mu; [<span class="bp">by</span> []|<span class="bp">exact</span>: bigcupT_measurable|].
<span class="nb">move</span>=&gt; n m nm; <span class="nb">apply</span>/subsetPset; <span class="nb">apply</span>: setIS.
<span class="bp">by</span> <span class="nb">move</span>/(nd_fleg c) : nm =&gt; /subsetPset.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sintegral_nondecreasing_limit_lemma</span>.

<span class="kn">Section</span> <span class="nf">sintegral_nondecreasing_limit</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Variables</span> (<span class="nv">g</span> : {nnsfun T &gt;-&gt; R}^nat) (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}).
<span class="kn">Hypothesis</span> <span class="nv">nd_g</span> : <span class="kr">forall</span> <span class="nv">x</span>, nondecreasing_seq (g^~ x).
<span class="kn">Hypothesis</span> <span class="nv">gf</span> : <span class="kr">forall</span> <span class="nv">x</span>, g ^~ x --&gt; f x.

<span class="kn">Let</span> <span class="nf">limg</span> <span class="nv">x</span> : lim (g^~x) = f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/cvg_lim; [<span class="bp">exact</span>: Rhausdorff| <span class="bp">exact</span>: gf]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nd_sintegral_lim</span> : sintegral mu f = lim (sintegral mu \o g).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: nd_sintegral_lim_lemma =&gt; // x; <span class="nb">rewrite</span> -limg.
<span class="nb">have</span> : nondecreasing_seq (sintegral mu \o g).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>: le_sintegral =&gt; // x; <span class="bp">exact</span>/nd_g.
<span class="nb">move</span>=&gt; /ereal_nondecreasing_cvg/cvg_lim -&gt; //.
<span class="nb">apply</span>: ub_ereal_sup =&gt; _ [n _ &lt;-] /=; <span class="nb">apply</span>: le_sintegral =&gt; // x.
<span class="nb">rewrite</span> -limg // (nondecreasing_cvg_le (nd_g x)) //.
<span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">x</span>); <span class="bp">exact</span>: gf.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sintegral_nondecreasing_limit</span>.

<span class="kn">Section</span> <span class="nf">integral</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; \bar R) (<span class="nv">D</span> : <span class="nb">set</span> T).

<span class="kn">Let</span> <span class="nf">nnintegral</span> <span class="nv">mu</span> <span class="nv">f</span> := ereal_sup [<span class="nb">set</span> sintegral mu h |
  h <span class="kr">in</span> [<span class="nb">set</span> h : {nnsfun T &gt;-&gt; R} | <span class="kr">forall</span> <span class="nv">x</span>, (h x)%:E &lt;= f x]].

<span class="kn">Definition</span> <span class="nf">integral</span> <span class="nv">mu</span> <span class="nv">D</span> <span class="nv">f</span> (<span class="nv">g</span> := f \_ D) :=
  nnintegral mu (g ^\+) - nnintegral mu (g ^\-).

<span class="kn">Variable</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Let</span> <span class="nf">nnintegral_ge0</span> <span class="nv">f</span> : (<span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= f x) -&gt; <span class="mi">0</span> &lt;= nnintegral mu f.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; f0; <span class="nb">apply</span>: ereal_sup_ub; <span class="kr">exists</span> <span class="nv">nnsfun0</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> sintegral0.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">eq_nnintegral</span> <span class="nv">g</span> <span class="nv">f</span> : f =<span class="mi">1</span> g -&gt; nnintegral mu f = nnintegral mu g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /funext-&gt;. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">nnintegral0</span> : nnintegral mu (cst <span class="mi">0</span>) = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /nnintegral /=; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">apply</span>/ereal_sup_ub; <span class="kr">exists</span> <span class="nv">nnsfun0</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> sintegral0.
  <span class="bp">by</span> [].
<span class="nb">apply</span>/ub_ereal_sup =&gt; /= x [f /= f0 &lt;-]; <span class="nb">have</span> {}f0 : <span class="kr">forall</span> <span class="nv">x</span>, f x = <span class="mi">0</span>%R.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; y; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le -<span class="mi">2</span>!lee_fin f0 //= lee_fin//.
<span class="bp">by</span> <span class="nb">rewrite</span> (eq_sintegral (@nnsfun0 _ T R)) <span class="nl">?sintegral0</span>.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">nnintegral_nnsfun</span> (<span class="nv">h</span> : {nnsfun T &gt;-&gt; R}) :
  nnintegral mu (EFin \o h) = sintegral mu h.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">apply</span>/ub_ereal_sup =&gt; /= _ -[g /= gh &lt;-]; <span class="nb">rewrite</span> le_sintegral.
<span class="bp">by</span> <span class="nb">apply</span>: ereal_sup_ub =&gt; /=; <span class="kr">exists</span> <span class="nv">h</span>.
<span class="kn">Qed</span>.

<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;\int_ ( x &#39;in&#39; D ) F&quot;</span> := (integral mu D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; F))
  (<span class="kn">at level</span> <span class="mi">36</span>, F <span class="kn">at level</span> <span class="mi">36</span>, x, D <span class="kn">at level</span> <span class="mi">50</span>,
  <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \int_ ( x  &#39;in&#39;  D ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).

<span class="kn">Lemma</span> <span class="nf">eq_integral</span> <span class="nv">D</span> <span class="nv">g</span> <span class="nv">f</span> : {<span class="kr">in</span> D, f =<span class="mi">1</span> g} -&gt;
  \int_(x <span class="kr">in</span> D) f x = \int_(x <span class="kr">in</span> D) g x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /integral =&gt; /eq_restrictP-&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ge0_integralE</span> <span class="nv">D</span> <span class="nv">f</span> : (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt;
  \int_(x <span class="kr">in</span> D) f x = nnintegral mu (f \_ D).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0; <span class="nb">rewrite</span> /integral funeneg_restrict funepos_restrict.
<span class="nb">have</span> /eq_restrictP-&gt; := ge0_funeposE f0.
<span class="nb">have</span> /eq_restrictP-&gt; := ge0_funenegE f0.
<span class="bp">by</span> <span class="nb">rewrite</span> erestrict0 nnintegral0 sube0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ge0_integralTE</span> <span class="nv">f</span> : (<span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= f x) -&gt;
  \int_(x <span class="kr">in</span> setT) f x = nnintegral mu f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f0; <span class="nb">rewrite</span> ge0_integralE// patch_setT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integralE</span> <span class="nv">D</span> <span class="nv">f</span> :
  \int_(x <span class="kr">in</span> D) f x = \int_(x <span class="kr">in</span> D) (f ^\+ x) - \int_(x <span class="kr">in</span> D) f ^\- x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> LHS]/integral funepos_restrict funeneg_restrict -!ge0_integralE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral0</span> <span class="nv">D</span> : \int_(x <span class="kr">in</span> D) (cst <span class="mi">0</span> x) = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> ge0_integralE// erestrict0 nnintegral0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral0_eq</span> <span class="nv">D</span> <span class="nv">f</span> :
  (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; f x = <span class="mi">0</span>) -&gt; \int_(x <span class="kr">in</span> D) f x = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0; <span class="nb">under</span> eq_integral; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; x /[<span class="mi">1</span>!inE] /f0 -&gt;; <span class="nb">over</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> integral0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_ge0</span> <span class="nv">D</span> <span class="nv">f</span> : (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt; <span class="mi">0</span> &lt;= \int_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0; <span class="nb">rewrite</span> ge0_integralE// nnintegral_ge0// =&gt; x.
<span class="bp">by</span> <span class="nb">rewrite</span> /patch; <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> // inE =&gt; /f0-&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_nnsfun</span> <span class="nv">D</span> (<span class="nv">mD</span> : measurable D) (<span class="nv">h</span> : {nnsfun T &gt;-&gt; R}) :
  \int_(x <span class="kr">in</span> D) (h x)%:E = sintegral mu (h \_ D).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> mrestrict -nnintegral_nnsfun// -mrestrict ge0_integralE <span class="nl">?comp_patch</span>//.
<span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx /=; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>: fun_ge0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral</span>.

<span class="kn">Notation</span> <span class="s2">&quot;\int [ mu ]_ ( x &#39;in&#39; D ) f&quot;</span> :=
  (integral mu D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f)) : ereal_scope.
<span class="kn">Notation</span> <span class="s2">&quot;\int [ mu ]_ x f&quot;</span> :=
  ((integral mu setT (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f)))%E : ereal_scope.
<span class="kn">Arguments</span> eq_integral {d T R mu D} g.

<span class="kn">Section</span> <span class="nf">eq_measure_integral</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType) (<span class="nv">D</span> : <span class="nb">set</span> T).
<span class="kn">Implicit Types</span> <span class="nv">m</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Let</span> <span class="nf">eq_measure_integral0</span> <span class="nv">m2</span> <span class="nv">m1</span> (<span class="nv">f</span> : T -&gt; \bar R) :
  (<span class="kr">forall</span> <span class="nv">A</span>, measurable A -&gt; A `&lt;=` D -&gt; m1 A = m2 A) -&gt;
  [<span class="nb">set</span> sintegral m1 h | h <span class="kr">in</span>
    [<span class="nb">set</span> h : {nnsfun T &gt;-&gt; R} | (<span class="kr">forall</span> <span class="nv">x</span>, (h x)%:E &lt;= (f \_ D) x)]] `&lt;=`
  [<span class="nb">set</span> sintegral m2 h | h <span class="kr">in</span>
    [<span class="nb">set</span> h : {nnsfun T &gt;-&gt; R} | (<span class="kr">forall</span> <span class="nv">x</span>, (h x)%:E &lt;= (f \_ D) x)]].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; m12 _ [h hfD &lt;-] /=; <span class="kr">exists</span> <span class="nv">h</span> =&gt; //; <span class="nb">apply</span>: eq_fsbigr =&gt; r _.
<span class="nb">have</span> [hrD|hrD] := pselect (h @^-<span class="mi">1</span>` [<span class="nb">set</span> r] `&lt;=` D); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> m12.
<span class="nb">suff</span> : r = <span class="mi">0</span>%R <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">rewrite</span> !mul0e.
<span class="nb">apply</span>: contra_notP hrD =&gt; /eqP r0 t/= htr.
<span class="nb">have</span> := hfD t.
<span class="nb">rewrite</span> /patch/=; <span class="nb">case</span>: ifPn; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> inE.
<span class="nb">move</span>=&gt; tD.
<span class="nb">move</span>: r0; <span class="nb">rewrite</span> -htr =&gt; ht0.
<span class="bp">by</span> <span class="nb">rewrite</span> le_eqVlt eqe (negbTE ht0)/= lte_fin// ltNge// fun_ge0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_measure_integral</span> <span class="nv">m2</span> <span class="nv">m1</span> (<span class="nv">f</span> : T -&gt; \bar R) :
    (<span class="kr">forall</span> <span class="nv">A</span>, measurable A -&gt; A `&lt;=` D -&gt; m1 A = m2 A) -&gt;
  \int[m1]_(x <span class="kr">in</span> D) f x = \int[m2]_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; m12; <span class="nb">rewrite</span> /integral funepos_restrict funeneg_restrict.
<span class="bp">by</span> <span class="nb">congr</span> (ereal_sup _ - ereal_sup _)%E; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>;
  <span class="nb">apply</span>: eq_measure_integral0 =&gt; A /m12 // /[<span class="nb">apply</span>].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">eq_measure_integral</span>.
<span class="kn">Arguments</span> eq_measure_integral {d T R D} m2 {m1 f}.

<span class="kn">Section</span> <span class="nf">integral_measure_zero</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).

<span class="kn">Let</span> <span class="nf">sintegral_measure_zero</span> (<span class="nv">f</span> : T -&gt; R) : sintegral mzero f = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> sintegralE big1// =&gt; r _ /=; <span class="nb">rewrite</span> /mzero mule0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_measure_zero</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; \bar R) :
  \int[mzero]_(x <span class="kr">in</span> D) f x = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">have</span> h g : (<span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= g x) -&gt; [<span class="nb">set</span> sintegral mzero h |
    h <span class="kr">in</span> [<span class="nb">set</span> h : {nnsfun T &gt;-&gt; R} | <span class="kr">forall</span> <span class="nv">x</span>, (h x)%:E &lt;= g x]] = [<span class="nb">set</span> <span class="mi">0</span>].
  <span class="nb">move</span>=&gt; g0; <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; [_ [h/= Dt &lt;-]|x -&gt; /=].
    <span class="bp">by</span> <span class="nb">rewrite</span> sintegral_measure_zero.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">cst_nnsfun</span> <span class="nv">_</span> (@NngNum _ <span class="mi">0</span> (lexx _))).
<span class="nb">rewrite</span> integralE !ge0_integralE//= h <span class="nl">?ereal_sup1</span>; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; r; <span class="nb">rewrite</span> erestrict_ge0.
<span class="bp">by</span> <span class="nb">rewrite</span> h <span class="nl">?ereal_sup1</span> <span class="nl">?subee</span>// =&gt; r; <span class="nb">rewrite</span> erestrict_ge0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_measure_zero</span>.

<span class="kn">Section</span> <span class="nf">domain_change</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">integral_mkcond</span> <span class="nv">D</span> <span class="nv">f</span> : \int[mu]_(x <span class="kr">in</span> D) f x = \int[mu]_x (f \_ D) x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /integral patch_setT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integralT_nnsfun</span> (<span class="nv">h</span> : {nnsfun T &gt;-&gt; R}) :
  \int[mu]_x (h x)%:E = sintegral mu h.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> integral_nnsfun// patch_setT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_mkcondr</span> <span class="nv">D</span> <span class="nv">P</span> <span class="nv">f</span> :
  \int[mu]_(x <span class="kr">in</span> D `&amp;` P) f x = \int[mu]_(x <span class="kr">in</span> D) (f \_ P) x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> integral_mkcond [RHS]integral_mkcond patch_setI. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_mkcondl</span> <span class="nv">D</span> <span class="nv">P</span> <span class="nv">f</span> :
  \int[mu]_(x <span class="kr">in</span> P `&amp;` D) f x = \int[mu]_(x <span class="kr">in</span> D) (f \_ P) x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> setIC integral_mkcondr. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">domain_change</span>.
<span class="kn">Arguments</span> integral_mkcond {d T R mu} D f.

<span class="kn">Section</span> <span class="nf">nondecreasing_integral_limit</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">f</span> : T -&gt; \bar R)
          (<span class="nv">g</span> : {nnsfun T &gt;-&gt; R}^nat).
<span class="kn">Hypothesis</span> <span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= f x.
<span class="kn">Hypothesis</span> <span class="nv">mf</span> : measurable_fun setT f.
<span class="kn">Hypothesis</span> <span class="nv">nd_g</span> : <span class="kr">forall</span> <span class="nv">x</span>, nondecreasing_seq (g^~x).
<span class="kn">Hypothesis</span> <span class="nv">gf</span> : <span class="kr">forall</span> <span class="nv">x</span>, EFin \o g^~x --&gt; f x.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">nd_ge0_integral_lim</span> : \int[mu]_x f x = lim (sintegral mu \o g).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> ge0_integralTE//.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">apply</span>: lime_le; <span class="kp">first</span> <span class="bp">exact</span>: is_cvg_sintegral.
  near=&gt; n; <span class="nb">apply</span>: ereal_sup_ub; <span class="kr">exists</span> (<span class="nv">g</span> <span class="nv">n</span>) =&gt; //= =&gt; x.
  <span class="nb">have</span> &lt;- : lim (EFin \o g ^~ x) = f x <span class="bp">by</span> <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="bp">exact</span>: gf.
  <span class="nb">have</span> : (EFin \o g ^~ x) --&gt; ereal_sup (range (EFin \o g ^~ x)).
    <span class="bp">by</span> <span class="nb">apply</span>: ereal_nondecreasing_cvg =&gt; p q pq /=; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>/nd_g.
  <span class="bp">by</span> <span class="nb">move</span>/cvg_lim =&gt; -&gt; //; <span class="nb">apply</span>: ereal_sup_ub; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="nb">have</span> := leey (\int[mu]_x (f x)).
<span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[|] mufoo; <span class="nb">last first</span>.
  <span class="nb">have</span> : \int[mu]_x (f x) \<span class="kr">is</span> a fin_num.
    <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE//; <span class="bp">exact</span>: integral_ge0.
  <span class="nb">rewrite</span> ge0_integralTE// =&gt; /ub_ereal_sup_adherent h.
  <span class="nb">apply</span>: lee_adde =&gt; e; <span class="nb">have</span> {h} [/= _ [G Gf &lt;-]] := h _ [gt0 of e%:num].
  <span class="nb">rewrite</span> EFinN lte_subl_addr// =&gt; fGe.
  <span class="nb">have</span> : <span class="kr">forall</span> <span class="nv">x</span>, cvg (g^~ x) -&gt; (G x &lt;= lim (g ^~ x))%R.
    <span class="nb">move</span>=&gt; x cg; <span class="nb">rewrite</span> -lee_fin -(EFin_lim cg).
    <span class="bp">by</span> <span class="nb">have</span> /cvg_lim gxfx := @gf x; <span class="nb">rewrite</span> (le_trans (Gf _))// gxfx.
  <span class="nb">move</span>=&gt; /(nd_sintegral_lim_lemma mu nd_g)/(lee_add2r e%:num%:E).
  <span class="bp">by</span> <span class="nb">apply</span>: le_trans; <span class="bp">exact</span>: ltW.
<span class="nb">suff</span> : lim (sintegral mu \o g) = +oo.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">rewrite</span> -ge0_integralTE// mufoo.
<span class="nb">apply</span>/eqyP =&gt; r r0.
<span class="nb">have</span> [G [Gf rG]] : <span class="kr">exists</span> <span class="nv">h</span> : {nnsfun T &gt;-&gt; R},
    (<span class="kr">forall</span> <span class="nv">x</span>, (h x)%:E &lt;= f x) /\ (r%:E &lt;= sintegral mu h).
  <span class="nb">have</span> : r%:E &lt; \int[mu]_x (f x).
    <span class="nb">move</span>: (mufoo) =&gt; /eqyP/(_ _ (addr_gt0 r0 r0)).
    <span class="bp">by</span> <span class="nb">apply</span>: lt_le_trans =&gt; //; <span class="nb">rewrite</span> lte_fin ltr_addr.
  <span class="nb">rewrite</span> ge0_integralTE// =&gt; /ereal_sup_gt[x [/= G Gf Gx rx]].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">G</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> (le_trans (ltW rx)) // Gx.
<span class="nb">have</span> : <span class="kr">forall</span> <span class="nv">x</span>, cvg (g^~ x) -&gt; (G x &lt;= lim (g^~ x))%R.
  <span class="nb">move</span>=&gt; x cg; <span class="nb">rewrite</span> -lee_fin -(EFin_lim cg).
  <span class="bp">by</span> <span class="nb">have</span> /cvg_lim gxfx := @gf x; <span class="nb">rewrite</span> (le_trans (Gf _)) // gxfx.
<span class="bp">by</span> <span class="nb">move</span>/(nd_sintegral_lim_lemma mu nd_g) =&gt; Gg; <span class="nb">rewrite</span> (le_trans rG).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">nondecreasing_integral_limit</span>.

<span class="kn">Section</span> <span class="nf">dyadic_interval</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.

<span class="kn">Definition</span> <span class="nf">dyadic_itv</span> <span class="nv">n</span> <span class="nv">k</span> : interval R :=
  `[(k%:R * <span class="mi">2</span> ^- n), (k.+<span class="mi">1</span>%:R * <span class="mi">2</span> ^- n)[.

<span class="kn">Local Notation</span> <span class="nf">I</span> := dyadic_itv.

<span class="kn">Lemma</span> <span class="nf">dyadic_itv_subU</span> <span class="nv">n</span> <span class="nv">k</span> : [<span class="nb">set</span>` I n k] `&lt;=`
  [<span class="nb">set</span>` I n.+<span class="mi">1</span> k.*<span class="mi">2</span>] `|` [<span class="nb">set</span>` I n.+<span class="mi">1</span> k.*<span class="mi">2</span>.+<span class="mi">1</span>].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; r /=; <span class="nb">rewrite</span> in_itv /= =&gt; /andP[Ir rI].
<span class="nb">have</span> [rk|rk] := ltP r (k.*<span class="mi">2</span>.+<span class="mi">1</span>%:R * (<span class="mi">2</span>%:R ^- n.+<span class="mi">1</span>)); [<span class="nb">left</span>|<span class="nb">right</span>].
- <span class="nb">rewrite</span> in_itv /= rk andbT (le_trans _ Ir)// -muln2.
  <span class="nb">rewrite</span> natrM exprS invrM <span class="nl">?unitfE</span>// <span class="nl">?expf_neq0</span>// -mulrA (mulrCA <span class="mi">2</span>).
  <span class="bp">by</span> <span class="nb">rewrite</span> divrr <span class="nl">?unitfE</span>// mulr1.
- <span class="nb">rewrite</span> in_itv /= rk /= (lt_le_trans rI)// -doubleS.
  <span class="nb">rewrite</span> -muln2 natrM exprS invrM <span class="nl">?unitfE</span>// <span class="nl">?expf_neq0</span>// -mulrA (mulrCA <span class="mi">2</span>).
  <span class="bp">by</span> <span class="nb">rewrite</span> divrr <span class="nl">?unitfE</span>// mulr1.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigsetU_dyadic_itv</span> <span class="nv">n</span> : `[n%:R, n.+<span class="mi">1</span>%:R[%classic =
  \big[setU/set0]_(n * <span class="mi">2</span> ^ n.+<span class="mi">1</span> &lt;= k &lt; n.+<span class="mi">1</span> * <span class="mi">2</span> ^ n.+<span class="mi">1</span>) [<span class="nb">set</span>` I n.+<span class="mi">1</span> k].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; r; <span class="nb">split</span> =&gt; [/= /[!in_itv]/= /andP[nr rn1]|].
- <span class="nb">rewrite</span> -bigcup_set /=; <span class="kr">exists</span> `|floor (r * <span class="mi">2</span> ^+ n.+<span class="mi">1</span>)|%N.
    <span class="nb">rewrite</span> /= mem_index_iota; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
      <span class="nb">rewrite</span> -ltez_nat gez0_abs <span class="nl">?floor_ge0</span>; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> mulr_ge0// (le_trans _ nr).
      <span class="nb">apply</span>: (@le_trans _ _ (floor (n * <span class="mi">2</span> ^ n.+<span class="mi">1</span>)%:R)); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">apply</span>: le_floor; <span class="nb">rewrite</span> natrM natrX ler_pmul2r.
      <span class="bp">by</span> <span class="nb">rewrite</span> floor_natz intz.
    <span class="nb">rewrite</span> -ltz_nat gez0_abs; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> floor_ge0 mulr_ge0// (le_trans _ nr).
    <span class="nb">rewrite</span> -(@ltr_int R) (le_lt_trans (floor_le _))//.
    <span class="bp">by</span> <span class="nb">rewrite</span> PoszM intrM -natrX ltr_pmul2r.
  <span class="nb">rewrite</span> /= in_itv /=; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
    <span class="nb">rewrite</span> ler_pdivr_mulr// (le_trans _ (floor_le _))//.
    <span class="bp">by</span> <span class="nb">rewrite</span> -(@gez0_abs (floor _))// floor_ge0 mulr_ge0// (le_trans _ nr).
  <span class="nb">rewrite</span> ltr_pdivl_mulr// (lt_le_trans (lt_succ_floor _))//.
  <span class="nb">rewrite</span> -[<span class="kr">in</span> leRHS]natr1 ler_add2r// -(@gez0_abs (floor _))// floor_ge0.
  <span class="bp">by</span> <span class="nb">rewrite</span> mulr_ge0// (le_trans _ nr).
- <span class="nb">rewrite</span> -bigcup_set =&gt; -[/= k] /[!mem_index_iota] /andP[nk kn].
  <span class="nb">rewrite</span> in_itv /= =&gt; /andP[knr rkn]; <span class="nb">rewrite</span> in_itv /=; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans _ knr)// ler_pdivl_mulr// -natrX -natrM ler_nat.
  <span class="bp">by</span> <span class="nb">rewrite</span> (lt_le_trans rkn)// ler_pdivr_mulr// -natrX -natrM ler_nat.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dyadic_itv_image</span> <span class="nv">n</span> <span class="nv">T</span> (<span class="nv">f</span> : T -&gt; \bar R) <span class="nv">x</span> :
  (n%:R%:E &lt;= f x &lt; n.+<span class="mi">1</span>%:R%:E)%E -&gt;
  <span class="kr">exists</span> <span class="nv">k</span>, (<span class="mi">2</span> ^ n.+<span class="mi">1</span> * n &lt;= k &lt; <span class="mi">2</span> ^ n.+<span class="mi">1</span> * n.+<span class="mi">1</span>)%N /\
    f x \<span class="kr">in</span> EFin @` [<span class="nb">set</span>` I n.+<span class="mi">1</span> k].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fxn; <span class="nb">have</span> fxfin : f x \<span class="kr">is</span> a fin_num.
  <span class="bp">by</span> <span class="nb">rewrite</span> fin_numE; <span class="nb">move</span>: fxn; <span class="nb">case</span>: (f x) =&gt; // /andP[].
<span class="nb">have</span> : f x \<span class="kr">in</span> EFin @` `[n%:R, n.+<span class="mi">1</span>%:R[%classic.
  <span class="nb">rewrite</span> inE /=; <span class="kr">exists</span> (<span class="nv">fine</span> (f x)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> fineK.
  <span class="bp">by</span> <span class="nb">rewrite</span> in_itv /= -lee_fin -lte_fin (fineK fxfin).
<span class="nb">rewrite</span> (bigsetU_dyadic_itv n) inE /= =&gt; -[r]; <span class="nb">rewrite</span> -bigcup_set =&gt; -[k /=].
<span class="nb">rewrite</span> mem_index_iota =&gt; nk Ir rfx.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span>; <span class="nb">split</span>; [<span class="nb">rewrite</span> !(mulnC (<span class="mi">2</span> ^ n.+<span class="mi">1</span>)%N)|<span class="nb">rewrite</span> !inE /=; <span class="kr">exists</span> <span class="nv">r</span>].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">dyadic_interval</span>.

<span class="kn">Section</span> <span class="nf">approximation</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variables</span> (<span class="nv">f</span> : T -&gt; \bar R) (<span class="nv">mf</span> : measurable_fun D f).

<span class="kn">Local Notation</span> <span class="nf">I</span> := (@dyadic_itv R).

<span class="kn">Let</span> <span class="nf">A</span> <span class="nv">n</span> <span class="nv">k</span> := <span class="kr">if</span> (k &lt; n * <span class="mi">2</span> ^ n)%N <span class="kr">then</span>
  D `&amp;` [<span class="nb">set</span> x | f x \<span class="kr">in</span> EFin @` [<span class="nb">set</span>` I n k]] <span class="kr">else</span> set0.

<span class="kn">Let</span> <span class="nf">B</span> <span class="nv">n</span> := D `&amp;` [<span class="nb">set</span> x | n%:R%:E &lt;= f x]%E.

<span class="kn">Definition</span> <span class="nf">approx</span> : (T -&gt; R)^nat := <span class="kr">fun</span> <span class="nv">n</span> <span class="nv">x</span> =&gt;
  \sum_(k &lt; n * <span class="mi">2</span> ^ n) k%:R * <span class="mi">2</span> ^- n * \<span class="mi">1_</span>(A n k) x + n%:R * \<span class="mi">1_</span>(B n) x.

<span class="c">(* technical properties of the sets A and B *)</span>
<span class="kn">Let</span> <span class="nf">mA</span> <span class="nv">n</span> <span class="nv">k</span> : measurable (A n k).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /A; <span class="nb">case</span>: ifPn =&gt; [kn|_]//; <span class="nb">rewrite</span> -preimage_comp.
<span class="bp">by</span> <span class="nb">apply</span>: mf =&gt; //; <span class="nb">apply</span>/measurable_EFin; <span class="bp">exact</span>: measurable_itv.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">trivIsetA</span> <span class="nv">n</span> : trivIset setT (A n).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/trivIsetP =&gt; i j _ _.
<span class="nb">wlog</span> : i j / (i &lt; j)%N.
  <span class="nb">move</span>=&gt; h; <span class="nb">rewrite</span> neq_lt =&gt; /orP[ij|ji].
    <span class="bp">by</span> <span class="nb">apply</span>: h =&gt; //; <span class="nb">rewrite</span> lt_eqF.
  <span class="bp">by</span> <span class="nb">rewrite</span> setIC; <span class="nb">apply</span>: h =&gt; //; <span class="nb">rewrite</span> lt_eqF.
<span class="nb">move</span>=&gt; ij _.
<span class="nb">rewrite</span> /A; <span class="nb">case</span>: ifPn =&gt; /= ni; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> set0I.
<span class="nb">case</span>: ifPn =&gt; /= nj; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> setI0.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; // -[/=] [_].
<span class="nb">rewrite</span> inE =&gt; -[r /=]; <span class="nb">rewrite</span> in_itv /= =&gt; /andP[r1 r2] rft [_].
<span class="nb">rewrite</span> inE =&gt; -[s /=]; <span class="nb">rewrite</span> in_itv /= =&gt; /andP[s1 s2].
<span class="nb">rewrite</span> -rft =&gt; -[sr]; <span class="nb">rewrite</span> {}sr {s} <span class="kr">in</span> s1 s2.
<span class="bp">by</span> <span class="nb">have</span> := le_lt_trans s1 r2; <span class="nb">rewrite</span> ltr_pmul2r// ltr_nat ltnS leqNgt ij.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">f0_A0</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_(n * <span class="mi">2</span> ^ n)) <span class="nv">x</span> : f x = <span class="mi">0</span>%:E -&gt; i != O :&gt; nat -&gt;
  \<span class="mi">1_</span>(A n i) x = <span class="mi">0</span> :&gt; R.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fx0 i0; <span class="nb">rewrite</span> indicE memNset// /A ltn_ord =&gt; -[Dx/=] /[<span class="mi">1</span>!inE]/= -[r].
<span class="nb">rewrite</span> in_itv/= fx0 =&gt; + r0; <span class="nb">move</span>/eqP : r0 =&gt; /[<span class="mi">1</span>!eqe] /eqP -&gt; /andP[+ _].
<span class="bp">by</span> <span class="nb">rewrite</span> ler_pdivr_mulr// mul0r lern0 (negbTE i0).
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">fgen_A0</span> <span class="nv">n</span> <span class="nv">x</span> (<span class="nv">i</span> : &#39;I_(n * <span class="mi">2</span> ^ n)) : (n%:R%:E &lt;= f x)%E -&gt;
  \<span class="mi">1_</span>(A n i) x = <span class="mi">0</span> :&gt; R.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fxn; <span class="nb">rewrite</span> indicE /A ltn_ord memNset// =&gt; -[Dx/=] /[<span class="mi">1</span>!inE]/= -[r].
<span class="nb">rewrite</span> in_itv/= =&gt; /andP[_ h] rfx; <span class="nb">move</span>: fxn; <span class="nb">rewrite</span> -rfx lee_fin; <span class="nb">apply</span>/negP.
<span class="nb">rewrite</span> -ltNge (lt_le_trans h)// -natrX ler_pdivr_mulr// -natrM ler_nat.
<span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (ltn_ord i)).
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">disj_A0</span> <span class="nv">x</span> <span class="nv">n</span> (<span class="nv">i</span> <span class="nv">k</span> : &#39;I_(n * <span class="mi">2</span> ^ n)) : i != k -&gt; x \<span class="kr">in</span> A n k -&gt;
  \<span class="mi">1_</span>(A n i) x = <span class="mi">0</span> :&gt; R.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ik /[<span class="mi">1</span>!inE] xAn1k; <span class="nb">rewrite</span> indicE memNset// =&gt; xAi.
<span class="nb">have</span> /trivIsetP/(_ _ _ Logic.I Logic.I ik)/= := @trivIsetA n.
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; /(_ x)[+ _]; <span class="bp">exact</span>.
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> disj_A0 {x n i} k.

<span class="kn">Let</span> <span class="nf">mB</span> <span class="nv">n</span> : measurable (B n). <span class="kn">Proof</span>. <span class="bp">exact</span>: emeasurable_fun_c_infty. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">foo_B1</span> <span class="nv">x</span> <span class="nv">n</span> : D x -&gt; f x = +oo%E -&gt; \<span class="mi">1_</span>(B n) x = <span class="mi">1</span> :&gt; R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Dx fxoo; <span class="nb">rewrite</span> indicE mem_set// /B/= fxoo leey. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">f0_B0</span> <span class="nv">x</span> <span class="nv">n</span> : f x = <span class="mi">0</span>%:E -&gt; n != <span class="mi">0</span>%N -&gt; \<span class="mi">1_</span>(B n) x = <span class="mi">0</span> :&gt; R.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; h /negbTE n0; <span class="nb">rewrite</span> indicE memNset// /B/= h lee_fin lern0 n0 =&gt; -[].
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">fgtn_B0</span> <span class="nv">x</span> <span class="nv">n</span> : (f x &lt; n%:R%:E)%E -&gt; \<span class="mi">1_</span>(B n) x = <span class="mi">0</span> :&gt; R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; h; <span class="nb">rewrite</span> indicE memNset// =&gt; -[_/=]; <span class="nb">rewrite</span> leNgt h. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">f0_approx0</span> <span class="nv">n</span> <span class="nv">x</span> : f x = <span class="mi">0</span>%E -&gt; approx n x = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fx0; <span class="nb">rewrite</span> /approx; <span class="nb">have</span> [-&gt;|n0] := eqVneq n O.
  <span class="bp">by</span> <span class="nb">rewrite</span> mul0n mul0r addr0 big_ord0.
<span class="nb">rewrite</span> f0_B0// mulr0 addr0 big1// =&gt; i _.
<span class="nb">have</span> [-&gt;|i0] := eqVneq (nat_of_ord i) <span class="mi">0</span>%N; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> mul0r mul0r.
<span class="bp">by</span> <span class="nb">rewrite</span> f0_A0 // mulr0.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">fpos_approx_neq0</span> <span class="nv">x</span> : D x -&gt; (<span class="mi">0</span>%E &lt; f x &lt; +oo)%E -&gt;
  \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, approx n x != <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dx /andP[fx_gt0 fxoo].
<span class="nb">have</span> fxfin : f x \<span class="kr">is</span> a fin_num <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE// ltW.
<span class="nb">rewrite</span> -(fineK fxfin) lte_fin <span class="kr">in</span> fx_gt0; near=&gt; n.
<span class="nb">rewrite</span> /approx paddr_eq0//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: sumr_ge0 =&gt; i _; <span class="nb">rewrite</span> mulr_ge0.
  <span class="bp">by</span> <span class="nb">rewrite</span> mulr_ge0.
<span class="nb">rewrite</span> psumr_eq0//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; i _; <span class="nb">rewrite</span> mulr_ge0.
<span class="nb">apply</span>/negP =&gt; /andP[/allP An0]; <span class="nb">rewrite</span> mulf_eq0 =&gt; /orP[|].
  <span class="bp">by</span> <span class="nb">apply</span>/negP; near: n; <span class="kr">exists</span> <span class="mi">1</span>%N =&gt; //= m /=; <span class="nb">rewrite</span> lt0n pnatr_eq0.
<span class="nb">rewrite</span> indicE mem_set <span class="nl">?oner_eq0</span>// /B /= leNgt; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>/negP =&gt; fxn.
<span class="nb">have</span> K : (`|floor (fine (f x) * <span class="mi">2</span> ^+ n)| &lt; n * <span class="mi">2</span> ^ n)%N.
  <span class="nb">rewrite</span> -ltz_nat gez0_abs; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> floor_ge0 mulr_ge0// ltW.
  <span class="nb">rewrite</span> -(@ltr_int R); <span class="nb">rewrite</span> (le_lt_trans (floor_le _))// PoszM intrM.
  <span class="bp">by</span> <span class="nb">rewrite</span> -natrX ltr_pmul2r// -lte_fin (fineK fxfin).
<span class="nb">have</span> /[!mem_index_enum]/(_ isT) := An0 (Ordinal K).
<span class="nb">rewrite</span> implyTb indicE mem_set <span class="nl">?mulr1</span>; <span class="nb">last first</span>.
  <span class="nb">rewrite</span> /A K /= inE; <span class="nb">split</span>=&gt; //=; <span class="kr">exists</span> (<span class="nv">fine</span> (f x)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> fineK.
  <span class="nb">rewrite</span> in_itv /=; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
    <span class="nb">rewrite</span> ler_pdivr_mulr// (le_trans _ (floor_le _))//.
    <span class="bp">by</span> <span class="nb">rewrite</span> -(@gez0_abs (floor _))// floor_ge0 mulr_ge0// ltW.
  <span class="nb">rewrite</span> ltr_pdivl_mulr// (lt_le_trans (lt_succ_floor _))// -[<span class="kr">in</span> leRHS]natr1.
  <span class="bp">by</span> <span class="nb">rewrite</span> ler_add2r// -{<span class="mi">1</span>}(@gez0_abs (floor _))// floor_ge0// mulr_ge0// ltW.
<span class="nb">rewrite</span> mulf_eq0// -exprVn; <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> negb_or expf_neq0//= andbT.
<span class="nb">rewrite</span> pnatr_eq0 -lt0n absz_gt0 floor_neq0// -ler_pdivr_mulr//.
<span class="nb">apply</span>/orP; <span class="nb">right</span>; <span class="nb">apply</span>/ltW; near: n.
<span class="bp">exact</span>: near_infty_natSinv_expn_lt (PosNum fx_gt0).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">f_ub_approx</span> <span class="nv">n</span> <span class="nv">x</span> : (f x &lt; n%:R%:E)%E -&gt;
  approx n x == <span class="mi">0</span> \/ <span class="kr">exists</span> <span class="nv">k</span>,
    [/\ (<span class="mi">0</span> &lt; k &lt; n * <span class="mi">2</span> ^ n)%N,
       x \<span class="kr">in</span> A n k, approx n x = k%:R / <span class="mi">2</span> ^+ n &amp;
       f x \<span class="kr">in</span> EFin @` [<span class="nb">set</span>` I n k]].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fxn; <span class="nb">rewrite</span> /approx fgtn_B0 // mulr0 addr0.
<span class="nb">set</span> lhs := (X <span class="kr">in</span> X == <span class="mi">0</span>); <span class="nb">have</span> [|] := eqVneq lhs <span class="mi">0</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">left</span>.
<span class="nb">rewrite</span> {}/lhs psumr_eq0; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; i _; <span class="nb">rewrite</span> mulr_ge0.
<span class="nb">move</span>=&gt; /allPn[/= k _].
<span class="nb">rewrite</span> mulf_eq0 negb_or mulf_eq0 negb_or -andbA =&gt; /and3P[k_neq0 _].
<span class="nb">rewrite</span> pnatr_eq0 eqb0 negbK =&gt; xAnk; <span class="nb">right</span>.
<span class="nb">rewrite</span> (bigD1 k) //= indicE xAnk mulr1 big1 <span class="nl">?addr0</span>; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i ik; <span class="nb">rewrite</span> (disj_A0 k)// mulr0.
<span class="kr">exists</span> <span class="nv">k</span>; <span class="nb">split</span> =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> lt0n -(@pnatr_eq0 R) k_neq0/=.
<span class="bp">by</span> <span class="nb">move</span>: xAnk; <span class="nb">rewrite</span> inE /A ltn_ord /= inE /= =&gt; -[/[<span class="nb">swap</span>] Dx].
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">notinD_approx0</span> <span class="nv">x</span> <span class="nv">n</span> : ~ D x -&gt; approx n x = <span class="mi">0</span> :&gt; R.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> /approx big1; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i _; <span class="nb">rewrite</span> indicE memNset <span class="nl">?mulr0</span>// /A; <span class="nb">case</span>: ifPn =&gt; [? []|_].
<span class="bp">by</span> <span class="nb">rewrite</span> indicE memNset// <span class="nl">?mulr0</span> <span class="nl">?addr0</span>// =&gt; -[].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nd_approx</span> : nondecreasing_seq approx.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/nondecreasing_seqP =&gt; n; <span class="nb">apply</span>/lefP =&gt; x.
<span class="nb">have</span> [Dx|Dx] := pselect (D x); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?notinD_approx0</span>.
<span class="nb">have</span> [fxn|fxn] := ltP (f x) n%:R%:E.
  <span class="nb">rewrite</span> {<span class="mi">2</span>}/approx fgtn_B0 <span class="nl">?mulr0</span> <span class="nl">?addr0</span>; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> (lt_trans fxn) // lte_fin ltr_nat.
  <span class="nb">have</span> [/eqP -&gt;|[k [/andP[k0 kn] xAnk -&gt; _]]] := f_ub_approx fxn.
    <span class="bp">by</span> <span class="nb">apply</span>: sumr_ge0 =&gt; i _; <span class="nb">rewrite</span> mulr_ge0.
  <span class="nb">move</span>: (xAnk); <span class="nb">rewrite</span> inE {<span class="mi">1</span>}/A kn =&gt; -[_] /=.
  <span class="nb">rewrite</span> inE =&gt; -[r] /dyadic_itv_subU[|] rnk rfx.
  - <span class="nb">have</span> k2n : (k.*<span class="mi">2</span> &lt; n.+<span class="mi">1</span> * <span class="mi">2</span> ^ n.+<span class="mi">1</span>)%N.
      <span class="nb">rewrite</span> expnS mulnCA mul2n ltn_double (ltn_trans kn) //.
      <span class="bp">by</span> <span class="nb">rewrite</span> ltn_mul2r expn_gt0 /= ltnS.
    <span class="nb">rewrite</span> (bigD1 (Ordinal k2n)) //= indicE.
    <span class="nb">have</span> xAn1k : x \<span class="kr">in</span> A n.+<span class="mi">1</span> k.*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> inE /A k2n; <span class="nb">split</span> =&gt; //=; <span class="nb">rewrite</span> inE; <span class="kr">exists</span> <span class="nv">r</span>.
    <span class="nb">rewrite</span> xAn1k mulr1 big1 <span class="nl">?addr0</span>; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; i ik2n; <span class="nb">rewrite</span> (disj_A0 (Ordinal k2n)) <span class="nl">?mulr0</span>.
    <span class="nb">rewrite</span> exprS invrM <span class="nl">?unitfE</span>// -muln2 natrM -mulrA (mulrCA <span class="mi">2</span>).
    <span class="bp">by</span> <span class="nb">rewrite</span> divrr <span class="nl">?mulr1</span> <span class="nl">?unitfE</span>.
  - <span class="nb">have</span> k2n : (k.*<span class="mi">2</span>.+<span class="mi">1</span> &lt; n.+<span class="mi">1</span> * <span class="mi">2</span> ^ n.+<span class="mi">1</span>)%N.
      <span class="nb">move</span>: kn; <span class="nb">rewrite</span> -ltn_double -(ltn_add2r <span class="mi">1</span>) <span class="mi">2</span>!addn1 =&gt; /leq_trans; <span class="nb">apply</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -muln2 -mulnA -expnSr ltn_mul2r expn_gt0 /= ltnS.
    <span class="nb">rewrite</span> (bigD1 (Ordinal k2n)) //= indicE.
    <span class="nb">have</span> xAn1k : x \<span class="kr">in</span> A n.+<span class="mi">1</span> k.*<span class="mi">2</span>.+<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> /A /= k2n inE; <span class="nb">split</span> =&gt; //=; <span class="nb">rewrite</span> inE/=; <span class="kr">exists</span> <span class="nv">r</span>.
    <span class="nb">rewrite</span> xAn1k mulr1 big1 <span class="nl">?addr0</span>; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; i ik2n; <span class="nb">rewrite</span> (disj_A0 (Ordinal k2n)) // mulr0.
    <span class="nb">rewrite</span> -(natr1 _ k.*<span class="mi">2</span>) mulrDl exprS -mul2n natrM -mulf_div divrr <span class="nl">?unitfE</span>//.
    <span class="bp">by</span> <span class="nb">rewrite</span> !mul1r ler_addl.
<span class="nb">have</span> /orP[{}fxn|{}fxn] :
    ((n%:R%:E &lt;= f x &lt; n.+<span class="mi">1</span>%:R%:E) || (n.+<span class="mi">1</span>%:R%:E &lt;= f x))%E.
  - <span class="bp">by</span> <span class="nb">move</span>: fxn; <span class="nb">case</span>: leP =&gt; /= [_ _|_ -&gt;//]; <span class="nb">rewrite</span> orbT.
  - <span class="nb">have</span> [k [k1 k2]] := dyadic_itv_image fxn.
    <span class="nb">have</span> xBn : x \<span class="kr">in</span> B n <span class="bp">by</span> <span class="nb">rewrite</span> /B /= inE /=; <span class="nb">case</span>/andP : fxn =&gt; -&gt;.
    <span class="nb">rewrite</span> /approx indicE xBn mulr1 big1 <span class="nl">?add0r</span>; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; /= i _; <span class="nb">rewrite</span> fgen_A0 <span class="nl">?mulr0</span>//; <span class="nb">case</span>/andP : fxn.
    <span class="nb">rewrite</span> fgtn_B0 <span class="nl">?mulr0</span> <span class="nl">?addr0</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>/andP : fxn.
    <span class="nb">have</span> kn2 : (k &lt; n.+<span class="mi">1</span> * <span class="mi">2</span> ^ n.+<span class="mi">1</span>)%N <span class="bp">by</span> <span class="nb">case</span>/andP : k1 =&gt; _; <span class="nb">rewrite</span> mulnC.
    <span class="nb">rewrite</span> (bigD1 (Ordinal kn2)) //=.
    <span class="nb">have</span> xAn1k : x \<span class="kr">in</span> A n.+<span class="mi">1</span> k <span class="bp">by</span> <span class="nb">rewrite</span> inE /A kn2.
    <span class="nb">rewrite</span> indicE xAn1k mulr1 big1 <span class="nl">?addr0</span>; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; i /= ikn2; <span class="nb">rewrite</span> (disj_A0 (Ordinal kn2)) // mulr0.
    <span class="bp">by</span> <span class="nb">rewrite</span> -natrX ler_pdivl_mulr// mulrC -natrM ler_nat; <span class="nb">case</span>/andP : k1.
- <span class="nb">have</span> xBn : x \<span class="kr">in</span> B n <span class="bp">by</span> <span class="nb">rewrite</span> /B inE /= (le_trans _ fxn) // lee_fin ler_nat.
  <span class="nb">rewrite</span> /approx indicE xBn mulr1.
  <span class="nb">have</span> xBn1 : x \<span class="kr">in</span> B n.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> /B /= inE.
  <span class="nb">rewrite</span> indicE xBn1 mulr1 big1 <span class="nl">?add0r</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> big1 <span class="nl">?add0r</span> <span class="nl">?ler_nat</span>// =&gt; /= i _; <span class="nb">rewrite</span> fgen_A0// mulr0.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /= i _; <span class="nb">rewrite</span> fgen_A0 <span class="nl">?mulr0</span>// (le_trans _ fxn)// lee_fin ler_nat.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_approx</span> <span class="nv">x</span> (<span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; (<span class="mi">0</span> &lt;= f x)%E) : D x -&gt;
  (f x &lt; +oo)%E -&gt; (approx^~ x) --&gt; fine (f x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dx fxoo; <span class="nb">have</span> fxfin : f x \<span class="kr">is</span> a fin_num <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE// f0.
<span class="nb">apply</span>/(@cvgrPdist_lt _ [normedModType R of R^o]) =&gt; _/posnumP[e].
<span class="nb">have</span> [fx0|fx0] := eqVneq (f x) <span class="mi">0</span>%E.
  <span class="bp">by</span> near=&gt; n; <span class="nb">rewrite</span> f0_approx0 // fx0 /= subrr normr0.
<span class="nb">have</span> /(fpos_approx_neq0 Dx)[m _ Hm] : (<span class="mi">0</span> &lt; f x &lt; +oo)%E <span class="bp">by</span> <span class="nb">rewrite</span> lt0e fx0 f0.
near=&gt; n.
<span class="nb">have</span> mn : (m &lt;= n)%N <span class="bp">by</span> near: n; <span class="kr">exists</span> <span class="nv">m</span>.
<span class="nb">have</span> : fine (f x) &lt; n%:R.
  near: n.
  <span class="kr">exists</span> `|floor (fine (f x))|.+<span class="mi">1</span>%N =&gt; //= p /=.
  <span class="nb">rewrite</span> -(@ler_nat R); <span class="nb">apply</span>: lt_le_trans.
  <span class="nb">rewrite</span> -natr1 (_ : `| _ |%:R  = (floor (fine (f x)))%:~R); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -[<span class="kr">in</span> RHS](@gez0_abs (floor _))// floor_ge0//; <span class="bp">exact</span>/fine_ge0/f0.
  <span class="bp">by</span> <span class="nb">rewrite</span> lt_succ_floor.
<span class="nb">rewrite</span> -lte_fin (fineK fxfin) =&gt; fxn.
<span class="nb">have</span> [approx_nx0|[k [/andP[k0 kn2n] ? -&gt;]]] := f_ub_approx fxn.
  <span class="bp">by</span> <span class="nb">have</span> := Hm _ mn; <span class="nb">rewrite</span> approx_nx0.
<span class="nb">rewrite</span> inE /= =&gt; -[r /=]; <span class="nb">rewrite</span> in_itv /= =&gt; /andP[k1 k2] rfx.
<span class="nb">rewrite</span> (@le_lt_trans _ _ (<span class="mi">1</span> / <span class="mi">2</span> ^+ n)) //.
  <span class="nb">rewrite</span> ler_norml; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
    <span class="nb">rewrite</span> ler_subr_addl -mulrBl -lee_fin (fineK fxfin) -rfx lee_fin.
    <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans _ k1)// ler_pmul2r// ler_subl_addl ler_addr.
  <span class="bp">by</span> <span class="nb">rewrite</span> ler_subl_addr -mulrDl -lee_fin nat1r fineK// ltW// -rfx lte_fin.
<span class="bp">by</span> near: n; <span class="bp">exact</span>: near_infty_natSinv_expn_lt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">le_approx</span> <span class="nv">k</span> <span class="nv">x</span> (<span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">x</span>, (<span class="mi">0</span> &lt;= f x)%E) : D x -&gt;
  ((approx k x)%:E &lt;= f x)%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dx; <span class="nb">have</span> [fixoo|] := ltP (f x) (+oo%E); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> leye_eq =&gt; /eqP -&gt;; <span class="nb">rewrite</span> leey.
<span class="nb">have</span> nd_ag : {homo approx ^~ x : n m / (n &lt;= m)%N &gt;-&gt; n &lt;= m}.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; m n mn; <span class="bp">exact</span>/lefP/nd_approx.
<span class="nb">have</span> fi0 y : D y -&gt; (<span class="mi">0</span> &lt;= f y)%E <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: f0.
<span class="nb">have</span> cvg_af := cvg_approx fi0 Dx fixoo.
<span class="nb">have</span> is_cvg_af : cvg (approx ^~ x) <span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: cvg_af.
<span class="nb">have</span> {is_cvg_af} := nondecreasing_cvg_le nd_ag is_cvg_af k.
<span class="nb">rewrite</span> -lee_fin =&gt; /le_trans; <span class="nb">apply</span>.
<span class="nb">rewrite</span> -(@fineK _ (f x)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE.
<span class="bp">by</span> <span class="nb">move</span>/(cvg_lim (@Rhausdorff R)) : cvg_af =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dvg_approx</span> <span class="nv">x</span> : D x -&gt; f x = +oo%E -&gt; ~ cvg (approx^~ x : _ -&gt; R^o).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dx fxoo; <span class="nb">have</span> approx_x n : approx n x = n%:R.
  <span class="nb">rewrite</span> /approx foo_B1// mulr1 big1 <span class="nl">?add0r</span>// =&gt; /= i _.
  <span class="bp">by</span> <span class="nb">rewrite</span> fgen_A0 // <span class="nl">?mulr0</span> // fxoo leey.
<span class="nb">case</span>/cvg_ex =&gt; /= l; <span class="nb">have</span> [l0|l0] := leP <span class="mi">0</span>%R l.
- <span class="nb">move</span>=&gt; /cvgrPdist_lt/(_ _ ltr01) -[n _].
  <span class="nb">move</span>=&gt; /(_ (`|ceil l|.+<span class="mi">1</span> + n)%N) /= /(_ (leq_addl _ _)).
  <span class="nb">rewrite</span> approx_x.
  <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -leNgt distrC (le_trans _ (ler_sub_norm_add _ _)) //.
  <span class="nb">rewrite</span> normrN ler_subr_addl addSnnS [leRHS]ger0_norm <span class="nl">?ler0n</span>//.
  <span class="nb">rewrite</span> natrD ler_add// <span class="nl">?ler1n</span>// ger0_norm // (le_trans (ceil_ge _)) //.
  <span class="bp">by</span> <span class="nb">rewrite</span> -(@gez0_abs (ceil _)) // ceil_ge0.
- <span class="nb">move</span>/cvgrPdist_lt =&gt; /(_ _ ltr01) -[n _].
  <span class="nb">move</span>=&gt; /(_ (`|floor l|.+<span class="mi">1</span> + n)%N) /= /(_ (leq_addl _ _)).
  <span class="nb">rewrite</span> approx_x.
  <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -leNgt distrC (le_trans _ (ler_sub_norm_add _ _)) //.
  <span class="nb">rewrite</span> normrN ler_subr_addl addSnnS [leRHS]ger0_norm <span class="nl">?ler0n</span>//.
  <span class="nb">rewrite</span> natrD ler_add// <span class="nl">?ler1n</span>// ler0_norm //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltW.
  <span class="nb">rewrite</span> (@le_trans _ _ (- floor l)%:~R) //.
    <span class="bp">by</span> <span class="nb">rewrite</span> mulrNz ler_oppl opprK floor_le.
  <span class="bp">by</span> <span class="nb">rewrite</span> -(@lez0_abs (floor _)) // floor_le0 // ltW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ecvg_approx</span> (<span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; (<span class="mi">0</span> &lt;= f x)%E) <span class="nv">x</span> :
  D x -&gt; EFin \o approx^~x --&gt; f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dx; <span class="nb">have</span> := leey (f x); <span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[|] fxoo.
<span class="nb">have</span> dvg_approx := dvg_approx Dx fxoo.
  <span class="nb">have</span> : {homo approx ^~ x : n m / (n &lt;= m)%N &gt;-&gt; n &lt;= m}.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; m n mn; <span class="nb">have</span> := nd_approx mn =&gt; /lefP; <span class="bp">exact</span>.
  <span class="nb">move</span>/nondecreasing_dvg_lt =&gt; /(_ dvg_approx).
  <span class="bp">by</span> <span class="nb">rewrite</span> fxoo =&gt; ?; <span class="nb">apply</span>/cvgeryP.
<span class="nb">rewrite</span> -(@fineK _ (f x)); <span class="kp">first</span> <span class="bp">exact</span>: (cvg_comp (cvg_approx f0 Dx fxoo)).
<span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE// f0.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">k2n_ge0</span> <span class="nv">n</span> (<span class="nv">k</span> : &#39;I_(n * <span class="mi">2</span> ^ n)) : <span class="mi">0</span> &lt;= k%:R * <span class="mi">2</span> ^- n :&gt; R.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">nnsfun_approx</span> : {nnsfun T &gt;-&gt; R}^nat := <span class="kr">fun</span> <span class="nv">n</span> =&gt; locked (add_nnsfun
  (sum_nnsfun
    (<span class="kr">fun</span> <span class="nv">k</span> =&gt; <span class="kr">match</span> Bool.bool_dec (k &lt; (n * <span class="mi">2</span> ^ n))%N true <span class="kr">with</span>
      | <span class="nb">left</span> h =&gt; scale_nnsfun (indic_nnsfun _ (mA n k)) (k2n_ge0 (Ordinal h))
      | <span class="nb">right</span> _ =&gt; nnsfun0
     <span class="kr">end</span>) (n * <span class="mi">2</span> ^ n)%N)
  (scale_nnsfun (indic_nnsfun _ (mB n)) (ler0n _ n))).

<span class="kn">Lemma</span> <span class="nf">nnsfun_approxE</span> <span class="nv">n</span> : nnsfun_approx n = approx n :&gt; (T -&gt; R).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; t /=; <span class="nb">rewrite</span> /nnsfun_approx; <span class="nb">unlock</span>; <span class="nb">rewrite</span> /=.
<span class="nb">rewrite</span> sum_nnsfunE; <span class="nb">congr</span> (_ + _).
<span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">case</span>: Bool.bool_dec =&gt; [h|/negP]; [|<span class="nb">rewrite</span> ltn_ord].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_nnsfun_approx</span> (<span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; (<span class="mi">0</span> &lt;= f x)%E) <span class="nv">x</span> :
  D x -&gt; EFin \o nnsfun_approx^~x --&gt; f x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Dx; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> nnsfun_approxE; <span class="bp">exact</span>: ecvg_approx.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nd_nnsfun_approx</span> : nondecreasing_seq (nnsfun_approx : (T -&gt; R)^nat).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; m n mn; <span class="nb">rewrite</span> (nnsfun_approxE n) (nnsfun_approxE m).
<span class="bp">exact</span>: nd_approx.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">approximation</span> : (<span class="kr">forall</span> <span class="nv">t</span>, D t -&gt; (<span class="mi">0</span> &lt;= f t)%E) -&gt;
  <span class="kr">exists</span> <span class="nv">g</span> : {nnsfun T &gt;-&gt; R}^nat, nondecreasing_seq (g : (T -&gt; R)^nat) /\
                        (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; EFin \o g^~x --&gt; f x).
<span class="kn">Proof</span>.
<span class="kr">exists</span> <span class="nv">nnsfun_approx</span>; <span class="nb">split</span>; [<span class="bp">exact</span>: nd_nnsfun_approx|].
<span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="bp">exact</span>: cvg_nnsfun_approx.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">approximation</span>.

<span class="kn">Section</span> <span class="nf">semi_linearity0</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variables</span> <span class="nv">f1</span> <span class="nv">f2</span> : T -&gt; \bar R.
<span class="kn">Hypothesis</span> <span class="nv">f10</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f1 x.
<span class="kn">Hypothesis</span> <span class="nv">mf1</span> : measurable_fun D f1.

<span class="kn">Lemma</span> <span class="nf">ge0_integralM_EFin</span> <span class="nv">k</span> : (<span class="mi">0</span> &lt;= k)%R -&gt;
  \int[mu]_(x <span class="kr">in</span> D) (k%:E * f1 x) = k%:E * \int[mu]_(x <span class="kr">in</span> D) f1 x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> integral_mkcond erestrict_scale [<span class="kr">in</span> RHS]integral_mkcond =&gt; k0.
<span class="nb">set</span> h1 := f1 \_ D.
<span class="nb">have</span> h10 x : <span class="mi">0</span> &lt;= h1 x <span class="bp">by</span> <span class="nb">apply</span>: erestrict_ge0.
<span class="nb">have</span> mh1 : measurable_fun setT h1 <span class="bp">by</span> <span class="nb">apply</span>/(measurable_restrict _ mD).
<span class="nb">have</span> [g [nd_g gh1]] := approximation measurableT mh1 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; h10 x).
<span class="nb">pose</span> kg := <span class="kr">fun</span> <span class="nv">n</span> =&gt; scale_nnsfun (g n) k0.
<span class="nb">rewrite</span> (@nd_ge0_integral_lim _ _ _ mu (<span class="kr">fun</span> <span class="nv">x</span> =&gt; k%:E * h1 x) kg).
- <span class="nb">rewrite</span> (_ : _ \o _ = <span class="kr">fun</span> <span class="nv">n</span> =&gt; sintegral mu (scale_nnsfun (g n) k0))//.
  <span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) = (<span class="kr">fun</span> <span class="nv">n</span> =&gt; k%:E * sintegral mu (g n))).
    <span class="nb">rewrite</span> limeMl //; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sintegral =&gt; // x m n mn; <span class="nb">apply</span>/(lef_at x nd_g).
    <span class="bp">by</span> <span class="nb">rewrite</span> -(nd_ge0_integral_lim mu h10) // =&gt; x;
      [<span class="bp">exact</span>/(lef_at x nd_g)|<span class="bp">exact</span>: gh1].
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> (sintegralrM mu k (g _)).
- <span class="bp">by</span> <span class="nb">move</span>=&gt; t; <span class="nb">rewrite</span> mule_ge0.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x m n mn; <span class="nb">rewrite</span> /kg ler_pmul//; <span class="bp">exact</span>/lefP/nd_g.
- <span class="nb">move</span>=&gt; x.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ = (<span class="kr">fun</span> <span class="nv">n</span> =&gt; k%:E * (g n x)%:E)) <span class="nl">?funeqE</span>//.
  <span class="bp">by</span> <span class="nb">apply</span>: cvgeMl =&gt; //; <span class="bp">exact</span>: gh1.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">semi_linearity0</span>.

<span class="kn">Section</span> <span class="nf">semi_linearity</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">f1</span> <span class="nv">f2</span> : T -&gt; \bar R).
<span class="kn">Hypothesis</span> <span class="nv">f10</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f1 x.
<span class="kn">Hypothesis</span> <span class="nv">mf1</span> : measurable_fun D f1.
<span class="kn">Hypothesis</span> <span class="nv">f20</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f2 x.
<span class="kn">Hypothesis</span> <span class="nv">mf2</span> : measurable_fun D f2.

<span class="kn">Lemma</span> <span class="nf">ge0_integralD</span> : \int[mu]_(x <span class="kr">in</span> D) (f1 x + f2 x) =
  \int[mu]_(x <span class="kr">in</span> D) f1 x + \int[mu]_(x <span class="kr">in</span> D) f2 x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> !(integral_mkcond D) erestrictD.
<span class="nb">set</span> h1 := f1 \_ D; <span class="nb">set</span> h2 := f2 \_ D.
<span class="nb">have</span> h10 x : <span class="mi">0</span> &lt;= h1 x <span class="bp">by</span> <span class="nb">apply</span>: erestrict_ge0.
<span class="nb">have</span> h20 x : <span class="mi">0</span> &lt;= h2 x <span class="bp">by</span> <span class="nb">apply</span>: erestrict_ge0.
<span class="nb">have</span> mh1 : measurable_fun setT h1 <span class="bp">by</span> <span class="nb">apply</span>/(measurable_restrict _ mD).
<span class="nb">have</span> mh2 : measurable_fun setT h2 <span class="bp">by</span> <span class="nb">apply</span>/(measurable_restrict _ mD).
<span class="nb">have</span> [g1 [nd_g1 gh1]] := approximation measurableT mh1 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; h10 x).
<span class="nb">have</span> [g2 [nd_g2 gh2]] := approximation measurableT mh2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; h20 x).
<span class="nb">pose</span> g12 := <span class="kr">fun</span> <span class="nv">n</span> =&gt; add_nnsfun (g1 n) (g2 n).
<span class="nb">rewrite</span> (@nd_ge0_integral_lim _ _ _ mu _ g12) //; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> adde_ge0.
  - <span class="bp">by</span> <span class="nb">apply</span>: nondecreasing_seqD =&gt; // x;
      [<span class="bp">exact</span>/(lef_at x nd_g1)|<span class="bp">exact</span>/(lef_at x nd_g2)].
  - <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> (_ : _ \o _ = (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (g1 n x)%:E + (g2 n x)%:E))//.
    <span class="nb">apply</span>: cvgeD =&gt; //; [|<span class="bp">exact</span>: gh1|<span class="bp">exact</span>: gh2].
    <span class="bp">by</span> <span class="nb">apply</span>: ge0_adde_def =&gt; //; <span class="nb">rewrite</span> !inE; [<span class="bp">exact</span>: h10|<span class="bp">exact</span>: h20].
<span class="nb">under</span> [_ \o _]eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> sintegralD.
<span class="nb">rewrite</span> (nd_ge0_integral_lim _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lef_at x nd_g1)) //; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="bp">exact</span>: gh1.
<span class="nb">rewrite</span> (nd_ge0_integral_lim _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lef_at x nd_g2)) //; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="bp">exact</span>: gh2.
<span class="nb">rewrite</span> limeD //.
  <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sintegral =&gt; // x Dx; <span class="bp">exact</span>/(lef_at x nd_g1).
  <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sintegral =&gt; // x Dx; <span class="bp">exact</span>/(lef_at x nd_g2).
<span class="nb">rewrite</span> ge0_adde_def =&gt; //; <span class="nb">rewrite</span> inE; <span class="nb">apply</span>: lime_ge.
- <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sintegral =&gt; // x Dx; <span class="bp">exact</span>/(lef_at x nd_g1).
- <span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; n; <span class="bp">exact</span>: sintegral_ge0.
- <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sintegral =&gt; // x Dx; <span class="bp">exact</span>/(lef_at x nd_g2).
- <span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; n; <span class="bp">exact</span>: sintegral_ge0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ge0_le_integral</span> : (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; f1 x &lt;= f2 x) -&gt;
  \int[mu]_(x <span class="kr">in</span> D) f1 x &lt;= \int[mu]_(x <span class="kr">in</span> D) f2 x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f12; <span class="nb">rewrite</span> !(integral_mkcond D).
<span class="nb">set</span> h1 := f1 \_ D; <span class="nb">set</span> h2 := f2 \_ D.
<span class="nb">have</span> h10 x : <span class="mi">0</span> &lt;= h1 x <span class="bp">by</span> <span class="nb">apply</span>: erestrict_ge0.
<span class="nb">have</span> h20 x : <span class="mi">0</span> &lt;= h2 x <span class="bp">by</span> <span class="nb">apply</span>: erestrict_ge0.
<span class="nb">have</span> mh1 : measurable_fun setT h1 <span class="bp">by</span> <span class="nb">apply</span>/(measurable_restrict _ mD).
<span class="nb">have</span> mh2 : measurable_fun setT h2 <span class="bp">by</span> <span class="nb">apply</span>/(measurable_restrict _ mD).
<span class="nb">have</span> h12 x : h1 x &lt;= h2 x <span class="bp">by</span> <span class="nb">apply</span>: lee_restrict.
<span class="nb">have</span> [g1 [nd_g1 /(_ _ Logic.I)gh1]] :=
  approximation measurableT mh1 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; h10 _).
<span class="nb">rewrite</span> (nd_ge0_integral_lim _ h10 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lef_at x nd_g1) gh1)//.
<span class="nb">apply</span>: lime_le.
  <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sintegral =&gt; // t Dt; <span class="bp">exact</span>/(lef_at t nd_g1).
near=&gt; n; <span class="nb">rewrite</span> ge0_integralTE//; <span class="nb">apply</span>: ereal_sup_ub =&gt; /=.
<span class="kr">exists</span> (<span class="nv">g1</span> <span class="nv">n</span>) =&gt; // t; <span class="nb">rewrite</span> (le_trans _ (h12 _)) //.
<span class="nb">have</span> := gh1 t.
<span class="nb">have</span> := leey (h1 t); <span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[-&gt;|ftoo].
  <span class="bp">by</span> <span class="nb">rewrite</span> leey.
<span class="nb">have</span> h1tfin : h1 t \<span class="kr">is</span> a fin_num.
  <span class="bp">by</span> <span class="nb">rewrite</span> fin_numE gt_eqF/= <span class="nl">?lt_eqF</span>// (lt_le_trans _ (h10 t)).
<span class="nb">have</span> := gh1 t.
<span class="nb">rewrite</span> -(fineK h1tfin) =&gt; /fine_cvgP[ft_near].
<span class="nb">set</span> u_ := (X <span class="kr">in</span> X --&gt; _) =&gt; u_h1 g1h1.
<span class="nb">have</span> &lt;- : lim u_ = fine (h1 t) <span class="bp">by</span> <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="bp">exact</span>: Rhausdorff.
<span class="nb">rewrite</span> lee_fin; <span class="nb">apply</span>: nondecreasing_cvg_le.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; // a b ab; <span class="nb">rewrite</span> /u_ /=; <span class="bp">exact</span>/lefP/nd_g1.
<span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: u_h1.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">semi_linearity</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_funN</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType) <span class="nv">D</span> (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable D -&gt; measurable_fun D f -&gt; measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; - f x)%E.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mD mf; <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: emeasurable_fun_minus.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">approximation_sfun</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType) (<span class="nv">f</span> : T -&gt; \bar R).
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">mf</span> : measurable_fun D f).

<span class="kn">Lemma</span> <span class="nf">approximation_sfun</span> :
  <span class="kr">exists</span> <span class="nv">g</span> : {sfun T &gt;-&gt; R}^nat, (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; EFin \o g^~x --&gt; f x).
<span class="kn">Proof</span>.
<span class="nb">have</span> fp0 : (<span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= f^\+ x)%E <span class="bp">by</span> [].
<span class="nb">have</span> mfp : measurable_fun D f^\+%E.
  <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_max =&gt; //; <span class="bp">exact</span>: measurable_fun_cst.
<span class="nb">have</span> fn0 : (<span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= f^\- x)%E <span class="bp">by</span> [].
<span class="nb">have</span> mfn : measurable_fun D f^\-%E.
  <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_max =&gt; //;
    [<span class="bp">exact</span>: emeasurable_funN | <span class="bp">exact</span>: measurable_fun_cst].
<span class="nb">have</span> [fp_ [fp_nd fp_cvg]] := approximation mD mfp (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; fp0 x).
<span class="nb">have</span> [fn_ [fn_nd fn_cvg]] := approximation mD mfn (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; fn0 x).
<span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">n</span> =&gt; [the {sfun T &gt;-&gt; R} of fp_ n \+ cst (-<span class="mi">1</span>) \* fn_ n]) =&gt; x /=.
<span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ =
    EFin \o fp_^~ x \+ (-%E \o EFin \o fn_^~ x))%E; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; n/=; <span class="nb">rewrite</span> EFinD mulN1r.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> (funeposneg f); <span class="nb">apply</span>: cvgeD;
  [<span class="bp">exact</span>: add_def_funeposneg|<span class="nb">apply</span>: fp_cvg|<span class="nb">apply</span>:cvgeN; <span class="bp">exact</span>: fn_cvg].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">approximation_sfun</span>.

<span class="kn">Section</span> <span class="nf">emeasurable_fun</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Implicit Types</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; \bar R).

<span class="kn">Lemma</span> <span class="nf">emeasurable_funD</span> <span class="nv">D</span> <span class="nv">f</span> <span class="nv">g</span> :
  measurable_fun D f -&gt; measurable_fun D g -&gt; measurable_fun D (f \+ g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf mg mD.
<span class="nb">have</span> Cnoom : measurable (~` [<span class="nb">set</span> -oo] : <span class="nb">set</span> (\bar R)) <span class="bp">by</span> <span class="nb">apply</span>: measurableC.
<span class="nb">have</span> Cpoom : measurable (~` [<span class="nb">set</span> +oo] : <span class="nb">set</span> (\bar R)) <span class="bp">by</span> <span class="nb">apply</span>: measurableC.
<span class="nb">have</span> mfg :  measurable (D `&amp;` [<span class="nb">set</span> x | f x +? g x]).
  <span class="nb">suff</span> -&gt; : [<span class="nb">set</span> x | f x +? g x] =
              (f @^-<span class="mi">1</span>` (~` [<span class="nb">set</span> +oo]) `|` g @^-<span class="mi">1</span>` (~` [<span class="nb">set</span> -oo])) `&amp;`
              (f @^-<span class="mi">1</span>` (~` [<span class="nb">set</span> -oo]) `|` g @^-<span class="mi">1</span>` (~` [<span class="nb">set</span> +oo])).
     <span class="bp">by</span> <span class="nb">rewrite</span> setIIr; <span class="nb">apply</span>: measurableI;
        <span class="nb">rewrite</span> setIUr; <span class="nb">apply</span>: measurableU; <span class="kp">do</span> ?[<span class="nb">apply</span>: mf|<span class="nb">apply</span>: mg].
   <span class="nb">apply</span>/predeqP=&gt; x; <span class="nb">rewrite</span> /preimage/= /adde_def !(negb_and, negb_or).
   <span class="bp">by</span> <span class="nb">rewrite</span> !(rwP2 eqP idP) !(rwP2 negP idP) !(rwP2 orP idP) !(rwP2 andP idP).
<span class="nb">wlog</span> fg : D mD mf mg mfg / <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; f x +? g x =&gt; [hwlogD|]; <span class="nb">last first</span>.
   <span class="nb">have</span> [f_ f_cvg] := approximation_sfun mD mf.
   <span class="nb">have</span> [g_ g_cvg] := approximation_sfun mD mg.
   <span class="nb">apply</span>: (emeasurable_fun_cvg (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">x</span> =&gt; (f_ n x + g_ n x)%:E)) =&gt; //.
     <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>/EFin_measurable_fun/measurable_funTS/measurable_funD.
  <span class="nb">move</span>=&gt; x Dx; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> EFinD.
  <span class="bp">exact</span>: cvgeD (fg _ _) (f_cvg _ _) (g_cvg _ _).
<span class="nb">move</span>=&gt; A mA; <span class="nb">wlog</span> NAnoo: A mD mf mg mA / ~ (A -oo) =&gt; [hwlogA|].
  <span class="nb">have</span> [] := pselect (A -oo); <span class="nb">last</span> <span class="bp">exact</span>: hwlogA.
  <span class="nb">move</span>=&gt; /(@setD1K _ -oo)&lt;-; <span class="nb">rewrite</span> preimage_setU setIUr.
  <span class="nb">apply</span>: measurableU; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: hwlogA=&gt; //; [<span class="bp">exact</span>: measurableD|<span class="nb">case</span>=&gt;/=].
  <span class="nb">have</span> -&gt; : (f \+ g) @^-<span class="mi">1</span>` [<span class="nb">set</span> -oo] = f @^-<span class="mi">1</span>` [<span class="nb">set</span> -oo] `|` g @^-<span class="mi">1</span>` [<span class="nb">set</span> -oo].
     <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; x /= =&gt; [/eqP|[]]; <span class="nb">rewrite</span> /preimage/=.
     - <span class="bp">by</span> <span class="nb">rewrite</span> adde_eq_ninfty =&gt; /orP[] /eqP-&gt;; [<span class="nb">left</span>|<span class="nb">right</span>].
     - <span class="bp">by</span> <span class="nb">move</span>-&gt;.
     - <span class="bp">by</span> <span class="nb">move</span>-&gt;; <span class="nb">rewrite</span> addeC.
   <span class="bp">by</span> <span class="nb">rewrite</span> setIUr; <span class="nb">apply</span>: measurableU; [<span class="nb">apply</span>: mf|<span class="nb">apply</span>: mg].
<span class="nb">have</span>-&gt; : D `&amp;` (f \+ g) @^-<span class="mi">1</span>` A =
       (D `&amp;` [<span class="nb">set</span> x | f x +? g x]) `&amp;` (f \+ g) @^-<span class="mi">1</span>` A.
  <span class="nb">rewrite</span> -setIA; <span class="nb">congr</span> (_ `&amp;` _).
  <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; x; <span class="nb">rewrite</span> /preimage/=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>.
  <span class="nb">move</span>=&gt; Afgx; <span class="nb">split</span>=&gt; //.
  <span class="bp">by</span> <span class="nb">case</span>: (f x) (g x) Afgx =&gt; [rf||] [rg||].
<span class="nb">have</span> Dfg : D `&amp;` [<span class="nb">set</span> x | f x +? g x] `&lt;=` D <span class="bp">by</span> <span class="nb">apply</span>: subIset; <span class="nb">left</span>.
<span class="nb">apply</span>: hwlogD =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: (measurable_funS mD) =&gt; //; <span class="kp">do</span> <span class="nl">?exact</span>: measurableI.
- <span class="bp">by</span> <span class="nb">apply</span>: (measurable_funS mD) =&gt; //; <span class="kp">do</span> <span class="nl">?exact</span>: measurableI.
- <span class="bp">by</span> <span class="nb">rewrite</span> -setIA setIid.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_sum</span> <span class="nv">D</span> <span class="nv">I</span> <span class="nv">s</span> (<span class="nv">h</span> : I -&gt; (T -&gt; \bar R)) :
  (<span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (h n)) -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; \sum_(i &lt;- s) h i x).
<span class="kn">Proof</span>.
<span class="nb">elim</span>: s =&gt; [|s t ih] mf.
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> big_nil; <span class="bp">exact</span>: measurable_fun_cst.
<span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> big_cons //=; <span class="nb">apply</span>: emeasurable_funD =&gt; //.
<span class="bp">exact</span>: ih.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_fsum</span> <span class="nv">D</span> (<span class="nv">I</span> : choiceType) (<span class="nv">A</span> : <span class="nb">set</span> I)
    (<span class="nv">h</span> : I -&gt; (T -&gt; \bar R)) : finite_set A -&gt;
    (<span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (h n)) -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; \sum_(i \<span class="kr">in</span> A) h i x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fs mh; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> fsbig_finite//.
<span class="bp">exact</span>: emeasurable_fun_sum.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ge0_emeasurable_fun_sum</span> <span class="nv">D</span> (<span class="nv">h</span> : nat -&gt; (T -&gt; \bar R)) :
  (<span class="kr">forall</span> <span class="nv">k</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= h k x) -&gt; (<span class="kr">forall</span> <span class="nv">k</span>, measurable_fun D (h k)) -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; \sum_(i &lt;oo) h i x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; h0 mh; <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable_fun _ X](_ : _ =
    (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lim_esup (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n) h i x))); <span class="nb">last first</span>.
  <span class="nb">apply</span>/funext=&gt; x; <span class="nb">rewrite</span> is_cvg_lim_esupE//.
  <span class="bp">exact</span>: is_cvg_ereal_nneg_natsum.
<span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_lim_esup =&gt; k; <span class="bp">exact</span>: emeasurable_fun_sum.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_funB</span> <span class="nv">D</span> <span class="nv">f</span> <span class="nv">g</span> :
  measurable_fun D f -&gt; measurable_fun D g -&gt; measurable_fun D (f \- g).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mf mg mD; <span class="nb">apply</span>: emeasurable_funD =&gt; //; <span class="bp">exact</span>: emeasurable_funN.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_funM</span> <span class="nv">D</span> <span class="nv">f</span> <span class="nv">g</span> :
  measurable_fun D f -&gt; measurable_fun D g -&gt; measurable_fun D (f \* g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf mg mD.
<span class="nb">have</span> m0 : measurable ([<span class="nb">set</span> <span class="mi">0</span>] : <span class="nb">set</span> (\bar R)) <span class="bp">by</span> [].
<span class="nb">have</span> mC0 : measurable ([<span class="nb">set</span>~ <span class="mi">0</span>] : <span class="nb">set</span> (\bar R)) <span class="bp">by</span> <span class="nb">apply</span>: measurableC.
<span class="nb">have</span> mCoo : measurable (~` [<span class="nb">set</span> -oo; +oo] : <span class="nb">set</span> (\bar R)).
  <span class="bp">exact</span>/measurableC/measurableU.
<span class="nb">have</span> mfg : measurable (D `&amp;` [<span class="nb">set</span> x | f x *? g x]).
  <span class="nb">suff</span> -&gt; : [<span class="nb">set</span> x | f x *? g x] =
              (f @^-<span class="mi">1</span>` (~` [<span class="nb">set</span> <span class="mi">0</span>]) `|` g @^-<span class="mi">1</span>` (~` [<span class="nb">set</span> -oo; +oo])) `&amp;`
              (g @^-<span class="mi">1</span>` (~` [<span class="nb">set</span> <span class="mi">0</span>]) `|` f @^-<span class="mi">1</span>` (~` [<span class="nb">set</span> -oo; +oo])).
     <span class="bp">by</span> <span class="nb">rewrite</span> setIIr; <span class="nb">apply</span>: measurableI;
        <span class="nb">rewrite</span> setIUr; <span class="nb">apply</span>: measurableU; <span class="kp">do</span> ?[<span class="nb">apply</span>: mf|<span class="nb">apply</span>: mg].
   <span class="nb">apply</span>/predeqP=&gt; x; <span class="nb">rewrite</span> /preimage/= /mule_def !(negb_and, negb_or).
   <span class="nb">rewrite</span> !(rwP2 eqP idP) !(rwP2 negP idP) !(rwP2 orP idP).
   <span class="nb">rewrite</span> !(rwP2 negP idP) !(rwP2 orP idP) !(rwP2 andP idP).
   <span class="nb">rewrite</span> eqe_absl leey andbT (orbC (g x == +oo)).
   <span class="bp">by</span> <span class="nb">rewrite</span> eqe_absl leey andbT (orbC (f x == +oo)).
<span class="nb">wlog</span> fg : D mD mf mg mfg / <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; f x *? g x =&gt; [hwlogM|]; <span class="nb">last first</span>.
  <span class="nb">have</span> [f_ f_cvg] := approximation_sfun mD mf.
  <span class="nb">have</span> [g_ g_cvg] := approximation_sfun mD mg.
  <span class="nb">apply</span>: (emeasurable_fun_cvg (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">x</span> =&gt; (f_ n x * g_ n x)%:E)) =&gt; //.
    <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>/EFin_measurable_fun.
    <span class="bp">by</span> <span class="nb">apply</span>: measurable_funM =&gt; //; <span class="bp">exact</span>: measurable_funTS.
  <span class="nb">move</span>=&gt; x Dx; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> EFinM.
  <span class="bp">exact</span>: cvgeM (fg _ _) (f_cvg _ _) (g_cvg _ _).
<span class="nb">move</span>=&gt; A mA; <span class="nb">wlog</span> NA0: A mD mf mg mA / ~ (A <span class="mi">0</span>) =&gt; [hwlogA|].
  <span class="nb">have</span> [] := pselect (A <span class="mi">0</span>); <span class="nb">last</span> <span class="bp">exact</span>: hwlogA.
  <span class="nb">move</span>=&gt; /(@setD1K _ <span class="mi">0</span>)&lt;-; <span class="nb">rewrite</span> preimage_setU setIUr.
  <span class="nb">apply</span>: measurableU; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: hwlogA=&gt; //; [<span class="bp">exact</span>: measurableD|<span class="nb">case</span> =&gt; /=].
  <span class="nb">have</span> -&gt; : (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x * g x) @^-<span class="mi">1</span>` [<span class="nb">set</span> <span class="mi">0</span>] =
           f @^-<span class="mi">1</span>` [<span class="nb">set</span> <span class="mi">0</span>] `|` g @^-<span class="mi">1</span>` [<span class="nb">set</span> <span class="mi">0</span>].
     <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; x /= =&gt; [/eqP|[]]; <span class="nb">rewrite</span> /preimage/=.
       <span class="bp">by</span> <span class="nb">rewrite</span> mule_eq0 =&gt; /orP[] /eqP-&gt;; [<span class="nb">left</span>|<span class="nb">right</span>].
     <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">rewrite</span> mul0e.
     <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">rewrite</span> mule0.
   <span class="bp">by</span> <span class="nb">rewrite</span> setIUr; <span class="nb">apply</span>: measurableU; [<span class="nb">apply</span>: mf|<span class="nb">apply</span>: mg].
<span class="nb">have</span>-&gt; : D `&amp;` (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x * g x) @^-<span class="mi">1</span>` A =
       (D `&amp;` [<span class="nb">set</span> x | f x *? g x]) `&amp;` (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x * g x) @^-<span class="mi">1</span>` A.
  <span class="nb">rewrite</span> -setIA; <span class="nb">congr</span> (_ `&amp;` _).
  <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; x; <span class="nb">rewrite</span> /preimage/=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>.
  <span class="nb">move</span>=&gt; Afgx; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: neq0_mule_def.
  <span class="bp">by</span> <span class="nb">apply</span>: contra_notT NA0; <span class="nb">rewrite</span> negbK =&gt; /eqP &lt;-.
<span class="nb">have</span> Dfg : D `&amp;` [<span class="nb">set</span> x | f x *? g x] `&lt;=` D <span class="bp">by</span> <span class="nb">apply</span>: subIset; <span class="nb">left</span>.
<span class="nb">apply</span>: hwlogM =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: (measurable_funS mD) =&gt; //; <span class="kp">do</span> <span class="nl">?exact</span>: measurableI.
- <span class="bp">by</span> <span class="nb">apply</span>: (measurable_funS mD) =&gt; //; <span class="kp">do</span> <span class="nl">?exact</span>: measurableI.
- <span class="bp">by</span> <span class="nb">rewrite</span> -setIA setIid.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_funeM</span> <span class="nv">D</span> (<span class="nv">f</span> : T -&gt; \bar R) (<span class="nv">k</span> : \bar R) :
  measurable_fun D f -&gt; measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; k * f x)%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mf; <span class="bp">exact</span>/(emeasurable_funM _ mf)/measurable_fun_cst. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">emeasurable_fun</span>.

<span class="kn">Section</span> <span class="nf">ge0_integral_sum</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variables</span> (<span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : I -&gt; (T -&gt; \bar R)).
<span class="kn">Hypothesis</span> <span class="nv">mf</span> : <span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (f n).
<span class="kn">Hypothesis</span> <span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f n x.

<span class="kn">Lemma</span> <span class="nf">ge0_integral_sum</span> (<span class="nv">s</span> : seq I) :
  \int[mu]_(x <span class="kr">in</span> D) (\sum_(k &lt;- s) f k x) =
  \sum_(k &lt;- s) \int[mu]_(x <span class="kr">in</span> D) (f k x).
<span class="kn">Proof</span>.
<span class="nb">elim</span>: s =&gt; [|h t ih].
  <span class="bp">by</span> (<span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> big_nil); <span class="nb">rewrite</span> big_nil integral0.
<span class="nb">rewrite</span> big_cons /= -ih -ge0_integralD//.
- <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; x Dx; <span class="nb">rewrite</span> big_cons.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: f0.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">apply</span>: sume_ge0 =&gt; // k _; <span class="bp">exact</span>: f0.
- <span class="bp">exact</span>: emeasurable_fun_sum.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ge0_integral_sum</span>.

<span class="kn">Section</span> <span class="nf">ge0_integral_fsum</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variables</span> (<span class="nv">I</span> : choiceType) (<span class="nv">f</span> : I -&gt; (T -&gt; \bar R)).
<span class="kn">Hypothesis</span> <span class="nv">mf</span> : <span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (f n).
<span class="kn">Hypothesis</span> <span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f n x.

<span class="kn">Lemma</span> <span class="nf">ge0_integral_fsum</span> (<span class="nv">A</span> : <span class="nb">set</span> I) : finite_set A -&gt;
  \int[mu]_(x <span class="kr">in</span> D) (\sum_(k \<span class="kr">in</span> A) f k x) =
  \sum_(k \<span class="kr">in</span> A) \int[mu]_(x <span class="kr">in</span> D) f k x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fs; <span class="nb">rewrite</span> fsbig_finite//= -ge0_integral_sum//.
<span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; x xD; <span class="nb">rewrite</span> fsbig_finite.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ge0_integral_fsum</span>.

<span class="kn">Section</span> <span class="nf">monotone_convergence_theorem</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">g&#39;</span> : (T -&gt; \bar R)^nat).
<span class="kn">Hypothesis</span> <span class="nv">mg&#39;</span> : <span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (g&#39; n).
<span class="kn">Hypothesis</span> <span class="nv">g&#39;0</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= g&#39; n x.
<span class="kn">Hypothesis</span> <span class="nv">nd_g&#39;</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; nondecreasing_seq (g&#39;^~ x).
<span class="kn">Let</span> <span class="nf">f&#39;</span> := <span class="kr">fun</span> <span class="nv">x</span> =&gt; lim (g&#39;^~ x).

<span class="kn">Let</span> <span class="nf">g</span> <span class="nv">n</span> := (g&#39; n \_ D).

<span class="kn">Let</span> <span class="nf">g0</span> <span class="nv">n</span> <span class="nv">x</span> : <span class="mi">0</span> &lt;= g n x. <span class="kn">Proof</span>. <span class="bp">exact</span>/erestrict_ge0/g&#39;0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mg</span> <span class="nv">n</span> : measurable_fun setT (g n).
<span class="kn">Proof</span>. <span class="bp">exact</span>/(measurable_restrict _ mD). <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">nd_g</span> <span class="nv">x</span> : nondecreasing_seq (g^~ x).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; m n mn; <span class="nb">rewrite</span> /g/patch; <span class="nb">case</span>: ifP =&gt; // /set_mem /nd_g&#39; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">f</span> := <span class="kr">fun</span> <span class="nv">x</span> =&gt; lim (g^~ x).

<span class="kn">Let</span> <span class="nf">is_cvg_g</span> <span class="nv">t</span> : cvg (g^~ t).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: ereal_nondecreasing_is_cvg =&gt; m n ?; <span class="nb">apply</span>/nd_g. <span class="kn">Qed</span>.

<span class="kn">Local Definition</span> <span class="nf">g2&#39;</span> <span class="nv">n</span> : (T -&gt; R)^nat := approx setT (g n).
<span class="kn">Local Definition</span> <span class="nf">g2</span> <span class="nv">n</span> : {nnsfun T &gt;-&gt; R}^nat := nnsfun_approx measurableT (mg n).

<span class="kn">Local Definition</span> <span class="nf">max_g2&#39;</span> : (T -&gt; R)^nat :=
  <span class="kr">fun</span> <span class="nv">k</span> <span class="nv">t</span> =&gt; (\big[maxr/<span class="mi">0</span>]_(i &lt; k) (g2&#39; i k) t)%R.
<span class="kn">Local Definition</span> <span class="nf">max_g2</span> : {nnsfun T &gt;-&gt; R}^nat :=
  <span class="kr">fun</span> <span class="nv">k</span> =&gt; bigmax_nnsfun (g2^~ k) k.

<span class="kn">Let</span> <span class="nf">is_cvg_g2</span> <span class="nv">n</span> <span class="nv">t</span> : cvg (EFin \o (g2 n ^~ t)).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: ereal_nondecreasing_is_cvg =&gt; a b ab.
<span class="bp">by</span> <span class="nb">rewrite</span> lee_fin <span class="mi">2</span>!nnsfun_approxE; <span class="bp">exact</span>/lefP/nd_approx.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">nd_max_g2</span> : nondecreasing_seq (max_g2 : (T -&gt; R)^nat).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/nondecreasing_seqP =&gt; n; <span class="nb">apply</span>/lefP =&gt; x; <span class="nb">rewrite</span> <span class="mi">2</span>!bigmax_nnsfunE.
<span class="nb">rewrite</span> (@le_trans _ _ (\big[maxr/<span class="mi">0</span>]_(i &lt; n) g2 i n.+<span class="mi">1</span> x)%R) //.
  <span class="nb">apply</span>: le_bigmax2 =&gt; i _; <span class="nb">apply</span>: (nondecreasing_seqP (g2 i ^~ x)).<span class="mi">2</span> =&gt; a b ab.
   <span class="bp">by</span> <span class="nb">rewrite</span> !nnsfun_approxE; <span class="bp">exact</span>/lefP/nd_approx.
<span class="nb">rewrite</span> (bigmaxD1 ord_max)// le_maxr; <span class="nb">apply</span>/orP; <span class="nb">right</span>.
<span class="nb">rewrite</span> [leRHS](eq_bigl (<span class="kr">fun</span> <span class="nv">i</span> =&gt; nat_of_ord i &lt; n)%N).
  <span class="bp">by</span> <span class="nb">rewrite</span> (big_ord_narrow (leqnSn n)).
<span class="nb">move</span>=&gt; i /=; <span class="nb">rewrite</span> neq_lt; <span class="nb">apply</span>/orP/idP =&gt; [[//|]|]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">left</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /(leq_trans (ltn_ord i)); <span class="nb">rewrite</span> ltnn.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">is_cvg_max_g2</span> <span class="nv">t</span> : cvg (EFin \o max_g2 ^~ t).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: ereal_nondecreasing_is_cvg =&gt; m n mn; <span class="nb">rewrite</span> lee_fin.
<span class="bp">exact</span>/lefP/nd_max_g2.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">max_g2_g</span> <span class="nv">k</span> <span class="nv">x</span> : ((max_g2 k x)%:E &lt;= g k x)%O.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> bigmax_nnsfunE.
<span class="nb">apply</span>: (@le_trans _ _ (\big[maxe/<span class="mi">0</span>%:E]_(i &lt; k) g k x)); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>/bigmax_leP; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: g0D.
<span class="nb">rewrite</span> (@big_morph _ _ EFin <span class="mi">0</span>%:E maxe) //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> maxEFin.
<span class="nb">apply</span>: le_bigmax2 =&gt; i _; <span class="nb">rewrite</span> nnsfun_approxE /=.
<span class="bp">by</span> <span class="nb">rewrite</span> (le_trans (le_approx _ _ _)) =&gt; //; <span class="bp">exact</span>/nd_g/ltnW.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lim_max_g2_f</span> <span class="nv">t</span> : lim (EFin \o max_g2 ^~ t) &lt;= f t.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: lee_lim =&gt; //=; [<span class="nb">apply</span>: is_cvg_max_g2|<span class="nb">apply</span>: is_cvg_g|].
<span class="bp">by</span> near=&gt; n; <span class="bp">exact</span>/max_g2_g.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lim_g2_max_g2</span> <span class="nv">t</span> <span class="nv">n</span> : lim (EFin\o g2 n ^~ t) &lt;= lim (EFin \o max_g2 ^~ t).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: lee_lim =&gt; //; [<span class="nb">apply</span>: is_cvg_g2|<span class="nb">apply</span>: is_cvg_max_g2|].
near=&gt; k; <span class="nb">rewrite</span> /= bigmax_nnsfunE lee_fin.
<span class="nb">have</span> nk : (n &lt; k)%N <span class="bp">by</span> near: k; <span class="kr">exists</span> <span class="nv">n</span>.+<span class="mi">1</span>.
<span class="bp">exact</span>: (bigmax_sup (Ordinal nk)).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">cvg_max_g2_f</span> <span class="nv">t</span> : EFin \o max_g2 ^~ t --&gt; f t.
<span class="kn">Proof</span>.
<span class="nb">have</span> /cvg_ex[l g_l] := @is_cvg_max_g2 t.
<span class="nb">suff</span> : l == f t <span class="bp">by</span> <span class="nb">move</span>=&gt; /eqP &lt;-.
<span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> /f (le_trans _ (lim_max_g2_f _)) // (cvg_lim _ g_l).
<span class="nb">have</span> := leey l; <span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[-&gt;|loo]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> leey.
<span class="nb">rewrite</span> -(cvg_lim _ g_l) //= lime_le =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: is_cvg_g.
near=&gt; n.
<span class="nb">have</span> := leey (g n t); <span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[|] fntoo.
  <span class="nb">have</span> h := @dvg_approx _ _ _ setT _ t Logic.I fntoo.
  <span class="nb">have</span> g2oo : lim (EFin \o g2 n ^~ t) = +oo.
    <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>/cvgeryP.
    <span class="nb">under</span> [<span class="kr">in</span> X <span class="kr">in</span> X --&gt; _]eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> nnsfun_approxE.
    <span class="nb">have</span> : {homo (approx setT (g n))^~ t : n0 m / (n0 &lt;= m)%N &gt;-&gt; (n0 &lt;= m)%R}.
      <span class="bp">exact</span>/lef_at/nd_approx.
    <span class="bp">by</span> <span class="nb">move</span>/nondecreasing_dvg_lt =&gt; /(_ h).
  <span class="nb">have</span> -&gt; : lim (EFin \o max_g2 ^~ t) = +oo.
    <span class="bp">by</span> <span class="nb">have</span> := lim_g2_max_g2 t n; <span class="nb">rewrite</span> g2oo leye_eq =&gt; /eqP.
  <span class="bp">by</span> <span class="nb">rewrite</span> leey.
- <span class="nb">have</span> approx_g_g := @cvg_approx _ _ _ setT _ t (<span class="kr">fun</span> <span class="nv">t</span> <span class="nv">_</span> =&gt; g0 n t) Logic.I fntoo.
  <span class="nb">suff</span> : lim (EFin \o g2 n ^~ t) = g n t.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; &lt;-; <span class="bp">exact</span>: (le_trans _ (lim_g2_max_g2 t n)).
  <span class="nb">have</span> /cvg_lim &lt;- // : EFin \o (approx setT (g n)) ^~ t --&gt; g n t.
    <span class="nb">move</span>/cvg_comp : approx_g_g; <span class="nb">apply</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -(@fineK _ (g n t))// ge0_fin_numE// g0.
  <span class="nb">rewrite</span> (_ : _ \o _ = EFin \o approx setT (g n) ^~ t)// funeqE =&gt; m.
  <span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> RHS]/= -nnsfun_approxE.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">monotone_convergence</span> :
  \int[mu]_(x <span class="kr">in</span> D) (f&#39; x) = lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) (g&#39; n x)).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> integral_mkcond.
<span class="nb">under</span> [<span class="kr">in</span> RHS]eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> integral_mkcond -/(g _).
<span class="nb">have</span> -&gt; : f&#39; \_ D = f.
  <span class="nb">apply</span>/funext =&gt; x; <span class="nb">rewrite</span> /f /f&#39; /g /patch /=; <span class="nb">case</span>: ifPn =&gt; //=.
  <span class="bp">by</span> <span class="nb">rewrite</span> lim_cst.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">have</span> nd_int_g : nondecreasing_seq (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_x g n x).
    <span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: nd_g.
  <span class="nb">have</span> ub n : \int[mu]_x g n x &lt;= \int[mu]_x f x.
    <span class="nb">apply</span>: ge0_le_integral =&gt; //.
    - <span class="nb">move</span>=&gt; x _; <span class="nb">apply</span>: lime_ge =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: is_cvg_g.
      <span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; k; <span class="bp">exact</span>/g0.
    - <span class="nb">apply</span>: emeasurable_fun_cvg mg _ =&gt; x _.
      <span class="bp">exact</span>: ereal_nondecreasing_is_cvg.
    - <span class="nb">move</span>=&gt; x Dx; <span class="nb">apply</span>: lime_ge =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: is_cvg_g.
      near=&gt; m; <span class="nb">have</span> nm : (n &lt;= m)%N <span class="bp">by</span> near: m; <span class="kr">exists</span> <span class="nv">n</span>.
      <span class="bp">exact</span>/nd_g.
  <span class="bp">by</span> <span class="nb">apply</span>: lime_le =&gt; //; [<span class="bp">exact</span>:ereal_nondecreasing_is_cvg|<span class="bp">exact</span>:nearW].
<span class="nb">rewrite</span> (@nd_ge0_integral_lim _ _ _ mu _ max_g2) //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; t; <span class="nb">apply</span>: lime_ge =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: is_cvg_g.
    <span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; n; <span class="bp">exact</span>: g0.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; t m n mn; <span class="bp">exact</span>/lefP/nd_max_g2.
<span class="nb">apply</span>: lee_lim.
- <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sintegral =&gt; // t m n mn; <span class="bp">exact</span>/lefP/nd_max_g2.
- <span class="nb">apply</span>: ereal_nondecreasing_is_cvg =&gt; // n m nm; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>/nd_g.
- <span class="nb">apply</span>: nearW =&gt; n; <span class="nb">rewrite</span> ge0_integralTE//.
  <span class="bp">by</span> <span class="nb">apply</span>: ereal_sup_ub; <span class="kr">exists</span> (<span class="nv">max_g2</span> <span class="nv">n</span>) =&gt; // t; <span class="bp">exact</span>: max_g2_g.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_monotone_convergence</span> :
  (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) g&#39; n x) --&gt; \int[mu]_(x <span class="kr">in</span> D) f&#39; x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> monotone_convergence; <span class="nb">apply</span>: ereal_nondecreasing_is_cvg =&gt; m n mn.
<span class="bp">by</span> <span class="nb">apply</span>: ge0_le_integral =&gt; // t Dt; [<span class="bp">exact</span>: g&#39;0|<span class="bp">exact</span>: g&#39;0|<span class="bp">exact</span>: nd_g&#39;].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">monotone_convergence_theorem</span>.

<span class="kn">Section</span> <span class="nf">integral_nneseries</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variable</span> <span class="nv">f</span> : (T -&gt; \bar R)^nat.
<span class="kn">Hypothesis</span> <span class="nv">mf</span> : <span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (f n).
<span class="kn">Hypothesis</span> <span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f n x.

<span class="kn">Lemma</span> <span class="nf">integral_nneseries</span> : \int[mu]_(x <span class="kr">in</span> D) (\sum_(n &lt;oo) f n x) =
                           \sum_(n &lt;oo) (\int[mu]_(x <span class="kr">in</span> D) (f n x)).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> monotone_convergence //.
- <span class="bp">by</span> <span class="nb">rewrite</span> -lim_mkord; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> ge0_integral_sum// big_mkord.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>: emeasurable_fun_sum.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n x Dx; <span class="nb">apply</span>: sume_ge0 =&gt; m _; <span class="bp">exact</span>: f0.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx m n mn; <span class="nb">apply</span>: lee_sum_nneg_natr =&gt; // k _ _; <span class="bp">exact</span>: f0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_nneseries</span>.

<span class="c">(* generalization of ge0_integralM_EFin to a constant potentially +oo</span>
<span class="c">   using the monotone convergence theorem *)</span>
<span class="kn">Section</span> <span class="nf">ge0_integralM</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">mu</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}.
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">f</span> : T -&gt; \bar R).
<span class="kn">Hypothesis</span> <span class="nv">mf</span> : measurable_fun D f.

<span class="kn">Lemma</span> <span class="nf">ge0_integralM</span> (<span class="nv">k</span> : \bar R) : (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt;
  <span class="mi">0</span> &lt;= k -&gt; \int[mu]_(x <span class="kr">in</span> D) (k * f x)%E = k * \int[mu]_(x <span class="kr">in</span> D) (f x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0; <span class="nb">move</span>: k =&gt; [k|_|//]; <span class="kp">first</span> <span class="bp">exact</span>: ge0_integralM_EFin.
<span class="nb">pose</span> g : (T -&gt; \bar R)^nat := <span class="kr">fun</span> <span class="nv">n</span> <span class="nv">x</span> =&gt; n%:R%:E * f x.
<span class="nb">have</span> mg n : measurable_fun D (g n) <span class="bp">by</span> <span class="nb">apply</span>: measurable_funeM.
<span class="nb">have</span> g0 n x : D x -&gt; <span class="mi">0</span> &lt;= g n x.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Dx; <span class="nb">apply</span>: mule_ge0; [<span class="nb">rewrite</span> lee_fin|<span class="bp">exact</span>:f0].
<span class="nb">have</span> nd_g x : D x -&gt; nondecreasing_seq (g^~x).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Dx m n mn; <span class="nb">rewrite</span> lee_wpmul2r <span class="nl">?f0</span>// lee_fin ler_nat.
<span class="nb">pose</span> h := <span class="kr">fun</span> <span class="nv">x</span> =&gt; lim (g^~ x).
<span class="nb">transitivity</span> (\int[mu]_(x <span class="kr">in</span> D) lim (g^~ x)).
  <span class="nb">apply</span>: eq_integral =&gt; x Dx; <span class="nb">apply</span>/esym/cvg_lim =&gt; //.
  <span class="nb">have</span> [fx0|fx0|fx0] := ltgtP <span class="mi">0</span> (f x).
  - <span class="nb">rewrite</span> gt0_mulye//; <span class="nb">apply</span>/cvgeyPgey; near=&gt; M.
    <span class="nb">have</span> M0 : (<span class="mi">0</span> &lt;= M)%R <span class="bp">by</span> [].
    <span class="nb">rewrite</span> /g; <span class="nb">case</span>: (f x) fx0 =&gt; [r r0|_|//]; <span class="nb">last first</span>.
      <span class="kr">exists</span> <span class="mi">1</span>%N =&gt; // m /= m0.
      <span class="bp">by</span> <span class="nb">rewrite</span> mulry gtr0_sg// <span class="nl">?mul1e</span> <span class="nl">?leey</span>// ltr0n.
    near=&gt; n; <span class="nb">rewrite</span> lee_fin -ler_pdivr_mulr//.
    near: n; <span class="kr">exists</span> `|ceil (M / r)|%N =&gt; // m /=.
    <span class="nb">rewrite</span> -(ler_nat R); <span class="nb">apply</span>: le_trans.
    <span class="bp">by</span> <span class="nb">rewrite</span> natr_absz ger0_norm <span class="nl">?ceil_ge</span>// ceil_ge0// divr_ge0// <span class="nl">?ltW</span>.
  - <span class="nb">rewrite</span> lt0_mulye//; <span class="nb">apply</span>/cvgeNyPleNy; near=&gt; M;
    <span class="nb">have</span> M0 : (M &lt;= <span class="mi">0</span>)%R <span class="bp">by</span> [].
    <span class="nb">rewrite</span> /g; <span class="nb">case</span>: (f x) fx0 =&gt; [r r0|//|_]; <span class="nb">last first</span>.
      <span class="kr">exists</span> <span class="mi">1</span>%N =&gt; // m /= m0.
      <span class="bp">by</span> <span class="nb">rewrite</span> mulrNy gtr0_sg// <span class="nl">?ltr0n</span>// mul1e <span class="nl">?leNye</span>.
    near=&gt; n; <span class="nb">rewrite</span> lee_fin -ler_ndivr_mulr//.
    near: n; <span class="kr">exists</span> `|ceil (M / r)|%N =&gt; // m /=.
    <span class="nb">rewrite</span> -(ler_nat R); <span class="nb">apply</span>: le_trans.
    <span class="nb">rewrite</span> natr_absz ger0_norm <span class="nl">?ceil_ge</span>// ceil_ge0// -mulrNN.
    <span class="bp">by</span> <span class="nb">rewrite</span> mulr_ge0// ler_oppr oppr0// ltW// invr_lt0.
  - <span class="nb">rewrite</span> -fx0 mule0 /g -fx0 [X <span class="kr">in</span> X @ _ --&gt; _](_ : _ = cst <span class="mi">0</span>).
      <span class="bp">exact</span>: cvg_cst.
    <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n /=; <span class="nb">rewrite</span> mule0.
<span class="nb">rewrite</span> (monotone_convergence mu mD mg g0 nd_g).
<span class="nb">under</span> eq_fun <span class="kp">do</span>  <span class="nb">rewrite</span> /g ge0_integralM_EFin//.
<span class="nb">have</span> : <span class="mi">0</span> &lt;= \int[mu]_(x <span class="kr">in</span> D) (f x) <span class="bp">by</span> <span class="bp">exact</span>: integral_ge0.
<span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[&lt;-|if_gt0].
  <span class="bp">by</span> <span class="nb">rewrite</span> mule0; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> mule0; <span class="nb">rewrite</span> lim_cst.
<span class="nb">rewrite</span> gt0_mulye//; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>/cvgeyPgey; near=&gt; M.
<span class="nb">have</span> M0 : (<span class="mi">0</span> &lt;= M)%R <span class="bp">by</span> [].
near=&gt; n; <span class="nb">have</span> [ifoo|] := ltP (\int[mu]_(x <span class="kr">in</span> D) (f x)) +oo; <span class="nb">last first</span>.
  <span class="nb">rewrite</span> leye_eq =&gt; /eqP -&gt;; <span class="nb">rewrite</span> mulry muleC gt0_mulye <span class="nl">?leey</span>//.
  <span class="bp">by</span> near: n; <span class="kr">exists</span> <span class="mi">1</span>%N =&gt; // n /= n0; <span class="nb">rewrite</span> gtr0_sg// <span class="nl">?lte_fin</span>// ltr0n.
<span class="nb">rewrite</span> -(@fineK _ (\int[mu]_(x <span class="kr">in</span> D) f x)); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> fin_numElt ifoo (le_lt_trans _ if_gt0).
<span class="nb">rewrite</span> -lee_pdivr_mulr//; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>: if_gt0 ifoo; <span class="nb">case</span>: (\int[mu]_(x <span class="kr">in</span> D) f x).
near: n.
<span class="kr">exists</span> `|ceil (M * (fine (\int[mu]_(x <span class="kr">in</span> D) f x))^-<span class="mi">1</span>)|%N =&gt; //.
<span class="nb">move</span>=&gt; n /=; <span class="nb">rewrite</span> -(@ler_nat R) -lee_fin; <span class="nb">apply</span>: le_trans.
<span class="nb">rewrite</span> lee_fin natr_absz ger0_norm <span class="nl">?ceil_ge</span>// ceil_ge0//.
<span class="bp">by</span> <span class="nb">rewrite</span> mulr_ge0// <span class="nl">?invr_ge0</span>//; <span class="nb">apply</span>/fine_ge0/integral_ge0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ge0_integralM</span>.

<span class="kn">Section</span> <span class="nf">integral_indic</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).

<span class="kn">Lemma</span> <span class="nf">integral_indic</span> (<span class="nv">E</span> : <span class="nb">set</span> T) : measurable E -&gt;
  \int[mu]_(x <span class="kr">in</span> D) (\<span class="mi">1_</span>E x)%:E = mu (E `&amp;` D).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mE; <span class="nb">rewrite</span> (_ : \<span class="mi">1_</span>E = indic_nnsfun R mE)// integral_nnsfun//=.
<span class="bp">by</span> <span class="nb">rewrite</span> restrict_indic sintegral_indic//; <span class="bp">exact</span>: measurableI.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_indic</span>.

<span class="kn">Section</span> <span class="nf">integralM_indic</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">m</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).

<span class="kn">Lemma</span> <span class="nf">integralM_indic</span> (<span class="nv">f</span> : R -&gt; <span class="nb">set</span> T) (<span class="nv">k</span> : R) :
    ((k &lt; <span class="mi">0</span>)%R -&gt; f k = set0) -&gt; measurable (f k) -&gt;
  \int[m]_(x <span class="kr">in</span> D) (k * \<span class="mi">1_</span>(f k) x)%:E =
  k%:E * \int[m]_(x <span class="kr">in</span> D) (\<span class="mi">1_</span>(f k) x)%:E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fk0 mfk; <span class="nb">have</span> [k0|k0] := ltP k <span class="mi">0</span>%R.
  <span class="nb">rewrite</span> integral0_eq//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> fk0// indic0 mulr0.
  <span class="bp">by</span> <span class="nb">rewrite</span> integral0_eq <span class="nl">?mule0</span>// =&gt; x _; <span class="nb">rewrite</span> fk0// indic0.
<span class="nb">under</span> eq_integral <span class="kp">do</span> <span class="nb">rewrite</span> EFinM.
<span class="nb">rewrite</span> ge0_integralM//.
- <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_indic.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; y _; <span class="nb">rewrite</span> lee_fin.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integralM_indic_nnsfun</span> (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) (<span class="nv">k</span> : R) :
  \int[m]_(x <span class="kr">in</span> D) (k * \<span class="mi">1_</span>(f @^-<span class="mi">1</span>` [<span class="nb">set</span> k]) x)%:E =
  k%:E * \int[m]_(x <span class="kr">in</span> D) (\<span class="mi">1_</span>(f @^-<span class="mi">1</span>` [<span class="nb">set</span> k]) x)%:E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (@integralM_indic (<span class="kr">fun</span> <span class="nv">k</span> =&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> k]))// =&gt; k0.
<span class="bp">by</span> <span class="nb">rewrite</span> preimage_nnfun0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integralM_indic</span>.
<span class="kn">Arguments</span> integralM_indic {d T R m D} mD f.

<span class="kn">Section</span> <span class="nf">integral_mscale</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">m</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variables</span> (<span class="nv">k</span> : {nonneg R}) (<span class="nv">f</span> : T -&gt; \bar R).

<span class="kn">Let</span> <span class="nf">integral_mscale_indic</span> <span class="nv">E</span> : measurable E -&gt;
  \int[mscale k m]_(x <span class="kr">in</span> D) (\<span class="mi">1_</span>E x)%:E =
  k%:num%:E * \int[m]_(x <span class="kr">in</span> D) (\<span class="mi">1_</span>E x)%:E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> !integral_indic. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">integral_mscale_nnsfun</span> (<span class="nv">h</span> : {nnsfun T &gt;-&gt; R}) :
  \int[mscale k m]_(x <span class="kr">in</span> D) (h x)%:E = k%:num%:E * \int[m]_(x <span class="kr">in</span> D) (h x)%:E.
<span class="kn">Proof</span>.
<span class="nb">under</span> [LHS]eq_integral <span class="kp">do</span> <span class="nb">rewrite</span> fimfunE -fsumEFin//.
<span class="nb">rewrite</span> [LHS]ge0_integral_fsum//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; r.
    <span class="bp">exact</span>/EFin_measurable_fun/measurable_funrM/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n x _; <span class="nb">rewrite</span> EFinM nnfun_muleindic_ge0.
<span class="nb">rewrite</span> -[RHS]ge0_integralM//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="bp">exact</span>/EFin_measurable_fun/measurable_funTS.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> lee_fin.
<span class="nb">under</span> [RHS]eq_integral.
  <span class="nb">move</span>=&gt; x xD; <span class="nb">rewrite</span> fimfunE -fsumEFin// ge0_mule_fsumr; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; r; <span class="nb">rewrite</span> EFinM nnfun_muleindic_ge0.
  <span class="nb">over</span>.
<span class="nb">rewrite</span> [RHS]ge0_integral_fsum//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; r; <span class="nb">apply</span>/EFin_measurable_fun/measurable_funrM/measurable_funrM.
    <span class="bp">exact</span>/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n x _; <span class="nb">rewrite</span> EFinM mule_ge0// nnfun_muleindic_ge0.
<span class="nb">apply</span> eq_fsbigr =&gt; r _; <span class="nb">rewrite</span> ge0_integralM//.
- <span class="bp">by</span> <span class="nb">rewrite</span> !integralM_indic_nnsfun//= integral_mscale_indic// muleCA.
- <span class="bp">exact</span>/EFin_measurable_fun/measurable_funrM/measurable_fun_indic.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; t _; <span class="nb">rewrite</span> nnfun_muleindic_ge0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ge0_integral_mscale</span> (<span class="nv">mf</span> : measurable_fun D f) :
    (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt;
  \int[mscale k m]_(x <span class="kr">in</span> D) f x = k%:num%:E * \int[m]_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0; <span class="nb">have</span> [f_ [ndf_ f_f]] := approximation mD mf f0.
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mscale k m]_(x <span class="kr">in</span> D) (f_ n x)%:E)).
  <span class="nb">rewrite</span> -monotone_convergence//=.
  - <span class="bp">by</span> <span class="nb">apply</span> eq_integral =&gt; x /[!inE] xD; <span class="nb">apply</span>/esym/cvg_lim =&gt; //=; <span class="bp">exact</span>: f_f.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>/EFin_measurable_fun/measurable_funTS.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n x _; <span class="nb">rewrite</span> lee_fin.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _ a b /ndf_ /lefP; <span class="nb">rewrite</span> lee_fin.
<span class="nb">rewrite</span> (_ : \int[m]_(x <span class="kr">in</span> D) _ =
    lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[m]_(x <span class="kr">in</span> D) (f_ n x)%:E)); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> -monotone_convergence//=.
  - <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; x /[!inE] xD; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: f_f.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>/EFin_measurable_fun/measurable_funTS.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n x _; <span class="nb">rewrite</span> lee_fin.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _ a b /ndf_ /lefP; <span class="nb">rewrite</span> lee_fin.
<span class="nb">rewrite</span> -limeMl//.
  <span class="bp">by</span> <span class="nb">congr</span> (lim _); <span class="nb">apply</span>/funext =&gt; n /=; <span class="nb">rewrite</span> integral_mscale_nnsfun.
<span class="nb">apply</span>/ereal_nondecreasing_is_cvg =&gt; a b ab; <span class="nb">apply</span> ge0_le_integral =&gt; //.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> lee_fin.
- <span class="bp">exact</span>/EFin_measurable_fun/measurable_funTS.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> lee_fin.
- <span class="bp">exact</span>/EFin_measurable_fun/measurable_funTS.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> lee_fin; <span class="nb">move</span>/ndf_ : ab =&gt; /lefP.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_mscale</span>.

<span class="kn">Section</span> <span class="nf">fatou</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variable</span> (<span class="nv">f</span> : (T -&gt; \bar R)^nat).
<span class="kn">Hypothesis</span> <span class="nv">mf</span> : <span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (f n).
<span class="kn">Hypothesis</span> <span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f n x.

<span class="kn">Lemma</span> <span class="nf">fatou</span> : \int[mu]_(x <span class="kr">in</span> D) lim_einf (f^~ x) &lt;=
              lim_einf (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) f n x).
<span class="kn">Proof</span>.
<span class="nb">pose</span> g n := <span class="kr">fun</span> <span class="nv">x</span> =&gt; einfs (f ^~ x) n.
<span class="nb">have</span> mg := measurable_fun_einfs mf.
<span class="nb">have</span> g0 n x : D x -&gt; <span class="mi">0</span> &lt;= g n x.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Dx; <span class="nb">apply</span>: lb_ereal_inf =&gt; _ [m /= nm &lt;-]; <span class="bp">exact</span>: f0.
<span class="nb">rewrite</span> monotone_convergence //; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; x Dx m n mn /=; <span class="nb">apply</span>: le_ereal_inf =&gt; _ /= [p /= np &lt;-].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">p</span> =&gt; //=; <span class="nb">rewrite</span> (leq_trans mn).
<span class="nb">apply</span>: lee_lim.
- <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="nb">apply</span>/ereal_nondecreasing_cvg =&gt; a b ab.
  <span class="nb">apply</span>: ge0_le_integral =&gt; //; [<span class="bp">exact</span>: g0| <span class="bp">exact</span>: mg| <span class="bp">exact</span>: g0| <span class="bp">exact</span>: mg|].
  <span class="nb">move</span>=&gt; x Dx; <span class="nb">apply</span>: le_ereal_inf =&gt; _ [n /= bn &lt;-].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; //=; <span class="nb">rewrite</span> (leq_trans ab).
- <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="nb">apply</span>/ereal_nondecreasing_cvg =&gt; a b ab.
  <span class="nb">apply</span>: le_ereal_inf =&gt; // _ [n /= bn &lt;-].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; //=; <span class="nb">rewrite</span> (leq_trans ab).
- <span class="nb">apply</span>: nearW =&gt; m.
  <span class="nb">have</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span>, (p &gt;= n)%N -&gt;
      \int[mu]_(x <span class="kr">in</span> D) g n x &lt;= einfs (<span class="kr">fun</span> <span class="nv">k</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) f k x) n.
    <span class="nb">move</span>=&gt; n p np; <span class="nb">apply</span>: lb_ereal_inf =&gt; /= _ [k /= nk &lt;-].
    <span class="nb">apply</span>: ge0_le_integral =&gt; //; [<span class="bp">exact</span>: g0|<span class="bp">exact</span>: mg|<span class="bp">exact</span>: f0|].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">apply</span>: ereal_inf_lb; <span class="kr">exists</span> <span class="nv">k</span>.
  <span class="bp">exact</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">fatou</span>.

<span class="kn">Section</span> <span class="nf">integralN</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">integralN</span> <span class="nv">D</span> (<span class="nv">f</span> : T -&gt; \bar R) :
  \int[mu]_(x <span class="kr">in</span> D) f^\+ x +? (- \int[mu]_(x <span class="kr">in</span> D) f^\- x) -&gt;
  \int[mu]_(x <span class="kr">in</span> D) - f x = - \int[mu]_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">have</span> [f_fin _|] := boolP (\int[mu]_(x <span class="kr">in</span> D) f^\- x \<span class="kr">is</span> a fin_num).
  <span class="nb">rewrite</span> integralE// [<span class="kr">in</span> RHS]integralE// fin_num_oppeD <span class="nl">?fin_numN</span>// oppeK addeC.
  <span class="bp">by</span> <span class="nb">rewrite</span> funenegN.
<span class="nb">rewrite</span> fin_numE negb_and <span class="mi">2</span>!negbK =&gt; /orP[nfoo|/eqP nfoo].
  <span class="nb">exfalso</span>; <span class="nb">move</span>/negP : nfoo; <span class="nb">apply</span>; <span class="nb">rewrite</span> -leeNy_eq; <span class="nb">apply</span>/negP.
  <span class="bp">by</span> <span class="nb">rewrite</span> -ltNge (lt_le_trans _ (integral_ge0 _ _)).
<span class="nb">rewrite</span> nfoo adde_defEninfty -leye_eq -ltNge ltey_eq =&gt; /orP[f_fin|/eqP pfoo].
  <span class="nb">rewrite</span> integralE// [<span class="kr">in</span> RHS]integralE// nfoo [<span class="kr">in</span> RHS]addeC fin_num_oppeD//.
  <span class="bp">by</span> <span class="nb">rewrite</span> funenegN.
<span class="bp">by</span> <span class="nb">rewrite</span> integralE// [<span class="kr">in</span> RHS]integralE// funeposN funenegN nfoo pfoo.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_ge0N</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; \bar R) :
  (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt;
  \int[mu]_(x <span class="kr">in</span> D) - f x = - \int[mu]_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0; <span class="nb">rewrite</span> integralN // (eq_integral _ _ (ge0_funenegE _))// integral0.
<span class="bp">by</span> <span class="nb">rewrite</span> oppe0 fin_num_adde_defl.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integralN</span>.

<span class="kn">Section</span> <span class="nf">integral_cst</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).
<span class="kn">Variables</span> (<span class="nv">f</span> : T -&gt; \bar R) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).

<span class="kn">Lemma</span> <span class="nf">sintegral_EFin_cst</span> (<span class="nv">x</span> : {nonneg R}) :
  sintegral mu (cst x%:num \_ D) = x%:num%:E * mu D.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> sintegralE (fsbig_widen _ [<span class="nb">set</span> <span class="mi">0</span>%R; x%:num])/=.
- <span class="nb">have</span> [-&gt;|x0] := eqVneq x%:num <span class="mi">0</span>%R; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> setUid fsbig_set1 !mul0e.
  <span class="nb">rewrite</span> fsbigU0//=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; y [-&gt;]/esym; <span class="nb">apply</span>/eqP.
  <span class="nb">rewrite</span> !fsbig_set1 mul0e add0e preimage_restrict//.
  <span class="bp">by</span> <span class="nb">rewrite</span> ifN <span class="nl">?set0U</span> <span class="nl">?setIidl</span>//= notin_set =&gt; /esym; <span class="bp">exact</span>/eqP.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; y [t _ &lt;-] /=; <span class="nb">rewrite</span> /patch; <span class="nb">case</span>: ifPn; [<span class="nb">right</span>|<span class="nb">left</span>].
- <span class="bp">by</span> <span class="nb">move</span>=&gt; y [_ /=/preimage10-&gt;]; <span class="nb">rewrite</span> measure0 mule0.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">integral_cstr</span> <span class="nv">r</span> : \int[mu]_(x <span class="kr">in</span> D) r%:E = r%:E * mu D.
<span class="kn">Proof</span>.
<span class="nb">wlog</span> r0 : r / (<span class="mi">0</span> &lt;= r)%R.
  <span class="nb">move</span>=&gt; h; <span class="nb">have</span> [|r0] := leP <span class="mi">0</span>%R r; <span class="kp">first</span> <span class="bp">exact</span>: h.
  <span class="nb">rewrite</span> -[<span class="kr">in</span> RHS](opprK r) EFinN mulNe -h <span class="nl">?oppr_ge0</span>; <span class="nb">last</span> <span class="bp">exact</span>: ltW.
  <span class="nb">rewrite</span> -integral_ge0N//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; t ?; <span class="nb">rewrite</span> /= lee_fin oppr_ge0 ltW.
  <span class="bp">by</span> <span class="nb">under</span> [RHS]eq_integral <span class="kp">do</span> <span class="nb">rewrite</span> /= opprK.
<span class="nb">rewrite</span> (eq_integral (EFin \o cst_nnsfun T (NngNum r0)))//.
<span class="bp">by</span> <span class="nb">rewrite</span> integral_nnsfun// sintegral_EFin_cst.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">integral_csty</span> : mu D != <span class="mi">0</span> -&gt; \int[mu]_(x <span class="kr">in</span> D) (cst +oo) x = +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; muD0; <span class="nb">pose</span> g : (T -&gt; \bar R)^nat := <span class="kr">fun</span> <span class="nv">n</span> =&gt; cst n%:R%:E.
<span class="nb">have</span> &lt;- : (<span class="kr">fun</span> <span class="nv">t</span> =&gt; lim (g^~ t)) = cst +oo.
  <span class="nb">rewrite</span> funeqE =&gt; t; <span class="nb">apply</span>/cvg_lim =&gt; //=.
  <span class="nb">apply</span>/cvgeryP/cvgryPge =&gt; M; <span class="kr">exists</span> `|ceil M|%N =&gt; //= m.
  <span class="nb">rewrite</span> /= -(ler_nat R); <span class="nb">apply</span>: le_trans.
  <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans (ceil_ge _))// natr_absz ler_int ler_norm.
<span class="nb">rewrite</span> monotone_convergence //.
- <span class="nb">under</span> [<span class="kr">in</span> LHS]eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> integral_cstr.
  <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>/cvgeyPge =&gt; M.
  <span class="nb">have</span> [muDoo|muDoo] := ltP (mu D) +oo; <span class="nb">last first</span>.
    <span class="kr">exists</span> <span class="mi">1</span>%N =&gt; // m /= m0; <span class="nb">move</span>: muDoo; <span class="nb">rewrite</span> leye_eq =&gt; /eqP -&gt;.
    <span class="bp">by</span> <span class="nb">rewrite</span> mulry gtr0_sg <span class="nl">?mul1e</span> <span class="nl">?leey</span>// ltr0n.
  <span class="kr">exists</span> `|ceil (M / fine (mu D))|%N =&gt; // m /=.
  <span class="nb">rewrite</span> -(ler_nat R) =&gt; MDm.
  <span class="nb">rewrite</span> -(@fineK _ (mu D)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE.
  <span class="nb">rewrite</span> -lee_pdivr_mulr; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> fine_gt0// lt0e muD0 measure_ge0.
  <span class="nb">rewrite</span> lee_fin; <span class="nb">apply</span>: le_trans MDm.
  <span class="bp">by</span> <span class="nb">rewrite</span> natr_absz (le_trans (ceil_ge _))// ler_int ler_norm.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>: measurable_fun_cst.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n x Dx; <span class="nb">rewrite</span> lee_fin.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; t Dt n m nm; <span class="nb">rewrite</span> /g lee_fin ler_nat.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">integral_cstNy</span> : mu D != <span class="mi">0</span> -&gt; \int[mu]_(x <span class="kr">in</span> D) (cst -oo) x = -oo.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> (eq_integral (\- cst +oo)) <span class="nl">?integral_ge0N</span>/= <span class="nl">?integral_csty</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_cst</span>.

<span class="kn">Section</span> <span class="nf">transfer</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">X</span> : measurableType d1) (<span class="nv">Y</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">phi</span> : X -&gt; Y) (<span class="nv">mphi</span> : measurable_fun setT phi).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> X -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">integral_pushforward</span> (<span class="nv">f</span> : Y -&gt; \bar R) :
  measurable_fun setT f -&gt; (<span class="kr">forall</span> <span class="nv">y</span>, <span class="mi">0</span> &lt;= f y) -&gt;
  \int[pushforward mu mphi]_y f y = \int[mu]_x (f \o phi) x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf f0.
<span class="nb">have</span> [f_ [ndf_ f_f]] := approximation measurableT mf (<span class="kr">fun</span> <span class="nv">t</span> <span class="nv">_</span> =&gt; f0 t).
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[pushforward mu mphi]_x (f_ n x)%:E)).
  <span class="nb">rewrite</span> -monotone_convergence//.
  - <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; y _; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: f_f.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>/EFin_measurable_fun.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n y _; <span class="nb">rewrite</span> lee_fin.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; y _ m n mn; <span class="nb">rewrite</span> lee_fin; <span class="nb">apply</span>/lefP/ndf_.
<span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) = (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_x (EFin \o f_ n \o phi) x)).
  <span class="nb">rewrite</span> -monotone_convergence//; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
    - <span class="nb">move</span>=&gt; n /=; <span class="nb">apply</span>: measurable_funT_comp; <span class="kp">first</span> <span class="bp">exact</span>: measurable_fun_EFin.
      <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_sfun.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; n x _ /=; <span class="nb">rewrite</span> lee_fin.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _ m n mn; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>/lefP/ndf_.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; x _ /=; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="bp">exact</span>: f_f.
<span class="nb">apply</span>/funext =&gt; n.
<span class="nb">have</span> mfnphi r : measurable (f_ n @^-<span class="mi">1</span>` [<span class="nb">set</span> r] \o phi).
  <span class="nb">rewrite</span> -[_ \o _]/(phi @^-<span class="mi">1</span>` (f_ n @^-<span class="mi">1</span>` [<span class="nb">set</span> r])) -(setTI (_ @^-<span class="mi">1</span>` _)).
  <span class="bp">exact</span>/mphi.
<span class="nb">transitivity</span> (\sum_(k \<span class="kr">in</span> range (f_ n))
    \int[mu]_x (k * \<span class="mi">1_</span>((f_ n @^-<span class="mi">1</span>` [<span class="nb">set</span> k]) \o phi) x)%:E).
  <span class="nb">under</span> eq_integral <span class="kp">do</span> <span class="nb">rewrite</span> fimfunE -fsumEFin//.
  <span class="nb">rewrite</span> ge0_integral_fsum//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    - <span class="nb">move</span>=&gt; y; <span class="nb">apply</span>/EFin_measurable_fun; <span class="nb">apply</span>: measurable_funM.
        <span class="bp">exact</span>: measurable_fun_cst.
      <span class="bp">by</span> <span class="nb">rewrite</span> (_ : \<span class="mi">1_</span> _ = mindic R (measurable_sfunP (f_ n) (measurable_set1 y))).
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; y x _; <span class="nb">rewrite</span> nnfun_muleindic_ge0.
  <span class="nb">apply</span> eq_fsbigr =&gt; r _; <span class="nb">rewrite</span> integralM_indic_nnsfun// integral_indic//=.
  <span class="nb">rewrite</span> (integralM_indic _ (<span class="kr">fun</span> <span class="nv">r</span> =&gt; f_ n @^-<span class="mi">1</span>` [<span class="nb">set</span> r] \o phi))//.
    <span class="bp">by</span> <span class="nb">congr</span> (_ * _); <span class="nb">rewrite</span> [RHS](@integral_indic).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; r0; <span class="nb">rewrite</span> preimage_nnfun0.
<span class="nb">rewrite</span> -ge0_integral_fsum//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; r; <span class="nb">apply</span>/EFin_measurable_fun; <span class="nb">apply</span>: measurable_funM.
      <span class="bp">exact</span>: measurable_fun_cst.
    <span class="bp">by</span> <span class="nb">rewrite</span> (_ : \<span class="mi">1_</span> _ = mindic R (mfnphi r)).
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; r x _; <span class="nb">rewrite</span> nnfun_muleindic_ge0.
<span class="bp">by</span> <span class="nb">apply</span> eq_integral =&gt; x _; <span class="nb">rewrite</span> fsumEFin// -fimfunE.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">transfer</span>.

<span class="kn">Section</span> <span class="nf">integral_dirac</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">a</span> : T) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).

<span class="kn">Let</span> <span class="nf">ge0_integral_dirac</span> (<span class="nv">f</span> : T -&gt; \bar R) (<span class="nv">mf</span> : measurable_fun D f)
    (<span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) :
  D a -&gt; \int[\d_a]_(x <span class="kr">in</span> D) (f x) = f a.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Da; <span class="nb">have</span> [f_ [ndf_ f_f]] := approximation mD mf f0.
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[\d_ a]_(x <span class="kr">in</span> D) (f_ n x)%:E)).
  <span class="nb">rewrite</span> -monotone_convergence//.
  - <span class="nb">apply</span>: eq_integral =&gt; x Dx; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="nb">apply</span>: f_f.
    <span class="bp">by</span> <span class="nb">rewrite</span> inE <span class="kr">in</span> Dx.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>/EFin_measurable_fun; <span class="bp">exact</span>/measurable_funTS.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> lee_fin.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _ m n mn; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>/lefP/ndf_.
<span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) = (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (f_ n a)%:E)).
  <span class="bp">by</span> <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="bp">exact</span>: f_f.
<span class="nb">apply</span>/funext =&gt; n.
<span class="nb">under</span> eq_integral <span class="kp">do</span> <span class="nb">rewrite</span> fimfunE// -fsumEFin//.
<span class="nb">rewrite</span> ge0_integral_fsum//.
- <span class="nb">under</span> eq_fsbigr <span class="kp">do</span> <span class="nb">rewrite</span> integralM_indic_nnsfun//.
  <span class="nb">rewrite</span> /= (fsbigD1 (f_ n a))//=; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">a</span>.
  <span class="nb">rewrite</span> integral_indic//= diracE mem_set// mule1.
  <span class="nb">rewrite</span> fsbig1 <span class="nl">?adde0</span>// =&gt; r /= [_ rfna].
  <span class="nb">rewrite</span> integral_indic//= diracE memNset <span class="nl">?mule0</span>//=.
  <span class="bp">by</span> <span class="nb">apply</span>/not_andP; <span class="nb">left</span>; <span class="bp">exact</span>/nesym.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; r; <span class="bp">exact</span>/EFin_measurable_fun/measurable_funrM/measurable_fun_indic.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; r x _; <span class="nb">rewrite</span> nnfun_muleindic_ge0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_dirac</span> (<span class="nv">f</span> : T -&gt; \bar R) (<span class="nv">mf</span> : measurable_fun D f) :
  \int[\d_ a]_(x <span class="kr">in</span> D) f x = (\<span class="mi">1_</span>D a)%:E * f a.
<span class="kn">Proof</span>.
<span class="nb">have</span> [/[!inE] aD|aD] := boolP (a \<span class="kr">in</span> D).
  <span class="nb">rewrite</span> integralE ge0_integral_dirac//; <span class="nb">last</span> <span class="bp">exact</span>/emeasurable_fun_funepos.
  <span class="nb">rewrite</span> ge0_integral_dirac//; <span class="nb">last</span> <span class="bp">exact</span>/emeasurable_fun_funeneg.
  <span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> RHS](funeposneg f) indicE mem_set// mul1e.
<span class="nb">rewrite</span> indicE (negbTE aD) mul0e -(integral_measure_zero D f)//.
<span class="nb">apply</span>: eq_measure_integral =&gt; //= S mS DS; <span class="nb">rewrite</span> /dirac indicE memNset// =&gt; /DS.
<span class="bp">by</span> <span class="nb">rewrite</span> notin_set <span class="kr">in</span> aD.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_dirac</span>.

<span class="kn">Section</span> <span class="nf">integral_measure_sum_nnsfun</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">m_</span> : {measure <span class="nb">set</span> T -&gt; \bar R}^nat) (<span class="nv">N</span> : nat).
<span class="kn">Let</span> <span class="nf">m</span> := msum m_ N.

<span class="kn">Let</span> <span class="nf">integral_measure_sum_indic</span> (<span class="nv">E</span> <span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mE</span> : measurable E)
    (<span class="nv">mD</span> : measurable D) :
  \int[m]_(x <span class="kr">in</span> E) (\<span class="mi">1_</span>D x)%:E = \sum_(n &lt; N) \int[m_ n]_(x <span class="kr">in</span> E) (\<span class="mi">1_</span>D x)%:E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> integral_indic//= /msum/=; <span class="nb">apply</span> eq_bigr =&gt; i _.
<span class="bp">by</span> <span class="nb">rewrite</span> integral_indic// setIT.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">integralT_measure_sum</span> (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) :
  \int[m]_x (f x)%:E = \sum_(n &lt; N) \int[m_ n]_x (f x)%:E.
<span class="kn">Proof</span>.
<span class="nb">under</span> eq_integral <span class="kp">do</span> <span class="nb">rewrite</span> fimfunE -fsumEFin//.
<span class="nb">rewrite</span> ge0_integral_fsum//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; r /=; <span class="nb">apply</span>: measurable_funT_comp =&gt; //.
    <span class="bp">exact</span>/measurable_funrM/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; r t _; <span class="nb">rewrite</span> EFinM nnfun_muleindic_ge0.
<span class="nb">transitivity</span> (\sum_(i \<span class="kr">in</span> range f)
    (\sum_(n &lt; N) i%:E * \int[m_ n]_x (\<span class="mi">1_</span>(f @^-<span class="mi">1</span>` [<span class="nb">set</span> i]) x)%:E)).
  <span class="nb">apply</span> eq_fsbigr =&gt; r _.
  <span class="nb">rewrite</span> integralM_indic_nnsfun// integral_measure_sum_indic//.
  <span class="bp">by</span> <span class="nb">rewrite</span> ge0_sume_distrr// =&gt; n _; <span class="nb">apply</span> integral_ge0 =&gt; t _; <span class="nb">rewrite</span> lee_fin.
<span class="nb">rewrite</span> fsbig_finite//= exchange_big/=; <span class="nb">apply</span> eq_bigr =&gt; i _.
<span class="nb">rewrite</span> integralT_nnsfun sintegralE fsbig_finite//=; <span class="nb">apply</span> eq_bigr =&gt; r _.
<span class="bp">by</span> <span class="nb">congr</span> (_ * _); <span class="nb">rewrite</span> integral_indic// setIT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_measure_sum_nnsfun</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D)
  (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) :
  \int[m]_(x <span class="kr">in</span> D) (f x)%:E = \sum_(n &lt; N) \int[m_ n]_(x <span class="kr">in</span> D) (f x)%:E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> integral_mkcond.
<span class="nb">transitivity</span> (\int[m]_x (proj_nnsfun f mD x)%:E).
  <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; t _ /=; <span class="nb">rewrite</span> /patch mindicE;
    <span class="nb">case</span>: ifPn =&gt; // tD; <span class="nb">rewrite</span> <span class="nl">?mulr1</span> <span class="nl">?mulr0</span>.
<span class="nb">rewrite</span> integralT_measure_sum; <span class="nb">apply</span> eq_bigr =&gt; i _.
<span class="nb">rewrite</span> [RHS]integral_mkcond; <span class="nb">apply</span>: eq_integral =&gt; t _.
<span class="nb">rewrite</span> /= /patch /mindic indicE.
<span class="bp">by</span> <span class="nb">case</span>: (boolP (t \<span class="kr">in</span> D)) =&gt; tD; <span class="nb">rewrite</span> <span class="nl">?mulr1</span> <span class="nl">?mulr0</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_measure_sum_nnsfun</span>.

<span class="kn">Lemma</span> <span class="nf">integral_measure_add_nnsfun</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">m1</span> <span class="nv">m2</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D)
    (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) :
  (\int[measure_add m1 m2]_(x <span class="kr">in</span> D) (f x)%:E =
   \int[m1]_(x <span class="kr">in</span> D) (f x)%:E + \int[m2]_(x <span class="kr">in</span> D) (f x)%:E)%E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /measureD integral_measure_sum_nnsfun// <span class="mi">2</span>!big_ord_recl/= big_ord0.
<span class="bp">by</span> <span class="nb">rewrite</span> adde0.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">integral_mfun_measure_sum</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m_</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}^nat.

<span class="kn">Lemma</span> <span class="nf">ge0_integral_measure_sum</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D)
    (<span class="nv">f</span> : T -&gt; \bar R) :
    (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt; measurable_fun D f -&gt; <span class="kr">forall</span> <span class="nv">N</span>,
  \int[msum m_ N]_(x <span class="kr">in</span> D) f x = \sum_(n &lt; N) \int[m_ n]_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0 mf.
<span class="nb">have</span> [f_ [f_nd f_f]] := approximation mD mf f0.
<span class="nb">elim</span> =&gt; [|N ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> big_ord0 msum_mzero integral_measure_zero.
<span class="nb">rewrite</span> big_ord_recr/= -ih.
<span class="nb">rewrite</span> (_ : _ m_ N.+<span class="mi">1</span> = measure_add [the <span class="kn">measure</span> _ _ of msum m_ N] (m_ N)); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; A; <span class="nb">rewrite</span> measure_addE /msum/= big_ord_recr.
<span class="nb">have</span> mf_ n : measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (f_ n x)%:E).
  <span class="bp">exact</span>/measurable_funTS/EFin_measurable_fun.
<span class="nb">have</span> f_ge0 n x : D x -&gt; <span class="mi">0</span> &lt;= (f_ n x)%:E <span class="bp">by</span> <span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> lee_fin.
<span class="nb">have</span> cvg_f_ (m : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}) : cvg (<span class="kr">fun</span> <span class="nv">x</span> =&gt; \int[m]_(x0 <span class="kr">in</span> D) (f_ x x0)%:E).
  <span class="nb">apply</span>: ereal_nondecreasing_is_cvg =&gt; a b ab.
  <span class="nb">apply</span> ge0_le_integral =&gt; //; [<span class="bp">exact</span>: f_ge0|<span class="bp">exact</span>: f_ge0|].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; t Dt; <span class="nb">rewrite</span> lee_fin; <span class="nb">apply</span>/lefP/f_nd.
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt;
    \int[measure_add [the <span class="kn">measure</span> _ _ of msum m_ N] (m_ N)]_(x <span class="kr">in</span> D) (f_ n x)%:E)).
  <span class="nb">rewrite</span> -monotone_convergence//; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; t Dt a b ab; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>/lefP/f_nd.
  <span class="bp">by</span> <span class="nb">apply</span> eq_integral =&gt; t /[!inE] Dt; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: f_f.
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt;
  \int[msum m_ N]_(x <span class="kr">in</span> D) (f_ n x)%:E + \int[m_ N]_(x <span class="kr">in</span> D) (f_ n x)%:E)).
  <span class="bp">by</span> <span class="nb">congr</span> (lim _); <span class="nb">apply</span>/funext =&gt; n; <span class="bp">by</span> <span class="nb">rewrite</span> integral_measure_add_nnsfun.
<span class="nb">rewrite</span> limeD//; <span class="kp">do</span>?[<span class="bp">exact</span>: cvg_f_]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: ge0_adde_def; <span class="nb">rewrite</span> inE; <span class="nb">apply</span>: lime_ge =&gt; //; <span class="kp">do</span>?[<span class="bp">exact</span>: cvg_f_];
      <span class="nb">apply</span>: nearW =&gt; n;  <span class="nb">apply</span>: integral_ge0 =&gt; //; <span class="bp">exact</span>: f_ge0.
<span class="bp">by</span> <span class="nb">congr</span> (_ + _); (<span class="nb">rewrite</span> -monotone_convergence//; [
    <span class="nb">apply</span> eq_integral =&gt; t /[!inE] Dt; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="bp">exact</span>: f_f |
    <span class="nb">move</span>=&gt; t Dt a b ab; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>/lefP/f_nd]).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_mfun_measure_sum</span>.

<span class="kn">Lemma</span> <span class="nf">integral_measure_add</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">m1</span> <span class="nv">m2</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D)
    (<span class="nv">f</span> : T -&gt; \bar R) :
  (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x)%E -&gt; measurable_fun D f -&gt;
  (\int[measure_add m1 m2]_(x <span class="kr">in</span> D) f x =
   \int[m1]_(x <span class="kr">in</span> D) f x + \int[m2]_(x <span class="kr">in</span> D) f x)%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0 mf; <span class="nb">rewrite</span> /measureD ge0_integral_measure_sum// <span class="mi">2</span>!big_ord_recl/=.
<span class="bp">by</span> <span class="nb">rewrite</span> big_ord0 adde0.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">integral_measure_series</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m_</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}^nat.
<span class="kn">Let</span> <span class="nf">m</span> := mseries m_ O.

<span class="kn">Let</span> <span class="nf">integral_measure_series_indic</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) :
  \int[m]_x (\<span class="mi">1_</span>D x)%:E = \sum_(n &lt;oo) \int[m_ n]_x (\<span class="mi">1_</span>D x)%:E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> integral_indic// setIT /m/= /mseries; <span class="nb">apply</span>: eq_eseries =&gt; i _.
<span class="bp">by</span> <span class="nb">rewrite</span> integral_indic// setIT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_measure_series_nnsfun</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D)
    (<span class="nv">f</span> : {nnsfun T &gt;-&gt; R}) :
  \int[m]_x (f x)%:E = \sum_(n &lt;oo) \int[m_ n]_x (f x)%:E.
<span class="kn">Proof</span>.
<span class="nb">under</span> eq_integral <span class="kp">do</span> <span class="nb">rewrite</span> fimfunE -fsumEFin//.
<span class="nb">rewrite</span> ge0_integral_fsum//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; r /=; <span class="nb">apply</span>: measurable_funT_comp =&gt; //.
    <span class="bp">exact</span>/measurable_funrM/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; r t _; <span class="nb">rewrite</span> EFinM nnfun_muleindic_ge0.
<span class="nb">transitivity</span> (\sum_(i \<span class="kr">in</span> range f)
    (\sum_(n &lt;oo) i%:E * \int[m_ n]_x (\<span class="mi">1_</span>(f @^-<span class="mi">1</span>` [<span class="nb">set</span> i]) x)%:E)).
  <span class="nb">apply</span> eq_fsbigr =&gt; r _.
  <span class="nb">rewrite</span> integralM_indic_nnsfun// integral_measure_series_indic// nneseriesrM//.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="nb">apply</span> integral_ge0 =&gt; t _; <span class="nb">rewrite</span> lee_fin.
<span class="nb">rewrite</span> fsbig_finite//= -nneseries_sum; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; r j _.
  <span class="nb">have</span> [r0|r0] := leP <span class="mi">0</span>%R r.
    <span class="bp">by</span> <span class="nb">rewrite</span> mule_ge0//; <span class="nb">apply</span> integral_ge0 =&gt; // t _; <span class="nb">rewrite</span> lee_fin.
  <span class="bp">by</span> <span class="nb">rewrite</span> integral0_eq// =&gt; x _; <span class="nb">rewrite</span> preimage_nnfun0// indicE in_set0.
<span class="nb">apply</span>: eq_eseries =&gt; k _.
<span class="nb">rewrite</span> integralT_nnsfun sintegralE fsbig_finite//=; <span class="nb">apply</span> eq_bigr =&gt; r _.
<span class="bp">by</span> <span class="nb">congr</span> (_ * _); <span class="nb">rewrite</span> integral_indic// setIT.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_measure_series</span>.

<span class="kn">Section</span> <span class="nf">ge0_integral_measure_series</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m_</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}^nat.
<span class="kn">Let</span> <span class="nf">m</span> := mseries m_ O.

<span class="kn">Lemma</span> <span class="nf">ge0_integral_measure_series</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">f</span> : T -&gt; \bar R) :
  (<span class="kr">forall</span> <span class="nv">t</span>, D t -&gt; <span class="mi">0</span> &lt;= f t) -&gt;
  measurable_fun D f -&gt;
  \int[m]_(x <span class="kr">in</span> D) f x = \sum_(n &lt;oo) \int[m_ n]_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0 mf.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">suff</span> : <span class="kr">forall</span> <span class="nv">n</span>, \sum_(k &lt; n) \int[m_ k]_(x <span class="kr">in</span> D) f x &lt;= \int[m]_(x <span class="kr">in</span> D) f x.
    <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>: lime_le =&gt; //.
      <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_ereal_nneg_natsum =&gt; k _; <span class="bp">exact</span>: integral_ge0.
    <span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; x; <span class="nb">rewrite</span> big_mkord.
  <span class="nb">move</span>=&gt; n.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= X](_ : _ = (\sum_(k &lt; n) \int[m_ k]_(x <span class="kr">in</span> D) f x
    + \int[mseries m_ n]_(x <span class="kr">in</span> D) f x)); <span class="nb">last first</span>.
    <span class="nb">transitivity</span> (\int[measure_add [the <span class="kn">measure</span> _ _ of msum m_ n]
                                   [the <span class="kn">measure</span> _ _ of mseries m_ n]]_(x <span class="kr">in</span> D) f x).
      <span class="nb">congr</span> (\int[_]_(_ <span class="kr">in</span> D) _); <span class="nb">apply</span>/funext =&gt; A.
      <span class="bp">by</span> <span class="nb">rewrite</span> measure_addE; <span class="bp">exact</span>: nneseries_split.
    <span class="nb">rewrite</span> integral_measure_add//; <span class="nb">congr</span> (_ + _).
    <span class="bp">by</span> <span class="nb">rewrite</span> -ge0_integral_measure_sum.
  <span class="bp">by</span> <span class="nb">apply</span>: lee_addl; <span class="bp">exact</span>: integral_ge0.
<span class="nb">rewrite</span> ge0_integralE//=; <span class="nb">apply</span>: ub_ereal_sup =&gt; /= _ [g /= gf] &lt;-.
<span class="nb">rewrite</span> -integralT_nnsfun (integral_measure_series_nnsfun _ mD).
<span class="nb">apply</span>: lee_nneseries =&gt; n _.
  <span class="bp">by</span> <span class="nb">apply</span> integral_ge0 =&gt; // x _; <span class="nb">rewrite</span> lee_fin.
<span class="nb">rewrite</span> [leRHS]integral_mkcond; <span class="nb">apply</span> ge0_le_integral =&gt; //.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> lee_fin.
- <span class="bp">exact</span>/EFin_measurable_fun.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> erestrict_ge0.
- <span class="bp">exact</span>/(measurable_restrict _ mD).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ge0_integral_measure_series</span>.

<span class="kn">Section</span> <span class="nf">subset_integral</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">integral_setU</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) (<span class="nv">mA</span> : measurable A) (<span class="nv">mB</span> : measurable B)
    (<span class="nv">f</span> : T -&gt; \bar R) : measurable_fun (A `|` B) f -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, (A `|` B) x -&gt; <span class="mi">0</span> &lt;= f x) -&gt; [disjoint A &amp; B] -&gt;
  \int[mu]_(x <span class="kr">in</span> A `|` B) f x = \int[mu]_(x <span class="kr">in</span> A) f x + \int[mu]_(x <span class="kr">in</span> B) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf f0 AB.
<span class="nb">transitivity</span> (\int[mu]_(x <span class="kr">in</span> A `|` B) ((f \_ A) x + (f \_ B) x)).
  <span class="nb">apply</span>: eq_integral =&gt; x; <span class="nb">rewrite</span> inE =&gt; -[xA|xB].
    <span class="nb">rewrite</span> /patch mem_set// ifF <span class="nl">?adde0</span>//; <span class="nb">apply</span>/negbTE/negP; <span class="nb">rewrite</span> inE =&gt; xB.
    <span class="bp">by</span> <span class="nb">move</span>: AB; <span class="nb">rewrite</span> disj_set2E =&gt; /eqP; <span class="nb">apply</span>/eqP/set0P; <span class="kr">exists</span> <span class="nv">x</span>.
  <span class="nb">rewrite</span> /patch addeC mem_set// ifF <span class="nl">?adde0</span>//; <span class="nb">apply</span>/negbTE/negP; <span class="nb">rewrite</span> inE =&gt; xA.
    <span class="bp">by</span> <span class="nb">move</span>: AB; <span class="nb">rewrite</span> disj_set2E =&gt; /eqP; <span class="nb">apply</span>/eqP/set0P; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="nb">rewrite</span> ge0_integralD//; <span class="nb">last</span> <span class="mi">5</span> <span class="kp">first</span>.
  - <span class="bp">exact</span>: measurableU.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">apply</span>: erestrict_ge0 =&gt; y Ay; <span class="nb">apply</span>: f0; <span class="nb">left</span>.
  - <span class="nb">have</span> : measurable_fun A f.
      <span class="bp">by</span> <span class="nb">apply</span>: measurable_funS mf; [<span class="bp">exact</span>: measurableU|<span class="bp">exact</span>: subsetUl].
    <span class="bp">by</span> <span class="nb">apply</span>/(measurable_restrict _ _ _ _).<span class="mi">1</span> =&gt; //; <span class="bp">exact</span>: measurableU.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">apply</span>: erestrict_ge0 =&gt; y By; <span class="nb">apply</span>: f0; <span class="nb">right</span>.
  - <span class="nb">have</span> : measurable_fun B f.
      <span class="bp">by</span> <span class="nb">apply</span>: measurable_funS mf; [<span class="bp">exact</span>: measurableU|<span class="bp">exact</span>: subsetUr].
    <span class="bp">by</span> <span class="nb">apply</span>/(measurable_restrict _ _ _ _).<span class="mi">1</span> =&gt; //; <span class="bp">exact</span>: measurableU.
<span class="bp">by</span> <span class="nb">rewrite</span> -integral_mkcondl setIC setUK -integral_mkcondl setKU.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subset_integral</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) (<span class="nv">mA</span> : measurable A) (<span class="nv">mB</span> : measurable B)
    (<span class="nv">f</span> : T -&gt; \bar R) : measurable_fun B f -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, B x -&gt; <span class="mi">0</span> &lt;= f x) -&gt;
  A `&lt;=` B -&gt; \int[mu]_(x <span class="kr">in</span> A) f x &lt;= \int[mu]_(x <span class="kr">in</span> B) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf f0 AB; <span class="nb">rewrite</span> -(setDUK AB) integral_setU//; <span class="nb">last</span> <span class="mi">4</span> <span class="kp">first</span>.
  - <span class="bp">exact</span>: measurableD.
  - <span class="bp">by</span> <span class="nb">rewrite</span> setDUK.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> setDUK//; <span class="bp">exact</span>: f0.
  - <span class="bp">by</span> <span class="nb">rewrite</span> disj_set2E setDIK.
<span class="bp">by</span> <span class="nb">apply</span>: lee_addl; <span class="nb">apply</span>: integral_ge0 =&gt; x [Bx _]; <span class="bp">exact</span>: f0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_set0</span> (<span class="nv">f</span> : T -&gt; \bar R) : \int[mu]_(x <span class="kr">in</span> set0) f x = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> integral_mkcond integral0_eq// =&gt; x _.
<span class="bp">by</span> <span class="nb">rewrite</span> /restrict; <span class="nb">case</span>: ifPn =&gt; //; <span class="nb">rewrite</span> in_set0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ge0_integral_bigsetU</span> (<span class="nv">F</span> : (<span class="nb">set</span> T)^nat) (<span class="nv">f</span> : T -&gt; \bar R) <span class="nv">n</span> :
  (<span class="kr">forall</span> <span class="nv">n</span>, measurable (F n)) -&gt;
  <span class="kr">let</span> <span class="nv">D</span> := \big[setU/set0]_(i &lt; n) F i <span class="kr">in</span>
  measurable_fun D f -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt;
  trivIset `I_n F -&gt;
  \int[mu]_(x <span class="kr">in</span> D) f x = \sum_(i &lt; n) \int[mu]_(x <span class="kr">in</span> F i) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF.
<span class="nb">elim</span>: n =&gt; [|n ih] D mf f0 tF; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /D <span class="mi">2</span>!big_ord0 integral_set0.
<span class="nb">rewrite</span> /D big_ord_recr/= integral_setU//; <span class="nb">last</span> <span class="mi">4</span> <span class="kp">first</span>.
  - <span class="bp">exact</span>: bigsetU_measurable.
  - <span class="bp">by</span> <span class="nb">move</span>: mf; <span class="nb">rewrite</span> /D big_ord_recr.
  - <span class="bp">by</span> <span class="nb">move</span>: f0; <span class="nb">rewrite</span> /D big_ord_recr.
  - <span class="nb">apply</span>/eqP; <span class="nb">move</span>: (trivIset_bigsetUI tF (ltnSn n) (leqnn n)).
    <span class="nb">rewrite</span> [<span class="kr">in</span> X <span class="kr">in</span> X -&gt; _](eq_bigl xpredT)// =&gt; i.
    <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (ltn_ord i)).
<span class="nb">rewrite</span> ih <span class="nl">?big_ord_recr</span>//.
- <span class="nb">apply</span>: measurable_funS mf =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: bigsetU_measurable.
  <span class="bp">by</span> <span class="nb">rewrite</span> /D big_ord_recr /=; <span class="nb">apply</span>: subsetUl.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; t Dt; <span class="nb">apply</span>: f0; <span class="nb">rewrite</span> /D big_ord_recr/=; <span class="nb">left</span>.
- <span class="bp">by</span> <span class="nb">apply</span>: sub_trivIset tF =&gt; x; <span class="bp">exact</span>: leq_trans.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">le_integral_abse</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">g</span> : T -&gt; \bar R) <span class="nv">a</span> :
  measurable_fun D g -&gt; (<span class="mi">0</span> &lt; a)%R -&gt;
  a%:E * mu (D `&amp;` [<span class="nb">set</span> x | `|g x| &gt;= a%:E]) &lt;= \int[mu]_(x <span class="kr">in</span> D) `|g x|.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mg a0; <span class="nb">have</span> ? : measurable (D `&amp;` [<span class="nb">set</span> x | a%:E &lt;= `|g x|]).
  <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_c_infty =&gt; //; <span class="bp">exact</span>: measurable_funT_comp.
<span class="nb">apply</span>: (@le_trans _ _ (\int[mu]_(x <span class="kr">in</span> D `&amp;` [<span class="nb">set</span> x | `|g x| &gt;= a%:E]) `|g x|)).
  <span class="nb">rewrite</span> -integral_cstr//; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _ /=; <span class="bp">exact</span>/ltW.
  - <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_cst.
  - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_funS mg.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x /= [].
<span class="bp">by</span> <span class="nb">apply</span>: subset_integral =&gt; //; <span class="bp">exact</span>: measurable_funT_comp.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">subset_integral</span>.

<span class="kn">Section</span> <span class="nf">Rintegral</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Definition</span> <span class="nf">Rintegral</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; R) :=
  fine (\int[mu]_(x <span class="kr">in</span> D) (f x)%:E).

<span class="kn">End</span> <span class="nf">Rintegral</span>.

<span class="kn">Notation</span> <span class="s2">&quot;\int [ mu ]_ ( x &#39;in&#39; D ) f&quot;</span> := (Rintegral mu D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f)) : ring_scope.
<span class="kn">Notation</span> <span class="s2">&quot;\int [ mu ]_ x f&quot;</span> := (Rintegral mu setT (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f)) : ring_scope.

<span class="kn">Section</span> <span class="nf">integrable</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).

<span class="kn">Definition</span> <span class="nf">integrable</span> (<span class="nv">mu</span> : <span class="nb">set</span> T -&gt; \bar R) <span class="nv">D</span> <span class="nv">f</span> :=
  measurable_fun D f /\ (\int[mu]_(x <span class="kr">in</span> D) `|f x| &lt; +oo).

<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Implicit Type</span> <span class="nf">f</span> g : T -&gt; \bar R.

<span class="kn">Notation</span> <span class="nf">mu_int</span> := (integrable mu D).

<span class="kn">Lemma</span> <span class="nf">integrable0</span> : mu_int (cst <span class="mi">0</span>).
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurable_fun_cst.
<span class="nb">under</span> eq_integral <span class="kp">do</span> <span class="nb">rewrite</span> (gee0_abs (lexx <span class="mi">0</span>)).
<span class="bp">by</span> <span class="nb">rewrite</span> integral0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_integrable</span> <span class="nv">f</span> <span class="nv">g</span> : {<span class="kr">in</span> D, f =<span class="mi">1</span> g} -&gt; mu_int f -&gt; mu_int g.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fg [mf fi]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: eq_measurable_fun mf.
<span class="nb">rewrite</span> (le_lt_trans _ fi)//; <span class="nb">apply</span>: ge0_le_integral=&gt; //.
  <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: eq_measurable_fun mf.
  <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: eq_measurable_fun mf.
<span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">rewrite</span> fg// inE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">le_integrable</span> <span class="nv">f</span> <span class="nv">g</span> : measurable_fun D f -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; `|f x| &lt;= `|g x|) -&gt; mu_int g -&gt; mu_int f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf fg [mfg goo]; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> (le_lt_trans _ goo) //.
<span class="bp">by</span> <span class="nb">apply</span>: ge0_le_integral =&gt; //; <span class="bp">exact</span>: measurable_funT_comp.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrableN</span> <span class="nv">f</span> : mu_int f -&gt; mu_int (-%E \o f).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [mf foo]; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> /comp; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> abseN.
<span class="bp">by</span> <span class="nb">rewrite</span> /comp; <span class="nb">apply</span>: measurable_funT_comp =&gt;//; <span class="bp">exact</span>: emeasurable_fun_minus.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrablerM</span> (<span class="nv">k</span> : R) <span class="nv">f</span> : mu_int f -&gt; mu_int (<span class="kr">fun</span> <span class="nv">x</span> =&gt; k%:E * f x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [mf foo]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurable_funeM.
<span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> abseM.
<span class="bp">by</span> <span class="nb">rewrite</span> ge0_integralM// <span class="nl">?lte_mul_pinfty</span>//; <span class="bp">exact</span>: measurable_funT_comp.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrableMr</span> (<span class="nv">k</span> : R) <span class="nv">f</span> : mu_int f -&gt; mu_int (f \* cst k%:E).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mf; <span class="nb">apply</span>: eq_integrable (integrablerM k mf) =&gt; // x; <span class="nb">rewrite</span> muleC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrableD</span> <span class="nv">f</span> <span class="nv">g</span> : mu_int f -&gt; mu_int g -&gt; mu_int (f \+ g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [mf foo] [mg goo]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: emeasurable_funD.
<span class="nb">apply</span>: (@le_lt_trans _ _ (\int[mu]_(x <span class="kr">in</span> D) (`|f x| + `|g x|))).
  <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: emeasurable_funD.
  - <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_funD; <span class="nb">apply</span>: measurable_funT_comp.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: lee_abs_add.
<span class="bp">by</span> <span class="nb">rewrite</span> ge0_integralD //; [<span class="bp">exact</span>: lte_add_pinfty|
  <span class="bp">exact</span>: measurable_funT_comp|<span class="bp">exact</span>: measurable_funT_comp].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrableB</span> <span class="nv">f</span> <span class="nv">g</span> : mu_int f -&gt; mu_int g -&gt; mu_int (f \- g).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fi gi; <span class="bp">exact</span>/(integrableD fi)/integrableN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrable_add_def</span> <span class="nv">f</span> : mu_int f -&gt;
  \int[mu]_(x <span class="kr">in</span> D) f^\+ x +? - \int[mu]_(x <span class="kr">in</span> D) f^\- x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt;  [mf]; <span class="nb">rewrite</span> -[<span class="kr">fun</span> <span class="nv">x</span> =&gt; _]/(abse \o f) fune_abse =&gt; foo.
<span class="nb">rewrite</span> ge0_integralD // <span class="kr">in</span> foo; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="bp">exact</span>: emeasurable_fun_funepos.
  - <span class="bp">exact</span>: emeasurable_fun_funeneg.
<span class="nb">apply</span>: ltpinfty_adde_def.
- <span class="bp">by</span> <span class="nb">apply</span>: le_lt_trans foo; <span class="nb">rewrite</span> lee_addl// integral_ge0.
- <span class="bp">by</span> <span class="nb">rewrite</span> inE (@le_lt_trans _ _ <span class="mi">0</span>)// lee_oppl oppe0 integral_ge0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrable_funepos</span> <span class="nv">f</span> : mu_int f -&gt; mu_int f^\+.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [Df foo]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: emeasurable_fun_funepos.
<span class="nb">apply</span>: le_lt_trans foo; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>/measurable_funT_comp =&gt; //; <span class="bp">exact</span>: emeasurable_fun_funepos.
- <span class="bp">exact</span>/measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; t Dt; <span class="nb">rewrite</span> -/((abse \o f) t) fune_abse gee0_abs// lee_addl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrable_funeneg</span> <span class="nv">f</span> : mu_int f -&gt; mu_int f^\-.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [Df foo]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: emeasurable_fun_funeneg.
<span class="nb">apply</span>: le_lt_trans foo; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>/measurable_funT_comp =&gt; //; <span class="bp">exact</span>: emeasurable_fun_funeneg.
- <span class="bp">exact</span>/measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; t Dt; <span class="nb">rewrite</span> -/((abse \o f) t) fune_abse gee0_abs// lee_addr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_funeneg_lt_pinfty</span> <span class="nv">f</span> : mu_int f -&gt;
  \int[mu]_(x <span class="kr">in</span> D) f^\- x &lt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [mf]; <span class="nb">apply</span>: le_lt_trans; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funeneg =&gt; //; <span class="bp">exact</span>: emeasurable_funN.
- <span class="bp">exact</span>: measurable_funT_comp.
- <span class="nb">move</span>=&gt; x Dx; <span class="nb">have</span> [fx0|/ltW fx0] := leP (f x) <span class="mi">0</span>.
    <span class="nb">rewrite</span> lee0_abs// /funeneg.
    <span class="bp">by</span> <span class="nb">move</span>: fx0; <span class="nb">rewrite</span> -{<span class="mi">1</span>}oppe0 -lee_oppr =&gt; /max_idPl -&gt;.
  <span class="nb">rewrite</span> gee0_abs// /funeneg.
  <span class="bp">by</span> <span class="nb">move</span>: (fx0); <span class="nb">rewrite</span> -{<span class="mi">1</span>}oppe0 -lee_oppl =&gt; /max_idPr -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_funepos_lt_pinfty</span> <span class="nv">f</span> : mu_int f -&gt;
  \int[mu]_(x <span class="kr">in</span> D) f^\+ x &lt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [mf]; <span class="nb">apply</span>: le_lt_trans; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funepos =&gt; //; <span class="bp">exact</span>: emeasurable_funN.
- <span class="bp">exact</span>: measurable_funT_comp.
- <span class="nb">move</span>=&gt; x Dx; <span class="nb">have</span> [fx0|/ltW fx0] := leP (f x) <span class="mi">0</span>.
    <span class="nb">rewrite</span> lee0_abs// /funepos.
    <span class="bp">by</span> <span class="nb">move</span>: (fx0) =&gt; /max_idPr -&gt;; <span class="nb">rewrite</span> -lee_oppr oppe0.
  <span class="bp">by</span> <span class="nb">rewrite</span> gee0_abs// /funepos; <span class="nb">move</span>: (fx0) =&gt; /max_idPl -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrable_neg_fin_num</span> <span class="nv">f</span> :
  mu_int f -&gt; \int[mu]_(x <span class="kr">in</span> D) f^\- x \<span class="kr">is</span> a fin_num.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fi.
<span class="nb">rewrite</span> fin_numElt; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> (@lt_le_trans _ _ <span class="mi">0</span>) <span class="nl">?lte_ninfty</span>//; <span class="bp">exact</span>: integral_ge0.
<span class="nb">case</span>: fi =&gt; mf; <span class="nb">apply</span>: le_lt_trans; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">exact</span>/emeasurable_fun_funeneg.
- <span class="bp">exact</span>/measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">rewrite</span> -/((abse \o f) x) (fune_abse f) lee_addr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrable_pos_fin_num</span> <span class="nv">f</span> :
  mu_int f -&gt; \int[mu]_(x <span class="kr">in</span> D) f^\+ x \<span class="kr">is</span> a fin_num.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fi.
<span class="nb">rewrite</span> fin_numElt; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> (@lt_le_trans _ _ <span class="mi">0</span>) <span class="nl">?lte_ninfty</span>//; <span class="bp">exact</span>: integral_ge0.
<span class="nb">case</span>: fi =&gt; mf; <span class="nb">apply</span>: le_lt_trans; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">exact</span>/emeasurable_fun_funepos.
- <span class="bp">exact</span>/measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">rewrite</span> -/((abse \o f) x) (fune_abse f) lee_addl.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integrable</span>.
<span class="kn">Notation</span> <span class="s2">&quot;mu .-integrable&quot;</span> := (integrable mu) : type_scope.
<span class="kn">Arguments</span> eq_integrable {d T R mu D} mD f.

<span class="kn">Section</span> <span class="nf">sequence_measure</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m_</span> : {<span class="kn">measure</span> <span class="nb">set</span> T -&gt; \bar R}^nat.
<span class="kn">Let</span> <span class="nf">m</span> := mseries m_ O.

<span class="kn">Lemma</span> <span class="nf">integral_measure_series</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">f</span> : T -&gt; \bar R) :
  (<span class="kr">forall</span> <span class="nv">n</span>, integrable (m_ n) D f) -&gt;
  measurable_fun D f -&gt;
  \sum_(n &lt;oo) `|\int[m_ n]_(x <span class="kr">in</span> D) f^\- x | &lt; +oo%E -&gt;
  \sum_(n &lt;oo) `|\int[m_ n]_(x <span class="kr">in</span> D) f^\+ x | &lt; +oo%E -&gt;
  \int[m]_(x <span class="kr">in</span> D) f x = \sum_(n &lt;oo) \int[m_ n]_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fi mf fmoo fpoo; <span class="nb">rewrite</span> integralE.
<span class="nb">rewrite</span> ge0_integral_measure_series//; <span class="nb">last</span> <span class="bp">exact</span>/emeasurable_fun_funepos.
<span class="nb">rewrite</span> ge0_integral_measure_series//; <span class="nb">last</span> <span class="bp">exact</span>/emeasurable_fun_funeneg.
<span class="nb">transitivity</span> (\sum_(n &lt;oo) (fine (\int[m_ n]_(x <span class="kr">in</span> D) f^\+ x))%:E -
              \sum_(n &lt;oo) (fine (\int[m_ n]_(x <span class="kr">in</span> D) f^\- x))%:E).
  <span class="bp">by</span> <span class="nb">congr</span> (_ - _); <span class="nb">apply</span> eq_eseries =&gt; n _; <span class="nb">rewrite</span> fineK//;
    [<span class="bp">exact</span>: integrable_pos_fin_num|<span class="bp">exact</span>: integrable_neg_fin_num].
<span class="nb">have</span> fineKn : \sum_(n &lt;oo) `|\int[m_ n]_(x <span class="kr">in</span> D) f^\- x| =
          \sum_(n &lt;oo) `|(fine (\int[m_ n]_(x <span class="kr">in</span> D) f^\- x))%:E|.
  <span class="nb">apply</span> eq_eseries =&gt; n _; <span class="nb">congr</span> abse; <span class="nb">rewrite</span> fineK//.
  <span class="bp">exact</span>: integrable_neg_fin_num.
<span class="nb">have</span> fineKp : \sum_(n &lt;oo) `|\int[m_ n]_(x <span class="kr">in</span> D) f^\+ x| =
          \sum_(n &lt;oo) `|(fine (\int[m_ n]_(x <span class="kr">in</span> D) f^\+ x))%:E|.
  <span class="nb">apply</span> eq_eseries =&gt; n _; <span class="nb">congr</span> abse; <span class="nb">rewrite</span> fineK//.
  <span class="bp">exact</span>: integrable_pos_fin_num.
<span class="nb">rewrite</span> nneseries_esum; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>/fine_ge0/integral_ge0.
<span class="nb">rewrite</span> nneseries_esum; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>/fine_ge0/integral_ge0.
<span class="nb">rewrite</span> -esumB//; <span class="nb">last</span> <span class="mi">4</span> <span class="kp">first</span>.
  - <span class="bp">by</span> <span class="nb">rewrite</span> /= /summable -nneseries_esum// -fineKp.
  - <span class="bp">by</span> <span class="nb">rewrite</span> /summable /= -nneseries_esum// -fineKn; <span class="bp">exact</span>: fmoo.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>/fine_ge0/integral_ge0.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>/fine_ge0/integral_ge0.
<span class="nb">rewrite</span> -summable_nneseries_esum; <span class="nb">last first</span>.
  <span class="nb">rewrite</span> /summable.
  <span class="nb">apply</span>: (@le_lt_trans _ _ (\esum_(i <span class="kr">in</span> (<span class="kr">fun</span>=&gt; true))
     `|(fine (\int[m_ i]_(x <span class="kr">in</span> D) f x))%:E|)).
    <span class="nb">apply</span>: le_esum =&gt; k _; <span class="nb">rewrite</span> -EFinB -fineB// -<span class="nl">?integralE</span>//;
      [<span class="bp">exact</span>: integrable_pos_fin_num|<span class="bp">exact</span>: integrable_neg_fin_num].
  <span class="nb">rewrite</span> -nneseries_esum; <span class="nb">last</span> <span class="bp">by</span> [].
  <span class="nb">apply</span>: (@le_lt_trans _ _ (\sum_(n &lt;oo) `|(fine (\int[m_ n]_(x <span class="kr">in</span> D) f^\+ x))%:E| +
                            \sum_(n &lt;oo) `|(fine (\int[m_ n]_(x <span class="kr">in</span> D) f^\- x))%:E|)).
    <span class="nb">rewrite</span> -nneseriesD//; <span class="nb">apply</span> lee_nneseries =&gt; // n _.
    <span class="nb">rewrite</span> integralE fineB// <span class="nl">?EFinB</span>.
    - <span class="bp">exact</span>: (le_trans (lee_abs_sub _ _)).
    - <span class="bp">exact</span>: integrable_pos_fin_num.
    - <span class="bp">exact</span>: integrable_neg_fin_num.
  <span class="nb">apply</span>: lte_add_pinfty; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -fineKp.
  <span class="bp">by</span> <span class="nb">rewrite</span> -fineKn; <span class="bp">exact</span>: fmoo.
<span class="bp">by</span> <span class="nb">apply</span> eq_eseries =&gt; k _; <span class="nb">rewrite</span> !fineK// -<span class="nl">?integralE</span>//;
  [<span class="bp">exact</span>: integrable_neg_fin_num|<span class="bp">exact</span>: integrable_pos_fin_num].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sequence_measure</span>.

<span class="kn">Section</span> <span class="nf">integrable_lemmas</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">ge0_integral_bigcup</span> (<span class="nv">F</span> : (<span class="nb">set</span> _)^nat) (<span class="nv">f</span> : T -&gt; \bar R) :
  (<span class="kr">forall</span> <span class="nv">k</span>, measurable (F k)) -&gt;
  <span class="kr">let</span> <span class="nv">D</span> := \bigcup_k F k <span class="kr">in</span>
  mu.-integrable D f -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt;
  trivIset setT F -&gt;
  \int[mu]_(x <span class="kr">in</span> D) f x = \sum_(i &lt;oo) \int[mu]_(x <span class="kr">in</span> F i) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF D fi f0 tF; <span class="nb">pose</span> f_ N := f \_ (\big[setU/set0]_(<span class="mi">0</span> &lt;= i &lt; N) F i).
<span class="nb">have</span> lim_f_ t : f_ ^~ t --&gt; (f \_ D) t.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ = ereal_sup (range (f_ ^~ t))); <span class="nb">last first</span>.
    <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
      <span class="nb">rewrite</span> /restrict; <span class="nb">case</span>: ifPn =&gt; [|_].
        <span class="nb">rewrite</span> in_setE =&gt; -[n _ Fnt]; <span class="nb">apply</span>: ereal_sup_ub; <span class="kr">exists</span> <span class="nv">n</span>.+<span class="mi">1</span> =&gt; //.
        <span class="bp">by</span> <span class="nb">rewrite</span> /f_ big_mkord patchT// in_setE big_ord_recr/=; <span class="nb">right</span>.
      <span class="nb">rewrite</span> (@le_trans _ _ (f_ O t))// <span class="nl">?ereal_sup_ub</span>//.
      <span class="bp">by</span> <span class="nb">rewrite</span> /f_ patchN// big_mkord big_ord0 inE/= in_set0.
    <span class="nb">apply</span>: ub_ereal_sup =&gt; x [n _ &lt;-].
    <span class="bp">by</span> <span class="nb">rewrite</span> /f_ restrict_lee// big_mkord; <span class="bp">exact</span>: bigsetU_bigcup.
  <span class="nb">apply</span>: ereal_nondecreasing_cvg =&gt; a b ab.
  <span class="nb">rewrite</span> /f_ !big_mkord restrict_lee //; <span class="nb">last</span> <span class="bp">exact</span>: subset_bigsetU.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">apply</span>: f0 =&gt; //; <span class="bp">exact</span>: bigsetU_bigcup Dx.
<span class="nb">transitivity</span> (\int[mu]_x lim (f_ ^~ x)).
  <span class="nb">rewrite</span> integral_mkcond; <span class="nb">apply</span>: eq_integral =&gt; x _.
  <span class="bp">by</span> <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: lim_f_.
<span class="nb">rewrite</span> monotone_convergence//; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>/(measurable_restrict f) =&gt; //.
      <span class="bp">by</span> <span class="nb">apply</span>: bigsetU_measurable =&gt; k _; <span class="bp">exact</span>: mF.
    <span class="nb">case</span>: fi =&gt; + _; <span class="nb">apply</span>/measurable_funS =&gt;//; <span class="kp">first</span> <span class="bp">exact</span>: bigcup_measurable.
    <span class="bp">by</span> <span class="nb">rewrite</span> big_mkord; <span class="bp">exact</span>: bigsetU_bigcup.
  - <span class="nb">move</span>=&gt; n x _; <span class="nb">apply</span>: erestrict_ge0 =&gt; y; <span class="nb">rewrite</span> big_mkord =&gt; Dy; <span class="nb">apply</span>: f0.
    <span class="bp">exact</span>: bigsetU_bigcup Dy.
  - <span class="nb">move</span>=&gt; x _ a b ab; <span class="nb">apply</span>: restrict_lee.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; y; <span class="nb">rewrite</span> big_mkord =&gt; Dy; <span class="nb">apply</span>: f0; <span class="bp">exact</span>: bigsetU_bigcup Dy.
    <span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span>!big_mkord; <span class="nb">apply</span>: subset_bigsetU.
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">N</span> =&gt; \int[mu]_(x <span class="kr">in</span> \big[setU/set0]_(i &lt; N) F i) f x)).
  <span class="nb">congr</span> (lim _); <span class="nb">rewrite</span> funeqE =&gt; n.
  <span class="bp">by</span> <span class="nb">rewrite</span> /f_ [<span class="kr">in</span> RHS]integral_mkcond big_mkord.
<span class="nb">congr</span> (lim _); <span class="nb">rewrite</span> funeqE =&gt; /= n; <span class="nb">rewrite</span> ge0_integral_bigsetU <span class="nl">?big_mkord</span>//.
- <span class="nb">case</span>: fi =&gt; + _; <span class="nb">apply</span>: measurable_funS =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: bigcup_measurable.
  <span class="bp">exact</span>: bigsetU_bigcup.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; y Dy; <span class="nb">apply</span>: f0; <span class="bp">exact</span>: bigsetU_bigcup Dy.
- <span class="bp">exact</span>: sub_trivIset tF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrableS</span> (<span class="nv">E</span> <span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable E -&gt; measurable D -&gt; D `&lt;=` E -&gt;
  mu.-integrable E f -&gt; mu.-integrable D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mE mD DE [mf ifoo]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurable_funS mf.
<span class="nb">apply</span>: le_lt_trans ifoo; <span class="nb">apply</span>: subset_integral =&gt; //.
<span class="bp">exact</span>: measurable_funT_comp.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrable_mkcond</span> <span class="nv">D</span> <span class="nv">f</span> : measurable D -&gt;
  mu.-integrable D f &lt;-&gt; mu.-integrable setT (f \_ D).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD; <span class="nb">rewrite</span> /integrable [<span class="kr">in</span> X <span class="kr">in</span> X &lt;-&gt; _]integral_mkcond.
<span class="nb">under</span> [<span class="kr">in</span> X <span class="kr">in</span> X &lt;-&gt; _]eq_integral <span class="kp">do</span> <span class="nb">rewrite</span> restrict_abse.
<span class="nb">split</span> =&gt; [|] [mf foo].
- <span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">exact</span>/(measurable_restrict _ _ _ _).<span class="mi">1</span>|
             <span class="bp">exact</span>: le_lt_trans foo].
- <span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">exact</span>/(measurable_restrict _ _ measurableT _).<span class="mi">2</span>|
             <span class="bp">exact</span>: le_lt_trans foo].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integrable_lemmas</span>.
<span class="kn">Arguments</span> integrable_mkcond {d T R mu D} f.

<span class="kn">Section</span> <span class="nf">integrable_ae</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variable</span> (<span class="nv">f</span> : T -&gt; \bar R).
<span class="kn">Hypotheses</span> <span class="nv">fint</span> : mu.-integrable D f.

<span class="kn">Lemma</span> <span class="nf">integrable_ae</span> : {ae mu, <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; f x \<span class="kr">is</span> a fin_num}.
<span class="kn">Proof</span>.
<span class="nb">have</span> [muD0|muD0] := eqVneq (mu D) <span class="mi">0</span>.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">D</span>; <span class="nb">split</span> =&gt; // t /= /not_implyP[].
<span class="nb">pose</span> E := [<span class="nb">set</span> x | `|f x| = +oo /\ D x ].
<span class="nb">have</span> mE : measurable E.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = D `&amp;` f @^-<span class="mi">1</span>` [<span class="nb">set</span> -oo; +oo]).
    <span class="bp">by</span> <span class="nb">apply</span>: fint.<span class="mi">1</span> =&gt; //; <span class="bp">exact</span>: measurableU.
  <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [[/eqP ftoo Dt]|[Dt]].
    <span class="nb">split</span> =&gt; //.
    <span class="bp">by</span> <span class="nb">move</span>: ftoo; <span class="nb">rewrite</span> /preimage /= eqe_absl =&gt; /andP[/orP[|]/eqP]; <span class="bp">tauto</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> /preimage /= =&gt; -[|]; <span class="nb">rewrite</span> /E /= =&gt; -&gt;.
<span class="nb">have</span> [ET|ET] := eqVneq E setT.
  <span class="nb">have</span> foo t : `|f t| = +oo <span class="bp">by</span> <span class="nb">have</span> [] : E t <span class="bp">by</span> <span class="nb">rewrite</span> ET.
  <span class="nb">move</span>: fint.<span class="mi">2</span>.
  <span class="nb">suff</span>: \int[mu]_(x <span class="kr">in</span> D) `|f x| = +oo <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">rewrite</span> ltxx.
  <span class="bp">by</span> <span class="nb">rewrite</span> -(integral_csty mD muD0)//; <span class="bp">exact</span>: eq_integral.
<span class="nb">suff</span>: mu E = <span class="mi">0</span>.
  <span class="nb">move</span>=&gt; muE0; <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span> =&gt; // t /= /not_implyP[Dt ftfin]; <span class="nb">split</span> =&gt; //.
  <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eqe_absl leey andbT.
  <span class="bp">by</span> <span class="nb">move</span>/negP : ftfin; <span class="nb">rewrite</span> fin_numE negb_and <span class="mi">2</span>!negbK orbC.
<span class="nb">have</span> [-&gt;|/set0P E0] := eqVneq E set0; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> measure0.
<span class="nb">have</span> [M M0 muM] : <span class="kr">exists2</span> M, (<span class="mi">0</span> &lt;= M)%R &amp;
    <span class="kr">forall</span> <span class="nv">n</span>, n%:R%:E * mu (E `&amp;` D) &lt;= M%:E.
  <span class="kr">exists</span> (<span class="nv">fine</span> (\int[mu]_(x <span class="kr">in</span> D) `|f x|)); <span class="kp">first</span> <span class="bp">exact</span>/fine_ge0/integral_ge0.
  <span class="nb">move</span>=&gt; n.
  <span class="nb">rewrite</span> -integral_indic// -ge0_integralM//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp=&gt; //; <span class="bp">exact</span>/measurable_fun_indic.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> lee_fin.
  <span class="nb">rewrite</span> fineK//; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">case</span>: fint =&gt; _ foo; <span class="nb">rewrite</span> ge0_fin_numE//; <span class="bp">exact</span>: integral_ge0.
  <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> lee_fin /indic.
  - <span class="bp">exact</span>/EFin_measurable_fun/measurable_funrM/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="nb">case</span>: fint.
  - <span class="nb">move</span>=&gt; x Dx; <span class="nb">rewrite</span> /= indicE.
    <span class="nb">have</span> [|xE] := boolP (x \<span class="kr">in</span> E); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> mule0.
    <span class="bp">by</span> <span class="nb">rewrite</span> /E inE /= =&gt; -[-&gt;]; <span class="nb">rewrite</span> leey.
<span class="nb">apply</span>/eqP/negPn/negP =&gt; /eqP muED0.
<span class="nb">move</span>/not_forallP : muM; <span class="nb">apply</span>.
<span class="nb">have</span> [muEDoo|] := ltP (mu (E `&amp;` D)) +oo; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> leye_eq =&gt; /eqP -&gt;; <span class="kr">exists</span> <span class="mi">1</span>%N; <span class="nb">rewrite</span> mul1e leye_eq.
<span class="kr">exists</span> `|ceil (M * (fine (mu (E `&amp;` D)))^-<span class="mi">1</span>)|%N.+<span class="mi">1</span>.
<span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -ltNge.
<span class="nb">rewrite</span> -[X <span class="kr">in</span> _ * X](@fineK _ (mu (E `&amp;` D))); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> fin_numElt muEDoo (lt_le_trans _ (measure_ge0 _ _)).
<span class="nb">rewrite</span> lte_fin -ltr_pdivr_mulr.
  <span class="nb">rewrite</span> -natr1 natr_absz ger0_norm.
    <span class="bp">by</span> <span class="nb">rewrite</span> (le_lt_trans (ceil_ge _))// ltr_addl.
  <span class="bp">by</span> <span class="nb">rewrite</span> ceil_ge0// divr_ge0//; <span class="nb">apply</span>/le0R/measure_ge0; <span class="bp">exact</span>: measurableI.
<span class="nb">rewrite</span> -lte_fin fineK.
  <span class="nb">rewrite</span> lt0e measure_ge0 andbT.
  <span class="nb">suff</span>: E `&amp;` D = E <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="bp">exact</span>/eqP.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; -[].
<span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE// measure_ge0//; <span class="bp">exact</span>: measurableI.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integrable_ae</span>.

<span class="kn">Section</span> <span class="nf">linearityM</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variable</span> (<span class="nv">f</span> : T -&gt; \bar R).
<span class="kn">Hypothesis</span> <span class="nv">intf</span> : mu.-integrable D f.

<span class="kn">Lemma</span> <span class="nf">integralM</span> <span class="nv">r</span> :
  \int[mu]_(x <span class="kr">in</span> D) (r%:E * f x) = r%:E * \int[mu]_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">have</span> [r0|r0|-&gt;] := ltgtP r <span class="mi">0</span>%R; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> mul0e; <span class="nb">rewrite</span> mul0e integral0.
- <span class="nb">rewrite</span> [<span class="kr">in</span> LHS]integralE// gt0_funeposM// gt0_funenegM//.
  <span class="nb">rewrite</span> (ge0_integralM_EFin _ _ _ _ (ltW r0)) //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funepos =&gt; //; <span class="nb">case</span>: intf.
  <span class="nb">rewrite</span> (ge0_integralM_EFin _ _ _ _ (ltW r0)) //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funeneg =&gt; //; <span class="nb">case</span>: intf.
  <span class="nb">rewrite</span> -muleBr <span class="mi">1</span>?[<span class="kr">in</span> RHS]integralE//.
  <span class="bp">by</span> <span class="nb">apply</span>: integrable_add_def; <span class="nb">case</span>: intf.
- <span class="nb">rewrite</span> [<span class="kr">in</span> LHS]integralE// lt0_funeposM// lt0_funenegM//.
  <span class="nb">rewrite</span> ge0_integralM_EFin //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    + <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funeneg =&gt; //; <span class="nb">case</span>: intf.
    + <span class="bp">by</span> <span class="nb">rewrite</span> -ler_oppr oppr0 ltW.
  <span class="nb">rewrite</span> ge0_integralM_EFin //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    + <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funepos =&gt; //; <span class="nb">case</span>: intf.
    + <span class="bp">by</span> <span class="nb">rewrite</span> -ler_oppr oppr0 ltW.
  <span class="nb">rewrite</span> -mulNe -EFinN opprK addeC EFinN mulNe -muleBr //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: integrable_add_def; <span class="nb">case</span>: intf.
  <span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> RHS]integralE.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">linearityM</span>.

<span class="kn">Section</span> <span class="nf">linearity</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variable</span> (<span class="nv">f1</span> <span class="nv">f2</span> : T -&gt; R).
<span class="kn">Let</span> <span class="nf">g1</span> := EFin \o f1.
<span class="kn">Let</span> <span class="nf">g2</span> := EFin \o f2.
<span class="kn">Hypothesis</span> <span class="nv">if1</span> : mu.-integrable D g1.
<span class="kn">Hypothesis</span> <span class="nv">if2</span> : mu.-integrable D g2.

<span class="kn">Lemma</span> <span class="nf">integralD_EFin</span> :
  \int[mu]_(x <span class="kr">in</span> D) (g1 \+ g2) x =
  \int[mu]_(x <span class="kr">in</span> D) g1 x + \int[mu]_(x <span class="kr">in</span> D) g2 x.
<span class="kn">Proof</span>.
<span class="nb">suff</span>: \int[mu]_(x <span class="kr">in</span> D) ((g1 \+ g2)^\+ x) + \int[mu]_(x <span class="kr">in</span> D) (g1^\- x) +
        \int[mu]_(x <span class="kr">in</span> D) (g2^\- x) =
      \int[mu]_(x <span class="kr">in</span> D) ((g1 \+ g2)^\- x) + \int[mu]_(x <span class="kr">in</span> D) (g1^\+ x) +
        \int[mu]_(x <span class="kr">in</span> D) (g2^\+ x).
  <span class="nb">move</span>=&gt; h; <span class="nb">rewrite</span> [<span class="kr">in</span> LHS]integralE.
  <span class="nb">move</span>/eqP : h; <span class="nb">rewrite</span> -[<span class="kr">in</span> eqRHS]addeA [<span class="kr">in</span> eqRHS]addeC.
  <span class="nb">have</span> g12pos :
      \int[mu]_(x <span class="kr">in</span> D) (g1^\+ x) + \int[mu]_(x <span class="kr">in</span> D) (g2^\+ x) \<span class="kr">is</span> a fin_num.
    <span class="nb">rewrite</span> ge0_fin_numE//.
      <span class="bp">by</span> <span class="nb">rewrite</span> lte_add_pinfty//; <span class="bp">exact</span>: integral_funepos_lt_pinfty.
    <span class="bp">by</span> <span class="nb">apply</span>: adde_ge0; <span class="bp">exact</span>: integral_ge0.
  <span class="nb">have</span> g12neg :
      \int[mu]_(x <span class="kr">in</span> D) (g1^\- x) + \int[mu]_(x <span class="kr">in</span> D) (g2^\- x) \<span class="kr">is</span> a fin_num.
    <span class="nb">rewrite</span> ge0_fin_numE//.
      <span class="bp">by</span> <span class="nb">rewrite</span> lte_add_pinfty// ; <span class="bp">exact</span>: integral_funeneg_lt_pinfty.
    <span class="bp">by</span> <span class="nb">apply</span>: adde_ge0; <span class="bp">exact</span>: integral_ge0.
  <span class="nb">rewrite</span> -sube_eq; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    - <span class="nb">rewrite</span> ge0_fin_numE.
        <span class="nb">apply</span>: lte_add_pinfty; <span class="nb">last</span> <span class="bp">exact</span>: integral_funeneg_lt_pinfty.
        <span class="nb">apply</span>: lte_add_pinfty; <span class="nb">last</span> <span class="bp">exact</span>: integral_funeneg_lt_pinfty.
        <span class="nb">have</span> : mu.-integrable D (g1 \+ g2) <span class="bp">by</span> <span class="nb">apply</span>: integrableD.
        <span class="bp">exact</span>: integral_funepos_lt_pinfty.
      <span class="nb">apply</span>: adde_ge0; <span class="nb">last</span> <span class="bp">exact</span>: integral_ge0.
      <span class="bp">by</span> <span class="nb">apply</span>: adde_ge0; <span class="bp">exact</span>: integral_ge0.
    - <span class="bp">by</span> <span class="nb">rewrite</span> fin_num_adde_defr.
  <span class="nb">rewrite</span> -(addeA (\int[mu]_(x <span class="kr">in</span> D) (g1 \+ g2)^\+ x)).
  <span class="nb">rewrite</span> (addeC (\int[mu]_(x <span class="kr">in</span> D) (g1 \+ g2)^\+ x)).
  <span class="nb">rewrite</span> -addeA (addeC (\int[mu]_(x <span class="kr">in</span> D) g1^\- x + \int[mu]_(x <span class="kr">in</span> D) g2^\- x)).
  <span class="nb">rewrite</span> eq_sym -(sube_eq g12pos) <span class="nl">?fin_num_adde_defl</span>// =&gt; /eqP &lt;-.
  <span class="nb">rewrite</span> fin_num_oppeD; <span class="nb">last first</span>.
    <span class="nb">rewrite</span> ge0_fin_numE; <span class="kp">first</span> <span class="bp">exact</span>: integral_funeneg_lt_pinfty if2.
    <span class="bp">exact</span>: integral_ge0.
  <span class="nb">rewrite</span> -addeA (addeCA (\int[mu]_(x <span class="kr">in</span> D) (g2^\+ x) )).
  <span class="bp">by</span> <span class="nb">rewrite</span> addeA -(integralE _ _ g1) -(integralE _ _ g2).
<span class="nb">have</span> : (g1 \+ g2)^\+ \+ g1^\- \+ g2^\- = (g1 \+ g2)^\- \+ g1^\+ \+ g2^\+.
  <span class="nb">rewrite</span> funeqE =&gt; x.
  <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> -<span class="mi">2</span>!addeA [<span class="kr">in</span> eqRHS]addeC -sube_eq; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> /funepos /funeneg /g1 /g2 /= !maxEFin.
    <span class="bp">by</span> <span class="nb">rewrite</span> /funepos /funeneg /g1 /g2 /= !maxEFin.
  <span class="nb">rewrite</span> addeAC eq_sym -sube_eq; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> /funepos /funeneg !maxEFin.
    <span class="bp">by</span> <span class="nb">rewrite</span> /funepos /funeneg !maxEFin.
  <span class="nb">apply</span>/eqP.
  <span class="nb">rewrite</span> -[LHS]/((g1^\+ \+ g2^\+ \- (g1^\- \+ g2^\-)) x) -funeD_posD.
  <span class="bp">by</span> <span class="nb">rewrite</span> -[RHS]/((_ \- _) x) -funeD_Dpos.
<span class="nb">move</span>/(congr1 (<span class="kr">fun</span> <span class="nv">y</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) (y x) )).
<span class="nb">rewrite</span> (ge0_integralD mu mD); <span class="nb">last</span> <span class="mi">4</span> <span class="kp">first</span>.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> adde_ge0.
  - <span class="nb">apply</span>: emeasurable_funD.
      <span class="bp">by</span> <span class="nb">apply</span>/emeasurable_fun_funepos/emeasurable_funD; [<span class="nb">case</span>: if1|<span class="nb">case</span>: if2].
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funeneg; <span class="nb">case</span>: if1.
  - <span class="bp">by</span> [].
  - <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funeneg; <span class="nb">case</span>: if2.
<span class="nb">rewrite</span> (ge0_integralD mu mD); <span class="nb">last</span> <span class="mi">4</span> <span class="kp">first</span>.
  - <span class="bp">by</span> [].
  - <span class="bp">by</span> <span class="nb">apply</span>/emeasurable_fun_funepos/emeasurable_funD; [<span class="nb">case</span>: if1|<span class="nb">case</span>: if2].
  - <span class="bp">by</span> [].
  - <span class="bp">by</span> <span class="nb">apply</span>/emeasurable_fun_funepos/emeasurable_funN =&gt; //; <span class="nb">case</span>: if1.
<span class="nb">move</span>=&gt; -&gt;.
<span class="nb">rewrite</span> (ge0_integralD mu mD); <span class="nb">last</span> <span class="mi">4</span> <span class="kp">first</span>.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="bp">exact</span>: adde_ge0.
  - <span class="nb">apply</span>: emeasurable_funD.
      <span class="bp">by</span> <span class="nb">apply</span>/emeasurable_fun_funeneg/emeasurable_funD; [<span class="nb">case</span>: if1|<span class="nb">case</span>: if2].
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funepos; <span class="nb">case</span>: if1.
  - <span class="bp">by</span> [].
  - <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funepos; <span class="nb">case</span>: if2.
<span class="nb">rewrite</span> (ge0_integralD mu mD) //.
- <span class="bp">by</span> <span class="nb">apply</span>/emeasurable_fun_funeneg/emeasurable_funD =&gt; //; [<span class="nb">case</span>: if1|<span class="nb">case</span>: if2].
- <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funepos; <span class="nb">case</span>: if1.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">linearity</span>.

<span class="kn">Lemma</span> <span class="nf">integralB_EFin</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
  (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f1</span> <span class="nv">f2</span> : T -&gt; R)
  (<span class="nv">mD</span> : measurable D) :
  mu.-integrable D (EFin \o f1) -&gt; mu.-integrable D (EFin \o f2) -&gt;
  (\int[mu]_(x <span class="kr">in</span> D) ((f1 x)%:E - (f2 x)%:E) =
    (\int[mu]_(x <span class="kr">in</span> D) (f1 x)%:E - \int[mu]_(x <span class="kr">in</span> D) (f2 x)%:E))%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; if1 if2; <span class="nb">rewrite</span> (integralD_EFin mD if1); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> (_ : _ \o _ = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; - (f2 x)%:E))%E; [<span class="bp">exact</span>: integrableN|<span class="bp">by</span> []].
<span class="bp">by</span> <span class="nb">rewrite</span> -integralN//; <span class="bp">exact</span>: integrable_add_def.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">le_abse_integral</span> <span class="nv">d</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : measurableType d)
  (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; \bar R)
  (<span class="nv">mD</span> : measurable D) : measurable_fun D f -&gt;
  (`| \int[mu]_(x <span class="kr">in</span> D) (f x) | &lt;= \int[mu]_(x <span class="kr">in</span> D) `|f x|)%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf.
<span class="nb">rewrite</span> integralE (le_trans (lee_abs_sub _ _))// gee0_abs; <span class="nb">last first</span>.
  <span class="bp">exact</span>: integral_ge0.
<span class="nb">rewrite</span> gee0_abs; <span class="nb">last</span> <span class="bp">exact</span>: integral_ge0.
<span class="bp">by</span> <span class="nb">rewrite</span> -ge0_integralD // -<span class="nl">?fune_abse</span>//;
  [<span class="bp">exact</span>: emeasurable_fun_funepos | <span class="bp">exact</span>: emeasurable_fun_funeneg].
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">integral_indic</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">integral_setI_indic</span> (<span class="nv">E</span> <span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable E -&gt;
  \int[mu]_(x <span class="kr">in</span> E `&amp;` D) f x = \int[mu]_(x <span class="kr">in</span> E) (f x * (\<span class="mi">1_</span>D x)%:E).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mE; <span class="nb">rewrite</span> integral_mkcondr; <span class="nb">apply</span>: eq_integral =&gt; x xE.
<span class="bp">by</span> <span class="nb">rewrite</span> indic_restrict /patch; <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> <span class="nl">?mule1</span> <span class="nl">?mule0</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integralEindic</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">f</span> : T -&gt; \bar R) :
  \int[mu]_(x <span class="kr">in</span> D) f x = \int[mu]_(x <span class="kr">in</span> D) (f x * (\<span class="mi">1_</span>D x)%:E).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -integral_setI_indic// setIid. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_indic</span>.

<span class="kn">Section</span> <span class="nf">ae_eq</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T).
<span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> <span class="nv">i</span> : T -&gt; \bar R.

<span class="kn">Definition</span> <span class="nf">ae_eq</span> <span class="nv">f</span> <span class="nv">g</span> := {ae mu, <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; f x = g x}.

<span class="kn">Lemma</span> <span class="nf">ae_eq0</span> <span class="nv">f</span> <span class="nv">g</span> : measurable D -&gt; mu D = <span class="mi">0</span> -&gt; ae_eq f g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mD D0; <span class="kr">exists</span> <span class="nv">D</span>; <span class="nb">split</span> =&gt; // t/= /not_implyP[]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_comp</span> (<span class="nv">j</span> : \bar R -&gt; \bar R) <span class="nv">f</span> <span class="nv">g</span> :
  ae_eq f g -&gt; ae_eq (j \o f) (j \o g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [N [mN N0 subN]]; <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //.
<span class="bp">by</span> <span class="nb">apply</span>: subset_trans subN; <span class="nb">apply</span>: subsetC =&gt; x /= /[<span class="nb">apply</span>] -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_funeposneg</span> <span class="nv">f</span> <span class="nv">g</span> : ae_eq f g &lt;-&gt; ae_eq f^\+ g^\+ /\ ae_eq f^\- g^\-.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [[N [mN N0 DfgN]]|[[A [mA A0 DfgA] [B [mB B0 DfgB]]]]].
  <span class="bp">by</span> <span class="nb">split</span>; <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; // x Dfgx; <span class="nb">apply</span>: DfgN =&gt; /=;
    <span class="nb">apply</span>: contra_not Dfgx =&gt; /= /[<span class="nb">apply</span>]; <span class="nb">rewrite</span> /funepos /funeneg =&gt; -&gt;.
<span class="kr">exists</span> (<span class="nv">A</span> `|` B); <span class="nb">rewrite</span> null_set_setU//; <span class="nb">split</span>=&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: measurableU.
<span class="nb">move</span>=&gt; x /= /not_implyP[Dx fgx]; <span class="nb">apply</span>: contrapT =&gt; /not_orP[Ax Bx].
<span class="nb">have</span> [fgpx|fgnx] : f^\+ x &lt;&gt; g^\+ x \/ f^\- x &lt;&gt; g^\- x.
  <span class="nb">apply</span>: contrapT =&gt; /not_orP[/contrapT fgpx /contrapT fgnx].
  <span class="bp">by</span> <span class="nb">apply</span>: fgx; <span class="nb">rewrite</span> (funeposneg f) (funeposneg g) fgpx fgnx.
- <span class="bp">by</span> <span class="nb">apply</span>: Ax; <span class="bp">exact</span>/DfgA/not_implyP.
- <span class="bp">by</span> <span class="nb">apply</span>: Bx; <span class="bp">exact</span>/DfgB/not_implyP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_sym</span> <span class="nv">f</span> <span class="nv">g</span> : ae_eq f g -&gt; ae_eq g f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [N1 [mN1 N10 subN1]]; <span class="kr">exists</span> <span class="nv">N1</span>; <span class="nb">split</span> =&gt; // x /= Dba; <span class="nb">apply</span>: subN1 =&gt; /=.
<span class="bp">by</span> <span class="nb">apply</span>: contra_not Dba =&gt; [+ Dx] =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_trans</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : ae_eq f g -&gt; ae_eq g h -&gt; ae_eq f h.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [N1 [mN1 N10 abN1]] [N2 [mN2 N20 bcN2]]; <span class="kr">exists</span> (<span class="nv">N1</span> `|` N2); <span class="nb">split</span> =&gt; //.
- <span class="bp">exact</span>: measurableU.
- <span class="bp">by</span> <span class="nb">rewrite</span> null_set_setU.
- <span class="nb">rewrite</span> -(setCK N1) -(setCK N2) -setCI; <span class="nb">apply</span>: subsetC =&gt; x [N1x N2x] /= Dx.
  <span class="nb">move</span>/subsetC : abN1 =&gt; /(_ _ N1x); <span class="nb">rewrite</span> setCK /= =&gt; -&gt;//.
  <span class="bp">by</span> <span class="nb">move</span>/subsetC : bcN2 =&gt; /(_ _ N2x); <span class="nb">rewrite</span> setCK /= =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_sub</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> <span class="nv">i</span> : ae_eq f g -&gt; ae_eq h i -&gt; ae_eq (f \- h) (g \- i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [N1 [mN1 N10 abN1]] [N2 [mN2 N20 bcN2]]; <span class="kr">exists</span> (<span class="nv">N1</span> `|` N2); <span class="nb">split</span> =&gt; //.
- <span class="bp">exact</span>: measurableU.
- <span class="bp">by</span> <span class="nb">rewrite</span> null_set_setU.
- <span class="nb">rewrite</span> -(setCK N1) -(setCK N2) -setCI; <span class="nb">apply</span>: subsetC =&gt; x [N1x N2x] /= Dx.
  <span class="nb">move</span>/subsetC : abN1 =&gt; /(_ _ N1x); <span class="nb">rewrite</span> setCK /= =&gt; -&gt;//.
  <span class="bp">by</span> <span class="nb">move</span>/subsetC : bcN2 =&gt; /(_ _ N2x); <span class="nb">rewrite</span> setCK /= =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_mul2r</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : ae_eq f g -&gt; ae_eq (f \* h) (g \* h).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [N1 [mN1 N10 abN1]]; <span class="kr">exists</span> <span class="nv">N1</span>; <span class="nb">split</span> =&gt; // x /= /not_implyP[Dx].
<span class="nb">move</span>=&gt; acbc; <span class="nb">apply</span>: abN1 =&gt; /=; <span class="nb">apply</span>/not_implyP; <span class="nb">split</span> =&gt; //.
<span class="bp">by</span> <span class="nb">apply</span>: contra_not acbc =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_mul2l</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : ae_eq f g -&gt; ae_eq (h \* f) (h \* g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /ae_eq_mul2r-/(_ h); <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC.
<span class="bp">by</span> <span class="nb">under</span> [<span class="kr">in</span> X <span class="kr">in</span> ae_eq _ X -&gt; _]eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_mul1l</span> <span class="nv">f</span> <span class="nv">g</span> : ae_eq f (cst <span class="mi">1</span>) -&gt; ae_eq g (g \* f).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /ae_eq_mul2l-/(_ g)/ae_eq_sym.
<span class="bp">by</span> <span class="nb">under</span> [<span class="kr">in</span> X <span class="kr">in</span> ae_eq X _ -&gt; _]eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> mule1.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_mul</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : ae_eq f g -&gt; ae_eq (f \* h) (g \* h).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [N1 [mN1 N10 abN1]]; <span class="kr">exists</span> <span class="nv">N1</span>; <span class="nb">split</span> =&gt; // x /= /not_implyP[Dx].
<span class="nb">move</span>=&gt; acbc; <span class="nb">apply</span>: abN1 =&gt; /=; <span class="nb">apply</span>/not_implyP; <span class="nb">split</span> =&gt; //.
<span class="bp">by</span> <span class="nb">apply</span>: contra_not acbc =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_abse</span> <span class="nv">f</span> <span class="nv">g</span> : ae_eq f g -&gt; ae_eq (abse \o f) (abse \o g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [N [mN N0 subN]]; <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: subset_trans subN.
<span class="bp">by</span> <span class="nb">apply</span>: subsetC =&gt; x /= /[<span class="nb">apply</span>] -&gt;.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ae_eq</span>.

<span class="kn">Section</span> <span class="nf">ae_eq_integral</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Local Notation</span> <span class="nf">ae_eq</span> := (ae_eq mu).

<span class="kn">Let</span> <span class="nf">ae_eq_integral_abs_bounded</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">f</span> : T -&gt; \bar R)
    <span class="nv">M</span> : measurable_fun D f -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; `|f x| &lt;= M%:E) -&gt;
  ae_eq D f (cst <span class="mi">0</span>) -&gt; \int[mu]_(x <span class="kr">in</span> D) `|f x|%E  = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf fM [N [mA mN0 Df0N]].
<span class="nb">pose</span> Df_neq0 := D `&amp;` [<span class="nb">set</span> x | f x != <span class="mi">0</span>].
<span class="nb">have</span> mDf_neq0 : measurable Df_neq0 <span class="bp">by</span> <span class="bp">exact</span>: emeasurable_neq.
<span class="nb">pose</span> f&#39; : T -&gt; R := indic Df_neq0.
<span class="nb">have</span> le_f_M t : D t -&gt; `|f t| &lt;= M%:E * (f&#39; t)%:E.
  <span class="nb">move</span>=&gt; Dt; <span class="nb">rewrite</span> /f&#39; indicE; <span class="nb">have</span> [|] := boolP (t \<span class="kr">in</span> Df_neq0).
    <span class="bp">by</span> <span class="nb">rewrite</span> inE =&gt; -[_ _]; <span class="nb">rewrite</span> mule1 fM.
  <span class="bp">by</span> <span class="nb">rewrite</span> notin_set=&gt; /not_andP[//|/negP/negPn/eqP -&gt;]; <span class="nb">rewrite</span> abse0 mule0.
<span class="nb">have</span> : <span class="mi">0</span> &lt;= \int[mu]_(x <span class="kr">in</span> D) `|f x|  &lt;= `|M|%:E * mu Df_neq0.
  <span class="nb">rewrite</span> integral_ge0//= /Df_neq0 -{<span class="mi">2</span>}(setIid D) setIAC -integral_indic//.
  <span class="nb">rewrite</span> -/Df_neq0 -ge0_integralM//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp=&gt; //; <span class="bp">exact</span>: measurable_fun_indic.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; x ?; <span class="nb">rewrite</span> lee_fin.
  <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  - <span class="bp">exact</span>: measurable_funT_comp.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">rewrite</span> mule_ge0// lee_fin.
  - <span class="nb">apply</span>: emeasurable_funM; <span class="kp">first</span> <span class="bp">exact</span>: measurable_fun_cst.
    <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_fun_indic.
  - <span class="nb">move</span>=&gt; x Dx.
    <span class="nb">rewrite</span> (le_trans (le_f_M _ Dx))// lee_fin /f&#39; indicE.
    <span class="bp">by</span> <span class="nb">case</span>: (_ \<span class="kr">in</span> _) =&gt; //; <span class="nb">rewrite</span> <span class="nl">?mulr1</span> <span class="nl">?mulr0</span>// ler_norm.
<span class="nb">have</span> -&gt; : mu Df_neq0 = <span class="mi">0</span>.
  <span class="nb">apply</span>: (subset_measure0 _ _ _ mN0) =&gt; //.
  <span class="nb">apply</span>: subset_trans Df0N =&gt; /= x [/= f0 Dx] /=.
  <span class="bp">by</span> <span class="nb">apply</span>/not_implyP; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>/eqP.
<span class="bp">by</span> <span class="nb">rewrite</span> mule0 -eq_le =&gt; /eqP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_integral_abs</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D) (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable_fun D f -&gt; \int[mu]_(x <span class="kr">in</span> D) `|f x|  = <span class="mi">0</span> &lt;-&gt; ae_eq D f (cst <span class="mi">0</span>).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf; <span class="nb">split</span>=&gt; [iDf0|Df0].
  <span class="kr">exists</span> (<span class="nv">D</span> `&amp;` [<span class="nb">set</span> x | f x != <span class="mi">0</span>]); <span class="nb">split</span>;
    [<span class="bp">exact</span>: emeasurable_neq| |<span class="bp">by</span> <span class="nb">move</span>=&gt; t /= /not_implyP [Dt /eqP ft0]].
  <span class="nb">have</span> muDf a : (<span class="mi">0</span> &lt; a)%R -&gt; mu (D `&amp;` [<span class="nb">set</span> x | a%:E &lt;= `|f x|]) = <span class="mi">0</span>.
    <span class="nb">move</span>=&gt; a0; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le measure_ge0 <span class="nl">?andbT</span>.
    <span class="bp">by</span> <span class="nb">have</span> := le_integral_abse mu mD mf a0; <span class="nb">rewrite</span> iDf0 pmule_rle0 <span class="nl">?lte_fin</span>.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> mu X](_ : _ =
     \bigcup_n (D `&amp;` [<span class="nb">set</span> x | `|f x| &gt;= n.+<span class="mi">1</span>%:R^-<span class="mi">1</span>%:E])); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [[Dt ft0]|[n _ /= [Dt nft]]].
      <span class="nb">have</span> [ftoo|ftoo] := eqVneq `|f t| +oo.
        <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>%N =&gt; //; <span class="nb">split</span> =&gt; //=; <span class="nb">rewrite</span> ftoo /= leey.
      <span class="nb">pose</span> m := `|ceil (fine `|f t|)^-<span class="mi">1</span>|%N.
      <span class="nb">have</span> ftfin : `|f t|%E \<span class="kr">is</span> a fin_num <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE// ltey.
      <span class="kr">exists</span> <span class="nv">m</span> =&gt; //; <span class="nb">split</span> =&gt; //=.
      <span class="nb">rewrite</span> -(@fineK _ `|f t|) // lee_fin -ler_pinv; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
        - <span class="nb">rewrite</span> inE unitfE fine_eq0// abse_eq0 ft0/= fine_gt0//.
          <span class="bp">by</span> <span class="nb">rewrite</span> lt0e abse_ge0 abse_eq0 ft0 ltey.
        - <span class="bp">by</span> <span class="nb">rewrite</span> inE unitfE invr_eq0 pnatr_eq0 /= invr_gt0.
      <span class="nb">rewrite</span> invrK /m -natr1 natr_absz ger0_norm <span class="nl">?ceil_ge0</span>//.
      <span class="nb">rewrite</span> (@le_trans _ _ ((fine `|f t|)^-<span class="mi">1</span> + <span class="mi">1</span>)%R) <span class="nl">?ler_addl</span>//.
      <span class="bp">by</span> <span class="nb">rewrite</span> ler_add2r// ceil_ge.
    <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: contraTN nft =&gt; /eqP -&gt;; <span class="nb">rewrite</span> abse0 -ltNge.
  <span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; mu (D `&amp;` [<span class="nb">set</span> x | `|f x| &gt;= n.+<span class="mi">1</span>%:R^-<span class="mi">1</span>%:E]))).
    <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="nb">apply</span>: nondecreasing_cvg_mu.
    - <span class="nb">move</span>=&gt; i; <span class="nb">apply</span>: emeasurable_fun_c_infty =&gt; //.
      <span class="bp">exact</span>: measurable_funT_comp.
    - <span class="nb">apply</span>: bigcupT_measurable =&gt; i.
      <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_c_infty =&gt; //; <span class="bp">exact</span>: measurable_funT_comp.
    - <span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>/subsetPset; <span class="nb">apply</span>: setIS =&gt; t /=.
      <span class="bp">by</span> <span class="nb">apply</span>: le_trans; <span class="nb">rewrite</span> lee_fin lef_pinv // <span class="nl">?ler_nat</span> // posrE.
  <span class="bp">by</span> <span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) = cst <span class="mi">0</span>) <span class="nl">?lim_cst</span>//= funeqE =&gt; n /=; <span class="nb">rewrite</span> muDf.
<span class="nb">pose</span> f_ := <span class="kr">fun</span> <span class="nv">n</span> <span class="nv">x</span> =&gt; mine `|f x| n%:R%:E.
<span class="nb">have</span> -&gt; : (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|f x|) = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lim (f_^~ x)).
  <span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="nb">apply</span>/cvg_ballP =&gt; _/posnumP[e].
  near=&gt; n; <span class="nb">rewrite</span> /ball /= /ereal_ball /= /f_.
  <span class="nb">have</span> [-&gt;|fxoo] := eqVneq `|f x|%E +oo.
    <span class="nb">rewrite</span> -[contract +oo](@divrr _ (<span class="mi">1</span> + n%:R)%R) <span class="nl">?unitfE</span> <span class="nl">?nat1r</span>//=.
    <span class="nb">rewrite</span> (@ger0_norm _ n%:R)// nat1r -mulrBl -natrB// subSnn ger0_norm//.
    <span class="bp">by</span> <span class="nb">rewrite</span> div1r; near: n; <span class="bp">exact</span>: near_infty_natSinv_lt.
  <span class="nb">have</span> fxn : `|f x| &lt;= n%:R%:E.
    <span class="nb">rewrite</span> -(@fineK _ `|f x|); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE// ltey.
    <span class="nb">rewrite</span> lee_fin; near: n; <span class="kr">exists</span> (<span class="nv">Num</span>.bound (fine `|f x|)) =&gt; //= n/=.
    <span class="bp">by</span> <span class="nb">rewrite</span> -(ler_nat R); <span class="nb">apply</span>: le_trans; <span class="bp">exact</span>/ltW/archi_boundP.
  <span class="bp">by</span> <span class="nb">rewrite</span> min_l// subrr normr0.
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) (f_ n x) )).
  <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="nb">apply</span>: cvg_monotone_convergence =&gt; //.
  - <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>: emeasurable_fun_min =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: measurable_funT_comp.
    <span class="bp">exact</span>: measurable_fun_cst.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n t Dt; <span class="nb">rewrite</span> /f_ lexI abse_ge0 //= lee_fin.
  - <span class="nb">move</span>=&gt; t Dt m n mn; <span class="nb">rewrite</span> /f_ lexI.
    <span class="nb">have</span> [ftm|ftm] := leP `|f t|%E m%:R%:E.
      <span class="bp">by</span> <span class="nb">rewrite</span> lexx /= (le_trans ftm)// lee_fin ler_nat.
    <span class="bp">by</span> <span class="nb">rewrite</span> (ltW ftm) /= lee_fin ler_nat.
<span class="nb">have</span> ae_eq_f_ n : ae_eq D (f_ n) (cst <span class="mi">0</span>).
  <span class="nb">case</span>: Df0 =&gt; N [mN muN0 DfN].
  <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; // t /= /not_implyP[Dt fnt0].
  <span class="nb">apply</span>: DfN =&gt; /=; <span class="nb">apply</span>/not_implyP; <span class="nb">split</span> =&gt; //.
  <span class="nb">apply</span>: contra_not fnt0 =&gt; ft0.
  <span class="bp">by</span> <span class="nb">rewrite</span> /f_ ft0 /= normr0 min_l// lee_fin.
<span class="nb">have</span> f_bounded n x : D x -&gt; `|f_ n x| &lt;= n%:R%:E.
  <span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> /f_; <span class="nb">have</span> [|_] := leP `|f x| n%:R%:E.
    <span class="bp">by</span> <span class="nb">rewrite</span> abse_id.
  <span class="bp">by</span> <span class="nb">rewrite</span> gee0_abs// lee_fin.
<span class="nb">have</span> if_0 n : \int[mu]_(x <span class="kr">in</span> D) `|f_ n x|  = <span class="mi">0</span>.
  <span class="nb">apply</span>: (@ae_eq_integral_abs_bounded _ _ _ n%:R) =&gt; //.
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_min =&gt; //;
      [<span class="bp">exact</span>: measurable_funT_comp|<span class="bp">exact</span>: measurable_fun_cst].
  <span class="bp">exact</span>: f_bounded.
<span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) = cst <span class="mi">0</span>) // <span class="nl">?lim_cst</span>// funeqE =&gt; n.
<span class="bp">by</span> <span class="nb">rewrite</span> -(if_0 n); <span class="nb">apply</span>: eq_integral =&gt; x _; <span class="nb">rewrite</span> gee0_abs// /f_.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_abs_eq0</span> <span class="nv">D</span> (<span class="nv">N</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable N -&gt; measurable D -&gt; N `&lt;=` D -&gt; measurable_fun D f -&gt;
  mu N = <span class="mi">0</span> -&gt; \int[mu]_(x <span class="kr">in</span> N) `|f x| = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mN mD ND mf muN0; <span class="nb">rewrite</span> integralEindic//.
<span class="nb">rewrite</span> (eq_integral (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|f x * (\<span class="mi">1_</span>N x)%:E|)); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; t _; <span class="nb">rewrite</span> abseM (@gee0_abs _ (\<span class="mi">1_</span>N t)%:E)// lee_fin.
<span class="nb">apply</span>/ae_eq_integral_abs =&gt; //.
  <span class="nb">apply</span>: emeasurable_funM =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: (measurable_funS mD).
  <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_indic.
<span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; // t /= /not_implyP[_]; <span class="nb">rewrite</span> indicE.
<span class="bp">by</span> <span class="nb">have</span> [|] := boolP (t \<span class="kr">in</span> N); <span class="nb">rewrite</span> <span class="nl">?inE</span> <span class="nl">?mule0</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">funID</span> (<span class="nv">N</span> : <span class="nb">set</span> T) (<span class="nv">mN</span> : measurable N) (<span class="nv">f</span> : T -&gt; \bar R) :
  <span class="kr">let</span> <span class="nv">oneCN</span> := [the {nnsfun T &gt;-&gt; R} of mindic R (measurableC mN)] <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">oneN</span> := [the {nnsfun T &gt;-&gt; R} of mindic R mN] <span class="kr">in</span>
  f = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x * (oneCN x)%:E) \+ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x * (oneN x)%:E).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; oneCN oneN; <span class="nb">rewrite</span> funeqE =&gt; x.
<span class="nb">rewrite</span> /oneCN /oneN/= /mindic !indicE.
<span class="nb">have</span> [xN|xN] := boolP (x \<span class="kr">in</span> N).
  <span class="bp">by</span> <span class="nb">rewrite</span> mule1 in_setC xN mule0 add0e.
<span class="bp">by</span> <span class="nb">rewrite</span> in_setC xN mule0 adde0 mule1.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">negligible_integrable</span> (<span class="nv">D</span> <span class="nv">N</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable N -&gt; measurable D -&gt; measurable_fun D f -&gt;
  mu N = <span class="mi">0</span> -&gt; mu.-integrable D f &lt;-&gt; mu.-integrable (D `\` N) f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mN mD mf muN0.
<span class="nb">pose</span> mCN := measurableC mN.
<span class="nb">pose</span> oneCN : {nnsfun T &gt;-&gt; R} := [the {nnsfun T &gt;-&gt; R} of mindic R mCN].
<span class="nb">pose</span> oneN : {nnsfun T &gt;-&gt; R} := [the {nnsfun T &gt;-&gt; R} of mindic R mN].
<span class="nb">have</span> intone : mu.-integrable D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x * (oneN x)%:E).
  <span class="nb">split</span>.
    <span class="nb">apply</span>: emeasurable_funM=&gt; //; <span class="nb">apply</span>/EFin_measurable_fun.
    <span class="bp">exact</span>: measurable_funTS.
  <span class="nb">rewrite</span> (eq_integral (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|f x| * (\<span class="mi">1_</span>N x)%:E)); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; t _; <span class="nb">rewrite</span> abseM (@gee0_abs _ (\<span class="mi">1_</span>N t)%:E) // lee_fin.
  <span class="nb">rewrite</span> -integral_setI_indic// (@integral_abs_eq0 D)//.
  - <span class="bp">exact</span>: measurableI.
  - <span class="bp">by</span> <span class="nb">apply</span>: (subset_measure0 _ _ _ muN0) =&gt; //; <span class="bp">exact</span>: measurableI.
<span class="nb">have</span> h1 : mu.-integrable D f &lt;-&gt; mu.-integrable D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x * (oneCN x)%:E).
  <span class="nb">split</span>=&gt; [intf|intCf].
    <span class="nb">split</span>.
      <span class="nb">apply</span>: emeasurable_funM=&gt; //; <span class="nb">apply</span>/EFin_measurable_fun =&gt; //.
      <span class="bp">exact</span>: measurable_funTS.
    <span class="nb">rewrite</span> (eq_integral (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|f x| * (\<span class="mi">1_</span>(~` N) x)%:E)); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; t _; <span class="nb">rewrite</span> abseM (@gee0_abs _ (\<span class="mi">1_</span>(~` N) t)%:E) // lee_fin.
    <span class="nb">rewrite</span> -integral_setI_indic//; <span class="nb">case</span>: intf =&gt; _; <span class="nb">apply</span>: le_lt_trans.
    <span class="bp">by</span> <span class="nb">apply</span>: subset_integral =&gt; //; [<span class="bp">exact</span>:measurableI|<span class="bp">exact</span>:measurable_funT_comp].
  <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> (funID mN f) -/oneCN -/oneN.
  <span class="nb">have</span> ? : measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; f x * (oneCN x)%:E).
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_funM=&gt; //; <span class="bp">exact</span>/EFin_measurable_fun/measurable_funTS.
  <span class="nb">have</span> ? : measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; f x * (oneN x)%:E).
    <span class="nb">apply</span>: emeasurable_funM =&gt; //.
    <span class="bp">exact</span>/EFin_measurable_fun/measurable_funTS.
  <span class="nb">apply</span>: (@le_lt_trans _ _
    (\int[mu]_(x <span class="kr">in</span> D) (`|f x * (oneCN x)%:E| + `|f x * (oneN x)%:E|))).
    <span class="nb">apply</span>: ge0_le_integral =&gt; //.
    - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: emeasurable_funD.
    - <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_funD; <span class="bp">exact</span>: measurable_funT_comp.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> lee_abs_add.
  <span class="nb">rewrite</span> ge0_integralD//;
    [|<span class="bp">exact</span>: measurable_funT_comp|<span class="bp">exact</span>: measurable_funT_comp].
  <span class="bp">by</span> <span class="nb">apply</span>: lte_add_pinfty; [<span class="nb">case</span>: intCf|<span class="nb">case</span>: intone].
<span class="nb">have</span> h2 : mu.-integrable (D `\` N) f &lt;-&gt;
    mu.-integrable D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x * (oneCN x)%:E).
  <span class="nb">split</span>=&gt; [intCf|intCf].
    <span class="nb">split</span>.
      <span class="nb">apply</span>: emeasurable_funM=&gt; //; <span class="nb">apply</span>/EFin_measurable_fun =&gt; //.
      <span class="bp">exact</span>: measurable_funTS.
    <span class="nb">rewrite</span> (eq_integral (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|f x| * (\<span class="mi">1_</span>(~` N) x)%:E)); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; t _; <span class="nb">rewrite</span> abseM (@gee0_abs _ (\<span class="mi">1_</span>(~` N) t)%:E)// lee_fin.
    <span class="nb">rewrite</span> -integral_setI_indic //; <span class="nb">case</span>: intCf =&gt; _; <span class="nb">apply</span>: le_lt_trans.
    <span class="nb">apply</span>: subset_integral=&gt; //; [<span class="bp">exact</span>: measurableI|<span class="bp">exact</span>: measurableD|].
    <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="nb">apply</span>: measurable_funS mf =&gt; // ? [].
  <span class="nb">split</span>.
    <span class="nb">move</span>=&gt; mDN A mA; <span class="nb">rewrite</span> setDE (setIC D) -setIA; <span class="nb">apply</span>: measurableI =&gt; //.
    <span class="bp">exact</span>: mf.
  <span class="nb">rewrite</span> integral_setI_indic//.
  <span class="nb">case</span>: intCf =&gt; _; <span class="nb">rewrite</span> (eq_integral (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|f x| * (\<span class="mi">1_</span>(~` N) x)%:E))//.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; t _; <span class="nb">rewrite</span> abseM (@gee0_abs _ (\<span class="mi">1_</span>(~` N) t)%:E)// lee_fin.
<span class="bp">by</span> <span class="nb">apply</span>: (iff_trans h1); <span class="bp">exact</span>: iff_sym.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">negligible_integral</span> (<span class="nv">D</span> <span class="nv">N</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable N -&gt; measurable D -&gt; measurable_fun D f -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt;
  mu N = <span class="mi">0</span> -&gt; \int[mu]_(x <span class="kr">in</span> D) f x = \int[mu]_(x <span class="kr">in</span> D `\` N) f x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mN mD mf f0 muN0.
<span class="nb">rewrite</span> {<span class="mi">1</span>}(funID mN f) ge0_integralD//; <span class="nb">last</span> <span class="mi">4</span> <span class="kp">first</span>.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">apply</span>: mule_ge0 =&gt; //; [<span class="bp">exact</span>: f0|<span class="nb">rewrite</span> lee_fin].
  - <span class="nb">apply</span>: emeasurable_funM=&gt; //; <span class="nb">apply</span>/EFin_measurable_fun=&gt; //.
    <span class="bp">exact</span>: measurable_funTS.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">apply</span>: mule_ge0 =&gt; //; [<span class="bp">exact</span>: f0|<span class="nb">rewrite</span> lee_fin].
  - <span class="nb">apply</span>: emeasurable_funM=&gt; //; <span class="nb">apply</span>/EFin_measurable_fun=&gt; //.
    <span class="bp">exact</span>: measurable_funTS.
<span class="nb">rewrite</span> -integral_setI_indic//; <span class="nb">last</span> <span class="bp">exact</span>: measurableC.
<span class="nb">rewrite</span> -integral_setI_indic// [X <span class="kr">in</span> _ + X = _](_ : _ = <span class="mi">0</span>) <span class="nl">?adde0</span>//.
<span class="nb">rewrite</span> (eq_integral (abse \o f)); <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> in_setI =&gt; /andP[xD xN].
  <span class="bp">by</span> <span class="nb">rewrite</span> /= gee0_abs// f0//; <span class="nb">rewrite</span> inE <span class="kr">in</span> xD.
<span class="nb">rewrite</span> (@integral_abs_eq0 D)//; <span class="kp">first</span> <span class="bp">exact</span>: measurableI.
<span class="bp">by</span> <span class="nb">apply</span>: (subset_measure0 _ _ _ muN0) =&gt; //; <span class="bp">exact</span>: measurableI.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ge0_ae_eq_integral</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; \bar R) :
  measurable D -&gt; measurable_fun D f -&gt; measurable_fun D g -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= f x) -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; <span class="mi">0</span> &lt;= g x) -&gt;
  ae_eq D f g -&gt; \int[mu]_(x <span class="kr">in</span> D) (f x)  = \int[mu]_(x <span class="kr">in</span> D) (g x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD mf mg f0 g0 [N [mN N0 subN]].
<span class="nb">rewrite</span> integralEindic// [RHS]integralEindic//.
<span class="nb">rewrite</span> (negligible_integral mN)//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">apply</span>: emeasurable_funM =&gt; //.
    <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">apply</span>: mule_ge0 =&gt; //; [<span class="bp">exact</span>: f0|<span class="nb">rewrite</span> lee_fin].
<span class="nb">rewrite</span> [RHS](negligible_integral mN)//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">apply</span>: emeasurable_funM =&gt; //.
    <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">apply</span>: mule_ge0 =&gt; //; [<span class="bp">exact</span>: g0|<span class="nb">rewrite</span> lee_fin].
- <span class="nb">apply</span>: eq_integral =&gt; x;<span class="nb">rewrite</span> in_setD =&gt; /andP[_ xN].
  <span class="nb">apply</span>: contrapT; <span class="nb">rewrite</span> indicE; <span class="nb">have</span> [|?] := boolP (x \<span class="kr">in</span> D).
    <span class="nb">rewrite</span> inE =&gt; Dx; <span class="nb">rewrite</span> !mule1.
    <span class="nb">move</span>: xN; <span class="nb">rewrite</span> notin_set; <span class="nb">apply</span>: contra_not =&gt; fxgx; <span class="nb">apply</span>: subN =&gt; /=.
    <span class="bp">exact</span>/not_implyP.
  <span class="bp">by</span> <span class="nb">rewrite</span> !mule0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_eq_integral</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">g</span> <span class="nv">f</span> : T -&gt; \bar R) :
  measurable D -&gt; measurable_fun D f -&gt; measurable_fun D g -&gt;
  ae_eq D f g -&gt; integral mu D f = integral mu D g.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD mf mg /ae_eq_funeposneg[Dfgp Dfgn].
<span class="nb">rewrite</span> integralE// [<span class="kr">in</span> RHS]integralE//; <span class="nb">congr</span> (_ - _).
  <span class="bp">by</span> <span class="nb">apply</span>: ge0_ae_eq_integral =&gt; //; [<span class="bp">exact</span>: emeasurable_fun_funepos|
                                      <span class="bp">exact</span>: emeasurable_fun_funepos].
<span class="bp">by</span> <span class="nb">apply</span>: ge0_ae_eq_integral =&gt; //; [<span class="bp">exact</span>: emeasurable_fun_funeneg|
                                    <span class="bp">exact</span>: emeasurable_fun_funeneg].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ae_eq_integral</span>.
<span class="kn">Arguments</span> ae_eq_integral {d T R mu D} g.

<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">integral_cst</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) : d.-measurable D -&gt;
  <span class="kr">forall</span> <span class="nv">r</span>, \int[mu]_(x <span class="kr">in</span> D) (cst r) x = r * mu D.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD; <span class="nb">have</span> [D0 r|D0 [r| |]] := eqVneq (mu D) <span class="mi">0</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> (ae_eq_integral (cst <span class="mi">0</span>))// <span class="nl">?integral0</span> <span class="nl">?D0</span> <span class="nl">?mule0</span>//;
    [<span class="bp">exact</span>: measurable_fun_cst|<span class="bp">exact</span>: measurable_fun_cst|<span class="bp">exact</span>: ae_eq0].
- <span class="bp">by</span> <span class="nb">rewrite</span> integral_cstr.
- <span class="bp">by</span> <span class="nb">rewrite</span> integral_csty// gt0_mulye// lt0e D0/=.
- <span class="bp">by</span> <span class="nb">rewrite</span> integral_cstNy// gt0_mulNye// lt0e D0/=.
<span class="kn">Qed</span>.
<span class="kn">Add Search Blacklist</span> <span class="s2">&quot;integral_cstr&quot;</span> <span class="s2">&quot;integral_csty&quot;</span> <span class="s2">&quot;integral_cstNy&quot;</span>.

<span class="kn">Lemma</span> <span class="nf">le_integral_comp_abse</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
    (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R})  (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D)
    (<span class="nv">g</span> : T -&gt; \bar R) <span class="nv">a</span> (<span class="nv">f</span> : \bar R -&gt; \bar R) (<span class="nv">mf</span> : measurable_fun setT f)
    (<span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">r</span>, <span class="mi">0</span> &lt;= r -&gt; <span class="mi">0</span> &lt;= f r)
    (<span class="nv">f_nd</span> : {<span class="kr">in</span> `[<span class="mi">0</span>, +oo[%classic &amp;, {homo f : x y / x &lt;= y}}) :
  measurable_fun D g -&gt; (<span class="mi">0</span> &lt; a)%R -&gt;
  (f a%:E) * mu (D `&amp;` [<span class="nb">set</span> x | (`|g x| &gt;= a%:E)%E]) &lt;= \int[mu]_(x <span class="kr">in</span> D) f `|g x|.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mg a0; <span class="nb">have</span> ? : measurable (D `&amp;` [<span class="nb">set</span> x | (a%:E &lt;= `|g x|)%E]).
  <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_c_infty =&gt; //; <span class="bp">exact</span>: measurable_funT_comp.
<span class="nb">apply</span>: (@le_trans _ _ (\int[mu]_(x <span class="kr">in</span> D `&amp;` [<span class="nb">set</span> x | `|g x| &gt;= a%:E]) f `|g x|)).
  <span class="nb">rewrite</span> -integral_cst//; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _ /=; <span class="nb">rewrite</span> f0 // lee_fin ltW.
  - <span class="bp">exact</span>/measurable_fun_cst.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _ /=; <span class="nb">rewrite</span> f0.
  - <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="nb">apply</span>: measurable_funT_comp =&gt; //.
    <span class="bp">exact</span>: measurable_funS mg.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x /= [Dx]; <span class="nb">apply</span>: f_nd;
      <span class="nb">rewrite</span> inE /= in_itv /= andbT// lee_fin ltW.
<span class="nb">apply</span>: subset_integral =&gt; //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; x _ /=; <span class="nb">rewrite</span> f0.
<span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_funT_comp.
<span class="kn">Qed</span>.

<span class="kn">Local</span> <span class="kn">Close Scope</span> ereal_scope.

<span class="kn">Section</span> <span class="nf">ae_measurable_fun</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType)
        (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).
<span class="kn">Hypothesis</span> <span class="nv">cmu</span> : measure_is_complete mu.
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; \bar R).

<span class="kn">Lemma</span> <span class="nf">ae_measurable_fun</span> : ae_eq mu D f g -&gt;
  measurable_fun D f -&gt; measurable_fun D g.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [N [mN N0 subN]] mf B mB mD.
<span class="nb">apply</span>: (measurability (ErealGenOInfty.measurableE R)) =&gt; // _ [_ [x -&gt;] &lt;-].
<span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = D `&amp;` ~` N `&amp;` (f @^-<span class="mi">1</span>` `]x%:E, +oo[)
    `|` (D `&amp;` N `&amp;` g @^-<span class="mi">1</span>` `]x%:E, +oo[)); <span class="nb">last first</span>.
  <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [y /= [Dy gyxoo]|y /= [[[Dy Ny] fyxoo]|]].
  - <span class="nb">have</span> [-&gt;|fgy] := eqVneq (f y) (g y).
      <span class="nb">have</span> [yN|yN] := boolP (y \<span class="kr">in</span> N).
        <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> inE <span class="kr">in</span> yN.
      <span class="bp">by</span> <span class="nb">left</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> notin_set <span class="kr">in</span> yN.
    <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">split</span> =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: subN =&gt; /= /(_ Dy); <span class="bp">exact</span>/eqP.
  - <span class="nb">split</span> =&gt; //; <span class="nb">have</span> [&lt;-//|fgy] := eqVneq (f y) (g y).
    <span class="bp">by</span> <span class="nb">exfalso</span>; <span class="nb">apply</span>/Ny/subN =&gt; /= /(_ Dy); <span class="bp">exact</span>/eqP.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; [[]].
<span class="nb">apply</span>: measurableU.
- <span class="nb">rewrite</span> setIAC; <span class="nb">apply</span>: measurableI; <span class="nb">last</span> <span class="bp">exact</span>/measurableC.
  <span class="bp">exact</span>/mf/emeasurable_itv_bnd_pinfty.
- <span class="bp">by</span> <span class="nb">apply</span>: cmu; <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> setIAC; <span class="nb">apply</span>: subIset; <span class="nb">right</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ae_measurable_fun</span>.

<span class="kn">Section</span> <span class="nf">integralD</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variables</span> (<span class="nv">f1</span> <span class="nv">f2</span> : T -&gt; \bar R).
<span class="kn">Hypotheses</span> (<span class="nv">if1</span> : mu.-integrable D f1) (<span class="nv">if2</span> : mu.-integrable D f2).

<span class="kn">Lemma</span> <span class="nf">integralD</span> : \int[mu]_(x <span class="kr">in</span> D) (f1 x + f2 x) =
  \int[mu]_(x <span class="kr">in</span> D) f1 x + \int[mu]_(x <span class="kr">in</span> D) f2 x.
<span class="kn">Proof</span>.
<span class="nb">pose</span> A := D `&amp;` [<span class="nb">set</span> x | f1 x \<span class="kr">is</span> a fin_num].
<span class="nb">pose</span> B := D `&amp;` [<span class="nb">set</span> x | f2 x \<span class="kr">is</span> a fin_num].
<span class="nb">have</span> mA : measurable A <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fin_num =&gt; //; <span class="nb">case</span>: if1.
<span class="nb">have</span> mB : measurable B <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fin_num =&gt; //; <span class="nb">case</span>: if2.
<span class="nb">have</span> mAB : measurable (A `&amp;` B) <span class="bp">by</span> <span class="nb">apply</span>: measurableI.
<span class="nb">pose</span> g1 := (fine \o f1 \_ (A `&amp;` B))%R.
<span class="nb">pose</span> g2 := (fine \o f2 \_ (A `&amp;` B))%R.
<span class="nb">have</span> ig1 : mu.-integrable D (EFin \o g1).
  <span class="nb">rewrite</span> (_ : _ \o _ = f1 \_ (A `&amp;` B)) //.
    <span class="nb">apply</span>: (integrableS measurableT)=&gt;//; <span class="nb">apply</span>/(integrable_mkcond _ _).<span class="mi">1</span> =&gt; //.
    <span class="bp">by</span> <span class="nb">apply</span>: integrableS if1=&gt;//; <span class="nb">rewrite</span> -setIAC -setIA; <span class="nb">apply</span>: subIset; <span class="nb">left</span>.
  <span class="nb">rewrite</span> /g1 funeqE =&gt; x //=; <span class="nb">rewrite</span> !/restrict; <span class="nb">case</span>: ifPn =&gt; //.
  <span class="nb">rewrite</span> <span class="mi">2</span>!in_setI =&gt; /andP[/andP[xA f1xfin] _] /=.
  <span class="bp">by</span> <span class="nb">rewrite</span> fineK//; <span class="nb">rewrite</span> inE <span class="kr">in</span> f1xfin.
<span class="nb">have</span> ig2 : mu.-integrable D (EFin \o g2).
  <span class="nb">rewrite</span> (_ : _ \o _ = f2 \_ (A `&amp;` B)) //.
    <span class="nb">apply</span>: (integrableS measurableT)=&gt;//; <span class="nb">apply</span>/(integrable_mkcond _ _).<span class="mi">1</span> =&gt; //.
    <span class="bp">by</span> <span class="nb">apply</span>: integrableS if2=&gt;//; <span class="nb">rewrite</span> -setIAC -setIA; <span class="nb">apply</span>: subIset; <span class="nb">left</span>.
  <span class="nb">rewrite</span> /g2 funeqE =&gt; x //=; <span class="nb">rewrite</span> !/restrict; <span class="nb">case</span>: ifPn =&gt; //.
  <span class="nb">rewrite</span> in_setI =&gt; /andP[_]; <span class="nb">rewrite</span> in_setI =&gt; /andP[xB f2xfin] /=.
  <span class="bp">by</span> <span class="nb">rewrite</span> fineK//; <span class="nb">rewrite</span> inE <span class="kr">in</span> f2xfin.
<span class="nb">transitivity</span> (\int[mu]_(x <span class="kr">in</span> D) (EFin \o (g1 \+ g2)%R) x).
  <span class="nb">apply</span>: ae_eq_integral =&gt; //.
  - <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_funD =&gt; //; [<span class="nb">case</span>: if1|<span class="nb">case</span>: if2].
  - <span class="nb">rewrite</span> (_ : _ \o _ = (EFin \o g1) \+ (EFin \o g2))//.
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_funD =&gt; //; [<span class="nb">case</span>: ig1|<span class="nb">case</span>: ig2].
  - <span class="nb">have</span> [N1 [mN1 N10 subN1]] := integrable_ae mD if1.
    <span class="nb">have</span> [N2 [mN2 N20 subN2]] := integrable_ae mD if2.
    <span class="kr">exists</span> (<span class="nv">N1</span> `|` N2); <span class="nb">split</span>; [<span class="bp">exact</span>: measurableU|<span class="bp">by</span> <span class="nb">rewrite</span> null_set_setU|].
    <span class="nb">rewrite</span> -(setCK N1) -(setCK N2) -setCI.
    <span class="nb">apply</span>: subsetC =&gt; x [N1x N2x] /= Dx.
    <span class="nb">move</span>/subsetC : subN1 =&gt; /(_ x N1x); <span class="nb">rewrite</span> setCK /= =&gt; /(_ Dx) f1x.
    <span class="nb">move</span>/subsetC : subN2 =&gt; /(_ x N2x); <span class="nb">rewrite</span> setCK /= =&gt; /(_ Dx) f2x.
    <span class="nb">rewrite</span> /g1 /g2 /restrict /=; <span class="nb">have</span> [|] := boolP (x \<span class="kr">in</span> A `&amp;` B).
      <span class="bp">by</span> <span class="nb">rewrite</span> in_setI =&gt; /andP[xA xB] /=; <span class="nb">rewrite</span> EFinD !fineK.
    <span class="bp">by</span> <span class="nb">rewrite</span> in_setI negb_and =&gt; /orP[|];
      <span class="nb">rewrite</span> in_setI negb_and /= (mem_set Dx)/= notin_set/=.
- <span class="nb">rewrite</span> (_ : _ \o _ = (EFin \o g1) \+ (EFin \o g2))// integralD_EFin//.
  <span class="nb">congr</span> (_ + _).
  + <span class="nb">apply</span>: ae_eq_integral =&gt; //; [<span class="bp">by</span> <span class="nb">case</span>: ig1|<span class="bp">by</span> <span class="nb">case</span>: if1|].
    <span class="nb">have</span> [N1 [mN1 N10 subN1]] := integrable_ae mD if1.
    <span class="nb">have</span> [N2 [mN2 N20 subN2]] := integrable_ae mD if2.
    <span class="kr">exists</span> (<span class="nv">N1</span> `|` N2); <span class="nb">split</span>; [<span class="bp">exact</span>: measurableU|<span class="bp">by</span> <span class="nb">rewrite</span> null_set_setU|].
    <span class="nb">rewrite</span> -(setCK N1) -(setCK N2) -setCI.
    <span class="nb">apply</span>: subsetC =&gt; x [N1x N2x] /= Dx.
    <span class="nb">move</span>/subsetC : subN1 =&gt; /(_ x N1x); <span class="nb">rewrite</span> setCK /= =&gt; /(_ Dx) f1x.
    <span class="nb">move</span>/subsetC : subN2 =&gt; /(_ x N2x); <span class="nb">rewrite</span> setCK /= =&gt; /(_ Dx) f2x.
    <span class="nb">rewrite</span> /g1 /= /restrict.
    <span class="nb">have</span> [/=|] := boolP (x \<span class="kr">in</span> A `&amp;` B); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> fineK.
    <span class="bp">by</span> <span class="nb">rewrite</span> in_setI negb_and =&gt; /orP[|];
      <span class="nb">rewrite</span> in_setI negb_and /= (mem_set Dx) /= notin_set.
  + <span class="nb">apply</span>: ae_eq_integral =&gt; //;[<span class="bp">by</span> <span class="nb">case</span>: ig2|<span class="bp">by</span> <span class="nb">case</span>: if2|].
    <span class="nb">have</span> [N1 [mN1 N10 subN1]] := integrable_ae mD if1.
    <span class="nb">have</span> [N2 [mN2 N20 subN2]] := integrable_ae mD if2.
    <span class="kr">exists</span> (<span class="nv">N1</span> `|` N2); <span class="nb">split</span>; [<span class="bp">exact</span>: measurableU|<span class="bp">by</span> <span class="nb">rewrite</span> null_set_setU|].
    <span class="nb">rewrite</span> -(setCK N1) -(setCK N2) -setCI.
    <span class="nb">apply</span>: subsetC =&gt; x [N1x N2x] /= Dx.
    <span class="nb">move</span>/subsetC : subN1 =&gt; /(_ x N1x); <span class="nb">rewrite</span> setCK /= =&gt; /(_ Dx) f1x.
    <span class="nb">move</span>/subsetC : subN2 =&gt; /(_ x N2x); <span class="nb">rewrite</span> setCK /= =&gt; /(_ Dx) f2x.
    <span class="nb">rewrite</span> /g2 /= /restrict.
    <span class="nb">have</span> [/=|] := boolP (x \<span class="kr">in</span> A `&amp;` B); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> fineK.
    <span class="bp">by</span> <span class="nb">rewrite</span> in_setI negb_and =&gt; /orP[|];
      <span class="nb">rewrite</span> in_setI negb_and /= (mem_set Dx) /= notin_set.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integralD</span>.

<span class="kn">Section</span> <span class="nf">integralB</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T).
<span class="kn">Variables</span> (<span class="nv">mD</span> : measurable D) (<span class="nv">f1</span> <span class="nv">f2</span> : T -&gt; \bar R).
<span class="kn">Hypotheses</span> (<span class="nv">if1</span> : mu.-integrable D f1) (<span class="nv">if2</span> : mu.-integrable D f2).

<span class="kn">Lemma</span> <span class="nf">integralB</span> : \int[mu]_(x <span class="kr">in</span> D) (f1 \- f2) x =
                  \int[mu]_(x <span class="kr">in</span> D) f1 x - \int[mu]_(x <span class="kr">in</span> D) f2 x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -[<span class="kr">in</span> RHS](@integralN _ _ _ _ _ f2); <span class="nb">last</span> <span class="bp">exact</span>: integrable_add_def.
<span class="bp">by</span> <span class="nb">rewrite</span> -[<span class="kr">in</span> RHS]integralD//; <span class="bp">exact</span>: integrableN.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integralB</span>.

<span class="kn">Section</span> <span class="nf">integrable_fune</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">integral_fune_lt_pinfty</span> (<span class="nv">f</span> : T -&gt; \bar R) :
  mu.-integrable D f -&gt; \int[mu]_(x <span class="kr">in</span> D) f x &lt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; intf; <span class="nb">rewrite</span> (funeposneg f) integralB//;
  [|<span class="bp">exact</span>: integrable_funepos|<span class="bp">exact</span>: integrable_funeneg].
<span class="nb">rewrite</span> lte_add_pinfty <span class="nl">?integral_funepos_lt_pinfty</span>// lte_oppl ltNye_eq.
<span class="bp">by</span> <span class="nb">rewrite</span> integrable_neg_fin_num.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_fune_fin_num</span> (<span class="nv">f</span> : T -&gt; \bar R) :
  mu.-integrable D f -&gt; \int[mu]_(x <span class="kr">in</span> D) f x \<span class="kr">is</span> a fin_num.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; h; <span class="nb">apply</span>/fin_numPlt; <span class="nb">rewrite</span> integral_fune_lt_pinfty// andbC/= -/(- +oo).
<span class="nb">rewrite</span> lte_oppl -integralN; <span class="kp">first</span> <span class="bp">exact</span>/integral_fune_lt_pinfty/integrableN.
<span class="bp">by</span> <span class="nb">rewrite</span> fin_num_adde_defl// fin_numN integrable_neg_fin_num.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integrable_fune</span>.

<span class="kn">Section</span> <span class="nf">integral_counting</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Variables</span> (<span class="nv">R</span> : realType).

<span class="kn">Lemma</span> <span class="nf">counting_dirac</span> (<span class="nv">A</span> : <span class="nb">set</span> nat) : counting R A = \sum_(n &lt;oo) \d_ n A.
<span class="kn">Proof</span>.
<span class="nb">have</span> -&gt; : \sum_(n &lt;oo) \d_ n A = \esum_(i <span class="kr">in</span> A) \d_ i A :&gt; \bar R.
  <span class="nb">rewrite</span> nneseries_esum// (_ : [<span class="nb">set</span> _ | _] = setT); <span class="nb">last</span> <span class="bp">exact</span>/seteqP.
  <span class="nb">rewrite</span> [<span class="kr">in</span> LHS](esumID A)// !setTI [X <span class="kr">in</span> _ + X](_ : _ = <span class="mi">0</span>) <span class="nl">?adde0</span>//.
  <span class="bp">by</span> <span class="nb">apply</span> esum1 =&gt; i Ai; <span class="nb">rewrite</span> /= /dirac indicE memNset.
<span class="nb">rewrite</span> /counting/=; <span class="nb">case</span>: ifPn =&gt; /asboolP finA.
  <span class="bp">by</span> <span class="nb">rewrite</span> -finite_card_dirac.
<span class="bp">by</span> <span class="nb">rewrite</span> infinite_card_dirac.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">summable_integral_dirac</span> (<span class="nv">a</span> : nat -&gt; \bar R) : summable setT a -&gt;
  \sum_(n &lt;oo) `|\int[\d_ n]_x a x| &lt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; sa.
<span class="nb">apply</span>: (@le_lt_trans _ _ (\sum_(i &lt;oo) `|fine (a i)|%:E)).
  <span class="nb">apply</span> lee_nneseries =&gt; // n _; <span class="nb">rewrite</span> integral_dirac//.
  <span class="nb">move</span>: (@summable_pinfty _ _ _ _ sa n Logic.I).
  <span class="bp">by</span> <span class="nb">case</span>: (a n) =&gt; //= r _; <span class="nb">rewrite</span> indicE/= mem_set// mul1r.
<span class="nb">move</span>: (sa); <span class="nb">rewrite</span> /summable (_ : [<span class="nb">set</span>: nat] = (<span class="kr">fun</span>=&gt; true))//; <span class="nb">last</span> <span class="bp">exact</span>/seteqP.
<span class="nb">rewrite</span> -nneseries_esum//; <span class="nb">apply</span>: le_lt_trans.
<span class="bp">by</span> <span class="nb">apply</span> lee_nneseries =&gt; // n _ /=; <span class="nb">case</span>: (a n) =&gt; //; <span class="nb">rewrite</span> leey.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_count</span> (<span class="nv">a</span> : nat -&gt; \bar R) : summable setT a -&gt;
  \int[counting R]_t (a t) = \sum_(k &lt;oo) (a k).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; sa.
<span class="nb">transitivity</span> (\int[mseries (<span class="kr">fun</span> <span class="nv">n</span> =&gt; [the <span class="kn">measure</span> _ _ of \d_ n]) O]_t a t).
  <span class="nb">congr</span> (integral _ _ _); <span class="nb">apply</span>/funext =&gt; A.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= counting_dirac.
<span class="nb">rewrite</span> (@integral_measure_series _ _ R (<span class="kr">fun</span> <span class="nv">n</span> =&gt; [the <span class="kn">measure</span> _ _ of \d_ n]) setT)//=.
- <span class="nb">apply</span>: eq_eseries =&gt; i _; <span class="nb">rewrite</span> integral_dirac//=.
  <span class="bp">by</span> <span class="nb">rewrite</span> indicE mem_set// mul1e.
- <span class="nb">move</span>=&gt; n; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> [].
  <span class="bp">by</span> <span class="nb">rewrite</span> integral_dirac//= indicE mem_set// mul1e; <span class="bp">exact</span>: (summable_pinfty sa).
- <span class="bp">by</span> <span class="nb">apply</span>: summable_integral_dirac =&gt; //; <span class="bp">exact</span>: summable_funeneg.
- <span class="bp">by</span> <span class="nb">apply</span>: summable_integral_dirac =&gt; //; <span class="bp">exact</span>: summable_funepos.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">integral_counting</span>.

<span class="kn">Section</span> <span class="nf">subadditive_countable</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}).

<span class="kn">Lemma</span> <span class="nf">integrable_abse</span> (<span class="nv">D</span> : <span class="nb">set</span> T) : measurable D -&gt;
  <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; \bar R, mu.-integrable D f -&gt; mu.-integrable D (abse \o f).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD f [mf fi]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurable_funT_comp.
<span class="nb">apply</span>: le_lt_trans fi; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; t Dt //=; <span class="nb">rewrite</span> abse_id.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrable_summable</span> (<span class="nv">F</span> : (<span class="nb">set</span> T)^nat) (<span class="nv">g</span> : T -&gt; \bar R):
  trivIset setT F -&gt; (<span class="kr">forall</span> <span class="nv">k</span>, measurable (F k)) -&gt;
  mu.-integrable (\bigcup_k F k) g -&gt;
  summable [<span class="nb">set</span>: nat] (<span class="kr">fun</span> <span class="nv">i</span> =&gt; \int[mu]_(x <span class="kr">in</span> F i) g x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; tF mF fi.
<span class="nb">rewrite</span> /summable -(_ : [<span class="nb">set</span> _ | true] = setT); <span class="nb">last</span> <span class="bp">exact</span>/seteqP.
<span class="nb">rewrite</span> -nneseries_esum//.
<span class="nb">case</span>: (fi) =&gt; _; <span class="nb">rewrite</span> ge0_integral_bigcup//; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: integrable_abse =&gt; //; <span class="bp">exact</span>: bigcup_measurable.
<span class="nb">apply</span>: le_lt_trans; <span class="nb">apply</span>: lee_lim.
- <span class="bp">exact</span>: is_cvg_ereal_nneg_natsum_cond.
- <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_ereal_nneg_natsum_cond =&gt; n _ _; <span class="bp">exact</span>: integral_ge0.
- <span class="nb">apply</span>: nearW =&gt; n; <span class="nb">apply</span>: lee_sum =&gt; m _; <span class="nb">apply</span>: le_abse_integral =&gt; //.
  <span class="bp">by</span> <span class="nb">apply</span>: measurable_funS fi.<span class="mi">1</span> =&gt; //; [<span class="bp">exact</span>: bigcup_measurable|
                                        <span class="bp">exact</span>: bigcup_sup].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integral_bigcup</span> (<span class="nv">F</span> : (<span class="nb">set</span> _)^nat) (<span class="nv">g</span> : T -&gt; \bar R) :
  trivIset setT F -&gt; (<span class="kr">forall</span> <span class="nv">k</span>, measurable (F k)) -&gt;
  mu.-integrable (\bigcup_k F k) g -&gt;
  (\int[mu]_(x <span class="kr">in</span> \bigcup_i F i) g x = \sum_(i &lt;oo) \int[mu]_(x <span class="kr">in</span> F i) g x)%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; tF mF fi.
<span class="nb">have</span> ? : \int[mu]_(x <span class="kr">in</span> \bigcup_i F i) g x \<span class="kr">is</span> a fin_num.
  <span class="nb">rewrite</span> fin_numElt -(lte_absl _ +oo).
  <span class="nb">apply</span>: le_lt_trans fi.<span class="mi">2</span>; <span class="nb">apply</span>: le_abse_integral =&gt; //.
    <span class="bp">exact</span>: bigcupT_measurable.
  <span class="bp">exact</span>: fi.<span class="mi">1</span>.
<span class="nb">transitivity</span> (\int[mu]_(x <span class="kr">in</span> \bigcup_i F i) g^\+ x -
              \int[mu]_(x <span class="kr">in</span> \bigcup_i F i) g^\- x)%E.
  <span class="nb">rewrite</span> -integralB; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
    - <span class="bp">exact</span>: bigcupT_measurable.
    - <span class="bp">by</span> <span class="nb">apply</span>: integrable_funepos =&gt; //; <span class="bp">exact</span>: bigcupT_measurable.
    -<span class="bp">by</span> <span class="nb">apply</span>: integrable_funeneg =&gt; //; <span class="bp">exact</span>: bigcupT_measurable.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; t Ft; <span class="nb">rewrite</span> [<span class="kr">in</span> LHS](funeposneg g).
<span class="nb">transitivity</span> (\sum_(i &lt;oo) (\int[mu]_(x <span class="kr">in</span> F i) g^\+ x -
                            \int[mu]_(x <span class="kr">in</span> F i) g^\- x)); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_eseries =&gt; // i; <span class="nb">rewrite</span> [RHS]integralE.
<span class="nb">transitivity</span> ((\sum_(i &lt;oo) \int[mu]_(x <span class="kr">in</span> F i) g^\+ x) -
              (\sum_(i &lt;oo) \int[mu]_(x <span class="kr">in</span> F i) g^\- x))%E.
  <span class="nb">rewrite</span> ge0_integral_bigcup//; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: integrable_funepos =&gt; //; <span class="bp">exact</span>: bigcupT_measurable.
  <span class="bp">by</span> <span class="nb">rewrite</span> ge0_integral_bigcup//; <span class="nb">apply</span>: integrable_funepos =&gt; //;
    [<span class="bp">exact</span>: bigcupT_measurable|<span class="bp">exact</span>: integrableN].
<span class="nb">rewrite</span> [X <span class="kr">in</span> X - _]nneseries_esum; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>: integral_ge0.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ - X]nneseries_esum; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>: integral_ge0.
<span class="nb">rewrite</span> set_true -esumB//=; <span class="nb">last</span> <span class="mi">4</span> <span class="kp">first</span>.
  - <span class="nb">apply</span>: integrable_summable =&gt; //; <span class="nb">apply</span>: integrable_funepos =&gt; //.
    <span class="bp">exact</span>: bigcup_measurable.
  - <span class="nb">apply</span>: integrable_summable =&gt; //; <span class="nb">apply</span>: integrable_funepos =&gt; //.
    <span class="bp">exact</span>: bigcup_measurable.
  - <span class="bp">exact</span>: integrableN.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>: integral_ge0.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n _; <span class="bp">exact</span>: integral_ge0.
<span class="nb">rewrite</span> summable_nneseries; <span class="nb">last first</span>.
  <span class="nb">under</span> [X <span class="kr">in</span> summable _ X]eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -integralE.
  <span class="bp">by</span> <span class="nb">rewrite</span> fun_true; <span class="bp">exact</span>: integrable_summable.
<span class="bp">by</span> <span class="nb">congr</span> (_ - _)%E; <span class="nb">rewrite</span> nneseries_esum// set_true.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">subadditive_countable</span>.

<span class="kn">Section</span> <span class="nf">dominated_convergence_lemma</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variables</span> (<span class="nv">f_</span> : (T -&gt; \bar R)^nat) (<span class="nv">f</span> : T -&gt; \bar R) (<span class="nv">g</span> : T -&gt; \bar R).
<span class="kn">Hypothesis</span> <span class="nv">mf_</span> : <span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (f_ n).
<span class="kn">Hypothesis</span> <span class="nv">f_f</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; f_ ^~ x --&gt; f x.
<span class="kn">Hypothesis</span> <span class="nv">fing</span> : <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; g x \<span class="kr">is</span> a fin_num.
<span class="kn">Hypothesis</span> <span class="nv">ig</span> : mu.-integrable D g.
<span class="kn">Hypothesis</span> <span class="nv">absfg</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">x</span>, D x -&gt; `|f_ n x| &lt;= g x.

<span class="kn">Let</span> <span class="nf">g0</span> <span class="nv">x</span> : D x -&gt; <span class="mi">0</span> &lt;= g x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> (le_trans _ (@absfg O _ Dx))// lee_fin. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mf</span> : measurable_fun D f.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (emeasurable_fun_cvg _ _ mf_ f_f). <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">dominated_integrable</span> : mu.-integrable D f.
<span class="kn">Proof</span>.
<span class="nb">split</span> =&gt; //; <span class="nb">have</span> Dfg x : D x -&gt; `| f x | &lt;= g x.
  <span class="nb">move</span>=&gt; Dx; <span class="nb">have</span> /(@cvg_lim _) &lt;- // : `|f_ n x| @[n --&gt; \oo] --&gt; `|f x|.
    <span class="bp">by</span> <span class="nb">apply</span>: cvg_abse =&gt; //; <span class="bp">exact</span>: f_f.
  <span class="nb">apply</span>: lime_le =&gt; //.
  - <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_abse; <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: f_f.
  - <span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; n; <span class="bp">exact</span>: absfg.
<span class="nb">move</span>: ig =&gt; [mg]; <span class="nb">apply</span>: le_lt_trans; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx /=; <span class="nb">rewrite</span> (gee0_abs (g0 Dx)); <span class="bp">exact</span>: Dfg.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">g_</span> <span class="nv">n</span> <span class="nv">x</span> := `|f_ n x - f x|.

<span class="kn">Let</span> <span class="nf">cvg_g_</span> <span class="nv">x</span> : D x -&gt; g_ ^~ x --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> -abse0; <span class="nb">apply</span>: cvg_abse.
<span class="nb">move</span>: (f_f Dx); <span class="nb">case</span>: (f x) =&gt; [r|/=|/=].
- <span class="bp">by</span> <span class="nb">move</span>=&gt; f_r; <span class="nb">apply</span>/cvge_sub0.
- <span class="nb">move</span>/cvgeyPge/(_ (fine (g x) + <span class="mi">1</span>)%R) =&gt; [n _]/(_ _ (leqnn n))/= h.
  <span class="nb">have</span> : (fine (g x) + <span class="mi">1</span>)%:E &lt;= g x.
    <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans h)// (le_trans _ (absfg n Dx))// lee_abs.
  <span class="bp">by</span> <span class="nb">case</span>: (g x) (fing Dx) =&gt; [r _| |]//; <span class="nb">rewrite</span> leNgt EFinD lte_addl <span class="nl">?lte01</span>.
- <span class="nb">move</span>/cvgeNyPle/(_ (- (fine (g x) + <span class="mi">1</span>))%R) =&gt; [n _]/(_ _ (leqnn n)) h.
  <span class="nb">have</span> : (fine (g x) + <span class="mi">1</span>)%:E &lt;= g x.
    <span class="nb">move</span>: h; <span class="nb">rewrite</span> EFinN lee_oppr =&gt; /le_trans -&gt;//.
    <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans _ (absfg n Dx))// -abseN lee_abs.
  <span class="bp">by</span> <span class="nb">case</span>: (g x) (fing Dx) =&gt; [r _| |]//; <span class="nb">rewrite</span> leNgt EFinD lte_addl <span class="nl">?lte01</span>.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">gg_</span> <span class="nv">n</span> <span class="nv">x</span> : D x -&gt; <span class="mi">0</span> &lt;= <span class="mi">2</span>%:E * g x - g_ n x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> subre_ge0; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> fin_numM// fing.
<span class="nb">rewrite</span> -(fineK (fing Dx)) -EFinM mulr_natl mulr2n /g_.
<span class="nb">rewrite</span> (le_trans (lee_abs_sub _ _))// [<span class="kr">in</span> leRHS]EFinD lee_add//.
  <span class="bp">by</span> <span class="nb">rewrite</span> fineK// <span class="nl">?fing</span>// absfg.
<span class="nb">have</span> f_fx : `|(f_ n x)| @[n --&gt; \oo] --&gt; `|f x| <span class="bp">by</span> <span class="nb">apply</span>: cvg_abse; <span class="bp">exact</span>: f_f.
<span class="nb">move</span>/cvg_lim : (f_fx) =&gt; &lt;-//.
<span class="nb">apply</span>: lime_le; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: f_fx.
<span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; k; <span class="nb">rewrite</span> fineK <span class="nl">?fing</span>//; <span class="nb">apply</span>: absfg.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">mgg</span> <span class="nv">n</span> : measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">2</span>%:E * g x - g_ n x).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/emeasurable_funB =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: measurable_funeM; <span class="nb">case</span>: ig.
<span class="bp">by</span> <span class="nb">apply</span>/measurable_funT_comp =&gt; //; <span class="bp">exact</span>: emeasurable_funB.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">gg_ge0</span> <span class="nv">n</span> <span class="nv">x</span> : D x -&gt; <span class="mi">0</span> &lt;= <span class="mi">2</span>%:E * g x - g_ n x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> gg_. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">dominated_cvg0</span> : [sequence \int[mu]_(x <span class="kr">in</span> D) g_ n x]_n --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">have</span> := fatou mu mD mgg gg_ge0.
<span class="nb">rewrite</span> [X <span class="kr">in</span> X &lt;= _ -&gt; _](_ : _ = \int[mu]_(x <span class="kr">in</span> D) (<span class="mi">2</span>%:E * g x) ); <span class="nb">last first</span>.
  <span class="nb">apply</span>: eq_integral =&gt; t; <span class="nb">rewrite</span> inE =&gt; Dt.
  <span class="nb">rewrite</span> lim_einf_shift//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> fin_numM// fing.
  <span class="nb">rewrite</span> is_cvg_lim_einfE//; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: is_cvgeN; <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: cvg_g_.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ + X](_ : _ = <span class="mi">0</span>) <span class="nl">?adde0</span>//; <span class="nb">apply</span>/cvg_lim =&gt; //.
  <span class="bp">by</span> <span class="nb">rewrite</span> -(oppe0); <span class="nb">apply</span>: cvgeN; <span class="bp">exact</span>: cvg_g_.
<span class="nb">have</span> i2g : \int[mu]_(x <span class="kr">in</span> D) (<span class="mi">2</span>%:E * g x)  &lt; +oo.
  <span class="nb">rewrite</span> integralM// lte_mul_pinfty// <span class="nl">?lee_fin</span>//; <span class="nb">case</span>: ig =&gt; _.
  <span class="nb">apply</span>: le_lt_trans; <span class="nb">rewrite</span> le_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; t Dt; <span class="nb">rewrite</span> gee0_abs// g0//; <span class="nb">rewrite</span> inE <span class="kr">in</span> Dt.
<span class="nb">have</span> ? : \int[mu]_(x <span class="kr">in</span> D) (<span class="mi">2</span>%:E * g x)  \<span class="kr">is</span> a fin_num.
  <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE// integral_ge0// =&gt; ? ?; <span class="nb">rewrite</span> mule_ge0 <span class="nl">?lee_fin</span> <span class="nl">?g0</span>.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= X -&gt; _](_ : _ = \int[mu]_(x <span class="kr">in</span> D) (<span class="mi">2</span>%:E * g x)  + -
    lim_esup (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) g_ n x)); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) = (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) (<span class="mi">2</span>%:E * g x)  +
      \int[mu]_(x <span class="kr">in</span> D) - g_ n x)); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> integralB//.
    - <span class="bp">by</span> <span class="nb">rewrite</span> -integral_ge0N// =&gt; x Dx//; <span class="nb">rewrite</span> /g_.
    - <span class="bp">exact</span>: integrablerM.
    - <span class="nb">have</span> integrable_normfn : mu.-integrable D (abse \o f_ n).
        <span class="nb">apply</span>: le_integrable ig =&gt; //.
        - <span class="bp">exact</span>: measurable_funT_comp.
        - <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx /=; <span class="nb">rewrite</span> abse_id (le_trans (absfg _ Dx))// lee_abs.
      <span class="nb">suff</span>: mu.-integrable D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|f_ n x| + `|f x|).
        <span class="nb">apply</span>: le_integrable =&gt; //.
        - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: emeasurable_funB.
        - <span class="nb">move</span>=&gt; x Dx.
          <span class="bp">by</span> <span class="nb">rewrite</span> /g_ abse_id (le_trans (lee_abs_sub _ _))// lee_abs.
      <span class="nb">apply</span>: integrableD; [<span class="bp">by</span> []| <span class="bp">by</span> []|].
      <span class="nb">apply</span>: le_integrable dominated_integrable =&gt; //.
      - <span class="bp">exact</span>: measurable_funT_comp.
      - <span class="bp">by</span> <span class="nb">move</span>=&gt; x Dx; <span class="nb">rewrite</span> /= abse_id.
  <span class="nb">rewrite</span> lim_einf_shift // -lim_einfN; <span class="nb">congr</span> (_ + lim_einf _).
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n /=; <span class="nb">rewrite</span> -integral_ge0N// =&gt; x Dx; <span class="nb">rewrite</span> /g_.
<span class="nb">rewrite</span> addeC -lee_subl_addr// subee// lee_oppr oppe0 =&gt; lim_ge0.
<span class="bp">by</span> <span class="nb">apply</span>/lim_esup_le_cvg =&gt; // n; <span class="nb">rewrite</span> integral_ge0// =&gt; x _; <span class="nb">rewrite</span> /g_.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">dominated_cvg</span> :
  (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) f_ n x) --&gt; \int[mu]_(x <span class="kr">in</span> D) f x.
<span class="kn">Proof</span>.
<span class="nb">have</span> h n : `| \int[mu]_(x <span class="kr">in</span> D) f_ n x - \int[mu]_(x <span class="kr">in</span> D) f x |
    &lt;= \int[mu]_(x <span class="kr">in</span> D) g_ n x.
  <span class="nb">rewrite</span> -(integralB _ _ dominated_integrable)//; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: le_integrable ig =&gt; // x Dx /=; <span class="nb">rewrite</span> (gee0_abs (g0 Dx)) absfg.
  <span class="bp">by</span> <span class="nb">apply</span>: le_abse_integral =&gt; //; <span class="bp">exact</span>: emeasurable_funB.
<span class="nb">suff</span>: (<span class="kr">fun</span> <span class="nv">n</span> =&gt; `| \int[mu]_(x <span class="kr">in</span> D) f_ n x - \int[mu]_(x <span class="kr">in</span> D) f x |) --&gt; <span class="mi">0</span>.
   <span class="nb">move</span>/cvg_abse0P/cvge_sub0; <span class="nb">apply</span>.
   <span class="nb">rewrite</span> fin_numElt (_ : -oo = - +oo)// -lte_absl.
   <span class="nb">case</span>: dominated_integrable =&gt; ?; <span class="nb">apply</span>: le_lt_trans.
   <span class="bp">by</span> <span class="nb">apply</span>: (le_trans _ (@le_abse_integral _ _ _ mu D f mD _)).
<span class="nb">apply</span>: (@squeeze_cvge _ _ _ _ (cst <span class="mi">0</span>) _ (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[mu]_(x <span class="kr">in</span> D) g_ n x)).
- <span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; n; <span class="nb">rewrite</span> abse_ge0//=; <span class="bp">exact</span>: h.
- <span class="bp">exact</span>: cvg_cst.
- <span class="bp">exact</span>: dominated_cvg0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">dominated_convergence_lemma</span>.
<span class="kn">Arguments</span> dominated_integrable {d T R mu D} _ f_ f g.

<span class="kn">Section</span> <span class="nf">dominated_convergence_theorem</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> T -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">mD</span> : measurable D).
<span class="kn">Variables</span> (<span class="nv">f_</span> : (T -&gt; \bar R)^nat) (<span class="nv">f</span> : T -&gt; \bar R) (<span class="nv">g</span> : T -&gt; \bar R).
<span class="kn">Hypothesis</span> <span class="nv">mf_</span> : <span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (f_ n).
<span class="kn">Hypothesis</span> <span class="nv">mf</span> : measurable_fun D f.
<span class="kn">Hypothesis</span> <span class="nv">f_f</span> : {ae mu, <span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; f_ ^~ x --&gt; f x}.
<span class="kn">Hypothesis</span> <span class="nv">ig</span> : mu.-integrable D g.
<span class="kn">Hypothesis</span> <span class="nv">f_g</span> : {ae mu, <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">n</span>, D x -&gt; `|f_ n x| &lt;= g x}.

<span class="kn">Let</span> <span class="nf">g_</span> <span class="nv">n</span> <span class="nv">x</span> := `|f_ n x - f x|.

<span class="kn">Theorem</span> <span class="nf">dominated_convergence</span> : [/\ mu.-integrable D f,
  [sequence \int[mu]_(x <span class="kr">in</span> D) (g_ n x)]_n --&gt; <span class="mi">0</span> &amp;
  [sequence \int[mu]_(x <span class="kr">in</span> D) (f_ n x)]_n --&gt; \int[mu]_(x <span class="kr">in</span> D) (f x) ].
<span class="kn">Proof</span>.
<span class="nb">have</span> [N1 [mN1 N10 subN1]] := f_f.
<span class="nb">have</span> [N2 [mN2 N20 subN2]] := f_g.
<span class="nb">have</span> [N3 [mN3 N30 subN3]] := integrable_ae mD ig.
<span class="nb">pose</span> N := N1 `|` N2 `|` N3.
<span class="nb">have</span> mN : measurable N <span class="bp">by</span> <span class="nb">apply</span>: measurableU =&gt; //; <span class="bp">exact</span>: measurableU.
<span class="nb">have</span> N0 : mu N = <span class="mi">0</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> null_set_setU// <span class="nl">?null_set_setU</span>//; <span class="bp">exact</span>: measurableU.
<span class="nb">pose</span> f&#39; := f \_ (D `\` N); <span class="nb">pose</span> g&#39; := g \_ (D `\` N).
<span class="nb">pose</span> f_&#39; := <span class="kr">fun</span> <span class="nv">n</span> =&gt; f_ n \_ (D `\` N).
<span class="nb">have</span> f_f&#39; x : D x -&gt; f_&#39; ^~ x --&gt; f&#39; x.
  <span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> /f_&#39; /f&#39; /restrict in_setD mem_set//=.
  <span class="nb">have</span> [/= xN|/= xN] := boolP (x \<span class="kr">in</span> N); <span class="kp">first</span> <span class="bp">exact</span>: cvg_cst.
  <span class="nb">apply</span>: contraPP (xN) =&gt; h; <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> negbK inE; <span class="nb">left</span>; <span class="nb">left</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: subN1 =&gt; /= /(_ Dx); <span class="bp">exact</span>: contra_not h.
<span class="nb">have</span> f_g&#39; n x : D x -&gt; `|f_&#39; n x| &lt;= g&#39; x.
  <span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> /f_&#39; /g&#39; /restrict in_setD mem_set//=.
  <span class="nb">have</span> [/=|/= xN] := boolP (x \<span class="kr">in</span> N); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> normr0.
  <span class="nb">apply</span>: contrapT =&gt; fg; <span class="nb">move</span>: xN; <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> negbK inE; <span class="nb">left</span>; <span class="nb">right</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: subN2 =&gt; /= /(_ n Dx).
<span class="nb">have</span> mu_ n : measurable_fun D (f_&#39; n).
  <span class="nb">apply</span>/(measurable_restrict (f_ n) (measurableD mD mN) _ _).<span class="mi">1</span> =&gt; //.
  <span class="bp">by</span> <span class="nb">apply</span>: measurable_funS (mf_ _) =&gt; // x [].
<span class="nb">have</span> ig&#39; : mu.-integrable D g&#39;.
  <span class="nb">apply</span>: (integrableS measurableT) =&gt; //.
  <span class="nb">apply</span>/(integrable_mkcond g (measurableD mD mN)).<span class="mi">1</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: integrableS ig =&gt; //; <span class="bp">exact</span>: measurableD.
<span class="nb">have</span> finv x : D x -&gt; g&#39; x \<span class="kr">is</span> a fin_num.
  <span class="nb">move</span>=&gt; Dx; <span class="nb">rewrite</span> /g&#39; /restrict in_setD// mem_set//=.
  <span class="nb">have</span> [//|xN /=] := boolP (x \<span class="kr">in</span> N).
  <span class="nb">apply</span>: contrapT =&gt; fing; <span class="nb">move</span>: xN; <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> negbK inE; <span class="nb">right</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: subN3 =&gt; /= /(_ Dx).
<span class="nb">split</span>.
- <span class="nb">have</span> if&#39; : mu.-integrable D f&#39; <span class="bp">by</span> <span class="bp">exact</span>: (dominated_integrable _ f_&#39; _ g&#39;).
  <span class="nb">split</span> =&gt; //.
  <span class="nb">move</span>: if&#39; =&gt; [?]; <span class="nb">apply</span>: le_lt_trans.
  <span class="nb">rewrite</span> le_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP/ae_eq_integral =&gt; //;
    [<span class="bp">exact</span>: measurable_funT_comp|<span class="bp">exact</span>: measurable_funT_comp|].
  <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> -(setCK N); <span class="nb">apply</span>: subsetC =&gt; x Nx Dx.
  <span class="bp">by</span> <span class="nb">rewrite</span> /f&#39; /restrict mem_set.
- <span class="nb">have</span> := @dominated_cvg0 _ _ _ _ _ mD _ _ _ mu_ f_f&#39; finv ig&#39; f_g&#39;.
  <span class="nb">set</span> X := (X <span class="kr">in</span> _ -&gt; X --&gt; _); <span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _ -&gt; _](_ : _ = X) //.
  <span class="nb">apply</span>/funext =&gt; n; <span class="nb">apply</span>: ae_eq_integral =&gt; //.
  + <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="nb">apply</span>: emeasurable_funB =&gt; //.
    <span class="nb">apply</span>/(measurable_restrict _ (measurableD _ _) _ _).<span class="mi">1</span> =&gt; //.
    <span class="bp">by</span> <span class="nb">apply</span>: (measurable_funS mD) =&gt; // x [].
  + <span class="bp">by</span> <span class="nb">rewrite</span> /g_; <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: emeasurable_funB.
  + <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> -(setCK N); <span class="nb">apply</span>: subsetC =&gt; x /= Nx Dx.
    <span class="bp">by</span> <span class="nb">rewrite</span> /f_&#39; /f&#39; /restrict mem_set.
- <span class="nb">have</span> := @dominated_cvg _ _ _ _ _ mD _ _ _ mu_ f_f&#39; finv ig&#39; f_g&#39;.
  <span class="nb">set</span> X := (X <span class="kr">in</span> _ -&gt; X --&gt; _); <span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _ -&gt; _](_ : _ = X) //; <span class="nb">last first</span>.
    <span class="nb">apply</span>/funext =&gt; n; <span class="nb">apply</span>: ae_eq_integral =&gt; //.
    <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> -(setCK N); <span class="nb">apply</span>: subsetC =&gt; x /= Nx Dx.
    <span class="bp">by</span> <span class="nb">rewrite</span> /f_&#39; /restrict mem_set.
  <span class="nb">set</span> Y := (X <span class="kr">in</span> _ -&gt; _ --&gt; X); <span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X -&gt; _](_ : _ = Y) //.
  <span class="nb">apply</span>: ae_eq_integral =&gt; //.
    <span class="nb">apply</span>/(measurable_restrict _ (measurableD _ _) _ _).<span class="mi">1</span> =&gt; //.
    <span class="bp">by</span> <span class="nb">apply</span>: (measurable_funS mD) =&gt; // x [].
  <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> -(setCK N); <span class="nb">apply</span>: subsetC =&gt; x /= Nx Dx.
  <span class="bp">by</span> <span class="nb">rewrite</span> /f&#39; /restrict mem_set.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">dominated_convergence_theorem</span>.

<span class="sd">(******************************************************************************)</span>
<span class="c">(* * product measure                                                          *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="kn">Section</span> <span class="nf">measurable_section</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> (T1 * T2)).

<span class="kn">Lemma</span> <span class="nf">measurable_xsection</span> <span class="nv">A</span> <span class="nv">x</span> : measurable A -&gt; measurable (xsection A x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA; <span class="nb">rewrite</span> (xsection_indic R) -(setTI (_ @^-<span class="mi">1</span>` _)).
<span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_prod1 =&gt; //; <span class="bp">exact</span>/measurable_fun_indic.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_ysection</span> <span class="nv">A</span> <span class="nv">y</span> : measurable A -&gt; measurable (ysection A y).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA; <span class="nb">rewrite</span> (ysection_indic R) -(setTI (_ @^-<span class="mi">1</span>` _)).
<span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_prod2 =&gt; //; <span class="bp">exact</span>/measurable_fun_indic.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measurable_section</span>.

<span class="kn">Section</span> <span class="nf">ndseq_closed_B</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> (T1 * T2).

<span class="kn">Section</span> <span class="nf">xsection</span>.
<span class="kn">Variables</span> (<span class="nv">pt2</span> : T2) (<span class="nv">m2</span> : {measure <span class="nb">set</span> T2 -&gt; \bar R}).
<span class="kn">Let</span> <span class="nf">phi</span> <span class="nv">A</span> := m2 \o xsection A.
<span class="kn">Let</span> <span class="nf">B</span> := [<span class="nb">set</span> A | measurable A /\ measurable_fun setT (phi A)].

<span class="kn">Lemma</span> <span class="nf">xsection_ndseq_closed</span> : ndseq_closed B.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F ndF; <span class="nb">rewrite</span> /B /= =&gt; BF; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: bigcupT_measurable =&gt; n; <span class="nb">have</span> [] := BF n.
<span class="nb">have</span> phiF x : (<span class="kr">fun</span> <span class="nv">i</span> =&gt; phi (F i) x) --&gt; phi (\bigcup_i F i) x.
  <span class="nb">rewrite</span> /phi /= xsection_bigcup; <span class="nb">apply</span>: nondecreasing_cvg_mu.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>: measurable_xsection; <span class="nb">case</span>: (BF n).
  - <span class="bp">by</span> <span class="nb">apply</span>: bigcupT_measurable =&gt; i; <span class="nb">apply</span>: measurable_xsection; <span class="nb">case</span>: (BF i).
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; m n mn; <span class="bp">exact</span>/subsetPset/le_xsection/subsetPset/ndF.
<span class="nb">apply</span>: (emeasurable_fun_cvg (phi \o F)) =&gt; //.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">have</span> [] := BF i.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="bp">exact</span>: phiF.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">xsection</span>.

<span class="kn">Section</span> <span class="nf">ysection</span>.
<span class="kn">Variable</span> <span class="nv">m1</span> : {<span class="kn">measure</span> <span class="nb">set</span> T1 -&gt; \bar R}.
<span class="kn">Let</span> <span class="nf">psi</span> <span class="nv">A</span> := m1 \o ysection A.
<span class="kn">Let</span> <span class="nf">B</span> := [<span class="nb">set</span> A | measurable A /\ measurable_fun setT (psi A)].

<span class="kn">Lemma</span> <span class="nf">ysection_ndseq_closed</span> : ndseq_closed B.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F ndF; <span class="nb">rewrite</span> /B /= =&gt; BF; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: bigcupT_measurable =&gt; n; <span class="nb">have</span> [] := BF n.
<span class="nb">have</span> psiF x : (<span class="kr">fun</span> <span class="nv">i</span> =&gt; psi (F i) x) --&gt; psi (\bigcup_i F i) x.
  <span class="nb">rewrite</span> /psi /= ysection_bigcup; <span class="nb">apply</span>: nondecreasing_cvg_mu.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>: measurable_ysection; <span class="nb">case</span>: (BF n).
  - <span class="bp">by</span> <span class="nb">apply</span>: bigcupT_measurable =&gt; i; <span class="nb">apply</span>: measurable_ysection; <span class="nb">case</span>: (BF i).
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; m n mn; <span class="bp">exact</span>/subsetPset/le_ysection/subsetPset/ndF.
<span class="nb">apply</span>: (emeasurable_fun_cvg (psi \o F)) =&gt; //.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">have</span> [] := BF i.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="bp">exact</span>: psiF.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">ysection</span>.

<span class="kn">End</span> <span class="nf">ndseq_closed_B</span>.

<span class="kn">Section</span> <span class="nf">measurable_prod_subset</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> (T1 * T2).

<span class="kn">Section</span> <span class="nf">xsection</span>.
<span class="kn">Variable</span> (<span class="nv">m2</span> : {measure <span class="nb">set</span> T2 -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T2) (<span class="nv">mD</span> : measurable D).
<span class="kn">Let</span> <span class="nf">m2D</span> := mrestr m2 mD.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Measure.on m2D.
<span class="kn">Let</span> <span class="nf">phi</span> <span class="nv">A</span> := m2D \o xsection A.
<span class="kn">Let</span> <span class="nf">B</span> := [<span class="nb">set</span> A | measurable A /\ measurable_fun setT (phi A)].

<span class="kn">Lemma</span> <span class="nf">measurable_prod_subset_xsection</span>
    (<span class="nv">m2D_bounded</span> : <span class="kr">exists</span> <span class="nv">M</span>, <span class="kr">forall</span> <span class="nv">X</span>, measurable X -&gt; (m2D X &lt; M%:E)%E) :
  measurable `&lt;=` B.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> measurable_prod_measurableType.
<span class="nb">set</span> C := [<span class="nb">set</span> A1 `*` A2 | A1 <span class="kr">in</span> measurable &amp; A2 <span class="kr">in</span> measurable].
<span class="nb">have</span> CI : setI_closed C.
  <span class="nb">move</span>=&gt; X Y [X1 mX1 [X2 mX2 &lt;-{X}]] [Y1 mY1 [Y2 mY2 &lt;-{Y}]].
  <span class="kr">exists</span> (<span class="nv">X1</span> `&amp;` Y1); <span class="kp">first</span> <span class="bp">exact</span>: measurableI.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">X2</span> `&amp;` Y2); [<span class="bp">exact</span>: measurableI|<span class="nb">rewrite</span> setMI].
<span class="nb">have</span> CT : C setT <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span> =&gt; //; <span class="kr">exists</span> <span class="nv">setT</span> =&gt; //; <span class="nb">rewrite</span> setMTT.
<span class="nb">have</span> CB : C `&lt;=` B.
  <span class="nb">move</span>=&gt; X [X1 mX1 [X2 mX2 &lt;-{X}]]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurableM.
  <span class="nb">have</span> -&gt; : phi (X1 `*` X2) = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; m2D X2 * (\<span class="mi">1_</span>X1 x)%:E)%E.
    <span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">rewrite</span> indicE /phi /m2/= /mrestr.
    <span class="nb">have</span> [xX1|xX1] := boolP (x \<span class="kr">in</span> X1); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> mule1 in_xsectionM.
    <span class="bp">by</span> <span class="nb">rewrite</span> mule0 notin_xsectionM// set0I measure0.
  <span class="bp">exact</span>/measurable_funeM/EFin_measurable_fun/measurable_fun_indic.
<span class="nb">suff</span> monoB : monotone_class setT B <span class="bp">by</span> <span class="bp">exact</span>: monotone_class_subset.
<span class="nb">split</span> =&gt; //; [<span class="bp">exact</span>: CB| |<span class="bp">exact</span>: xsection_ndseq_closed].
<span class="nb">move</span>=&gt; X Y XY [mX mphiX] [mY mphiY]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurableD.
<span class="nb">have</span> -&gt; : phi (X `\` Y) = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; phi X x - phi Y x)%E.
  <span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">rewrite</span> /phi/= xsectionD// /m2D measureD.
  - <span class="bp">by</span> <span class="nb">rewrite</span> setIidr//; <span class="bp">exact</span>: le_xsection.
  - <span class="bp">exact</span>: measurable_xsection.
  - <span class="bp">exact</span>: measurable_xsection.
  - <span class="nb">move</span>: m2D_bounded =&gt; [M m2M].
    <span class="nb">rewrite</span> (lt_le_trans (m2M (xsection X x) _))// <span class="nl">?leey</span>//.
    <span class="bp">exact</span>: measurable_xsection.
<span class="bp">exact</span>: emeasurable_funB.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">xsection</span>.

<span class="kn">Section</span> <span class="nf">ysection</span>.
<span class="kn">Variable</span> (<span class="nv">m1</span> : {measure <span class="nb">set</span> T1 -&gt; \bar R}) (<span class="nv">D</span> : <span class="nb">set</span> T1) (<span class="nv">mD</span> : measurable D).
<span class="kn">Let</span> <span class="nf">m1D</span> := mrestr m1 mD.
HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := Measure.on m1D.
<span class="kn">Let</span> <span class="nf">psi</span> <span class="nv">A</span> := m1D \o ysection A.
<span class="kn">Let</span> <span class="nf">B</span> := [<span class="nb">set</span> A | measurable A /\ measurable_fun setT (psi A)].

<span class="kn">Lemma</span> <span class="nf">measurable_prod_subset_ysection</span>
    (<span class="nv">m1_bounded</span> : <span class="kr">exists</span> <span class="nv">M</span>, <span class="kr">forall</span> <span class="nv">X</span>, measurable X -&gt; (m1D X &lt; M%:E)%E) :
  measurable `&lt;=` B.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> measurable_prod_measurableType.
<span class="nb">set</span> C := [<span class="nb">set</span> A1 `*` A2 | A1 <span class="kr">in</span> measurable &amp; A2 <span class="kr">in</span> measurable].
<span class="nb">have</span> CI : setI_closed C.
  <span class="nb">move</span>=&gt; X Y [X1 mX1 [X2 mX2 &lt;-{X}]] [Y1 mY1 [Y2 mY2 &lt;-{Y}]].
  <span class="kr">exists</span> (<span class="nv">X1</span> `&amp;` Y1); <span class="kp">first</span> <span class="bp">exact</span>: measurableI.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">X2</span> `&amp;` Y2); [<span class="bp">exact</span>: measurableI|<span class="nb">rewrite</span> setMI].
<span class="nb">have</span> CT : C setT <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span> =&gt; //; <span class="kr">exists</span> <span class="nv">setT</span> =&gt; //; <span class="nb">rewrite</span> setMTT.
<span class="nb">have</span> CB : C `&lt;=` B.
  <span class="nb">move</span>=&gt; X [X1 mX1 [X2 mX2 &lt;-{X}]]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurableM.
  <span class="nb">have</span> -&gt; : psi (X1 `*` X2) = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; m1D X1 * (\<span class="mi">1_</span>X2 x)%:E)%E.
    <span class="nb">rewrite</span> funeqE =&gt; y; <span class="nb">rewrite</span> indicE /psi /m1/= /mrestr.
    <span class="nb">have</span> [yX2|yX2] := boolP (y \<span class="kr">in</span> X2); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> mule1 in_ysectionM.
    <span class="bp">by</span> <span class="nb">rewrite</span> mule0 notin_ysectionM// set0I measure0.
  <span class="bp">exact</span>/measurable_funeM/EFin_measurable_fun/measurable_fun_indic.
<span class="nb">suff</span> monoB : monotone_class setT B <span class="bp">by</span> <span class="bp">exact</span>: monotone_class_subset.
<span class="nb">split</span> =&gt; //; [<span class="bp">exact</span>: CB| |<span class="bp">exact</span>: ysection_ndseq_closed].
<span class="nb">move</span>=&gt; X Y XY [mX mphiX] [mY mphiY]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurableD.
<span class="nb">rewrite</span> (_ : psi _ = (psi X \- psi Y)%E); <span class="kp">first</span> <span class="bp">exact</span>: emeasurable_funB.
<span class="nb">rewrite</span> funeqE =&gt; y; <span class="nb">rewrite</span> /psi/= ysectionD// /m1D measureD.
- <span class="bp">by</span> <span class="nb">rewrite</span> setIidr//; <span class="bp">exact</span>: le_ysection.
- <span class="bp">exact</span>: measurable_ysection.
- <span class="bp">exact</span>: measurable_ysection.
- <span class="nb">have</span> [M m1M] := m1_bounded.
  <span class="nb">rewrite</span> (lt_le_trans (m1M (ysection X y) _))// <span class="nl">?leey</span>//.
  <span class="bp">exact</span>: measurable_ysection.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ysection</span>.

<span class="kn">End</span> <span class="nf">measurable_prod_subset</span>.

<span class="kn">Section</span> <span class="nf">measurable_fun_xsection</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m2</span> : {sigma_finite_measure <span class="nb">set</span> T2 -&gt; \bar R}.
<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> (T1 * T2).

<span class="kn">Let</span> <span class="nf">phi</span> <span class="nv">A</span> := m2 \o xsection A.
<span class="kn">Let</span> <span class="nf">B</span> := [<span class="nb">set</span> A | measurable A /\ measurable_fun setT (phi A)].

<span class="kn">Lemma</span> <span class="nf">measurable_fun_xsection</span> <span class="nv">A</span> : measurable A -&gt; measurable_fun setT (phi A).
<span class="kn">Proof</span>.
<span class="nb">move</span>: A; <span class="nb">suff</span> : measurable `&lt;=` B <span class="bp">by</span> <span class="nb">move</span>=&gt; + A =&gt; /[<span class="nb">apply</span>] -[].
<span class="nb">have</span> /sigma_finiteP [F F_T [F_nd F_oo]] := sigma_finiteT m2 =&gt; X mX.
<span class="nb">have</span> -&gt; : X = \bigcup_n (X `&amp;` (setT `*` F n)).
  <span class="bp">by</span> <span class="nb">rewrite</span> -setI_bigcupr -setM_bigcupr -F_T setMTT setIT.
<span class="nb">apply</span>: xsection_ndseq_closed.
  <span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>/subsetPset; <span class="nb">apply</span>: setIS; <span class="nb">apply</span>: setSM =&gt; //.
  <span class="bp">exact</span>/subsetPset/F_nd.
<span class="nb">move</span>=&gt; n; <span class="nb">rewrite</span> -/B; <span class="nb">have</span> [? ?] := F_oo n.
<span class="nb">pose</span> m2Fn := [the <span class="kn">measure</span> _ _ of mrestr m2 (F_oo n).<span class="mi">1</span>].
<span class="nb">have</span> m2Fn_bounded : <span class="kr">exists</span> <span class="nv">M</span>, <span class="kr">forall</span> <span class="nv">X</span>, measurable X -&gt; (m2Fn X &lt; M%:E)%E.
  <span class="kr">exists</span> (<span class="nv">fine</span> (m2Fn (F n)) + <span class="mi">1</span>) =&gt; Y mY.
  <span class="nb">rewrite</span> [<span class="kr">in</span> ltRHS]EFinD lte_spadder// fineK; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE <span class="nl">?measure_ge0</span>//= /mrestr/= setIid.
  <span class="nb">rewrite</span> /= /mrestr/= setIid; <span class="nb">apply</span>: le_measure =&gt; //; <span class="nb">rewrite</span> inE//.
  <span class="bp">exact</span>: measurableI.
<span class="nb">pose</span> phi&#39; A := m2Fn \o xsection A.
<span class="nb">pose</span> B&#39; := [<span class="nb">set</span> A | measurable A /\ measurable_fun setT (phi&#39; A)].
<span class="nb">have</span> subset_B&#39; : measurable `&lt;=` B&#39; <span class="bp">by</span> <span class="bp">exact</span>: measurable_prod_subset_xsection.
<span class="nb">split</span>=&gt; [|_ Y mY]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: measurableI =&gt; //; <span class="bp">exact</span>: measurableM.
<span class="nb">have</span> [_ /(_ measurableT Y mY)] := subset_B&#39; X mX.
<span class="nb">have</span> -&gt;// : phi&#39; X = m2 \o xsection (X `&amp;` setT `*` F n).
<span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; x/=; <span class="nb">rewrite</span> /phi&#39; setTM xsectionI xsection_preimage_snd.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measurable_fun_xsection</span>.

<span class="kn">Section</span> <span class="nf">measurable_fun_ysection</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m1</span> : {sigma_finite_measure <span class="nb">set</span> T1 -&gt; \bar R}.
<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> (T1 * T2).

<span class="kn">Let</span> <span class="nf">phi</span> <span class="nv">A</span> := m1 \o ysection A.
<span class="kn">Let</span> <span class="nf">B</span> := [<span class="nb">set</span> A | measurable A /\ measurable_fun setT (phi A)].

<span class="kn">Lemma</span> <span class="nf">measurable_fun_ysection</span> <span class="nv">A</span> : measurable A -&gt; measurable_fun setT (phi A).
<span class="kn">Proof</span>.
<span class="nb">move</span>: A; <span class="nb">suff</span> : measurable `&lt;=` B <span class="bp">by</span> <span class="nb">move</span>=&gt; + A =&gt; /[<span class="nb">apply</span>] -[].
<span class="nb">have</span> /sigma_finiteP[F F_T [F_nd F_oo]] := sigma_finiteT m1 =&gt; X mX.
<span class="nb">have</span> -&gt; : X = \bigcup_n (X `&amp;` (F n `*` setT)).
  <span class="bp">by</span> <span class="nb">rewrite</span> -setI_bigcupr -setM_bigcupl -F_T setMTT setIT.
<span class="nb">apply</span>: ysection_ndseq_closed.
  <span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>/subsetPset; <span class="nb">apply</span>: setIS; <span class="nb">apply</span>: setSM =&gt; //.
  <span class="bp">exact</span>/subsetPset/F_nd.
<span class="nb">move</span>=&gt; n; <span class="nb">have</span> [? ?] := F_oo n; <span class="nb">rewrite</span> -/B.
<span class="nb">pose</span> m1Fn := [the <span class="kn">measure</span> _ _ of mrestr m1 (F_oo n).<span class="mi">1</span>].
<span class="nb">have</span> m1Fn_bounded : <span class="kr">exists</span> <span class="nv">M</span>, <span class="kr">forall</span> <span class="nv">X</span>, measurable X -&gt; (m1Fn X &lt; M%:E)%E.
  <span class="kr">exists</span> (<span class="nv">fine</span> (m1Fn (F n)) + <span class="mi">1</span>) =&gt; Y mY.
  <span class="nb">rewrite</span> [<span class="kr">in</span> ltRHS]EFinD lte_spadder// fineK; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ge0_fin_numE <span class="nl">?measure_ge0</span>// /m1Fn/= /mrestr setIid.
  <span class="nb">rewrite</span> /m1Fn/= /mrestr setIid; <span class="nb">apply</span>: le_measure =&gt; //; <span class="nb">rewrite</span> inE//=.
  <span class="bp">exact</span>: measurableI.
<span class="nb">pose</span> psi&#39; A := m1Fn \o ysection A.
<span class="nb">pose</span> B&#39; := [<span class="nb">set</span> A | measurable A /\ measurable_fun setT (psi&#39; A)].
<span class="nb">have</span> subset_B&#39; : measurable `&lt;=` B&#39; <span class="bp">by</span> <span class="bp">exact</span>: measurable_prod_subset_ysection.
<span class="nb">split</span>=&gt; [|_ Y mY]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: measurableI =&gt; //; <span class="bp">exact</span>: measurableM.
<span class="nb">have</span> [_ /(_ measurableT Y mY)] := subset_B&#39; X mX.
<span class="nb">have</span> -&gt;// : psi&#39; X = m1 \o (ysection (X `&amp;` F n `*` setT)).
<span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; y/=; <span class="nb">rewrite</span> /psi&#39; setMT ysectionI// ysection_preimage_fst.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measurable_fun_ysection</span>.

<span class="kn">Section</span> <span class="nf">product_measures</span>.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Context</span> (<span class="nv">m1</span> : {measure <span class="nb">set</span> T1 -&gt; \bar R}) (<span class="nv">m2</span> : {measure <span class="nb">set</span> T2 -&gt; \bar R}).

<span class="kn">Definition</span> <span class="nf">product_measure1</span> := (<span class="kr">fun</span> <span class="nv">A</span> =&gt; \int[m1]_x (m2 \o xsection A) x)%E.
<span class="kn">Definition</span> <span class="nf">product_measure2</span> := (<span class="kr">fun</span> <span class="nv">A</span> =&gt; \int[m2]_x (m1 \o ysection A) x)%E.

<span class="kn">End</span> <span class="nf">product_measures</span>.

<span class="kn">Notation</span> <span class="s2">&quot;m1 &#39;\x&#39; m2&quot;</span> := (product_measure1 m1 m2) : ereal_scope.
<span class="kn">Notation</span> <span class="s2">&quot;m1 &#39;\x^&#39; m2&quot;</span> := (product_measure2 m1 m2) : ereal_scope.

<span class="kn">Section</span> <span class="nf">product_measure1</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m1</span> : {<span class="kn">measure</span> <span class="nb">set</span> T1 -&gt; \bar R}.
<span class="kn">Variable</span> <span class="nv">m2</span> : {sigma_finite_measure <span class="nb">set</span> T2 -&gt; \bar R}.
<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> (T1 * T2).

<span class="kn">Let</span> <span class="nf">pm10</span> : (m1 \x m2) set0 = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> [LHS]integral0_eq// =&gt; x/= _; <span class="nb">rewrite</span> xsection0 measure0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">pm1_ge0</span> <span class="nv">A</span> : <span class="mi">0</span> &lt;= (m1 \x m2) A.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>: integral_ge0 =&gt; // *; <span class="bp">exact</span>/measure_ge0/measurable_xsection.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">pm1_sigma_additive</span> : semi_sigma_additive (m1 \x m2).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mUF.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ = \sum_(n &lt;oo) (m1 \x m2) (F n)).
  <span class="nb">apply</span>/cvg_closeP; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> closeE.
  <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_nneseries =&gt; *; <span class="bp">exact</span>: integral_ge0.
<span class="nb">rewrite</span> -integral_nneseries//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>: measurable_fun_xsection.
<span class="nb">apply</span>: eq_integral =&gt; x _; <span class="nb">apply</span>/esym/cvg_lim =&gt; //=; <span class="nb">rewrite</span> xsection_bigcup.
<span class="nb">apply</span>: (measure_sigma_additive _ (trivIset_xsection tF)) =&gt; ?.
<span class="bp">exact</span>: measurable_xsection.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ (m1 \x m2)
  pm10 pm1_ge0 pm1_sigma_additive.

<span class="kn">End</span> <span class="nf">product_measure1</span>.

<span class="kn">Section</span> <span class="nf">product_measure1E</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m1</span> : {<span class="kn">measure</span> <span class="nb">set</span> T1 -&gt; \bar R}.
<span class="kn">Variable</span> <span class="nv">m2</span> : {sigma_finite_measure <span class="nb">set</span> T2 -&gt; \bar R}.
<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> (T1 * T2).

<span class="kn">Lemma</span> <span class="nf">product_measure1E</span> (<span class="nv">A1</span> : <span class="nb">set</span> T1) (<span class="nv">A2</span> : <span class="nb">set</span> T2) :
  measurable A1 -&gt; measurable A2 -&gt; (m1 \x m2) (A1 `*` A2) = m1 A1 * m2 A2.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mA1 mA2 /=; <span class="nb">rewrite</span> /product_measure1 /=.
<span class="nb">rewrite</span> (eq_integral (<span class="kr">fun</span> <span class="nv">x</span> =&gt; m2 A2 * (\<span class="mi">1_</span>A1 x)%:E)); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> indicE; <span class="nb">have</span> [xA1|xA1] /= := boolP (x \<span class="kr">in</span> A1);
    [<span class="nb">rewrite</span> in_xsectionM// mule1|<span class="nb">rewrite</span> mule0 notin_xsectionM].
<span class="nb">rewrite</span> ge0_integralM//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> lee_fin.
- <span class="bp">by</span> <span class="nb">rewrite</span> muleC integral_indic// setIT.
- <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>/measurable_fun_indic.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">product_measure1E</span>.

<span class="kn">Section</span> <span class="nf">product_measure_unique</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m1</span> : {sigma_finite_measure <span class="nb">set</span> T1 -&gt; \bar R}.
<span class="kn">Variable</span> <span class="nv">m2</span> : {sigma_finite_measure <span class="nb">set</span> T2 -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">product_measure_unique</span>
    (<span class="nv">m&#39;</span> : {measure <span class="nb">set</span> [the semiRingOfSetsType _ of (T1 * T2)%type] -&gt; \bar R}) :
    (<span class="kr">forall</span> <span class="nv">A1</span> <span class="nv">A2</span>, measurable A1 -&gt; measurable A2 -&gt;
      m&#39; (A1 `*` A2) = m1 A1 * m2 A2) -&gt;
  <span class="kr">forall</span> <span class="nv">X</span> : <span class="nb">set</span> (T1 * T2), measurable X -&gt; (m1 \x m2) X = m&#39; X.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; m&#39;E; <span class="nb">pose</span> m := product_measure1 m1 m2.
<span class="nb">have</span> /sigma_finiteP [F1 F1_T [F1_nd F1_oo]] := sigma_finiteT m1.
<span class="nb">have</span> /sigma_finiteP [F2 F2_T [F2_nd F2_oo]] := sigma_finiteT m2.
<span class="nb">have</span> UF12T : \bigcup_k (F1 k `*` F2 k) = setT.
  <span class="nb">rewrite</span> -setMTT F1_T F2_T predeqE =&gt; -[x y]; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; [n _ []/= ? ?]; <span class="nb">split</span>; <span class="kr">exists</span> <span class="nv">n</span>.
  <span class="nb">move</span>=&gt; [/= [n _ F1nx] [k _ F2ky]]; <span class="kr">exists</span> (<span class="nv">maxn</span> <span class="nv">n</span> <span class="nv">k</span>) =&gt; //; <span class="nb">split</span>.
  - <span class="bp">by</span> <span class="nb">move</span>: x F1nx; <span class="nb">apply</span>/subsetPset/F1_nd; <span class="nb">rewrite</span> leq_maxl.
  - <span class="bp">by</span> <span class="nb">move</span>: y F2ky; <span class="nb">apply</span>/subsetPset/F2_nd; <span class="nb">rewrite</span> leq_maxr.
<span class="nb">have</span> mF1F2 n : measurable (F1 n `*` F2 n) /\ m (F1 n `*` F2 n) &lt; +oo.
  <span class="nb">have</span> [? ?] := F1_oo n; <span class="nb">have</span> [? ?] := F2_oo n.
  <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurableM.
  <span class="bp">by</span> <span class="nb">rewrite</span> /m product_measure1E // lte_mul_pinfty// ge0_fin_numE.
<span class="nb">have</span> sm : sigma_finite setT m <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">n</span> =&gt; F1 n `*` F2 n).
<span class="nb">pose</span> C : <span class="nb">set</span> (<span class="nb">set</span> (T1 * T2)) := [<span class="nb">set</span> C |
  <span class="kr">exists</span> <span class="nv">A1</span>, measurable A1 /\ <span class="kr">exists</span> <span class="nv">A2</span>, measurable A2 /\ C = A1 `*` A2].
<span class="nb">have</span> CI : setI_closed C.
  <span class="nb">move</span>=&gt; /= _ _ [X1 [mX1 [X2 [mX2 -&gt;]]]] [Y1 [mY1 [Y2 [mY2 -&gt;]]]].
  <span class="nb">rewrite</span> -setMI; <span class="kr">exists</span> (<span class="nv">X1</span> `&amp;` Y1); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurableI.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">X2</span> `&amp;` Y2); <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: measurableI.
<span class="nb">move</span>=&gt; X mX; <span class="nb">apply</span>: (measure_unique C (<span class="kr">fun</span> <span class="nv">n</span> =&gt; F1 n `*` F2 n)) =&gt; //.
- <span class="nb">rewrite</span> measurable_prod_measurableType //; <span class="nb">congr</span> (&lt;&lt;s _ &gt;&gt;).
  <span class="nb">rewrite</span> predeqE; <span class="nb">split</span> =&gt; [[A1 mA1 [A2 mA2 &lt;-]]|[A1 [mA1 [A2 [mA2 -&gt;]]]]].
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A1</span>; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">A2</span>; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A1</span> =&gt; //; <span class="kr">exists</span> <span class="nv">A2</span>.
- <span class="nb">move</span>=&gt; n; <span class="nb">rewrite</span> /C /=; <span class="kr">exists</span> (<span class="nv">F1</span> <span class="nv">n</span>); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">have</span> [] := F1_oo n.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">F2</span> <span class="nv">n</span>); <span class="nb">split</span> =&gt; //; <span class="nb">have</span> [] := F2_oo n.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; A [A1 [mA1 [A2 [mA2 -&gt;]]]]; <span class="nb">rewrite</span> m&#39;E//= product_measure1E.
- <span class="nb">move</span>=&gt; k; <span class="nb">have</span> [? ?] := F1_oo k; <span class="nb">have</span> [? ?] := F2_oo k.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= product_measure1E// lte_mul_pinfty// ge0_fin_numE.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">product_measure_unique</span>.

<span class="kn">Section</span> <span class="nf">product_measure2</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m1</span> : {sigma_finite_measure <span class="nb">set</span> T1 -&gt; \bar R}.
<span class="kn">Variable</span> <span class="nv">m2</span> : {<span class="kn">measure</span> <span class="nb">set</span> T2 -&gt; \bar R}.
<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> (T1 * T2).

<span class="kn">Let</span> <span class="nf">pm20</span> : (m1 \x^ m2) set0 = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> /(_ \x^ _) integral0_eq// =&gt; y/= _; <span class="nb">rewrite</span> ysection0 measure0.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">pm2_ge0</span> <span class="nv">A</span> : <span class="mi">0</span> &lt;= (m1 \x^ m2) A.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>: integral_ge0 =&gt; // *; <span class="bp">exact</span>/measure_ge0/measurable_ysection.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">pm2_sigma_additive</span> : semi_sigma_additive (m1 \x^ m2).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F mF tF mUF.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ = \sum_(n &lt;oo) (m1 \x^ m2) (F n)).
  <span class="nb">apply</span>/cvg_closeP; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> closeE.
  <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_nneseries =&gt; *; <span class="bp">exact</span>: integral_ge0.
<span class="nb">rewrite</span> -integral_nneseries//; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>: measurable_fun_ysection =&gt; //; <span class="nb">rewrite</span> inE.
<span class="nb">apply</span>: eq_integral =&gt; y _; <span class="nb">apply</span>/esym/cvg_lim =&gt; //=; <span class="nb">rewrite</span> ysection_bigcup.
<span class="nb">apply</span>: (measure_sigma_additive _ (trivIset_ysection tF)) =&gt; ?.
<span class="bp">exact</span>: measurable_ysection.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ (m1 \x^ m2)
  pm20 pm2_ge0 pm2_sigma_additive.

<span class="kn">End</span> <span class="nf">product_measure2</span>.

<span class="kn">Section</span> <span class="nf">product_measure2E</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m1</span> : {sigma_finite_measure <span class="nb">set</span> T1 -&gt; \bar R}.
<span class="kn">Variable</span> <span class="nv">m2</span> : {<span class="kn">measure</span> <span class="nb">set</span> T2 -&gt; \bar R}.

<span class="kn">Lemma</span> <span class="nf">product_measure2E</span> (<span class="nv">A1</span> : <span class="nb">set</span> T1) (<span class="nv">A2</span> : <span class="nb">set</span> T2)
    (<span class="nv">mA1</span> : measurable A1) (<span class="nv">mA2</span> : measurable A2) :
  (m1 \x^ m2) (A1 `*` A2) = m1 A1 * m2 A2.
<span class="kn">Proof</span>.
<span class="nb">have</span> mA1A2 : measurable (A1 `*` A2) <span class="bp">by</span> <span class="nb">apply</span>: measurableM.
<span class="nb">transitivity</span> (\int[m2]_y (m1 \o ysection (A1 `*` A2)) y) =&gt; //.
<span class="nb">rewrite</span> (_ : _ \o _ = <span class="kr">fun</span> <span class="nv">y</span> =&gt; m1 A1 * (\<span class="mi">1_</span>A2 y)%:E).
  <span class="nb">rewrite</span> ge0_integralM//; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>/measurable_fun_indic.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; y _; <span class="nb">rewrite</span> lee_fin.
  <span class="bp">by</span> <span class="nb">rewrite</span> integral_indic <span class="nl">?setIT</span> <span class="nl">?mul1e</span>.
<span class="nb">rewrite</span> funeqE =&gt; y; <span class="nb">rewrite</span> indicE.
<span class="nb">have</span> [yA2|yA2] := boolP (y \<span class="kr">in</span> A2); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> mule1 /= in_ysectionM.
<span class="bp">by</span> <span class="nb">rewrite</span> mule0 /= notin_ysectionM.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">product_measure2E</span>.

<span class="kn">Section</span> <span class="nf">fubini_functions</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">m1</span> : {measure <span class="nb">set</span> T1 -&gt; \bar R}) (<span class="nv">m2</span> : {measure <span class="nb">set</span> T2 -&gt; \bar R}).
<span class="kn">Variable</span> <span class="nv">f</span> : T1 * T2 -&gt; \bar R.

<span class="kn">Definition</span> <span class="nf">fubini_F</span> <span class="nv">x</span> := \int[m2]_y f (x, y).
<span class="kn">Definition</span> <span class="nf">fubini_G</span> <span class="nv">y</span> := \int[m1]_x f (x, y).

<span class="kn">End</span> <span class="nf">fubini_functions</span>.

<span class="kn">Section</span> <span class="nf">fubini_tonelli</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m1</span> : {sigma_finite_measure <span class="nb">set</span> T1 -&gt; \bar R}.
<span class="kn">Variable</span> <span class="nv">m2</span> : {sigma_finite_measure <span class="nb">set</span> T2 -&gt; \bar R}.

<span class="kn">Section</span> <span class="nf">indic_fubini_tonelli</span>.
<span class="kn">Variables</span> (<span class="nv">A</span> : <span class="nb">set</span> (T1 * T2)) (<span class="nv">mA</span> : measurable A).
<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> (T1 * T2).
<span class="kn">Let</span> <span class="nf">f</span> : (T1 * T2) -&gt; R := \<span class="mi">1_</span>A.

<span class="kn">Let</span> <span class="nf">F</span> := fubini_F m2 (EFin \o f).
<span class="kn">Let</span> <span class="nf">G</span> := fubini_G m1 (EFin \o f).

<span class="kn">Lemma</span> <span class="nf">indic_fubini_tonelli_F_ge0</span> <span class="nv">x</span> : <span class="mi">0</span> &lt;= F x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: integral_ge0 =&gt; // y _; <span class="nb">rewrite</span> lee_fin. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">indic_fubini_tonelli_G_ge0</span> <span class="nv">x</span> : <span class="mi">0</span> &lt;= G x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: integral_ge0 =&gt; // y _; <span class="nb">rewrite</span> lee_fin. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">indic_fubini_tonelli_FE</span> : F = m2 \o xsection A.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">rewrite</span> /= -(setTI (xsection _ _)).
<span class="nb">rewrite</span> -integral_indic//; <span class="nb">last</span> <span class="bp">exact</span>: measurable_xsection.
<span class="nb">rewrite</span> /F /fubini_F -(setTI (xsection _ _)).
<span class="nb">rewrite</span> integral_setI_indic; [|<span class="bp">exact</span>: measurable_xsection|<span class="bp">by</span> []].
<span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; y _ /=; <span class="nb">rewrite</span> indicT mul1e /f !indicE mem_xsection.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">indic_fubini_tonelli_GE</span> : G = m1 \o ysection A.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; y; <span class="nb">rewrite</span> /= -(setTI (ysection _ _)).
<span class="nb">rewrite</span> -integral_indic//; <span class="nb">last</span> <span class="bp">exact</span>: measurable_ysection.
<span class="nb">rewrite</span> /F /fubini_F -(setTI (ysection _ _)).
<span class="nb">rewrite</span> integral_setI_indic; [|<span class="bp">exact</span>: measurable_ysection|<span class="bp">by</span> []].
<span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; x _ /=; <span class="nb">rewrite</span> indicT mul1e /f <span class="mi">2</span>!indicE mem_ysection.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">indic_measurable_fun_fubini_tonelli_F</span> : measurable_fun setT F.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> indic_fubini_tonelli_FE//; <span class="bp">exact</span>: measurable_fun_xsection.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">indic_measurable_fun_fubini_tonelli_G</span> : measurable_fun setT G.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> indic_fubini_tonelli_GE//; <span class="bp">exact</span>: measurable_fun_ysection.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">indic_fubini_tonelli1</span> : \int[m1 \x m2]_z (f z)%:E = \int[m1]_x F x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /f integral_indic// setIT indic_fubini_tonelli_FE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">indic_fubini_tonelli2</span> : \int[m1 \x^ m2]_z (f z)%:E = \int[m2]_y G y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /f integral_indic// setIT indic_fubini_tonelli_GE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">indic_fubini_tonelli</span> : \int[m1]_x F x = \int[m2]_y G y.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -indic_fubini_tonelli1// -indic_fubini_tonelli2// integral_indic//=.
<span class="nb">rewrite</span> integral_indic//= !setIT.
<span class="bp">by</span> <span class="nb">apply</span>: product_measure_unique =&gt; //= ? ? ? ?; <span class="nb">rewrite</span> product_measure2E.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">indic_fubini_tonelli</span>.

<span class="kn">Section</span> <span class="nf">sfun_fubini_tonelli</span>.
<span class="kn">Variable</span> <span class="nv">f</span> : {nnsfun [the measurableType _ of T1 * T2 : <span class="kt">Type</span>] &gt;-&gt; R}.

<span class="kn">Let</span> <span class="nf">F</span> := fubini_F m2 (EFin \o f).
<span class="kn">Let</span> <span class="nf">G</span> := fubini_G m1 (EFin \o f).

<span class="kn">Lemma</span> <span class="nf">sfun_fubini_tonelli_FE</span> : F = <span class="kr">fun</span> <span class="nv">x</span> =&gt;
  \sum_(k \<span class="kr">in</span> range f) k%:E * m2 (xsection (f @^-<span class="mi">1</span>` [<span class="nb">set</span> k]) x).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">rewrite</span> /F /fubini_F [<span class="kr">in</span> LHS]/=.
<span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> fimfunE -fsumEFin//.
<span class="nb">rewrite</span> ge0_integral_fsum //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; i; <span class="nb">apply</span>/EFin_measurable_fun =&gt; //; <span class="nb">apply</span>: measurable_funrM =&gt; //.
    <span class="bp">exact</span>/measurable_fun_prod1/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; r y _; <span class="nb">rewrite</span> EFinM nnfun_muleindic_ge0.
<span class="nb">apply</span>: eq_fsbigr =&gt; i; <span class="nb">rewrite</span> inE =&gt; -[/= t _ &lt;-{i}].
<span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> EFinM.
<span class="nb">rewrite</span> ge0_integralM//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin.
- <span class="bp">by</span> <span class="nb">rewrite</span> -/((m2 \o xsection _) x) -indic_fubini_tonelli_FE.
- <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_prod1/measurable_fun_indic.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; y _; <span class="nb">rewrite</span> lee_fin.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sfun_measurable_fun_fubini_tonelli_F</span> : measurable_fun setT F.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> sfun_fubini_tonelli_FE//; <span class="nb">apply</span>: emeasurable_fun_fsum =&gt; // r.
<span class="bp">exact</span>/measurable_funeM/measurable_fun_xsection.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sfun_fubini_tonelli_GE</span> : G = <span class="kr">fun</span> <span class="nv">y</span> =&gt;
  \sum_(k \<span class="kr">in</span> range f) k%:E * m1 (ysection (f @^-<span class="mi">1</span>` [<span class="nb">set</span> k]) y).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; y; <span class="nb">rewrite</span> /G /fubini_G [<span class="kr">in</span> LHS]/=.
<span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> fimfunE -fsumEFin//.
<span class="nb">rewrite</span> ge0_integral_fsum //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; i; <span class="nb">apply</span>/EFin_measurable_fun =&gt; //; <span class="nb">apply</span>: measurable_funrM =&gt; //.
    <span class="bp">exact</span>/measurable_fun_prod2/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; r x _; <span class="nb">rewrite</span> EFinM nnfun_muleindic_ge0.
<span class="nb">apply</span>: eq_fsbigr =&gt; i; <span class="nb">rewrite</span> inE =&gt; -[/= t _ &lt;-{i}].
<span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> EFinM.
<span class="nb">rewrite</span> ge0_integralM//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin.
- <span class="bp">by</span> <span class="nb">rewrite</span> -/((m1 \o ysection _) y) -indic_fubini_tonelli_GE.
- <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_prod2/measurable_fun_indic.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> lee_fin.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sfun_measurable_fun_fubini_tonelli_G</span> : measurable_fun setT G.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> sfun_fubini_tonelli_GE//; <span class="nb">apply</span>: emeasurable_fun_fsum =&gt; // r.
<span class="bp">exact</span>/measurable_funeM/measurable_fun_ysection.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">EFinf</span> <span class="nv">x</span> : (f x)%:E =
  \sum_(k \<span class="kr">in</span> range f) k%:E * (\<span class="mi">1_</span>(f @^-<span class="mi">1</span>` [<span class="nb">set</span> k]) x)%:E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> fsumEFin //= fimfunE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sfun_fubini_tonelli1</span> : \int[m1 \x m2]_z (f z)%:E = \int[m1]_x F x.
<span class="kn">Proof</span>.
<span class="nb">under</span> [LHS]eq_integral
  <span class="kp">do</span> <span class="nb">rewrite</span> EFinf; <span class="nb">rewrite</span> ge0_integral_fsum //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; r.
    <span class="bp">exact</span>/EFin_measurable_fun/measurable_funrM/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; r /= z _; <span class="bp">exact</span>: nnfun_muleindic_ge0.
<span class="nb">transitivity</span> (\sum_(k \<span class="kr">in</span> range f)
  \int[m1]_x (k%:E * (fubini_F m2 (EFin \o \<span class="mi">1_</span>(f @^-<span class="mi">1</span>` [<span class="nb">set</span> k])) x))).
  <span class="nb">apply</span>: eq_fsbigr =&gt; i; <span class="nb">rewrite</span> inE =&gt; -[z _ &lt;-{i}].
  <span class="nb">rewrite</span> ge0_integralM//; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
    - <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_indic.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; /= x _; <span class="nb">rewrite</span> lee_fin.
    - <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin.
  <span class="nb">rewrite</span> indic_fubini_tonelli1// -ge0_integralM//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin.
  - <span class="bp">exact</span>: indic_measurable_fun_fubini_tonelli_F.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; /= x _; <span class="bp">exact</span>: indic_fubini_tonelli_F_ge0.
<span class="nb">rewrite</span> -ge0_integral_fsum //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; r; <span class="nb">apply</span>/measurable_funeM/indic_measurable_fun_fubini_tonelli_F.
  - <span class="nb">move</span>=&gt; r x _; <span class="nb">rewrite</span> /fubini_F.
    <span class="nb">have</span> [r0|r0] := leP <span class="mi">0</span>%R r.
      <span class="bp">by</span> <span class="nb">rewrite</span> mule_ge0//; <span class="bp">exact</span>: indic_fubini_tonelli_F_ge0.
    <span class="bp">by</span> <span class="nb">rewrite</span> integral0_eq// =&gt; y _; <span class="nb">rewrite</span> preimage_nnfun0//= indicE in_set0.
<span class="nb">apply</span>: eq_integral =&gt; x _; <span class="nb">rewrite</span> sfun_fubini_tonelli_FE.
<span class="bp">by</span> <span class="nb">under</span> eq_fsbigr <span class="kp">do</span> <span class="nb">rewrite</span> indic_fubini_tonelli_FE//.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sfun_fubini_tonelli2</span> : \int[m1 \x^ m2]_z (f z)%:E = \int[m2]_y G y.
<span class="kn">Proof</span>.
<span class="nb">under</span> [LHS]eq_integral
  <span class="kp">do</span> <span class="nb">rewrite</span> EFinf; <span class="nb">rewrite</span> ge0_integral_fsum //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="nb">move</span>=&gt; i.
    <span class="bp">exact</span>/EFin_measurable_fun/measurable_funrM/measurable_fun_indic.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; r /= z _; <span class="bp">exact</span>: nnfun_muleindic_ge0.
<span class="nb">transitivity</span> (\sum_(k \<span class="kr">in</span> range f)
  \int[m2]_x (k%:E * (fubini_G m1 (EFin \o \<span class="mi">1_</span>(f @^-<span class="mi">1</span>` [<span class="nb">set</span> k])) x))).
  <span class="nb">apply</span>: eq_fsbigr =&gt; i; <span class="nb">rewrite</span> inE =&gt; -[z _ &lt;-{i}].
  <span class="nb">rewrite</span> ge0_integralM//; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
    - <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_indic.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; /= x _; <span class="nb">rewrite</span> lee_fin.
    - <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin.
  <span class="nb">rewrite</span> indic_fubini_tonelli2// -ge0_integralM//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin.
  - <span class="bp">exact</span>: indic_measurable_fun_fubini_tonelli_G.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; /= x _; <span class="bp">exact</span>: indic_fubini_tonelli_G_ge0.
<span class="nb">rewrite</span> -ge0_integral_fsum //; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; r; <span class="nb">apply</span>/measurable_funeM/indic_measurable_fun_fubini_tonelli_G.
  - <span class="nb">move</span>=&gt; r y _; <span class="nb">rewrite</span> /fubini_G.
    <span class="nb">have</span> [r0|r0] := leP <span class="mi">0</span>%R r.
      <span class="bp">by</span> <span class="nb">rewrite</span> mule_ge0//; <span class="bp">exact</span>: indic_fubini_tonelli_G_ge0.
    <span class="bp">by</span> <span class="nb">rewrite</span> integral0_eq// =&gt; x _; <span class="nb">rewrite</span> preimage_nnfun0//= indicE in_set0.
<span class="nb">apply</span>: eq_integral =&gt; x _; <span class="nb">rewrite</span> sfun_fubini_tonelli_GE.
<span class="bp">by</span> <span class="nb">under</span> eq_fsbigr <span class="kp">do</span> <span class="nb">rewrite</span> indic_fubini_tonelli_GE//.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sfun_fubini_tonelli</span> :
  \int[m1 \x m2]_z (f z)%:E = \int[m1 \x^ m2]_z (f z)%:E.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: eq_measure_integral =&gt; /= A Ameasurable _.
<span class="bp">by</span> <span class="nb">apply</span>: product_measure_unique =&gt; //= *; <span class="nb">rewrite</span> product_measure2E.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sfun_fubini_tonelli</span>.

<span class="kn">Section</span> <span class="nf">fubini_tonelli</span>.
<span class="kn">Variable</span> <span class="nv">f</span> : T1 * T2 -&gt; \bar R.
<span class="kn">Hypothesis</span> <span class="nv">mf</span> : measurable_fun setT f.
<span class="kn">Hypothesis</span> <span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= f x.
<span class="kn">Let</span> <span class="nf">T</span> := [the measurableType _ of T1 * T2 : <span class="kt">Type</span>].

<span class="kn">Let</span> <span class="nf">F</span> := fubini_F m2 f.
<span class="kn">Let</span> <span class="nf">G</span> := fubini_G m1 f.

<span class="kn">Let</span> <span class="nf">F_</span> (<span class="nv">g</span> : {nnsfun T &gt;-&gt; R}^nat) <span class="nv">n</span> <span class="nv">x</span> := \int[m2]_y (g n (x, y))%:E.
<span class="kn">Let</span> <span class="nf">G_</span> (<span class="nv">g</span> : {nnsfun T &gt;-&gt; R}^nat) <span class="nv">n</span> <span class="nv">y</span> := \int[m1]_x (g n (x, y))%:E.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_fubini_tonelli_F</span> : measurable_fun setT F.
<span class="kn">Proof</span>.
<span class="nb">have</span> [g [g_nd /= g_f]] := approximation measurableT mf (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; f0 x).
<span class="nb">apply</span>: (emeasurable_fun_cvg (F_ g)) =&gt; //.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>: sfun_measurable_fun_fubini_tonelli_F.
- <span class="nb">move</span>=&gt; x _.
  <span class="nb">rewrite</span> /F_ /F /fubini_F [<span class="kr">in</span> X <span class="kr">in</span> _ --&gt; X](_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) =
      <span class="kr">fun</span> <span class="nv">y</span> =&gt; lim (EFin \o g ^~ (x, y))); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; y; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: g_f.
  <span class="nb">apply</span>: cvg_monotone_convergence =&gt; //.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>/EFin_measurable_fun =&gt; //; <span class="bp">exact</span>/measurable_fun_prod1.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n y _; <span class="nb">rewrite</span> lee_fin//; <span class="bp">exact</span>: fun_ge0.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; y _ a b ab; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>/lefP/g_nd.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_fubini_tonelli_G</span> : measurable_fun setT G.
<span class="kn">Proof</span>.
<span class="nb">have</span> [g [g_nd /= g_f]] := approximation measurableT mf (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; f0 x).
<span class="nb">apply</span>: (emeasurable_fun_cvg (G_ g)) =&gt; //.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>: sfun_measurable_fun_fubini_tonelli_G.
- <span class="nb">move</span>=&gt; y _; <span class="nb">rewrite</span> /G_ /G /fubini_G [<span class="kr">in</span> X <span class="kr">in</span> _ --&gt; X](_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) =
      <span class="kr">fun</span> <span class="nv">x</span> =&gt; lim (EFin \o g ^~ (x, y))); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: g_f.
  <span class="nb">apply</span>: cvg_monotone_convergence =&gt; //.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>/EFin_measurable_fun =&gt; //; <span class="bp">exact</span>/measurable_fun_prod2.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n x _; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>: fun_ge0.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _ a b ab; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>/lefP/g_nd.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fubini_tonelli1</span> : \int[m1 \x m2]_z f z = \int[m1]_x F x.
<span class="kn">Proof</span>.
<span class="nb">have</span> [g [g_nd /= g_f]] := approximation measurableT mf (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; f0 x).
<span class="nb">have</span> F_F x : F x = lim (F_ g ^~ x).
  <span class="nb">rewrite</span> [RHS](_ : _ = lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[m2]_y (EFin \o g n) (x, y)))//.
  <span class="nb">rewrite</span> -monotone_convergence//; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_prod1.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; n /= y _; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>: fun_ge0.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; y /= _ a b; <span class="nb">rewrite</span> lee_fin =&gt; /g_nd/lefP; <span class="bp">exact</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; y _; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: g_f.
<span class="nb">rewrite</span> [RHS](_ : _ = lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[m1 \x m2]_z (EFin \o g n) z)).
  <span class="nb">rewrite</span> -monotone_convergence //; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>/EFin_measurable_fun.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; n /= x _; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>: fun_ge0.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; y /= _ a b; <span class="nb">rewrite</span> lee_fin =&gt; /g_nd/lefP; <span class="bp">exact</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; /= x _; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: g_f.
<span class="nb">rewrite</span> [LHS](_ : _ =
    lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[m1]_x (\int[m2]_y (EFin \o g n) (x, y)))).
  <span class="bp">by</span> <span class="nb">congr</span> (lim _); <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> sfun_fubini_tonelli1.
<span class="nb">rewrite</span> [RHS](_ : _ = lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[m1]_x F_ g n x))//.
<span class="nb">rewrite</span> -monotone_convergence //; <span class="kp">first</span> <span class="bp">exact</span>: eq_integral.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>: sfun_measurable_fun_fubini_tonelli_F.
- <span class="nb">move</span>=&gt; n x _; <span class="nb">apply</span>: integral_ge0 =&gt; // y _ /=; <span class="nb">rewrite</span> lee_fin.
  <span class="bp">exact</span>: fun_ge0.
- <span class="nb">move</span>=&gt; x /= _ a b ab; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; y _; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>: fun_ge0.
  + <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_prod1.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>: fun_ge0.
  + <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_prod1.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; y _; <span class="nb">rewrite</span> lee_fin; <span class="nb">move</span>/g_nd : ab =&gt; /lefP; <span class="bp">exact</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fubini_tonelli2</span> : \int[m1 \x m2]_z f z = \int[m2]_y G y.
<span class="kn">Proof</span>.
<span class="nb">have</span> [g [g_nd /= g_f]] := approximation measurableT mf (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> =&gt; f0 x).
<span class="nb">have</span> G_G y : G y = lim (G_ g ^~ y).
  <span class="nb">rewrite</span> /G /fubini_G.
  <span class="nb">rewrite</span> [RHS](_ : _ = lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[m1]_x (EFin \o g n) (x, y)))//.
  <span class="nb">rewrite</span> -monotone_convergence//; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_prod2.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; n /= x _; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>: fun_ge0.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; x /= _ a b; <span class="nb">rewrite</span> lee_fin =&gt; /g_nd/lefP; <span class="bp">exact</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; x _; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: g_f.
<span class="nb">rewrite</span> [RHS](_ : _ = lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[m1 \x m2]_z (EFin \o g n) z)).
  <span class="nb">rewrite</span> -monotone_convergence //; <span class="nb">last</span> <span class="mi">3</span> <span class="kp">first</span>.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>/EFin_measurable_fun.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; n /= x _; <span class="nb">rewrite</span> lee_fin; <span class="bp">exact</span>: fun_ge0.
    - <span class="bp">by</span> <span class="nb">move</span>=&gt; y /= _ a b; <span class="nb">rewrite</span> lee_fin =&gt; /g_nd/lefP; <span class="bp">exact</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: eq_integral =&gt; /= x _; <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="bp">exact</span>: g_f.
<span class="nb">rewrite</span> [LHS](_ : _ = lim
    (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[m2]_y (\int[m1]_x (EFin \o g n) (x, y)))).
  <span class="nb">congr</span> (lim _); <span class="nb">rewrite</span> funeqE =&gt; n.
  <span class="bp">by</span> <span class="nb">rewrite</span> sfun_fubini_tonelli sfun_fubini_tonelli2.
<span class="nb">rewrite</span> [RHS](_ : _ = lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \int[m2]_y G_ g n y))//.
<span class="nb">rewrite</span> -monotone_convergence //; <span class="kp">first</span> <span class="bp">exact</span>: eq_integral.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>: sfun_measurable_fun_fubini_tonelli_G.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; n y _; <span class="nb">apply</span>: integral_ge0 =&gt; // x _ /=; <span class="nb">rewrite</span> lee_fin fun_ge0.
- <span class="nb">move</span>=&gt; y /= _ a b ab; <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> lee_fin fun_ge0.
  + <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_prod2.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> lee_fin fun_ge0.
  + <span class="bp">exact</span>/EFin_measurable_fun/measurable_fun_prod2.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> lee_fin; <span class="nb">move</span>/g_nd : ab =&gt; /lefP; <span class="bp">exact</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fubini_tonelli</span> :
  \int[m1]_x \int[m2]_y f (x, y) = \int[m2]_y \int[m1]_x f (x, y).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -fubini_tonelli1// fubini_tonelli2. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">fubini_tonelli</span>.

<span class="kn">End</span> <span class="nf">fubini_tonelli</span>.
<span class="kn">Arguments</span> fubini_tonelli1 {d1 d2 T1 T2 R m1 m2} f.
<span class="kn">Arguments</span> fubini_tonelli2 {d1 d2 T1 T2 R m1 m2} f.
<span class="kn">Arguments</span> fubini_tonelli {d1 d2 T1 T2 R m1 m2} f.
<span class="kn">Arguments</span> measurable_fun_fubini_tonelli_F {d1 d2 T1 T2 R m2} f.
<span class="kn">Arguments</span> measurable_fun_fubini_tonelli_G {d1 d2 T1 T2 R m1} f.

<span class="kn">Section</span> <span class="nf">fubini</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d1</span> <span class="nv">d2</span> (<span class="nv">T1</span> : measurableType d1) (<span class="nv">T2</span> : measurableType d2) (<span class="nv">R</span> : realType).
<span class="kn">Variable</span> <span class="nv">m1</span> : {sigma_finite_measure <span class="nb">set</span> T1 -&gt; \bar R}.
<span class="kn">Variable</span> <span class="nv">m2</span> : {sigma_finite_measure <span class="nb">set</span> T2 -&gt; \bar R}.
<span class="kn">Variable</span> <span class="nv">f</span> : T1 * T2 -&gt; \bar R.

<span class="kn">Hypothesis</span> <span class="nv">imf</span> : (m1 \x m2).-integrable setT f.
<span class="kn">Let</span> <span class="nf">mf</span> : measurable_fun setT f := imf.<span class="mi">1</span>.

<span class="c">(* NB: only relies on mf *)</span>
<span class="kn">Lemma</span> <span class="nf">fubini1a</span> :
  (m1 \x m2).-integrable setT f &lt;-&gt; \int[m1]_x \int[m2]_y `|f (x, y)| &lt; +oo.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [[_]|] ioo.
- <span class="bp">by</span> <span class="nb">rewrite</span> -(fubini_tonelli1 (abse \o f))//=; <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">rewrite</span> fubini_tonelli1//; <span class="bp">exact</span>: measurable_funT_comp.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fubini1b</span> :
  (m1 \x m2).-integrable setT f &lt;-&gt; \int[m2]_y \int[m1]_x `|f (x, y)| &lt; +oo.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [[_]|] ioo.
- <span class="bp">by</span> <span class="nb">rewrite</span> -(fubini_tonelli2 (abse \o f))//=; <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">rewrite</span> fubini_tonelli2//; <span class="bp">exact</span>: measurable_funT_comp.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">measurable_fun1</span> : measurable_fun setT (<span class="kr">fun</span> <span class="nv">x</span> =&gt; \int[m2]_y `|f (x, y)|).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (measurable_fun_fubini_tonelli_F (abse \o f)) =&gt; //=.
<span class="bp">exact</span>: measurable_funT_comp.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">measurable_fun2</span> : measurable_fun setT (<span class="kr">fun</span> <span class="nv">y</span> =&gt; \int[m1]_x `|f (x, y)|).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (measurable_fun_fubini_tonelli_G (abse \o f)) =&gt; //=.
<span class="bp">exact</span>: measurable_funT_comp.
<span class="kn">Qed</span>.
<span class="c">(* /NB: only relies on mf *)</span>

<span class="kn">Lemma</span> <span class="nf">ae_integrable1</span> :
  {ae m1, <span class="kr">forall</span> <span class="nv">x</span>, m2.-integrable setT (<span class="kr">fun</span> <span class="nv">y</span> =&gt; f (x, y))}.
<span class="kn">Proof</span>.
<span class="nb">have</span> : m1.-integrable setT (<span class="kr">fun</span> <span class="nv">x</span> =&gt; \int[m2]_y `|f (x, y)|).
  <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> (le_lt_trans _  (fubini1a.<span class="mi">1</span> imf))// ge0_le_integral //.
  - <span class="bp">exact</span>: measurable_funT_comp.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: integral_ge0.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> gee0_abs//; <span class="bp">exact</span>: integral_ge0.
<span class="nb">move</span>/integrable_ae =&gt; /(_ measurableT) [N [mN N0 subN]]; <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //.
<span class="nb">apply</span>/(subset_trans _ subN)/subsetC =&gt; x /= /(_ Logic.I) im2f.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">exact</span>/measurable_fun_prod1|<span class="bp">by</span> <span class="nb">move</span>/fin_numPlt : im2f =&gt; /andP[]].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ae_integrable2</span> :
  {ae m2, <span class="kr">forall</span> <span class="nv">y</span>, m1.-integrable setT (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f (x, y))}.
<span class="kn">Proof</span>.
<span class="nb">have</span> : m2.-integrable setT (<span class="kr">fun</span> <span class="nv">y</span> =&gt; \int[m1]_x `|f (x, y)|).
  <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> (le_lt_trans _ (fubini1b.<span class="mi">1</span> imf))// ge0_le_integral //.
  - <span class="bp">exact</span>: measurable_funT_comp.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: integral_ge0.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> gee0_abs//; <span class="bp">exact</span>: integral_ge0.
<span class="nb">move</span>/integrable_ae =&gt; /(_ measurableT) [N [mN N0 subN]]; <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //.
<span class="nb">apply</span>/(subset_trans _ subN)/subsetC =&gt; x /= /(_ Logic.I) im1f.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">exact</span>/measurable_fun_prod2|<span class="nb">move</span>/fin_numPlt : im1f =&gt; /andP[]].
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">F</span> := fubini_F m2 f.

<span class="kn">Let</span> <span class="nf">Fplus</span> <span class="nv">x</span> := \int[m2]_y f^\+ (x, y).
<span class="kn">Let</span> <span class="nf">Fminus</span> <span class="nv">x</span> := \int[m2]_y f^\- (x, y).

<span class="kn">Let</span> <span class="nf">FE</span> : F = Fplus \- Fminus. <span class="kn">Proof</span>. <span class="nb">apply</span>/funext=&gt; x; <span class="bp">exact</span>: integralE. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">measurable_Fplus</span> : measurable_fun setT Fplus.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_fubini_tonelli_F =&gt; //; <span class="bp">exact</span>: emeasurable_fun_funepos.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">measurable_Fminus</span> : measurable_fun setT Fminus.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_fubini_tonelli_F =&gt; //; <span class="bp">exact</span>: emeasurable_fun_funeneg.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fubini_F</span> : measurable_fun setT F.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> FE.
<span class="bp">by</span> <span class="nb">apply</span>: emeasurable_funB; [<span class="bp">exact</span>: measurable_Fplus|<span class="bp">exact</span>: measurable_Fminus].
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">integrable_Fplus</span> : m1.-integrable setT Fplus.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: le_lt_trans (fubini1a.<span class="mi">1</span> imf); <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="bp">exact</span>: integral_ge0.
- <span class="nb">move</span>=&gt; x _; <span class="nb">apply</span>: le_trans.
    <span class="nb">apply</span>: le_abse_integral =&gt; //; <span class="nb">apply</span>: emeasurable_fun_funepos =&gt; //.
    <span class="bp">exact</span>: measurable_fun_prod1.
  <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  - <span class="nb">apply</span>: measurable_funT_comp =&gt; //.
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funepos =&gt; //; <span class="bp">exact</span>: measurable_fun_prod1.
  - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>/measurable_fun_prod1.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; y _; <span class="nb">rewrite</span> gee0_abs// -/((abse \o f) (x, y)) fune_abse lee_addl.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">integrable_Fminus</span> : m1.-integrable setT Fminus.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: le_lt_trans (fubini1a.<span class="mi">1</span> imf); <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: integral_ge0.
- <span class="nb">move</span>=&gt; x _; <span class="nb">apply</span>: le_trans.
    <span class="nb">apply</span>: le_abse_integral =&gt; //; <span class="nb">apply</span>: emeasurable_fun_funeneg =&gt; //.
    <span class="bp">exact</span>: measurable_fun_prod1.
  <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  + <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="nb">apply</span>: emeasurable_fun_funeneg =&gt; //.
    <span class="bp">exact</span>: measurable_fun_prod1.
  + <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_fun_prod1.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; y _; <span class="nb">rewrite</span> gee0_abs// -/((abse \o f) (x, y)) fune_abse lee_addr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">integrable_fubini_F</span> : m1.-integrable setT F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> FE; <span class="bp">exact</span>: integrableB. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">G</span> := fubini_G m1 f.

<span class="kn">Let</span> <span class="nf">Gplus</span> <span class="nv">y</span> := \int[m1]_x f^\+ (x, y).
<span class="kn">Let</span> <span class="nf">Gminus</span> <span class="nv">y</span> := \int[m1]_x f^\- (x, y).

<span class="kn">Let</span> <span class="nf">GE</span> : G = Gplus \- Gminus. <span class="kn">Proof</span>. <span class="nb">apply</span>/funext=&gt; x; <span class="bp">exact</span>: integralE. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">measurable_Gplus</span> : measurable_fun setT Gplus.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_fubini_tonelli_G =&gt; //; <span class="bp">exact</span>: emeasurable_fun_funepos.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">measurable_Gminus</span> : measurable_fun setT Gminus.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_fubini_tonelli_G =&gt; //; <span class="bp">exact</span>: emeasurable_fun_funeneg.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fubini_G</span> : measurable_fun setT G.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> GE; <span class="bp">exact</span>: emeasurable_funB. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">integrable_Gplus</span> : m2.-integrable setT Gplus.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: le_lt_trans (fubini1b.<span class="mi">1</span> imf); <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: integral_ge0.
- <span class="nb">move</span>=&gt; y _; <span class="nb">apply</span>: le_trans.
    <span class="nb">apply</span>: le_abse_integral =&gt; //; <span class="nb">apply</span>: emeasurable_fun_funepos =&gt; //.
    <span class="bp">exact</span>: measurable_fun_prod2.
  <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  - <span class="nb">apply</span>: measurable_funT_comp =&gt; //.
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funepos =&gt; //; <span class="bp">exact</span>: measurable_fun_prod2.
  - <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_fun_prod2.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> gee0_abs// -/((abse \o f) (x, y)) fune_abse lee_addl.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">integrable_Gminus</span> : m2.-integrable setT Gminus.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: le_lt_trans (fubini1b.<span class="mi">1</span> imf); <span class="nb">apply</span>: ge0_le_integral =&gt; //.
- <span class="bp">exact</span>: measurable_funT_comp.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: integral_ge0.
- <span class="nb">move</span>=&gt; y _; <span class="nb">apply</span>: le_trans.
    <span class="nb">apply</span>: le_abse_integral =&gt; //; <span class="nb">apply</span>: emeasurable_fun_funeneg =&gt; //.
    <span class="bp">exact</span>: measurable_fun_prod2.
  <span class="nb">apply</span>: ge0_le_integral =&gt; //.
  + <span class="nb">apply</span>: measurable_funT_comp =&gt; //.
    <span class="bp">by</span> <span class="nb">apply</span>: emeasurable_fun_funeneg =&gt; //; <span class="bp">exact</span>: measurable_fun_prod2.
  + <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: measurable_fun_prod2.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> gee0_abs// -/((abse \o f) (x, y)) fune_abse lee_addr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fubini1</span> : \int[m1]_x F x = \int[m1 \x m2]_z f z.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> FE integralB// [<span class="kr">in</span> RHS]integralE//.
<span class="nb">rewrite</span> fubini_tonelli1//; <span class="nb">last</span> <span class="bp">exact</span>: emeasurable_fun_funepos.
<span class="bp">by</span> <span class="nb">rewrite</span> fubini_tonelli1//; <span class="bp">exact</span>: emeasurable_fun_funeneg.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fubini2</span> : \int[m2]_x G x = \int[m1 \x m2]_z f z.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> GE integralB// [<span class="kr">in</span> RHS]integralE//.
<span class="nb">rewrite</span> fubini_tonelli2//; <span class="nb">last</span> <span class="bp">exact</span>: emeasurable_fun_funepos.
<span class="bp">by</span> <span class="nb">rewrite</span> fubini_tonelli2//; <span class="bp">exact</span>: emeasurable_fun_funeneg.
<span class="kn">Qed</span>.

<span class="kn">Theorem</span> <span class="nf">Fubini</span> :
  \int[m1]_x \int[m2]_y f (x, y) = \int[m2]_y \int[m1]_x f (x, y).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> fubini1 -fubini2. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">fubini</span>.</span></pre></article></body></html>