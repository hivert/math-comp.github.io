<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>classical_sets.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect ssralg matrix finmap order ssrnum.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predI _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predU _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predD _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predC _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ preim _ of _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closedM;
                   GRing.smulr_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedM; GRing.smulr_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed.
New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.sdivr_closed_div;
                   GRing.divr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.sdivr_closedM; GRing.smulr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subalg_closedBM;
                   GRing.subring_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subalg_closedZ; GRing.submod_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divring_closed_div;
                   GRing.sdivr_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divring_closedBM; GRing.subring_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divalg_closedBdiv;
                   GRing.divring_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divalg_closedZ; GRing.subalg_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.Pred.subring_smul;
                   GRing.Pred.smul_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.Pred.subring_semi; GRing.Pred.semiring_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> ssrint interval.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Require Import</span> mathcomp_extra boolp.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ \* _&quot;</span> was already used <span class="kr">in</span> scope
ring_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;\- _&quot;</span> was already used <span class="kr">in</span> scope ring_scope.
[notation-overridden,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(******************************************************************************)</span>
<span class="c">(* This file develops a basic theory of sets and types equipped with a        *)</span>
<span class="c">(* canonical inhabitant (pointed types).                                      *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* --&gt; A decidable equality is defined for any type. It is thus possible to   *)</span>
<span class="c">(*     define an eqType structure for any type using the mixin gen_eqMixin.   *)</span>
<span class="c">(* --&gt; This file adds the possibility to define a choiceType structure for    *)</span>
<span class="c">(*     any type thanks to an axiom gen_choiceMixin giving a choice mixin.     *)</span>
<span class="c">(* --&gt; We chose to have generic mixins and no global instances of the eqType  *)</span>
<span class="c">(*     and choiceType structures to let the user choose which definition of   *)</span>
<span class="c">(*     equality to use and to avoid conflict with already declared instances. *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Sets:                                                                    *)</span>
<span class="c">(*                       set T == type of sets on T.                          *)</span>
<span class="c">(*                   (x \in P) == boolean membership predicate from ssrbool   *)</span>
<span class="c">(*                                for set P, available thanks to a canonical  *)</span>
<span class="c">(*                                predType T structure on sets on T.          *)</span>
<span class="c">(*             [set x : T | P] == set of points x : T such that P holds.      *)</span>
<span class="c">(*                 [set x | P] == same as before with T left implicit.        *)</span>
<span class="c">(*            [set E | x in A] == set defined by the expression E for x in    *)</span>
<span class="c">(*                                set A.                                      *)</span>
<span class="c">(*   [set E | x in A &amp; y in B] == same as before for E depending on 2         *)</span>
<span class="c">(*                                variables x and y in sets A and B.          *)</span>
<span class="c">(*                        setT == full set.                                   *)</span>
<span class="c">(*                        set0 == empty set.                                  *)</span>
<span class="c">(*                     range f == the range of f, i.e. [set f x | x in setT]  *)</span>
<span class="c">(*                     [set a] == set containing only a.                      *)</span>
<span class="c">(*                 [set a : T] == same as before with the type of a made      *)</span>
<span class="c">(*                                explicit.                                   *)</span>
<span class="c">(*                     A `|` B == union of A and B.                           *)</span>
<span class="c">(*                      a |` A == A extended with a.                          *)</span>
<span class="c">(*        [set a1; a2; ..; an] == set containing only the n elements ai.      *)</span>
<span class="c">(*                     A `&amp;` B == intersection of A and B.                    *)</span>
<span class="c">(*                     A `*` B == product of A and B, i.e. set of pairs (a,b) *)</span>
<span class="c">(*                                such that A a and B b.                      *)</span>
<span class="c">(*                        A.`1 == set of points a such that there exists b so *)</span>
<span class="c">(*                                that A (a, b).                              *)</span>
<span class="c">(*                        A.`2 == set of points a such that there exists b so *)</span>
<span class="c">(*                                that A (b, a).                              *)</span>
<span class="c">(*                        ~` A == complement of A.                            *)</span>
<span class="c">(*                    [set~ a] == complement of [set a].                      *)</span>
<span class="c">(*                     A `\` B == complement of B in A.                       *)</span>
<span class="c">(*                      A `\ a == A deprived of a.                            *)</span>
<span class="c">(*                        `I_n := [set k | k &lt; n]                             *)</span>
<span class="c">(*          \bigcup_(i in P) F == union of the elements of the family F whose *)</span>
<span class="c">(*                                index satisfies P.                          *)</span>
<span class="c">(*           \bigcup_(i : T) F == union of the family F indexed on T.         *)</span>
<span class="c">(*           \bigcup_(i &lt; n) F := \bigcup_(i in `I_n) F                       *)</span>
<span class="c">(*                 \bigcup_i F == same as before with T left implicit.        *)</span>
<span class="c">(*          \bigcap_(i in P) F == intersection of the elements of the family  *)</span>
<span class="c">(*                                F whose index satisfies P.                  *)</span>
<span class="c">(*           \bigcap_(i : T) F == union of the family F indexed on T.         *)</span>
<span class="c">(*           \bigcap_(i &lt; n) F := \bigcap_(i in `I_n) F                       *)</span>
<span class="c">(*                 \bigcap_i F == same as before with T left implicit.        *)</span>
<span class="c">(*                smallest C G := \bigcap_(A in [set M | C M /\ G `&lt;=` M]) A  *)</span>
<span class="c">(*                   A `&lt;=` B &lt;-&gt; A is included in B.                         *)</span>
<span class="c">(*                  A `&lt;=&gt;` B &lt;-&gt; double inclusion A `&lt;=` B and B `&lt;=` A.     *)</span>
<span class="c">(*                   f @^-1` A == preimage of A by f.                         *)</span>
<span class="c">(*                      f @` A == image of A by f. Notation for `image A f`.  *)</span>
<span class="c">(*                    A !=set0 := exists x, A x.                              *)</span>
<span class="c">(*                    [set` p] == a classical set corresponding to the        *)</span>
<span class="c">(*                                predType p                                  *)</span>
<span class="c">(*                     `[a, b] := [set` `[a, b]], i.e., a classical set       *)</span>
<span class="c">(*                                corresponding to the interval `[a, b].      *)</span>
<span class="c">(*                     `]a, b] := [set` `]a, b]]                              *)</span>
<span class="c">(*                     `[a, b[ := [set` `[a, b[]                              *)</span>
<span class="c">(*                     `]a, b[ := [set` `]a, b[]                              *)</span>
<span class="c">(*                   `]-oo, b] := [set` `]-oo, b]]                            *)</span>
<span class="c">(*                   `]-oo, b[ := [set` `]-oo, b[]                            *)</span>
<span class="c">(*                   `[a, +oo[ := [set` `[a, +oo[]                            *)</span>
<span class="c">(*                   `]a, +oo[ := [set` `]a, +oo[]                            *)</span>
<span class="c">(*                 `]-oo, +oo[ := [set` `]-oo, +oo[]                          *)</span>
<span class="c">(*               is_subset1 A &lt;-&gt; A contains only 1 element.                  *)</span>
<span class="c">(*                   is_fun f &lt;-&gt; for each a, f a contains only 1 element.    *)</span>
<span class="c">(*                 is_total f &lt;-&gt; for each a, f a is non empty.               *)</span>
<span class="c">(*              is_totalfun f &lt;-&gt; conjunction of is_fun and is_total.         *)</span>
<span class="c">(*                   xget x0 P == point x in P if it exists, x0 otherwise;    *)</span>
<span class="c">(*                                P must be a set on a choiceType.            *)</span>
<span class="c">(*             fun_of_rel f0 f == function that maps x to an element of f x   *)</span>
<span class="c">(*                                if there is one, to f0 x otherwise.         *)</span>
<span class="c">(*                    F `#` G &lt;-&gt; intersections beween elements of F an G are *)</span>
<span class="c">(*                                all non empty.                              *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Pointed types:                                                           *)</span>
<span class="c">(*                 pointedType == interface type for types equipped with a    *)</span>
<span class="c">(*                                canonical inhabitant.                       *)</span>
<span class="c">(*             PointedType T m == packs the term m : T to build a             *)</span>
<span class="c">(*                                pointedType; T must have a choiceType       *)</span>
<span class="c">(*                                structure.                                  *)</span>
<span class="c">(*   [pointedType of T for cT] == T-clone of the pointedType structure cT.    *)</span>
<span class="c">(*          [pointedType of T] == clone of a canonical pointedType structure  *)</span>
<span class="c">(*                                on T.                                       *)</span>
<span class="c">(*                       point == canonical inhabitant of a pointedType.      *)</span>
<span class="c">(*                       get P == point x in P if it exists, point otherwise; *)</span>
<span class="c">(*                                P must be a set on a pointedType.           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* --&gt; Thanks to this basic set theory, we proved Zorn&#39;s Lemma, which states  *)</span>
<span class="c">(*     that any ordered set such that every totally ordered subset admits an  *)</span>
<span class="c">(*     upper bound has a maximal element. We also proved an analogous version *)</span>
<span class="c">(*     for preorders, where maximal is replaced with premaximal: t is         *)</span>
<span class="c">(*     premaximal if whenever t &lt; s we also have s &lt; t.                       *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*                      $| T | == T : Type is inhabited                       *)</span>
<span class="c">(*                    squash x == proof of $| T | (with x : T)                *)</span>
<span class="c">(*                  unsquash s == extract a witness from s : $| T |           *)</span>
<span class="c">(* --&gt; Tactic:                                                                *)</span>
<span class="c">(*   - squash x:                                                              *)</span>
<span class="c">(*     solves a goal $| T | by instantiating with x or [the T of x]           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*                trivIset D F == the sets F i, where i ranges over D : set I,*)</span>
<span class="c">(*                                are pairwise-disjoint                       *)</span>
<span class="c">(*                   cover D F := \bigcup_(i in D) F i                        *)</span>
<span class="c">(*             partition D F A == the non-empty sets F i,where i ranges over  *)</span>
<span class="c">(*                                D : set I, form a partition of A            *)</span>
<span class="c">(*          pblock_index D F x == index i such that i \in D and x \in F i     *)</span>
<span class="c">(*                pblock D F x := F (pblock_index D F x)                      *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Upper and lower bounds:                                                  *)</span>
<span class="c">(*              ubound A == the set of upper bounds of the set A              *)</span>
<span class="c">(*              lbound A == the set of lower bounds of the set A              *)</span>
<span class="c">(*   Predicates to express existence conditions of supremum and infimum of    *)</span>
<span class="c">(*   sets of real numbers:                                                    *)</span>
<span class="c">(*          has_ubound A := ubound A != set0                                  *)</span>
<span class="c">(*             has_sup A := A != set0 /\ has_ubound A                         *)</span>
<span class="c">(*          has_lbound A := lbound A != set0                                  *)</span>
<span class="c">(*             has_inf A := A != set0 /\ has_lbound A                         *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*             isLub A m := m is a least upper bound of the set A             *)</span>
<span class="c">(*           supremums A := set of supremums of the set A                     *)</span>
<span class="c">(*         supremum x0 A == supremum of A or x0 if A is empty                 *)</span>
<span class="c">(*            infimums A := set of infimums of the set A                      *)</span>
<span class="c">(*          infimum x0 A == infimum of A or x0 if A is empty                  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*               F `#` G := the classes of sets F and G intersect             *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * sections:                                                                *)</span>
<span class="c">(*           xsection A x == with A : set (T1 * T2) and x : T1 is the         *)</span>
<span class="c">(*                           x-section of A                                   *)</span>
<span class="c">(*           ysection A y == with A : set (T1 * T2) and y : T2 is the         *)</span>
<span class="c">(*                           y-section of A                                   *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * About the naming conventions in this file:                               *)</span>
<span class="c">(* - use T, T&#39;, T1, T2, etc., aT (domain type), rT (return type) for names of *)</span>
<span class="c">(*   variables in Type (or choiceType/pointedType/porderType)                 *)</span>
<span class="c">(*   + use the same suffix or prefix for the sets as their containing type    *)</span>
<span class="c">(*     (e.g., A1 in T1, etc.)                                                 *)</span>
<span class="c">(*   + as a consequence functions are rather of type aT -&gt; rT                 *)</span>
<span class="c">(* - use I, J when the type corresponds to an index                           *)</span>
<span class="c">(* - sets are named A, B, C, D, etc., or Y when it is ostensibly an image set *)</span>
<span class="c">(*   (i.e., of type set rT)                                                   *)</span>
<span class="c">(* - indexed sets are rather named F                                          *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Composition of relations:                                                *)</span>
<span class="c">(*                A \; B == [set x | exists z, A (x.1, z) &amp; B (z, x.2)]       *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Strict Implicit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Printing Implicit Defensive</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set&#39; x : T | P ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, x <span class="kn">at level</span> <span class="mi">99</span>, <span class="kn">only parsing</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="kn">only parsing</span> modifier has no effect <span class="kr">in</span> Reserved
<span class="kn">Notation</span>.
[irrelevant-reserved-notation-<span class="kp">only</span>-parsing,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set&#39; x | P ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, x, P <span class="kn">at level</span> <span class="mi">99</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;set&#39;  x  |  P ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set&#39; E | x &#39;in&#39; A ]&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, E, x <span class="kn">at level</span> <span class="mi">99</span>,
  <span class="kn">format</span> <span class="s2">&quot;[ &#39;[hv&#39; &#39;set&#39;  E &#39;/ &#39;  |  x  &#39;in&#39;  A ] &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set&#39; E | x &#39;in&#39; A &amp; y &#39;in&#39; B ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, E, x <span class="kn">at level</span> <span class="mi">99</span>,
  <span class="kn">format</span> <span class="s2">&quot;[ &#39;[hv&#39; &#39;set&#39;  E &#39;/ &#39;  |  x  &#39;in&#39;  A  &amp;  y  &#39;in&#39;  B ] &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set&#39; a ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, a <span class="kn">at level</span> <span class="mi">99</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;set&#39;  a ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set&#39; : T ]&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;set&#39; :  T ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set&#39; a : T ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, a <span class="kn">at level</span> <span class="mi">99</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;set&#39;  a   :  T ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A `|` B&quot;</span> (<span class="kn">at level</span> <span class="mi">52</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;a |` A&quot;</span> (<span class="kn">at level</span> <span class="mi">52</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set&#39; a1 ; a2 ; .. ; an ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, a1 <span class="kn">at level</span> <span class="mi">99</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;set&#39;  a1 ;  a2 ;  .. ;  an ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A `&amp;` B&quot;</span>  (<span class="kn">at level</span> <span class="mi">48</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A `*` B&quot;</span>  (<span class="kn">at level</span> <span class="mi">46</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A `*`` B&quot;</span>  (<span class="kn">at level</span> <span class="mi">46</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A ``*` B&quot;</span>  (<span class="kn">at level</span> <span class="mi">46</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A .`1&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">left associativity</span>, <span class="kn">format</span> <span class="s2">&quot;A .`1&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A .`2&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">left associativity</span>, <span class="kn">format</span> <span class="s2">&quot;A .`2&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;~` A&quot;</span> (<span class="kn">at level</span> <span class="mi">35</span>, <span class="kn">right associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set&#39; ~ a ]&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;set&#39; ~  a ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A `\` B&quot;</span> (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A `\ b&quot;</span> (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(*</span>
<span class="c">Reserved Notation &quot;A `+` B&quot;  (at level 54, left associativity).</span>
<span class="c">Reserved Notation &quot;A +` B&quot;  (at level 54, left associativity).</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;\bigcup_ ( i &#39;in&#39; P ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i, P <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \bigcup_ ( i  &#39;in&#39;  P ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;\bigcup_ ( i : T ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \bigcup_ ( i  :  T ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;\bigcup_ ( _ : _ ) _&quot;</span> was already defined
<span class="kr">with</span> a different <span class="kn">format</span>.
[notation-incompatible-<span class="kn">format</span>,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;\bigcup_ ( i &lt; n ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i, n <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \bigcup_ ( i  &lt;  n ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;\bigcup_ i F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i <span class="kn">at level</span> <span class="mi">0</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \bigcup_ i &#39;/  &#39;  F &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;\bigcap_ ( i &#39;in&#39; P ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i, P <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \bigcap_ ( i  &#39;in&#39;  P ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;\bigcap_ ( i : T ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \bigcap_ ( i  :  T ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;\bigcap_ ( _ : _ ) _&quot;</span> was already defined
<span class="kr">with</span> a different <span class="kn">format</span>.
[notation-incompatible-<span class="kn">format</span>,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;\bigcap_ ( i &lt; n ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i, n <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \bigcap_ ( i  &lt;  n ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;\bigcap_ i F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i <span class="kn">at level</span> <span class="mi">0</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \bigcap_ i &#39;/  &#39;  F &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A `&lt;` B&quot;</span> (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A `&lt;=` B&quot;</span> (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A `&lt;=&gt;` B&quot;</span> (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;f @^-1` A&quot;</span> (<span class="kn">at level</span> <span class="mi">24</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;f @` A&quot;</span> (<span class="kn">at level</span> <span class="mi">24</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A !=set0&quot;</span> (<span class="kn">at level</span> <span class="mi">80</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;set`&#39; p ]&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;set`&#39;  p ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;disjoint&#39; A &amp; B ]&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>,
  <span class="kn">format</span> <span class="s2">&quot;&#39;[hv&#39; [ &#39;disjoint&#39; &#39;/  &#39;  A &#39;/&#39;  &amp;  B ] &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;F `#` G&quot;</span>
 (<span class="kn">at level</span> <span class="mi">48</span>, <span class="kn">left associativity</span>, <span class="kn">format</span> <span class="s2">&quot;F  `#`  G&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;`I_&#39; n&quot;</span> (<span class="kn">at level</span> <span class="mi">8</span>, n <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;`I_&#39; n&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">set</span> <span class="nv">T</span> := T -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* we use fun x =&gt; instead of pred to prevent inE from working *)</span>
<span class="c">(* we will then extend inE with in_setE to make this work      *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">in_set</span> <span class="nv">T</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : pred T := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `[&lt;A x&gt;]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">set_predType</span> T := @PredType T (<span class="nb">set</span> T) (@in_set T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_setE</span> <span class="nv">T</span> (<span class="nv">A</span> : <span class="nb">set</span> T) <span class="nv">x</span> : x \<span class="kr">in</span> A = A x :&gt; <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \<span class="kr">in</span> A) = A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [] /asboolP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inE</span> := (inE, in_setE).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Bind Scope</span> classical_set_scope <span class="kr">with</span> <span class="nb">set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> classical_set_scope <span class="kr">with</span> classic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mkset</span> {<span class="nv">T</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) : <span class="nb">set</span> T := P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> mkset _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set&#39; x : T | P ]&quot;</span> := (mkset (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; P)) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set&#39; x | P ]&quot;</span> := [<span class="nb">set</span> x : _ | P] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">image</span> {<span class="nv">T</span> <span class="nv">rT</span>} (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; rT) :=
  [<span class="nb">set</span> y | <span class="kr">exists2</span> x, A x &amp; f x = y].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> image _ _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set&#39; E | x &#39;in&#39; A ]&quot;</span> :=
  (image A (<span class="kr">fun</span> <span class="nv">x</span> =&gt; E)) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">image2</span> {<span class="nv">TA</span> <span class="nv">TB</span> <span class="nv">rT</span>} (<span class="nv">A</span> : <span class="nb">set</span> TA) (<span class="nv">B</span> : <span class="nb">set</span> TB) (<span class="nv">f</span> : TA -&gt; TB -&gt; rT) :=
  [<span class="nb">set</span> z | <span class="kr">exists2</span> x, A x &amp; <span class="kr">exists2</span> y, B y &amp; f x y = z].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> image2 _ _ _ _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set&#39; E | x &#39;in&#39; A &amp; y &#39;in&#39; B ]&quot;</span> :=
  (image2 A B (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; E)) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">basic_definitions</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span> <span class="nv">rT</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; rT) (<span class="nv">Y</span> : <span class="nb">set</span> rT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">preimage</span> <span class="nv">f</span> <span class="nv">Y</span> : <span class="nb">set</span> T := [<span class="nb">set</span> t | Y (f t)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">setT</span> := [<span class="nb">set</span> _ : T | <span class="kt">True</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">set0</span> := [<span class="nb">set</span> _ : T | <span class="kt">False</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">set1</span> (<span class="nv">t</span> : T) := [<span class="nb">set</span> x : T | x = t].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">setI</span> <span class="nv">A</span> <span class="nv">B</span> := [<span class="nb">set</span> x | A x /\ B x].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">setU</span> <span class="nv">A</span> <span class="nv">B</span> := [<span class="nb">set</span> x | A x \/ B x].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">nonempty</span> <span class="nv">A</span> := <span class="kr">exists</span> <span class="nv">a</span>, A a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">setC</span> <span class="nv">A</span> := [<span class="nb">set</span> a | ~ A a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">setD</span> <span class="nv">A</span> <span class="nv">B</span> := [<span class="nb">set</span> x | A x /\ ~ B x].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">setM</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">A1</span> : <span class="nb">set</span> T1) (<span class="nv">A2</span> : <span class="nb">set</span> T2) := [<span class="nb">set</span> z | A1 z.<span class="mi">1</span> /\ A2 z.<span class="mi">2</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fst_set</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">A</span> : <span class="nb">set</span> (T1 * T2)) := [<span class="nb">set</span> x | <span class="kr">exists</span> <span class="nv">y</span>, A (x, y)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">snd_set</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">A</span> : <span class="nb">set</span> (T1 * T2)) := [<span class="nb">set</span> y | <span class="kr">exists</span> <span class="nv">x</span>, A (x, y)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">setMR</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">A1</span> : <span class="nb">set</span> T1) (<span class="nv">A2</span> : T1 -&gt; <span class="nb">set</span> T2) :=
  [<span class="nb">set</span> z | A1 z.<span class="mi">1</span> /\ A2 z.<span class="mi">1</span> z.<span class="mi">2</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">setML</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">A1</span> : T2 -&gt; <span class="nb">set</span> T1) (<span class="nv">A2</span> : <span class="nb">set</span> T2) :=
  [<span class="nb">set</span> z | A1 z.<span class="mi">2</span> z.<span class="mi">1</span> /\ A2 z.<span class="mi">2</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mksetE</span> (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) <span class="nv">x</span> : [<span class="nb">set</span> x | P x] x = P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, rT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> x | P x] x = P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bigcap</span> <span class="nv">T</span> <span class="nv">I</span> (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :=
  [<span class="nb">set</span> a | <span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bigcup</span> <span class="nv">T</span> <span class="nv">I</span> (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :=
  [<span class="nb">set</span> a | <span class="kr">exists2</span> i, P i &amp; F i a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subset</span> <span class="nv">A</span> <span class="nv">B</span> := <span class="kr">forall</span> <span class="nv">t</span>, A t -&gt; B t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;A `&lt;=` B&quot;</span> := (subset A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">disj_set</span> <span class="nv">A</span> <span class="nv">B</span> := setI A B == set0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">proper</span> <span class="nv">A</span> <span class="nv">B</span> := A `&lt;=` B /\ ~ (B `&lt;=` A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">basic_definitions</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> preimage T rT f Y t /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> set0 _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> setT _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> set1 _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> setI _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> setU _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> setC _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> setD _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> setM _ _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> setMR _ _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> setML _ _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> fst_set _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> snd_set _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">range</span> F := [<span class="nb">set</span> F i | i <span class="kr">in</span> setT].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set&#39; a ]&quot;</span> := (set1 a) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set&#39; a : T ]&quot;</span> := [<span class="nb">set</span> (a : T)] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set&#39; : T ]&quot;</span> := (@setT T) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A `|` B&quot;</span> := (setU A B) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;a |` A&quot;</span> := ([<span class="nb">set</span> a] `|` A) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set&#39; a1 ; a2 ; .. ; an ]&quot;</span> :=
  (setU .. (a1 |` [<span class="nb">set</span> a2]) .. [<span class="nb">set</span> an]) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A `&amp;` B&quot;</span> := (setI A B) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A `*` B&quot;</span> := (setM A B) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A .`1&quot;</span> := (fst_set A) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A .`2&quot;</span> := (snd_set A) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A `*`` B&quot;</span> := (setMR A B) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A ``*` B&quot;</span> := (setML A B) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;~` A&quot;</span> := (setC A) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set&#39; ~ a ]&quot;</span> := (~` [<span class="nb">set</span> a]) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A `\` B&quot;</span> := (setD A B) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A `\ a&quot;</span> := (A `\` [<span class="nb">set</span> a]) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;disjoint&#39; A &amp; B ]&quot;</span> := (disj_set A B) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;`I_&#39; n&quot;</span> := [<span class="nb">set</span> k | is_true (k &lt; n)%N].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\bigcup_ ( i &#39;in&#39; P ) F&quot;</span> :=
  (bigcup P (<span class="kr">fun</span> <span class="nv">i</span> =&gt; F)) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\bigcup_ ( i : T ) F&quot;</span> :=
  (\bigcup_(i <span class="kr">in</span> @setT T) F) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\bigcup_ ( i &lt; n ) F&quot;</span> :=
  (\bigcup_(i <span class="kr">in</span> `I_n) F) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\bigcup_ i F&quot;</span> := (\bigcup_(i : _) F) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\bigcap_ ( i &#39;in&#39; P ) F&quot;</span> :=
  (bigcap P (<span class="kr">fun</span> <span class="nv">i</span> =&gt; F)) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\bigcap_ ( i : T ) F&quot;</span> :=
  (\bigcap_(i <span class="kr">in</span> @setT T) F) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\bigcap_ ( i &lt; n ) F&quot;</span> :=
  (\bigcap_(i <span class="kr">in</span> `I_n) F) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\bigcap_ i F&quot;</span> := (\bigcap_(i : _) F) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A `&lt;=` B&quot;</span> := (subset A B) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A `&lt;` B&quot;</span> := (proper A B) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A `&lt;=&gt;` B&quot;</span> := ((A `&lt;=` B) /\ (B `&lt;=` A)) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;f @^-1` A&quot;</span> := (preimage f A) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;f @` A&quot;</span> := (image A f) (<span class="kn">only parsing</span>) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A !=set0&quot;</span> := (nonempty A) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;set`&#39; p ]&quot;</span>:= [<span class="nb">set</span> x | is_true (x \<span class="kr">in</span> p)] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">pred_set</span> := (<span class="kr">fun</span> <span class="nv">i</span> =&gt; [<span class="nb">set</span>` i]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`[ a , b ]&quot;</span> :=
  [<span class="nb">set</span>` Interval (BLeft a) (BRight b)] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`] a , b ]&quot;</span> :=
  [<span class="nb">set</span>` Interval (BRight a) (BRight b)] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`[ a , b [&quot;</span> :=
  [<span class="nb">set</span>` Interval (BLeft a) (BLeft b)] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`] a , b [&quot;</span> :=
  [<span class="nb">set</span>` Interval (BRight a) (BLeft b)] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`] &#39;-oo&#39; , b ]&quot;</span> :=
  [<span class="nb">set</span>` Interval -oo%O (BRight b)] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`] &#39;-oo&#39; , b [&quot;</span> :=
  [<span class="nb">set</span>` Interval -oo%O (BLeft b)] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`[ a , &#39;+oo&#39; [&quot;</span> :=
  [<span class="nb">set</span>` Interval (BLeft a) +oo%O] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`] a , &#39;+oo&#39; [&quot;</span> :=
  [<span class="nb">set</span>` Interval (BRight a) +oo%O] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`] -oo , &#39;+oo&#39; [&quot;</span> :=
  [<span class="nb">set</span>` Interval -oo%O +oo%O] : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_itv</span> <span class="nv">T</span> (<span class="nv">d</span> : unit) (<span class="nv">rT</span> : porderType d) (<span class="nv">f</span> : T -&gt; rT) (<span class="nv">i</span> : interval rT) (<span class="nv">x</span> : T) :
  ((f @^-<span class="mi">1</span>` [<span class="nb">set</span>` i]) x) = (f x \<span class="kr">in</span> i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>d</var><span class="hyp-type"><b>: </b><span>unit</span></span></span><br><span><var>rT</var><span class="hyp-type"><b>: </b><span>porderType d</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T -&gt; rT</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>interval rT</span></span></span><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f @^-<span class="mi">1</span>` [<span class="nb">set</span>` i]) x = (f x \<span class="kr">in</span> i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>17</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_itv_o_infty</span> <span class="nv">T</span> (<span class="nv">d</span> : unit) (<span class="nv">rT</span> : porderType d) (<span class="nv">f</span> : T -&gt; rT) <span class="nv">y</span> :
  f @^-<span class="mi">1</span>` `]y, +oo[%classic = [<span class="nb">set</span> x | (y &lt; f x)%O].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>1a</q><br><q>1b</q><br><q>1c</q><br><span><var>y</var><span class="hyp-type"><b>: </b><span>rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` `]y, +oo[ = [<span class="nb">set</span> x | (y &lt; f x)%O]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>21</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [|?]; <span class="nb">rewrite</span> /= in_itv/= andbT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_itv_c_infty</span> <span class="nv">T</span> (<span class="nv">d</span> : unit) (<span class="nv">rT</span> : porderType d) (<span class="nv">f</span> : T -&gt; rT) <span class="nv">y</span> :
  f @^-<span class="mi">1</span>` `[y, +oo[%classic = [<span class="nb">set</span> x | (y &lt;= f x)%O].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` `[y, +oo[ = [<span class="nb">set</span> x | (y &lt;= f x)%O]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>28</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [|?]; <span class="nb">rewrite</span> /= in_itv/= andbT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_itv_infty_o</span> <span class="nv">T</span> (<span class="nv">d</span> : unit) (<span class="nv">rT</span> : orderType d) (<span class="nv">f</span> : T -&gt; rT) <span class="nv">y</span> :
  f @^-<span class="mi">1</span>` `]-oo, y[%classic = [<span class="nb">set</span> x | (f x &lt; y)%O].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>1a</q><br><span><var>rT</var><span class="hyp-type"><b>: </b><span>orderType d</span></span></span><br><q>1c</q><br><q>24</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` `]-oo, y[ = [<span class="nb">set</span> x | (f x &lt; y)%O]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [|?]; <span class="nb">rewrite</span> /= in_itv.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_itv_infty_c</span> <span class="nv">T</span> (<span class="nv">d</span> : unit) (<span class="nv">rT</span> : orderType d) (<span class="nv">f</span> : T -&gt; rT) <span class="nv">y</span> :
  f @^-<span class="mi">1</span>` `]-oo, y]%classic = [<span class="nb">set</span> x | (f x &lt;= y)%O].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` `]-oo, y] = [<span class="nb">set</span> x | (f x &lt;= y)%O]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>34</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [|?]; <span class="nb">rewrite</span> /= in_itv.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_set</span> <span class="nv">T</span> (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; <span class="kt">Prop</span>) : (<span class="kr">forall</span> <span class="nv">x</span> : T, P x = Q x) -&gt;
  [<span class="nb">set</span> x | P x] = [<span class="nb">set</span> x | Q x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, P x = Q x) -&gt;
[<span class="nb">set</span> x | P x] = [<span class="nb">set</span> x | Q x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>39</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /funext-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">set_type</span> T (A : <span class="nb">set</span> T) := {x : T | x \<span class="kr">in</span> A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">SigSub</span> {<span class="nv">T</span>} {<span class="nv">pT</span> : predType T} {<span class="nv">P</span> : pT} <span class="nv">x</span> : x \<span class="kr">in</span> P -&gt; {x | x \<span class="kr">in</span> P} :=
  exist (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x \<span class="kr">in</span> P) x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set0fun</span> {<span class="nv">P</span> <span class="nv">T</span> : <span class="kt">Type</span>} : @set0 T -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set0 -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>40</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; x; <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">pred_oappE</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">D</span> : {pred T}) :
  pred_oapp D = mem (some @` D)%classic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>D</var><span class="hyp-type"><b>: </b><span>{pred T}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pred_oapp D = mem [<span class="nb">set</span> Some x | x <span class="kr">in</span> <span class="kr">fun</span> <span class="nv">x</span> : T =&gt; D x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>47</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/funext=&gt; -[x|]/=; <span class="nb">apply</span>/idP/idP; <span class="nb">rewrite</span> /pred_oapp/= inE //=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>4a</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x \<span class="kr">in</span> D -&gt;
ex2 (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; D x)
  (<span class="kr">fun</span> <span class="nv">x0</span> : T =&gt; Some x0 = Some x)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>50</q><label class="goal-separator"><hr></label><div class="goal-conclusion">ex2 (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; D x)
  (<span class="kr">fun</span> <span class="nv">x0</span> : T =&gt; Some x0 = Some x) -&gt; x \<span class="kr">in</span> D</div></blockquote><blockquote class="alectryon-goal"><q>49</q><label class="goal-separator"><hr></label><div class="goal-conclusion">(<span class="kr">exists2</span> x : T, D x &amp; Some x = None) -&gt; false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>4e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; xD; <span class="kr">exists</span> <span class="nv">x</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>50</q><span class="goal-separator"><hr></span><q>54</q></blockquote><div class="alectryon-extra-goals"><q>55</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>59</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [// + + [&lt;-]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>49</q><span class="goal-separator"><hr></span><q>56</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>5e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">pred_oapp_set</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">D</span> : <span class="nb">set</span> T) :
  pred_oapp (mem D) = mem (some @` D)%classic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pred_oapp (mem D) = mem [<span class="nb">set</span> Some x | x <span class="kr">in</span> D]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>62</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> pred_oappE; <span class="nb">apply</span>/funext =&gt; x/=; <span class="nb">apply</span>/idP/idP; <span class="nb">rewrite</span> <span class="nl">?inE</span>;
   <span class="nb">move</span>=&gt; [y/= ]; <span class="nb">rewrite</span> <span class="nl">?in_setE</span>; <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">rewrite</span> <span class="nl">?in_setE</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">basic_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="nb">set</span> T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mem_set</span> {<span class="nv">A</span>} {<span class="nv">u</span> : T} : A u -&gt; u \<span class="kr">in</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A u -&gt; u \<span class="kr">in</span> A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>69</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_mem</span> {<span class="nv">A</span>} {<span class="nv">u</span> : T} : u \<span class="kr">in</span> A -&gt; A u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">u \<span class="kr">in</span> A -&gt; A u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>70</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mem_setT</span> (<span class="nv">u</span> : T)    : u \<span class="kr">in</span> [<span class="nb">set</span>: T].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>6c</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u \<span class="kr">in</span> [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>75</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mem_setK</span> {<span class="nv">A</span>} {<span class="nv">u</span> : T} : cancel (@mem_set A u) set_mem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel mem_set set_mem</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_memK</span> {<span class="nv">A</span>} {<span class="nv">u</span> : T} : cancel (@set_mem A u) mem_set.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel set_mem mem_set</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>80</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">memNset</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">u</span> : T) : ~ A u -&gt; u \<span class="kr">in</span> A = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ A u -&gt; (u \<span class="kr">in</span> A) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>85</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: contra_notF; <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notin_set</span> (<span class="nv">A</span> : <span class="nb">set</span> T) <span class="nv">x</span> : (x \notin A : <span class="kt">Prop</span>) = ~ (A x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \notin A : <span class="kt">Prop</span>) = (~ A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/propext; <span class="nb">split</span>=&gt; /asboolPn.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setTPn</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : A != setT &lt;-&gt; <span class="kr">exists</span> <span class="nv">t</span>, ~ A t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A != [<span class="nb">set</span>: T] &lt;-&gt; (<span class="kr">exists</span> <span class="nv">t</span> : T, ~ A t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span> =&gt; [/negP|[t]]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: contra_notP =&gt; /negP/negPn/eqP -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ A == [<span class="nb">set</span>: T] -&gt; <span class="kr">exists</span> <span class="nv">t</span> : T, ~ A t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: contra_notP =&gt; /forallNP h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : T, ~ ~ A x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A == [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; // _; <span class="nb">apply</span>: contrapT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[deprecated(note=<span class="s2">&quot;Use setTPn instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">setTP</span> := setTPn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_set0</span> (<span class="nv">x</span> : T) : (x \<span class="kr">in</span> set0) = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \<span class="kr">in</span> set0) = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> memNset.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_setT</span> (<span class="nv">x</span> : T) : x \<span class="kr">in</span> setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">x \<span class="kr">in</span> [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> mem_set.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_setC</span> (<span class="nv">x</span> : T) <span class="nv">A</span> : (x \<span class="kr">in</span> ~` A) = (x \notin A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b</q><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \<span class="kr">in</span> ~` A) = (x \notin A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>aa</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP/idP; <span class="nb">rewrite</span> inE notin_set.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_setI</span> (<span class="nv">x</span> : T) <span class="nv">A</span> <span class="nv">B</span> : (x \<span class="kr">in</span> A `&amp;` B) = (x \<span class="kr">in</span> A) &amp;&amp; (x \<span class="kr">in</span> B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b</q><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \<span class="kr">in</span> A `&amp;` B) = (x \<span class="kr">in</span> A) &amp;&amp; (x \<span class="kr">in</span> B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP/andP; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_setD</span> (<span class="nv">x</span> : T) <span class="nv">A</span> <span class="nv">B</span> : (x \<span class="kr">in</span> A `\` B) = (x \<span class="kr">in</span> A) &amp;&amp; (x \notin B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \<span class="kr">in</span> A `\` B) = (x \<span class="kr">in</span> A) &amp;&amp; (x \notin B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b7</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP/andP; <span class="nb">rewrite</span> !inE notin_set.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_setU</span> (<span class="nv">x</span> : T) <span class="nv">A</span> <span class="nv">B</span> : (x \<span class="kr">in</span> A `|` B) = (x \<span class="kr">in</span> A) || (x \<span class="kr">in</span> B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \<span class="kr">in</span> A `|` B) = (x \<span class="kr">in</span> A) || (x \<span class="kr">in</span> B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP/orP; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_setM</span> <span class="nv">T&#39;</span> (<span class="nv">x</span> : T * T&#39;) <span class="nv">A</span> <span class="nv">E</span> : (x \<span class="kr">in</span> A `*` E) = (x.<span class="mi">1</span> \<span class="kr">in</span> A) &amp;&amp; (x.<span class="mi">2</span> \<span class="kr">in</span> E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, T'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(T * T&#39;)%type</span></span></span><br><q>a</q><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \<span class="kr">in</span> A `*` E) = (x.<span class="mi">1</span> \<span class="kr">in</span> A) &amp;&amp; (x.<span class="mi">2</span> \<span class="kr">in</span> E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP/andP; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_valP</span> {<span class="nv">A</span>} (<span class="nv">x</span> : A) : A (val x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A (val x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ca</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: set_mem; <span class="nb">apply</span>: valP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eqEsubset</span> <span class="nv">A</span> <span class="nv">B</span> : (A = B) = (A `&lt;=&gt;` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A = B) = (A `&lt;=&gt;` B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>d1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [-&gt;|[AB BA]]; [<span class="bp">by</span> <span class="nb">split</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><span><var>AB</var><span class="hyp-type"><b>: </b><span>A `&lt;=` B</span></span></span><br><span><var>BA</var><span class="hyp-type"><b>: </b><span>B `&lt;=` A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [/AB|/BA].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">seteqP</span> <span class="nv">A</span> <span class="nv">B</span> : (A = B) &lt;-&gt; (A `&lt;=&gt;` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A = B &lt;-&gt; A `&lt;=&gt;` B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>de</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_true</span> : [<span class="nb">set</span>` predT] = setT :&gt; <span class="nb">set</span> T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` predT] = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>e3</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_false</span> : [<span class="nb">set</span>` pred0] = set0 :&gt; <span class="nb">set</span> T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` pred0] = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>e9</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_andb</span> (<span class="nv">P</span> <span class="nv">Q</span> : {pred T}) : [<span class="nb">set</span>` predI P Q] = [<span class="nb">set</span>` P] `&amp;` [<span class="nb">set</span>` Q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>{pred T}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` predI P Q] = [<span class="nb">set</span>` P] `&amp;` [<span class="nb">set</span>` Q]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ee</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/predeqP =&gt; x; <span class="nb">split</span>; <span class="nb">rewrite</span> /= inE =&gt; /andP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_orb</span> (<span class="nv">P</span> <span class="nv">Q</span> : {pred T}) : [<span class="nb">set</span>` predU P Q] = [<span class="nb">set</span>` P] `|` [<span class="nb">set</span>` Q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` predU P Q] = [<span class="nb">set</span>` P] `|` [<span class="nb">set</span>` Q]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>f5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/predeqP =&gt; x; <span class="nb">split</span>; <span class="nb">rewrite</span> /= inE =&gt; /orP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fun_true</span> : (<span class="kr">fun</span>=&gt; true) = setT :&gt; <span class="nb">set</span> T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>=&gt; true) = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>fa</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> [LHS]set_true.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fun_false</span> : (<span class="kr">fun</span>=&gt; false) = set0 :&gt; <span class="nb">set</span> T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>=&gt; false) = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ff</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> [LHS]set_false.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_mem_set</span> <span class="nv">A</span> : [<span class="nb">set</span>` A] = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` A] = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>104</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; x/=; <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mem_setE</span> (<span class="nv">P</span> : pred T) : mem [<span class="nb">set</span>` P] = mem P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pred T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mem [<span class="nb">set</span>` P] = mem P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>109</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">congr</span> Mem; <span class="nb">apply</span>/funext=&gt; x; <span class="nb">apply</span>/asboolP/idP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_refl</span> <span class="nv">A</span> : A `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>110</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_trans</span> <span class="nv">B</span> <span class="nv">A</span> <span class="nv">C</span> : A `&lt;=` B -&gt; B `&lt;=` C -&gt; A `&lt;=` C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>B, A, C</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; B `&lt;=` C -&gt; A `&lt;=` C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>115</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; sAB sBC ? ?; <span class="nb">apply</span>/sBC/sAB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub0set</span> <span class="nv">A</span> : set0 `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">set0 `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setC0</span> : ~` set0 = setT :&gt; <span class="nb">set</span> T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` set0 = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>121</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE; <span class="nb">split</span> =&gt; ?.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setCK</span> : involutive (@setC T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">involutive setC</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>126</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> funeqE =&gt; t; <span class="nb">rewrite</span> /setC; <span class="bp">exact</span>: notLR.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setCT</span> : ~` setT = set0 :&gt; <span class="nb">set</span> T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` [<span class="nb">set</span>: T] = set0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>12b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -setC0 setCK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">setC_inj</span> := can_inj setCK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIC</span> : commutative (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">commutative setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>130</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B; <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span>=&gt; [[]|[]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIS</span> <span class="nv">C</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; C `&amp;` A `&lt;=` C `&amp;` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>C, A, B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; C `&amp;` A `&lt;=` C `&amp;` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>135</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; sAB t [Ct At]; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: sAB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setSI</span> <span class="nv">C</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; A `&amp;` C `&lt;=` B `&amp;` C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>137</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; A `&amp;` C `&lt;=` B `&amp;` C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>13c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; sAB; <span class="nb">rewrite</span> -!(setIC C); <span class="nb">apply</span> setIS.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setISS</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : A `&lt;=` C -&gt; B `&lt;=` D -&gt; A `&amp;` B `&lt;=` C `&amp;` D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` C -&gt; B `&lt;=` D -&gt; A `&amp;` B `&lt;=` C `&amp;` D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>141</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /(@setSI B) /subset_trans sAC /(@setIS C) /sAC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIT</span> : right_id setT (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_id [<span class="nb">set</span>: T] setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>148</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span>=&gt; [[]|].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setTI</span> : left_id setT (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_id [<span class="nb">set</span>: T] setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>14d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span>=&gt; [[]|].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setI0</span> : right_zero set0 (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_zero set0 setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>152</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span>=&gt; [[]|].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set0I</span> : left_zero set0 (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_zero set0 setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>157</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> setIC setI0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setICl</span> : left_inverse set0 setC (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_inverse set0 setC setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>15c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span> =&gt; // -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setICr</span> : right_inverse set0 setC (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_inverse set0 setC setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>161</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> setIC setICl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIA</span> : associative (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">associative setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>166</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span>=&gt; [[? []]|[[]]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setICA</span> : left_commutative (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_commutative setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>16b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> setIA [A `&amp;` _]setIC -setIA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIAC</span> : right_commutative (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_commutative setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>170</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> setIC setICA setIA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIACA</span> : @interchange (<span class="nb">set</span> T) setI setI.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">interchange setI setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>175</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C D; <span class="nb">rewrite</span> -setIA [B `&amp;` _]setICA setIA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIid</span> : idempotent (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">idempotent setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>17a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span>=&gt; [[]|].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIIl</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : A `&amp;` B `&amp;` C = (A `&amp;` C) `&amp;` (B `&amp;` C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B `&amp;` C = A `&amp;` C `&amp;` (B `&amp;` C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>17f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setIA !(setIAC _ C) -(setIA _ C) setIid.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIIr</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : A `&amp;` (B `&amp;` C) = (A `&amp;` B) `&amp;` (A `&amp;` C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` (B `&amp;` C) = A `&amp;` B `&amp;` (A `&amp;` C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>186</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !(setIC A) setIIl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUC</span> : commutative (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">commutative setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>18b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; p q; <span class="nb">rewrite</span> /setU/mkset predeqE =&gt; a; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUS</span> <span class="nv">C</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; C `|` A `&lt;=` C `|` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>137</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; C `|` A `&lt;=` C `|` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>190</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; sAB t [Ct|At]; [<span class="nb">left</span>|<span class="nb">right</span>; <span class="bp">exact</span>: sAB].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setSU</span> <span class="nv">C</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; A `|` C `&lt;=` B `|` C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>137</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; A `|` C `&lt;=` B `|` C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>195</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; sAB; <span class="nb">rewrite</span> -!(setUC C); <span class="nb">apply</span> setUS.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUSS</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : A `&lt;=` C -&gt; B `&lt;=` D -&gt; A `|` B `&lt;=` C `|` D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>143</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` C -&gt; B `&lt;=` D -&gt; A `|` B `&lt;=` C `|` D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>19a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /(@setSU B) /subset_trans sAC /(@setUS C) /sAC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setTU</span> : left_zero setT (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_zero [<span class="nb">set</span>: T] setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>19f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>; [<span class="nb">case</span>|<span class="nb">left</span>].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUT</span> : right_zero setT (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_zero [<span class="nb">set</span>: T] setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1a4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>; [<span class="nb">case</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set0U</span> : left_id set0 (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_id set0 setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1a9</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>; [<span class="nb">case</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setU0</span> : right_id set0 (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_id set0 setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1ae</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>; [<span class="nb">case</span>|<span class="nb">left</span>].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUCl</span> : left_inverse setT setC (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_inverse [<span class="nb">set</span>: T] setC setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1b3</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` A `|` A = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; // _; <span class="nb">case</span>: (pselect (A t)); [<span class="nb">right</span>|<span class="nb">left</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUCr</span> : right_inverse setT setC (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_inverse [<span class="nb">set</span>: T] setC setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1bc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A; <span class="nb">rewrite</span> setUC setUCl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUA</span> : associative (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">associative setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1c1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; p q r; <span class="nb">rewrite</span> /setU/mkset predeqE =&gt; a; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUCA</span> : left_commutative (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_commutative setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1c6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> setUA [A `|` _]setUC -setUA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUAC</span> : right_commutative (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_commutative setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1cb</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> setUC setUCA setUA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUACA</span> : @interchange (<span class="nb">set</span> T) setU setU.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">interchange setU setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1d0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C D; <span class="nb">rewrite</span> -setUA [B `|` _]setUCA setUA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUid</span> : idempotent (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">idempotent setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1d5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; p; <span class="nb">rewrite</span> /setU/mkset predeqE =&gt; a; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUUl</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : A `|` B `|` C = (A `|` C) `|` (B `|` C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` B `|` C = A `|` C `|` (B `|` C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1da</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUA !(setUAC _ C) -(setUA _ C) setUid.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUUr</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : A `|` (B `|` C) = (A `|` B) `|` (A `|` C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` (B `|` C) = A `|` B `|` (A `|` C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1df</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !(setUC A) setUUl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDE</span> <span class="nv">A</span> <span class="nv">B</span> : A `\` B = A `&amp;` ~` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` B = A `&amp;` ~` B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1e4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDUK</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; A `|` (B `\` A) = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; A `|` B `\` A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1e9</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; AB; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [x [/AB//|[//]]|x Bx].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><q>da</q><br><q>b</q><br><span><var>Bx</var><span class="hyp-type"><b>: </b><span>B x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `|` B `\` A) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [Ax|nAx] := pselect (A x); [<span class="nb">left</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDKU</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; (B `\` A) `|` A = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; B `\` A `|` A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1f4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /setDUK; <span class="nb">rewrite</span> setUC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDv</span> <span class="nv">A</span> : A `\` A = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` A = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1f9</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; // -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUv</span> <span class="nv">A</span> : A `|` ~` A = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` ~` A = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1fe</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/predeqP =&gt; x; <span class="nb">split</span>=&gt; //= _; <span class="nb">apply</span>: lem.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setvU</span> <span class="nv">A</span> : ~` A `|` A = setT.</label><small class="alectryon-output"><div><q>1b8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1b8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUC setUv.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUCK</span> <span class="nv">A</span> <span class="nv">B</span> : (A `|` B) `|` ~` B = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` B `|` ~` B = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>205</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -setUA setUv setUT.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUKC</span> <span class="nv">A</span> <span class="nv">B</span> : ~` A `|` (A `|` B) = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` A `|` (A `|` B) = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>20a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUA setvU setTU.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setICK</span> <span class="nv">A</span> <span class="nv">B</span> : (A `&amp;` B) `&amp;` ~` B = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B `&amp;` ~` B = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>20f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -setIA setICr setI0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIKC</span> <span class="nv">A</span> <span class="nv">B</span> : ~` A `&amp;` (A `&amp;` B) = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` A `&amp;` (A `&amp;` B) = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>214</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setIA setICl set0I.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDIK</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` (B `\` A) = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` (B `\` A) = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>219</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setDE setICA -setDE setDv setI0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDKI</span> <span class="nv">A</span> <span class="nv">B</span> : (B `\` A) `&amp;` A = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(B `\` A) `&amp;` A = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>21e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setIC setDIK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setD1K</span> <span class="nv">a</span> <span class="nv">A</span> : A a -&gt; a |` A `\ a = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A a -&gt; a |` A `\ a = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>223</q></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Aa; <span class="nb">rewrite</span> setDUK//= =&gt; x -&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setI1</span> <span class="nv">A</span> <span class="nv">a</span> : A `&amp;` [<span class="nb">set</span> a] = <span class="kr">if</span> a \<span class="kr">in</span> A <span class="kr">then</span> [<span class="nb">set</span> a] <span class="kr">else</span> set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br><q>226</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` [<span class="nb">set</span> a] = (<span class="kr">if</span> a \<span class="kr">in</span> A <span class="kr">then</span> [<span class="nb">set</span> a] <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>22a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/predeqP =&gt; b; <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> (inE, notin_set) =&gt; Aa;
   <span class="nb">split</span>=&gt; [[]|]//; [<span class="nb">move</span>=&gt; -&gt; //|<span class="nb">move</span>=&gt; /[<span class="nb">swap</span>] -&gt; /Aa].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set1I</span> <span class="nv">A</span> <span class="nv">a</span> : [<span class="nb">set</span> a] `&amp;` A = <span class="kr">if</span> a \<span class="kr">in</span> A <span class="kr">then</span> [<span class="nb">set</span> a] <span class="kr">else</span> set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>22c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> a] `&amp;` A = (<span class="kr">if</span> a \<span class="kr">in</span> A <span class="kr">then</span> [<span class="nb">set</span> a] <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>230</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setIC setI1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset0</span> <span class="nv">A</span> : (A `&lt;=` set0) = (A = set0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `&lt;=` set0) = (A = set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>235</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset propeqE; <span class="nb">split</span>=&gt; [A0|[]//]; <span class="nb">split</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subTset</span> <span class="nv">A</span> : (setT `&lt;=` A) = (A = setT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">([<span class="nb">set</span>: T] `&lt;=` A) = (A = [<span class="nb">set</span>: T])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>23a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset propeqE; <span class="nb">split</span>=&gt; [|[]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub1set</span> <span class="nv">x</span> <span class="nv">A</span> : ([<span class="nb">set</span> x] `&lt;=` A) = (x \<span class="kr">in</span> A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ac</q><span class="goal-separator"><hr></span><div class="goal-conclusion">([<span class="nb">set</span> x] `&lt;=` A) = (x \<span class="kr">in</span> A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>23f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/propext; <span class="nb">split</span>=&gt; [|/[!inE] xA _ -&gt;//]; <span class="nb">rewrite</span> inE; <span class="bp">exact</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetT</span> <span class="nv">A</span> : A `&lt;=` setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>244</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetW</span> {<span class="nv">A</span> <span class="nv">B</span>} : A = B -&gt; A `&lt;=` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A = B -&gt; A `&lt;=` B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>249</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subsetCW</span> {<span class="nv">A</span> <span class="nv">B</span>} : A = B -&gt; B `&lt;=` A := subsetW \o esym.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disj_set2E</span> <span class="nv">A</span> <span class="nv">B</span> : [disjoint A &amp; B] = (A `&amp;` B == set0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[disjoint A &amp; B] = (A `&amp;` B == set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>24e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disj_set2P</span> {<span class="nv">A</span> <span class="nv">B</span>} : reflect (A `&amp;` B = set0) [disjoint A &amp; B]%classic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (A `&amp;` B = set0) [disjoint A &amp; B]%classic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>253</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/eqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disj_setPS</span> {<span class="nv">A</span> <span class="nv">B</span>} : reflect (A `&amp;` B `&lt;=` set0) [disjoint A &amp; B]%classic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (A `&amp;` B `&lt;=` set0) [disjoint A &amp; B]%classic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>258</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> subset0; <span class="nb">apply</span>: disj_set2P.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disj_set_sym</span> <span class="nv">A</span> <span class="nv">B</span> : [disjoint B &amp; A] = [disjoint A &amp; B].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[disjoint B &amp; A] = [disjoint A &amp; B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>25d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !disj_set2E setIC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disj_setPCl</span> {<span class="nv">A</span> <span class="nv">B</span>} : reflect (A `&lt;=` B) [disjoint A &amp; ~` B]%classic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (A `&lt;=` B) [disjoint A &amp; ~` B]%classic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>262</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP disj_setPS) =&gt; [P t ?|P t [/P//]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A `&amp;` ~` B `&lt;=` set0</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>_Hyp_</var><span class="hyp-type"><b>: </b><span>A t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: contrapT =&gt; ?; <span class="nb">apply</span>: (P t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disj_setPCr</span> {<span class="nv">A</span> <span class="nv">B</span>} : reflect (A `&lt;=` B) [disjoint ~` B &amp; A]%classic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (A `&lt;=` B) [disjoint ~` B &amp; A]%classic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>26f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> disj_set_sym; <span class="nb">apply</span>: disj_setPCl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disj_setPLR</span> {<span class="nv">A</span> <span class="nv">B</span>} : reflect (A `&lt;=` ~` B) [disjoint A &amp; B]%classic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (A `&lt;=` ~` B) [disjoint A &amp; B]%classic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>274</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (equivP idP); <span class="nb">rewrite</span> (rwP disj_setPCl) setCK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disj_setPRL</span> {<span class="nv">A</span> <span class="nv">B</span>} : reflect (B `&lt;=` ~` A) [disjoint A &amp; B]%classic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (B `&lt;=` ~` A) [disjoint A &amp; B]%classic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>279</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (equivP idP); <span class="nb">rewrite</span> (rwP disj_setPCr) setCK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsets_disjoint</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B &lt;-&gt; A `&amp;` ~` B = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B &lt;-&gt; A `&amp;` ~` B = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>27e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (rwP disj_setPCl) (rwP eqP).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disjoints_subset</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` B = set0 &lt;-&gt; A `&lt;=` ~` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B = set0 &lt;-&gt; A `&lt;=` ~` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>283</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> subsets_disjoint setCK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetC1</span> <span class="nv">x</span> <span class="nv">A</span> : (A `&lt;=` [<span class="nb">set</span>~ x]) = (x \<span class="kr">in</span> ~` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ac</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `&lt;=` [<span class="nb">set</span>~ x]) = (x \<span class="kr">in</span> ~` A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>288</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> !inE; <span class="nb">apply</span>/propext; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>/[<span class="nb">apply</span>]; <span class="nb">apply</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ac</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~` A) x -&gt; A `&lt;=` [<span class="nb">set</span>~ x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; NAx y; <span class="nb">apply</span>: contraPnot =&gt; -&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setSD</span> <span class="nv">C</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; A `\` C `&lt;=` B `\` C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>137</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; A `\` C `&lt;=` B `\` C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>291</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !setDE; <span class="nb">apply</span>: setSI.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setTD</span> <span class="nv">A</span> : setT `\` A = ~` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>: T] `\` A = ~` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>296</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; // -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set0P</span> <span class="nv">A</span> : (A != set0) &lt;-&gt; (A !=set0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A != set0 &lt;-&gt; A !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>29b</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [/negP A_neq0|[t tA]]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>/negP =&gt; /eqP A0; <span class="nb">rewrite</span> A0 <span class="kr">in</span> tA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br><span><var>A_neq0</var><span class="hyp-type"><b>: </b><span>~ A == set0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: contrapT =&gt; /asboolPn/forallp_asboolPn A0; <span class="nb">apply</span>/A_neq0/eqP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br><q>2a3</q><br><span><var>A0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : T, ~ A x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setF_eq0</span> : (T -&gt; <span class="kt">False</span>) -&gt; all_equal_to (set0 : <span class="nb">set</span> T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(T -&gt; <span class="kt">False</span>) -&gt; all_equal_to (set0 : <span class="nb">set</span> T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2ac</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; TF A; <span class="nb">rewrite</span> -subset0 =&gt; x; <span class="nb">have</span> := TF x.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_nonempty</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; A !=set0 -&gt; B !=set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; A !=set0 -&gt; B !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2b1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; sAB [x Ax]; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">apply</span>: sAB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetC</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; ~` B `&lt;=` ~` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; ~` B `&lt;=` ~` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2b6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; sAB ? nBa ?; <span class="nb">apply</span>/nBa/sAB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetCl</span> <span class="nv">A</span> <span class="nv">B</span> : ~` A `&lt;=` B -&gt; ~` B `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` A `&lt;=` B -&gt; ~` B `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2bb</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /subsetC; <span class="nb">rewrite</span> setCK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetCr</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` ~` B -&gt; B `&lt;=` ~` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` ~` B -&gt; B `&lt;=` ~` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2c0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /subsetC; <span class="nb">rewrite</span> setCK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetC2</span> <span class="nv">A</span> <span class="nv">B</span> : ~` A `&lt;=` ~` B -&gt; B `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` A `&lt;=` ~` B -&gt; B `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2c5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /subsetC; <span class="nb">rewrite</span> !setCK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetCP</span> <span class="nv">A</span> <span class="nv">B</span> : ~` A `&lt;=` ~` B &lt;-&gt; B `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` A `&lt;=` ~` B &lt;-&gt; B `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2ca</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; /subsetC; <span class="nb">rewrite</span> <span class="nl">?setCK</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetCPl</span> <span class="nv">A</span> <span class="nv">B</span> : ~` A `&lt;=` B &lt;-&gt; ~` B `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` A `&lt;=` B &lt;-&gt; ~` B `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2cf</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; /subsetC; <span class="nb">rewrite</span> <span class="nl">?setCK</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetCPr</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` ~` B &lt;-&gt; B `&lt;=` ~` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` ~` B &lt;-&gt; B `&lt;=` ~` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2d4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; /subsetC; <span class="nb">rewrite</span> <span class="nl">?setCK</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetUl</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` A `|` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` A `|` B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2d9</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">left</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetUr</span> <span class="nv">A</span> <span class="nv">B</span> : B `&lt;=` A `|` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">B `&lt;=` A `|` B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2de</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">right</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subUset</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : (B `|` C `&lt;=` A) = ((B `&lt;=` A) /\ (C `&lt;=` A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(B `|` C `&lt;=` A) = (B `&lt;=` A /\ C `&lt;=` A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2e3</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [|[BA CA] x]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>; [<span class="bp">exact</span>: BA | <span class="bp">exact</span>: CA].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">B `|` C `&lt;=` A -&gt; B `&lt;=` A /\ C `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; sBC_A; <span class="nb">split</span>=&gt; x ?; <span class="nb">apply</span> sBC_A; [<span class="nb">left</span> | <span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIidPl</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` B = A &lt;-&gt; A `&lt;=` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B = A &lt;-&gt; A `&lt;=` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2ec</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE; <span class="nb">split</span>=&gt; [AB t /AB [] //|AB t].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><q>da</q><br><q>26b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `&amp;` B) t &lt;-&gt; A t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; [[]//|At]; <span class="nb">split</span>=&gt; //; <span class="bp">exact</span>: AB.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIidPr</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` B = B &lt;-&gt; B `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B = B &lt;-&gt; B `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2f6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setIC setIidPl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIidl</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; A `&amp;` B = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; A `&amp;` B = A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2fb</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setIidPl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIidr</span> <span class="nv">A</span> <span class="nv">B</span> : B `&lt;=` A -&gt; A `&amp;` B = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">B `&lt;=` A -&gt; A `&amp;` B = B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>300</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setIidPr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUidPl</span> <span class="nv">A</span> <span class="nv">B</span> : A `|` B = A &lt;-&gt; B `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` B = A &lt;-&gt; B `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>305</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [&lt;- ? ?|BA]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><q>db</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` B = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [[//|/BA//]|?]; <span class="bp">by</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUidPr</span> <span class="nv">A</span> <span class="nv">B</span> : A `|` B = B &lt;-&gt; A `&lt;=` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` B = B &lt;-&gt; A `&lt;=` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>30f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUC setUidPl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUidl</span> <span class="nv">A</span> <span class="nv">B</span> : B `&lt;=` A -&gt; A `|` B = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">B `&lt;=` A -&gt; A `|` B = A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>314</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUidPl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUidr</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; A `|` B = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; A `|` B = B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>319</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUidPr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetI</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : (A `&lt;=` B `&amp;` C) = ((A `&lt;=` B) /\ (A `&lt;=` C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `&lt;=` B `&amp;` C) = (A `&lt;=` B /\ A `&lt;=` C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>31e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [H|[y z ??]]; <span class="nb">split</span>; <span class="bp">by</span> [<span class="nb">move</span>=&gt; ?/H[]|<span class="nb">apply</span> y|<span class="nb">apply</span> z].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDidPl</span> <span class="nv">A</span> <span class="nv">B</span> : A `\` B = A &lt;-&gt; A `&amp;` B = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` B = A &lt;-&gt; A `&amp;` B = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>323</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> setDE disjoints_subset predeqE; <span class="nb">split</span> =&gt; [AB t|AB t].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><span><var>AB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : T, (A `&amp;` ~` B) x &lt;-&gt; A x</span></span></span><br><q>26b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A t -&gt; (~` B) t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><span><var>AB</var><span class="hyp-type"><b>: </b><span>A `&lt;=` ~` B</span></span></span><br><q>26b</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">(A `&amp;` ~` B) t &lt;-&gt; A t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -AB =&gt; -[].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>32f</q><span class="goal-separator"><hr></span><q>331</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; [[]//|At]; <span class="nb">move</span>: (AB t At).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDidl</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` B = set0 -&gt; A `\` B = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B = set0 -&gt; A `\` B = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>336</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /setDidPl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subIset</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : A `&lt;=` C \/ B `&lt;=` C -&gt; A `&amp;` B `&lt;=` C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` C \/ B `&lt;=` C -&gt; A `&amp;` B `&lt;=` C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>33b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">case</span>=&gt; sub a; <span class="bp">by</span> [<span class="nb">move</span>=&gt; [/sub] | <span class="nb">move</span>=&gt; [_ /sub]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subIsetl</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` B `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>340</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subIsetr</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` B `&lt;=` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B `&lt;=` B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>345</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subDsetl</span> <span class="nv">A</span> <span class="nv">B</span> : A `\` B `&lt;=` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` B `&lt;=` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>34a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setDE; <span class="nb">apply</span>: subIsetl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subDsetr</span> <span class="nv">A</span> <span class="nv">B</span> : A `\` B `&lt;=` ~` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` B `&lt;=` ~` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>34f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setDE; <span class="nb">apply</span>: subIsetr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetI_neq0</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> :
  A `&lt;=` B -&gt; C `&lt;=` D -&gt; A `&amp;` C !=set0 -&gt; B `&amp;` D !=set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>143</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt;
C `&lt;=` D -&gt; A `&amp;` C !=set0 -&gt; B `&amp;` D !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>354</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; AB CD [x [/AB Bx /CD Dx]]; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetI_eq0</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> :
  A `&lt;=` B -&gt; C `&lt;=` D -&gt; B `&amp;` D = set0 -&gt; A `&amp;` C = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>143</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt;
C `&lt;=` D -&gt; B `&amp;` D = set0 -&gt; A `&amp;` C = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>359</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; AB /(subsetI_neq0 AB); <span class="nb">rewrite</span> -!set0P =&gt; /contra_eq.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setD_eq0</span> <span class="nv">A</span> <span class="nv">B</span> : (A `\` B = set0) = (A `&lt;=` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `\` B = set0) = (A `&lt;=` B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>35e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [ADB0 a|sAB].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><span><var>ADB0</var><span class="hyp-type"><b>: </b><span>A `\` B = set0</span></span></span><br><q>226</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A a -&gt; B a</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><span><var>sAB</var><span class="hyp-type"><b>: </b><span>A `&lt;=` B</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">A `\` B = set0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: contraPP =&gt; nBa xA; <span class="nb">rewrite</span> -[<span class="kt">False</span>]/(set0 a) -ADB0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>36a</q><span class="goal-separator"><hr></span><q>36c</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span>=&gt; // - [?]; <span class="nb">apply</span>; <span class="nb">apply</span>: sAB.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">properEneq</span> <span class="nv">A</span> <span class="nv">B</span> : (A `&lt;` B) = (A != B /\ A `&lt;=` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `&lt;` B) = (A != B /\ A `&lt;=` B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>371</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /proper andC propeqE; <span class="nb">split</span> =&gt; [[BA AB]|[/eqP]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><span><var>BA</var><span class="hyp-type"><b>: </b><span>~ B `&lt;=` A</span></span></span><br><q>da</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A != B /\ A `&lt;=` B</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>d3</q><label class="goal-separator"><hr></label><div class="goal-conclusion">A &lt;&gt; B -&gt; A `&lt;=` B -&gt; ~ B `&lt;=` A /\ A `&lt;=` B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>/negP; <span class="nb">apply</span>: contra_not BA =&gt; /eqP -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><q>37d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset =&gt; AB BA; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: contra_not AB.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">nonsubset</span> <span class="nv">A</span> <span class="nv">B</span> : ~ (A `&lt;=` B) -&gt; A `&amp;` ~` B !=set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ A `&lt;=` B -&gt; A `&amp;` ~` B !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>382</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -setD_eq0 setDE -set0P =&gt; /eqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setU_eq0</span> <span class="nv">A</span> <span class="nv">B</span> : (A `|` B = set0) = ((A = set0) /\ (B = set0)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `|` B = set0) = (A = set0 /\ B = set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>387</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -!subset0 subUset.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setCS</span> <span class="nv">A</span> <span class="nv">B</span> : (~` A `&lt;=` ~` B) = (B `&lt;=` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~` A `&lt;=` ~` B) = (B `&lt;=` A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>38c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [|BA].</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>2c6</q><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>30c</q><label class="goal-separator"><hr></label><div class="goal-conclusion">~` A `&lt;=` ~` B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/subsets_disjoint; <span class="nb">rewrite</span> setCK setIC =&gt; /subsets_disjoint.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>30c</q><span class="goal-separator"><hr></span><q>394</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/subsets_disjoint; <span class="nb">rewrite</span> setCK setIC; <span class="nb">apply</span>/subsets_disjoint.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDT</span> <span class="nv">A</span> : A `\` setT = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` [<span class="nb">set</span>: T] = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>399</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setDE setCT setI0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set0D</span> <span class="nv">A</span> : set0 `\` A = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">set0 `\` A = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>39e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setDE set0I.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setD0</span> <span class="nv">A</span> : A `\` set0 = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` set0 = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3a3</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setDE setC0 setIT.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDS</span> <span class="nv">C</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; C `\` B `&lt;=` C `\` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>137</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; C `\` B `&lt;=` C `\` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3a8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !setDE -setCS; <span class="nb">apply</span>: setIS.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDSS</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : A `&lt;=` C -&gt; D `&lt;=` B -&gt; A `\` B `&lt;=` C `\` D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>143</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` C -&gt; D `&lt;=` B -&gt; A `\` B `&lt;=` C `\` D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3ad</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /(@setSD B) /subset_trans sAC /(@setDS C) /sAC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setCU</span> <span class="nv">A</span> <span class="nv">B</span> : ~`(A `|` B) = ~` A `&amp;` ~` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` (A `|` B) = ~` A `&amp;` ~` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3b2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><span><var>z</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(~` (A `|` B)) z &lt;-&gt; (~` A `&amp;` ~` B) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: asbool_eq_equiv; <span class="nb">rewrite</span> asbool_and !asbool_neg asbool_or negb_or.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setCI</span> <span class="nv">A</span> <span class="nv">B</span> : ~` (A `&amp;` B) = ~` A `|` ~` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` (A `&amp;` B) = ~` A `|` ~` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3bd</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -[<span class="kr">in</span> LHS](setCK A) -[<span class="kr">in</span> LHS](setCK B) -setCU setCK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDUr</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : A `\` (B `|` C) = (A `\` B) `&amp;` (A `\` C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` (B `|` C) = (A `\` B) `&amp;` (A `\` C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3c2</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !setDE setCU setIIr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIUl</span> : left_distributive (@setI T) (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_distributive setI setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3c7</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>182</q><br><q>26b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((A `|` B) `&amp;` C) t -&gt; (A `&amp;` C `|` B `&amp;` C) t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>3ce</q><label class="goal-separator"><hr></label><div class="goal-conclusion">(A `&amp;` C `|` B `&amp;` C) t -&gt; ((A `|` B) `&amp;` C) t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [[At|Bt] Ct]; [<span class="nb">left</span>|<span class="nb">right</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ce</q><span class="goal-separator"><hr></span><q>3d2</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [[At Ct]|[Bt Ct]]; <span class="nb">split</span> =&gt; //; [<span class="nb">left</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIUr</span> : right_distributive (@setI T) (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_distributive setI setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3d7</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> ![A `&amp;` _]setIC setIUl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUIl</span> : left_distributive (@setU T) (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_distributive setU setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3dc</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ce</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `&amp;` B `|` C) t -&gt; ((A `|` C) `&amp;` (B `|` C)) t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>3ce</q><label class="goal-separator"><hr></label><div class="goal-conclusion">((A `|` C) `&amp;` (B `|` C)) t -&gt; (A `&amp;` B `|` C) t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [[At Bt]|Ct]; <span class="nb">split</span>; <span class="bp">by</span> [<span class="nb">left</span>|<span class="nb">right</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ce</q><span class="goal-separator"><hr></span><q>3e6</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [[At|Ct] [Bt|Ct&#39;]]; <span class="bp">by</span> [<span class="nb">left</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUIr</span> : right_distributive (@setU T) (@setI T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">right_distributive setU setI</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3eb</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> ![A `|` _]setUC setUIl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUK</span> <span class="nv">A</span> <span class="nv">B</span> : (A `|` B) `&amp;` A = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `|` B) `&amp;` A = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3f0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [t []//|t ?]; <span class="nb">split</span> =&gt; //; <span class="nb">left</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setKU</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` (B `|` A) = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` (B `|` A) = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3f5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [t []//|t ?]; <span class="nb">split</span> =&gt; //; <span class="nb">right</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIK</span> <span class="nv">A</span> <span class="nv">B</span> : (A `&amp;` B) `|` A = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B `|` A = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3fa</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [t [[]//|//]|t At]; <span class="nb">right</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setKI</span> <span class="nv">A</span> <span class="nv">B</span> : A `|` (B `&amp;` A) = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` B `&amp;` A = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3ff</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [t [//|[]//]|t At]; <span class="nb">left</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDUl</span> : left_distributive setD (@setU T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">left_distributive setD setU</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>404</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B C; <span class="nb">rewrite</span> !setDE setIUl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUKD</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` B `&lt;=` set0 -&gt; (A `|` B) `\` A = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B `&lt;=` set0 -&gt; (A `|` B) `\` A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>409</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; AB0; <span class="nb">rewrite</span> setDUl setDv set0U setDidl// -subset0 setIC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUDK</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` B `&lt;=` set0 -&gt; (B `|` A) `\` A = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B `&lt;=` set0 -&gt; (B `|` A) `\` A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>40e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> setUC setUKD.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setIDA</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : A `&amp;` (B `\` C) = (A `&amp;` B) `\` C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` (B `\` C) = A `&amp;` B `\` C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>413</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !setDE setIA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDD</span> <span class="nv">A</span> <span class="nv">B</span> : A `\` (A `\` B) = A `&amp;` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` (A `\` B) = A `&amp;` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>418</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span>!setDE setCI setCK setIUr setICr set0U.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDDl</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : (A `\` B) `\` C = A `\` (B `|` C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` B `\` C = A `\` (B `|` C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>41d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !setDE setCU setIA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDDr</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : A `\` (B `\` C) = (A `\` B) `|` (A `&amp;` C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` (B `\` C) = A `\` B `|` A `&amp;` C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>422</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !setDE setCI setIUr setCK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setDIr</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : A `\` B `&amp;` C = (A `\` B) `|` (A `\` C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>181</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `\` B `&amp;` C = A `\` B `|` A `\` C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>427</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !setDE setCI setIUr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setUIDK</span> <span class="nv">A</span> <span class="nv">B</span> : (A `&amp;` B) `|` A `\` B = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` B `|` A `\` B = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>42c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUC -setDDr setDv setD0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setM0</span> <span class="nv">T&#39;</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : A `*` set0 = set0 :&gt; <span class="nb">set</span> (T * T&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c4</q><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `*` set0 = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>431</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; -[t u]; <span class="nb">split</span> =&gt; // -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set0M</span> <span class="nv">T&#39;</span> (<span class="nv">A</span> : <span class="nb">set</span> T&#39;) : set0 `*` A = set0 :&gt; <span class="nb">set</span> (T * T&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c4</q><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set0 `*` A = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>437</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; -[t u]; <span class="nb">split</span> =&gt; // -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setMTT</span> <span class="nv">T&#39;</span> : setT `*` setT = setT :&gt; <span class="nb">set</span> (T * T&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>: T] `*` [<span class="nb">set</span>: T&#39;] = [<span class="nb">set</span>: T * T&#39;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>43e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/predeqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setMT</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">A</span> : <span class="nb">set</span> T1) : A `*` @setT T2 = fst @^-<span class="mi">1</span>` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, T1, T2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `*` [<span class="nb">set</span>: T2] = fst @^-<span class="mi">1</span>` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>444</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; -[x y]; <span class="nb">split</span> =&gt; //= -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setTM</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">B</span> : <span class="nb">set</span> T2) : @setT T1 `*` B = snd @^-<span class="mi">1</span>` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>447</q><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>: T1] `*` B = snd @^-<span class="mi">1</span>` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>44c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; -[x y]; <span class="nb">split</span> =&gt; //= -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setMI</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">X1</span> : <span class="nb">set</span> T1) (<span class="nv">X2</span> : <span class="nb">set</span> T2) (<span class="nv">Y1</span> : <span class="nb">set</span> T1) (<span class="nv">Y2</span> : <span class="nb">set</span> T2) :
  (X1 `&amp;` Y1) `*` (X2 `&amp;` Y2) = X1 `*` X2 `&amp;` Y1 `*` Y2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>447</q><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T1</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T2</span></span></span><br><span><var>Y1</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T1</span></span></span><br><span><var>Y2</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X1 `&amp;` Y1) `*` (X2 `&amp;` Y2) = X1 `*` X2 `&amp;` Y1 `*` Y2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>453</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; -[x y]; <span class="nb">split</span>=&gt; [[[? ?] [*]//]|[] [? ?] [*]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setSM</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="nb">set</span> T1) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T2) :
  A `&lt;=` B -&gt; C `&lt;=` D -&gt; C `*` A `&lt;=` D `*` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>447</q><br><span><var>C, D</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; C `&lt;=` D -&gt; C `*` A `&lt;=` D `*` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>45d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; AB CD x [] /CD Dx1 /AB Bx2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setM_bigcupr</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">I</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T2) (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">A</span> : <span class="nb">set</span> T1) :
  A `*` \bigcup_(i <span class="kr">in</span> P) F i = \bigcup_(i <span class="kr">in</span> P) (A `*` F i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, T1, T2, I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>I -&gt; <span class="nb">set</span> T2</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> I</span></span></span><br><q>448</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `*` \bigcup_(i <span class="kr">in</span> P) F i =
\bigcup_(i <span class="kr">in</span> P) (A `*` F i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>465</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; -[x y]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; [/= Ax [n Pn Fny]]; <span class="kr">exists</span> <span class="nv">n</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>468</q><br><q>469</q><br><q>46a</q><br><q>448</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(i <span class="kr">in</span> P) (A `*` F i)) (x, y) -&gt;
(A `*` \bigcup_(i <span class="kr">in</span> P) F i) (x, y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [n Pn [/= Ax Fny]]; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">n</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setM_bigcupl</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">I</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T2) (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">A</span> : <span class="nb">set</span> T1) :
  \bigcup_(i <span class="kr">in</span> P) F i `*` A = \bigcup_(i <span class="kr">in</span> P) (F i `*` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>467</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) F i `*` A =
\bigcup_(i <span class="kr">in</span> P) (F i `*` A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>475</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; -[x y]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; [[n Pn Fnx] Ax]; <span class="kr">exists</span> <span class="nv">n</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>468</q><br><q>469</q><br><q>46a</q><br><q>448</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>T1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(i <span class="kr">in</span> P) (F i `*` A)) (x, y) -&gt;
(\bigcup_(i <span class="kr">in</span> P) F i `*` A) (x, y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [n Pn [/= Ax Fny]]; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">n</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcupM1l</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">A1</span> : <span class="nb">set</span> T1) (<span class="nv">A2</span> : T1 -&gt; <span class="nb">set</span> T2) :
  \bigcup_(i <span class="kr">in</span> A1) ([<span class="nb">set</span> i] `*` (A2 i)) = A1 `*`` A2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>447</q><br><span><var>A1</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T1</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>T1 -&gt; <span class="nb">set</span> T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> A1) ([<span class="nb">set</span> i] `*` A2 i) = A1 `*`` A2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>481</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/predeqP =&gt; -[i j]; <span class="nb">split</span>=&gt; [[? ? [/= -&gt; //]]|[]]; <span class="kr">exists</span> <span class="nv">i</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcupM1r</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">A1</span> : T2 -&gt; <span class="nb">set</span> T1) (<span class="nv">A2</span> : <span class="nb">set</span> T2) :
  \bigcup_(i <span class="kr">in</span> A2) (A1 i `*` [<span class="nb">set</span> i]) = A1 ``*` A2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>447</q><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>T2 -&gt; <span class="nb">set</span> T1</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> A2) (A1 i `*` [<span class="nb">set</span> i]) = A1 ``*` A2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>489</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/predeqP =&gt; -[i j]; <span class="nb">split</span>=&gt; [[? ? [? /= -&gt; //]]|[]]; <span class="kr">exists</span> <span class="nv">j</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">basic_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Hint Resolve</span> subsetUl subsetUr subIsetl subIsetr subDsetl subDsetr : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6&quot;</span>, note=<span class="s2">&quot;Use setICl instead.&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">setvI</span> := setICl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6&quot;</span>, note=<span class="s2">&quot;Use setICr instead.&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">setIv</span> := setICr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image2E</span> {<span class="nv">TA</span> <span class="nv">TB</span> <span class="nv">rT</span> : <span class="kt">Type</span>} (<span class="nv">A</span> : <span class="nb">set</span> TA) (<span class="nv">B</span> : <span class="nb">set</span> TB) (<span class="nv">f</span> : TA -&gt; TB -&gt; rT) :
  [<span class="nb">set</span> f x y | x <span class="kr">in</span> A &amp; y <span class="kr">in</span> B] = uncurry f @` (A `*` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>TA, TB, rT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> TA</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> TB</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>TA -&gt; TB -&gt; rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x y | x <span class="kr">in</span> A &amp; y <span class="kr">in</span> B] =
[<span class="nb">set</span> uncurry f x | x <span class="kr">in</span> A `*` B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>491</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span>/predeqP =&gt; x; <span class="nb">split</span>=&gt; [[a ? [b ? &lt;-]]|[[a b] [? ? &lt;-]]]/=;
<span class="bp">by</span> [<span class="kr">exists</span> (<span class="nv">a</span>, b) | <span class="kr">exists</span> <span class="nv">a</span> =&gt; //; <span class="kr">exists</span> <span class="nv">b</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_nil</span> (<span class="nv">T</span> : choiceType) : [<span class="nb">set</span>` [::]] = @set0 T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span>choiceType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` [::]] = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>49b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_seq_eq0</span> (<span class="nv">T</span> : eqType) (<span class="nv">S</span> : seq T) : ([<span class="nb">set</span>` S] == set0) = (S == [::]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span>eqType</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>seq T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([<span class="nb">set</span>` S] == set0) = (S == [::])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4a2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/eqP/eqP=&gt; [|-&gt;]; <span class="nb">rewrite</span> predeqE //; <span class="nb">case</span>: S =&gt; // h t /(_ h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><span><var>h</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>seq T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` h :: t] h &lt;-&gt; set0 h -&gt; h :: t = [::]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /= mem_head =&gt; -[/(_ erefl)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_fset_eq0</span> (<span class="nv">T</span> : choiceType) (<span class="nv">S</span> : {fset T}) :
  ([<span class="nb">set</span>` S] == set0) = (S == fset0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><span><var>S</var><span class="hyp-type"><b>: </b><span>{fset T}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([<span class="nb">set</span>` S] == set0) = (S == fset0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4b1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> set_seq_eq0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">InitialSegment</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">II0</span> : `I_0 = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_0 = set0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4b8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">II1</span> : `I_1 = [<span class="nb">set</span> <span class="mi">0</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_1 = [<span class="nb">set</span> <span class="mi">0</span>]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4bd</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE; <span class="nb">case</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">IIn_eq0</span> <span class="nv">n</span> : `I_n = set0 -&gt; n = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_n = set0 -&gt; n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4c2</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: n =&gt; // n; <span class="nb">rewrite</span> predeqE; <span class="nb">case</span>/(_ <span class="mi">0</span>%N); <span class="nb">case</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">IIS</span> <span class="nv">n</span> : `I_n.+<span class="mi">1</span> = `I_n `|` [<span class="nb">set</span> n].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4c4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_n.+<span class="mi">1</span> = `I_n `|` [<span class="nb">set</span> n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4c9</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /mkset predeqE =&gt; i; <span class="nb">split</span> =&gt; [|[|-&gt;//]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt; n.+<span class="mi">1</span> -&gt; ((<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; k &lt; n) `|` [<span class="nb">set</span> n]) i</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>4d0</q><label class="goal-separator"><hr></label><div class="goal-conclusion">i &lt; n -&gt; i &lt; n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ltnS leq_eqVlt =&gt; /orP[/eqP -&gt;|]; <span class="bp">by</span> [<span class="nb">left</span>|<span class="nb">right</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4d0</q><span class="goal-separator"><hr></span><q>4d5</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/ltn_trans; <span class="nb">apply</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">IISl</span> <span class="nv">n</span> : `I_n.+<span class="mi">1</span> = n |` `I_n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4c4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_n.+<span class="mi">1</span> = n |` `I_n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4da</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUC IIS.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">IIDn</span> <span class="nv">n</span> : `I_n.+<span class="mi">1</span> `\ n = `I_n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4c4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_n.+<span class="mi">1</span> `\ n = `I_n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4df</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IIS setUDK// =&gt; x [-&gt;/=]; <span class="nb">rewrite</span> ltnn.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setI_II</span> <span class="nv">m</span> <span class="nv">n</span> : `I_m `&amp;` `I_n = `I_(minn m n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_m `&amp;` `I_n = `I_(minn m n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4e4</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: leqP =&gt; mn; [<span class="nb">rewrite</span> setIidl// | <span class="nb">rewrite</span> setIidr//]
   =&gt; k /= /leq_trans; <span class="nb">apply</span> =&gt; //; <span class="nb">apply</span>: ltnW.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setU_II</span> <span class="nv">m</span> <span class="nv">n</span> : `I_m `|` `I_n = `I_(maxn m n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4e6</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_m `|` `I_n = `I_(maxn m n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4eb</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: leqP =&gt; mn; [<span class="nb">rewrite</span> setUidr// | <span class="nb">rewrite</span> setUidl//]
   =&gt; k /= /leq_trans; <span class="nb">apply</span> =&gt; //; <span class="nb">apply</span>: ltnW.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">Iiota</span> (<span class="nv">n</span> : nat) : [<span class="nb">set</span>` iota <span class="mi">0</span> n] = `I_n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4c4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` iota <span class="mi">0</span> n] = `I_n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4f0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; [|] ?; <span class="nb">rewrite</span> /= mem_iota add0n.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ordII</span> {<span class="nv">n</span>} (<span class="nv">k</span> : &#39;I_n) : `I_n := SigSub (@mem_set _ `I_n _ (ltn_ord k)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IIord</span> {<span class="nv">n</span>} (<span class="nv">k</span> : `I_n) := Ordinal (set_valP k).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ordIIK</span> {<span class="nv">n</span>} : cancel (@ordII n) IIord.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4c4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel ordII IIord</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4f5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">apply</span>/val_inj.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">IIordK</span> {<span class="nv">n</span>} : cancel (@IIord n) ordII.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4c4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel IIord ordII</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4fa</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">apply</span>/val_inj.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">InitialSegment</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setT_unit</span> : [<span class="nb">set</span>: unit] = [<span class="nb">set</span> tt].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>: unit] = [<span class="nb">set</span> tt]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4ff</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; // -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_unit</span> (<span class="nv">A</span> : <span class="nb">set</span> unit) : A = set0 \/ A = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A = set0 \/ A = [<span class="nb">set</span>: unit]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>504</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [-&gt;|/set0P[[] Att]] := eqVneq A set0; [<span class="bp">by</span> <span class="nb">left</span>|<span class="nb">right</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>507</q><br><span><var>Att</var><span class="hyp-type"><b>: </b><span>A tt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A = [<span class="nb">set</span>: unit]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; [|] [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setT_bool</span> : [<span class="nb">set</span>: bool] = [<span class="nb">set</span> true; false].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>: bool] = [<span class="nb">set</span> true; false]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>511</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; // [[]] // _; [<span class="nb">left</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_bool</span> (<span class="nv">B</span> : <span class="nb">set</span> bool) :
  [\/ B == [<span class="nb">set</span> true], B == [<span class="nb">set</span> false], B == set0 | B == setT].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[\/ B == [<span class="nb">set</span> true], B == [<span class="nb">set</span> false], B == set0
  | B == [<span class="nb">set</span>: bool]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>516</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [Bt|Bt] := boolP (true \<span class="kr">in</span> B); <span class="nb">have</span> [Bf|Bf] := boolP (false \<span class="kr">in</span> B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>519</q><br><span><var>Bt</var><span class="hyp-type"><b>: </b><span>true \<span class="kr">in</span> B</span></span></span><br><span><var>Bf</var><span class="hyp-type"><b>: </b><span>false \<span class="kr">in</span> B</span></span></span><br></div><span class="goal-separator"><hr></span><q>51a</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>519</q><br><q>520</q><br><span><var>Bf</var><span class="hyp-type"><b>: </b><span>false \notin B</span></span></span><br></div><label class="goal-separator"><hr></label><q>51a</q></blockquote><blockquote class="alectryon-goal"><div class="goal-hyps"><q>519</q><br><span><var>Bt</var><span class="hyp-type"><b>: </b><span>true \notin B</span></span></span><br><q>521</q><br></div><label class="goal-separator"><hr></label><q>51a</q></blockquote><blockquote class="alectryon-goal"><div class="goal-hyps"><q>519</q><br><q>528</q><br><q>525</q><br></div><label class="goal-separator"><hr></label><q>51a</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>51d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> -&gt; : B = setT <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; // -[] _; <span class="bp">exact</span>: set_mem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>51f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[\/ [<span class="nb">set</span>: bool] == [<span class="nb">set</span> true],
    [<span class="nb">set</span>: bool] == [<span class="nb">set</span> false], [<span class="nb">set</span>: bool] == set0
  | [<span class="nb">set</span>: bool] == [<span class="nb">set</span>: bool]]</div></blockquote><q>522</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/or4P; <span class="nb">rewrite</span> eqxx/= !orbT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>524</q><span class="goal-separator"><hr></span><q>51a</q></blockquote><div class="alectryon-extra-goals"><q>526</q><q>529</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>531</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">suff</span> : B = [<span class="nb">set</span> true] <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">apply</span>/or4P; <span class="nb">rewrite</span> eqxx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>524</q><span class="goal-separator"><hr></span><div class="goal-conclusion">B = [<span class="nb">set</span> true]</div></blockquote><q>533</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; -[]// /mem_set; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="bp">exact</span>: set_mem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>524</q><span class="goal-separator"><hr></span><div class="goal-conclusion">false \<span class="kr">in</span> B -&gt; [<span class="nb">set</span> true] false</div></blockquote><q>533</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (negbTE Bf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>527</q><span class="goal-separator"><hr></span><q>51a</q></blockquote><div class="alectryon-extra-goals"><q>529</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>53e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">suff</span> : B = [<span class="nb">set</span> false] <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">apply</span>/or4P; <span class="nb">rewrite</span> eqxx/= orbT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>527</q><span class="goal-separator"><hr></span><div class="goal-conclusion">B = [<span class="nb">set</span> false]</div></blockquote><q>540</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; -[]// /mem_set; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="bp">exact</span>: set_mem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>527</q><span class="goal-separator"><hr></span><div class="goal-conclusion">true \<span class="kr">in</span> B -&gt; [<span class="nb">set</span> false] true</div></blockquote><q>540</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (negbTE Bt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>52a</q><span class="goal-separator"><hr></span><q>51a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>54b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">suff</span> : B = set0 <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">apply</span>/or4P; <span class="nb">rewrite</span> eqxx/= !orbT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>52a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">B = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; -[]//=; <span class="nb">rewrite</span> <span class="mi">2</span>!notin_set <span class="kr">in</span> Bt, Bf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* TODO: other lemmas that relate fset and classical sets *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fdisjoint_cset</span> (<span class="nv">T</span> : choiceType) (<span class="nv">A</span> <span class="nv">B</span> : {fset T}) :
  [disjoint A &amp; B]%fset = [disjoint [<span class="nb">set</span>` A] &amp; [<span class="nb">set</span>` B]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>{fset T}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[disjoint A &amp; B]%fset = [disjoint [<span class="nb">set</span>` A] &amp; [<span class="nb">set</span>` B]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>553</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -fsetI_eq0; <span class="nb">apply</span>/idP/idP; <span class="nb">apply</span>: contraLR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>555</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ [disjoint [<span class="nb">set</span>` A] &amp; [<span class="nb">set</span>` B]]%classic -&gt;
(A `&amp;` B)%fset != fset0</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>555</q><label class="goal-separator"><hr></label><div class="goal-conclusion">(A `&amp;` B)%fset != fset0 -&gt;
~~ [disjoint [<span class="nb">set</span>` A] &amp; [<span class="nb">set</span>` B]]%classic</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /set0P[t [tA tB]]; <span class="nb">apply</span>/fset0Pn; <span class="kr">exists</span> <span class="nv">t</span>; <span class="nb">rewrite</span> inE; <span class="nb">apply</span>/andP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>555</q><span class="goal-separator"><hr></span><q>55f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /fset0Pn[t]; <span class="nb">rewrite</span> inE =&gt; /andP[tA tB]; <span class="nb">apply</span>/set0P; <span class="kr">exists</span> <span class="nv">t</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">SetFset</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span> : choiceType}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">x</span> <span class="nv">y</span> : T) (<span class="nv">A</span> <span class="nv">B</span> : {fset T}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_fset0</span> : [<span class="nb">set</span> y : T | y \<span class="kr">in</span> fset0] = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>49d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` fset0] = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>564</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -subset0 =&gt; x.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_fset1</span> <span class="nv">x</span> : [<span class="nb">set</span> y | y \<span class="kr">in</span> [fset x]%fset] = [<span class="nb">set</span> x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` [fset x]%fset] = [<span class="nb">set</span> x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>569</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; y; <span class="nb">split</span>; <span class="nb">rewrite</span> /= inE =&gt; /eqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_fsetI</span> <span class="nv">A</span> <span class="nv">B</span> : [<span class="nb">set</span>` (A `&amp;` B)%fset] = [<span class="nb">set</span>` A] `&amp;` [<span class="nb">set</span>` B].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>555</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` (A `&amp;` B)%fset] = [<span class="nb">set</span>` A] `&amp;` [<span class="nb">set</span>` B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>56f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>; <span class="nb">rewrite</span> /= !inE; [<span class="nb">case</span>/andP|<span class="nb">case</span>=&gt; -&gt; -&gt;].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_fsetIr</span> (<span class="nv">P</span> : {pred T}) (<span class="nv">A</span> : {fset T}) :
  [<span class="nb">set</span>` [fset x | x <span class="kr">in</span> A &amp; P x]%fset] = [<span class="nb">set</span>` A] `&amp;` [<span class="nb">set</span>` P].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span>{pred T}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>{fset T}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` [fset x | x <span class="kr">in</span> A &amp; P x]%fset] =
[<span class="nb">set</span>` A] `&amp;` [<span class="nb">set</span>` P]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>574</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/predeqP =&gt; x /=; <span class="nb">split</span>; <span class="nb">rewrite</span> <span class="mi">2</span>!inE/= =&gt; /andP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_fsetU</span> <span class="nv">A</span> <span class="nv">B</span> :
  [<span class="nb">set</span>` (A `|` B)%fset] = [<span class="nb">set</span>` A] `|` [<span class="nb">set</span>` B].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>555</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` (A `|` B)%fset] = [<span class="nb">set</span>` A] `|` [<span class="nb">set</span>` B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>57c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>; <span class="nb">rewrite</span> /= !inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>556</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \<span class="kr">in</span> A) || (x \<span class="kr">in</span> B) -&gt; x \<span class="kr">in</span> A \/ x \<span class="kr">in</span> B</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>583</q><label class="goal-separator"><hr></label><div class="goal-conclusion">x \<span class="kr">in</span> A \/ x \<span class="kr">in</span> B -&gt; (x \<span class="kr">in</span> A) || (x \<span class="kr">in</span> B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>/orP; [<span class="nb">left</span>|<span class="nb">right</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>583</q><span class="goal-separator"><hr></span><q>587</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; []-&gt;; <span class="nb">rewrite</span> <span class="nl">?orbT</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_fsetU1</span> <span class="nv">x</span> <span class="nv">A</span> : [<span class="nb">set</span> y | y \<span class="kr">in</span> (x |` A)%fset] = x |` [<span class="nb">set</span>` A].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>b</q><br><q>578</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` (x |` A)%fset] = x |` [<span class="nb">set</span>` A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>58c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> set_fsetU set_fset1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_fsetD</span> <span class="nv">A</span> <span class="nv">B</span> :
  [<span class="nb">set</span>` (A `\` B)%fset] = [<span class="nb">set</span>` A] `\` [<span class="nb">set</span>` B].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>555</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` (A `\` B)%fset] = [<span class="nb">set</span>` A] `\` [<span class="nb">set</span>` B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>592</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>; <span class="nb">rewrite</span> /= !inE; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; [-&gt; /negP -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>583</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \notin B) &amp;&amp; (x \<span class="kr">in</span> A) -&gt; x \<span class="kr">in</span> A /\ ~ x \<span class="kr">in</span> B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>/andP =&gt; /negP xNB xA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_fsetD1</span> <span class="nv">A</span> <span class="nv">x</span> : [<span class="nb">set</span> y | y \<span class="kr">in</span> (A `\ x)%fset] = [<span class="nb">set</span>` A] `\ x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>578</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` (A `\ x)%fset] = [<span class="nb">set</span>` A] `\ x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>59b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> set_fsetD set_fset1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_imfset</span> (<span class="nv">key</span> : unit) [K : choiceType] (f : T -&gt; K) (p : finmempred T) :
  [<span class="nb">set</span>` imfset key f p] = f @` [<span class="nb">set</span>` p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><span><var>key</var><span class="hyp-type"><b>: </b><span>unit</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>choiceType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T -&gt; K</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>finmempred T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>` imfset key f p] = [<span class="nb">set</span> f x | x <span class="kr">in</span> [<span class="nb">set</span>` p]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5a1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/predeqP =&gt; x; <span class="nb">split</span>=&gt; [/imfsetP[i ip -&gt; /=]|]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>5a4</q><br><q>5a5</q><br><q>5a6</q><br><q>5a7</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> [<span class="nb">set</span>` p]] x -&gt; [<span class="nb">set</span>` imfset key f p] x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [i ip &lt;-]; <span class="nb">apply</span>: in_imfset.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">SetFset</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">SetMonoids</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> (<span class="nv">T</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">setU_monoid</span> := Law (@setUA T) (@set0U T) (@setU0 T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">setU_comoid</span> := ComLaw (@setUC T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">setU_mul_monoid</span> := MulLaw (@setTU T) (@setUT T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">setI_monoid</span> := Law (@setIA T) (@setTI T) (@setIT T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">setI_comoid</span> := ComLaw (@setIC T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">setI_mul_monoid</span> := MulLaw (@set0I T) (@setI0 T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">setU_add_monoid</span> := AddLaw (@setUIl T) (@setUIr T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">setI_add_monoid</span> := AddLaw (@setIUl T) (@setIUr T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">SetMonoids</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">base_image_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">Y</span> : <span class="nb">set</span> rT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">imageP</span> <span class="nv">f</span> <span class="nv">A</span> <span class="nv">a</span> : A a -&gt; (f @` A) (f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT, rT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>aT -&gt; rT</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> aT</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>aT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A a -&gt; [<span class="nb">set</span> f x | x <span class="kr">in</span> A] (f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5b1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">a</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">imageT</span> (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">a</span> : aT) : range f (f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><q>5b7</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">range f (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5bb</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: imageP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">base_image_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> ((<span class="nl">?f</span> @` _) (<span class="nl">?f</span> _)) =&gt;  <span class="kp">solve</span> [<span class="nb">apply</span>: imageP; <span class="bp">assumption</span>] : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> ((<span class="nl">?f</span> @` setT) _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: imageT] : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">image_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">aT</span> <span class="nv">rT</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">Y</span> : <span class="nb">set</span> rT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_inj</span> {<span class="nv">f</span> <span class="nv">A</span> <span class="nv">a</span>} : injective f -&gt; (f @` A) (f a) = A a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5b3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">injective f -&gt; [<span class="nb">set</span> f x | x <span class="kr">in</span> A] (f a) = A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5c1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; f_inj; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [[b Ab /f_inj &lt;-]|/(imageP f)//].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_id</span> <span class="nv">A</span> : id @` A = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> x | x <span class="kr">in</span> A] = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5c6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; a; [<span class="nb">case</span>=&gt; /= x Ax &lt;-|<span class="kr">exists</span> <span class="nv">a</span>].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">homo_setP</span> {<span class="nv">A</span> <span class="nv">Y</span> <span class="nv">f</span>} :
  {homo f : x / x \<span class="kr">in</span> A &gt;-&gt; x \<span class="kr">in</span> Y} &lt;-&gt; {homo f : x / A x &gt;-&gt; Y x}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> rT</span></span></span><br><q>5b5</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo f : x / x \<span class="kr">in</span> A &gt;-&gt; x \<span class="kr">in</span> Y} &lt;-&gt;
{homo f : x / A x &gt;-&gt; Y x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5cc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; fAY x; <span class="nb">have</span> := fAY x; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_subP</span> {<span class="nv">A</span> <span class="nv">Y</span> <span class="nv">f</span>} : f @` A `&lt;=` Y &lt;-&gt; {homo f : x / A x &gt;-&gt; Y x}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5ce</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> A] `&lt;=` Y &lt;-&gt;
{homo f : x / A x &gt;-&gt; Y x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5d3</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; fAY x =&gt; [Ax|[y + &lt;-]]; <span class="nb">apply</span>: fAY=&gt; //; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_sub</span>  {<span class="nv">f</span> : aT -&gt; rT} {<span class="nv">A</span> : <span class="nb">set</span> aT} {<span class="nv">B</span> : <span class="nb">set</span> rT} :
  (f @` A `&lt;=` B) = (A `&lt;=` f @^-<span class="mi">1</span>` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><q>5b6</q><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([<span class="nb">set</span> f x | x <span class="kr">in</span> A] `&lt;=` B) = (A `&lt;=` f @^-<span class="mi">1</span>` B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5d8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/propext; <span class="nb">rewrite</span> image_subP; <span class="nb">split</span>=&gt; AB a /AB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_setU</span> <span class="nv">f</span> <span class="nv">A</span> <span class="nv">B</span> : f @` (A `|` B) = f @` A `|` f @` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> aT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> A `|` B] =
[<span class="nb">set</span> f x | x <span class="kr">in</span> A] `|` [<span class="nb">set</span> f x | x <span class="kr">in</span> B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5df</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><q>5e2</q><br><span><var>b</var><span class="hyp-type"><b>: </b><span>rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> A `|` B] b -&gt;
([<span class="nb">set</span> f x | x <span class="kr">in</span> A] `|` [<span class="nb">set</span> f x | x <span class="kr">in</span> B]) b</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>5e8</q><label class="goal-separator"><hr></label><div class="goal-conclusion">([<span class="nb">set</span> f x | x <span class="kr">in</span> A] `|` [<span class="nb">set</span> f x | x <span class="kr">in</span> B]) b -&gt;
[<span class="nb">set</span> f x | x <span class="kr">in</span> A `|` B] b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>5e6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; a [] Ha &lt;-; [<span class="nb">left</span> | <span class="nb">right</span>]; <span class="nb">apply</span> imageP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5e8</q><span class="goal-separator"><hr></span><q>5ed</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>5f0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; -[] a Ha &lt;-; <span class="nb">apply</span> imageP; [<span class="nb">left</span> | <span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_set0</span> <span class="nv">f</span> : f @` set0 = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> set0] = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5f4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; b // -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_set0_set0</span> <span class="nv">A</span> <span class="nv">f</span> : f @` A = set0 -&gt; A = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br><q>5b5</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> A] = set0 -&gt; A = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5fa</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fA0; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; // At.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br><q>5b5</q><br><span><var>fA0</var><span class="hyp-type"><b>: </b><span>[<span class="nb">set</span> f x | x <span class="kr">in</span> A] = set0</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>aT</span></span></span><br><span><var>At</var><span class="hyp-type"><b>: </b><span>A t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set0 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> : set0 (f t) <span class="bp">by</span> <span class="nb">rewrite</span> -fA0; <span class="kr">exists</span> <span class="nv">t</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_set1</span> <span class="nv">f</span> <span class="nv">t</span> : f @` [<span class="nb">set</span> t] = [<span class="nb">set</span> f t].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><q>604</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> [<span class="nb">set</span> t]] = [<span class="nb">set</span> f t]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>608</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [b [a&#39; -&gt; &lt;-] //|b -&gt;]; <span class="bp">exact</span>/imageP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_set1</span> <span class="nv">A</span> <span class="nv">a</span> : A `&lt;=` [<span class="nb">set</span> a] -&gt; A = set0 \/ A = [<span class="nb">set</span> a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br><q>5b7</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` [<span class="nb">set</span> a] -&gt; A = set0 \/ A = [<span class="nb">set</span> a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>60e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; Aa; <span class="nb">have</span> [/eqP|/set0P[t At]] := boolP (A == set0); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br><q>5b7</q><br><span><var>Aa</var><span class="hyp-type"><b>: </b><span>A `&lt;=` [<span class="nb">set</span> a]</span></span></span><br><q>604</q><br><q>605</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A = set0 \/ A = [<span class="nb">set</span> a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; // ? -&gt;; <span class="nb">rewrite</span> -(Aa _ At).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_set2</span> <span class="nv">A</span> <span class="nv">a</span> <span class="nv">b</span> : A `&lt;=` [<span class="nb">set</span> a; b] -&gt;
  [\/ A = set0, A = [<span class="nb">set</span> a], A = [<span class="nb">set</span> b] | A = [<span class="nb">set</span> a; b]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>aT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` [<span class="nb">set</span> a; b] -&gt;
[\/ A = set0, A = [<span class="nb">set</span> a], A = [<span class="nb">set</span> b]
  | A = [<span class="nb">set</span> a; b]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>61a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [&lt;-|ab Aab] := pselect (a = b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>61c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` [<span class="nb">set</span> a; a] -&gt;
[\/ A = set0, A = [<span class="nb">set</span> a], A = [<span class="nb">set</span> a]
  | A = [<span class="nb">set</span> a; a]]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br><q>61d</q><br><span><var>ab</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; b</span></span></span><br><span><var>Aab</var><span class="hyp-type"><b>: </b><span>A `&lt;=` [<span class="nb">set</span> a; b]</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">[\/ A = set0, A = [<span class="nb">set</span> a], A = [<span class="nb">set</span> b]
  | A = [<span class="nb">set</span> a; b]]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUid =&gt; /subset_set1[]-&gt;; [<span class="nb">apply</span>: Or41|<span class="nb">apply</span>: Or42].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>626</q><span class="goal-separator"><hr></span><q>629</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [|/nonsubset[x [/[dup] /Aab []// -&gt; Ab _]]] := pselect (A `&lt;=` [<span class="nb">set</span> a]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>626</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` [<span class="nb">set</span> a] -&gt;
[\/ A = set0, A = [<span class="nb">set</span> a], A = [<span class="nb">set</span> b]
  | A = [<span class="nb">set</span> a; b]]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br><q>61d</q><br><q>627</q><br><q>628</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>aT</span></span></span><br><span><var>Ab</var><span class="hyp-type"><b>: </b><span>A b</span></span></span><br></div><label class="goal-separator"><hr></label><q>629</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /subset_set1[]-&gt;; [<span class="nb">apply</span>: Or41|<span class="nb">apply</span>: Or42].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>633</q><span class="goal-separator"><hr></span><q>629</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [|/nonsubset[y [/[dup] /Aab []// -&gt; Aa _]]] := pselect (A `&lt;=` [<span class="nb">set</span> b]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>633</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` [<span class="nb">set</span> b] -&gt;
[\/ A = set0, A = [<span class="nb">set</span> a], A = [<span class="nb">set</span> b]
  | A = [<span class="nb">set</span> a; b]]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b6</q><br><q>61d</q><br><q>627</q><br><q>628</q><br><q>634</q><br><q>635</q><br><span><var>y</var><span class="hyp-type"><b>: </b><span>aT</span></span></span><br><span><var>Aa</var><span class="hyp-type"><b>: </b><span>A a</span></span></span><br></div><label class="goal-separator"><hr></label><q>629</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /subset_set1[]-&gt;; [<span class="nb">apply</span>: Or41|<span class="nb">apply</span>: Or43].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>63f</q><span class="goal-separator"><hr></span><q>629</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or44; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; // z /= [] -&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_image_setI</span> <span class="nv">f</span> <span class="nv">A</span> <span class="nv">B</span> : f @` (A `&amp;` B) `&lt;=` f @` A `&amp;` f @` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5e1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> A `&amp;` B]
`&lt;=` [<span class="nb">set</span> f x | x <span class="kr">in</span> A] `&amp;` [<span class="nb">set</span> f x | x <span class="kr">in</span> B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>646</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; b [x [Aa Ba &lt;-]]; <span class="nb">split</span>; <span class="nb">apply</span>: imageP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">nonempty_image</span> <span class="nv">f</span> <span class="nv">A</span> : f @` A !=set0 -&gt; A !=set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><q>5b6</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> A] !=set0 -&gt; A !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>64b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; b [a]; <span class="kr">exists</span> <span class="nv">a</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_subset</span> <span class="nv">f</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; f @` A `&lt;=` f @` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5e1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; [<span class="nb">set</span> f x | x <span class="kr">in</span> A] `&lt;=` [<span class="nb">set</span> f x | x <span class="kr">in</span> B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>651</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; AB _ [a Aa &lt;-]; <span class="kr">exists</span> <span class="nv">a</span> =&gt; //; <span class="nb">apply</span>/AB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_set0</span> <span class="nv">f</span> : f @^-<span class="mi">1</span>` set0 = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5f6</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` set0 = set0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>656</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/predeqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_setT</span> <span class="nv">f</span> : f @^-<span class="mi">1</span>` setT = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5f6</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` [<span class="nb">set</span>: rT] = [<span class="nb">set</span>: aT]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>65b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">nonempty_preimage</span> <span class="nv">f</span> <span class="nv">Y</span> : f @^-<span class="mi">1</span>` Y !=set0 -&gt; Y !=set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><q>5cf</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` Y !=set0 -&gt; Y !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>660</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; [t ?]; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">t</span>).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_image</span> <span class="nv">f</span> <span class="nv">A</span> : A `&lt;=` f @^-<span class="mi">1</span>` (f @` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>64d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` f @^-<span class="mi">1</span>` [<span class="nb">set</span> f x | x <span class="kr">in</span> A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>666</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; a Aa; <span class="kr">exists</span> <span class="nv">a</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_range</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) : f @^-<span class="mi">1</span>` (range f) = [<span class="nb">set</span>: A].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT, rT, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` range f = [<span class="nb">set</span>: A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>66b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; x // _; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_preimage_subset</span> <span class="nv">f</span> <span class="nv">Y</span> : f @` (f @^-<span class="mi">1</span>` Y) `&lt;=` Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>662</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> f @^-<span class="mi">1</span>` Y] `&lt;=` Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>673</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; _ [t /= Yft &lt;-].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_preimage</span> <span class="nv">f</span> <span class="nv">Y</span> : f @` setT = setT -&gt; f @` (f @^-<span class="mi">1</span>` Y) = Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>662</q><span class="goal-separator"><hr></span><div class="goal-conclusion">range f = [<span class="nb">set</span>: rT] -&gt; [<span class="nb">set</span> f x | x <span class="kr">in</span> f @^-<span class="mi">1</span>` Y] = Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>678</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fsurj; <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; [? ? &lt;-].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><q>5cf</q><br><span><var>fsurj</var><span class="hyp-type"><b>: </b><span>range f = [<span class="nb">set</span>: rT]</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y x -&gt; [<span class="nb">set</span> f x | x <span class="kr">in</span> f @^-<span class="mi">1</span>` Y] x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; Yx; <span class="nb">have</span> : setT x <span class="bp">by</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><q>5cf</q><br><q>680</q><br><q>681</q><br><span><var>Yx</var><span class="hyp-type"><b>: </b><span>Y x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>: rT] x -&gt; [<span class="nb">set</span> f x | x <span class="kr">in</span> f @^-<span class="mi">1</span>` Y] x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -fsurj =&gt; - [y _ fy_eqx]; <span class="kr">exists</span> <span class="nv">y</span> =&gt; //=; <span class="nb">rewrite</span> fy_eqx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_imagel</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">A</span> : <span class="nb">set</span> T1) (<span class="nv">f</span> <span class="nv">f&#39;</span> : T1 -&gt; T2) :
  (<span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; f x = f&#39; x) -&gt; f @` A = f&#39; @` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT, rT, T1, T2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><q>448</q><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>T1 -&gt; T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T1, A x -&gt; f x = f&#39; x) -&gt;
[<span class="nb">set</span> f x | x <span class="kr">in</span> A] = [<span class="nb">set</span> f&#39; x | x <span class="kr">in</span> A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>68a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; h; <span class="nb">rewrite</span> predeqE=&gt; y; <span class="nb">split</span>=&gt; [][x ? &lt;-]; <span class="kr">exists</span> <span class="nv">x</span>=&gt; //; <span class="nb">rewrite</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_image_id</span> <span class="nv">g</span> <span class="nv">A</span> : (<span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; g x = x) -&gt; g @` A = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><span><var>g</var><span class="hyp-type"><b>: </b><span>aT -&gt; aT</span></span></span><br><q>5b6</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : aT, A x -&gt; g x = x) -&gt;
[<span class="nb">set</span> g x | x <span class="kr">in</span> A] = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>692</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /eq_imagel-&gt;; <span class="nb">rewrite</span> image_id.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_setU</span> <span class="nv">f</span> <span class="nv">Y1</span> <span class="nv">Y2</span> : f @^-<span class="mi">1</span>` (Y1 `|` Y2) = f @^-<span class="mi">1</span>` Y1 `|` f @^-<span class="mi">1</span>` Y2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><span><var>Y1, Y2</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` (Y1 `|` Y2) = f @^-<span class="mi">1</span>` Y1 `|` f @^-<span class="mi">1</span>` Y2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>699</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/predeqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_setI</span> <span class="nv">f</span> <span class="nv">Y1</span> <span class="nv">Y2</span> : f @^-<span class="mi">1</span>` (Y1 `&amp;` Y2) = f @^-<span class="mi">1</span>` Y1 `&amp;` f @^-<span class="mi">1</span>` Y2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>69b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` (Y1 `&amp;` Y2) = f @^-<span class="mi">1</span>` Y1 `&amp;` f @^-<span class="mi">1</span>` Y2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6a0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/predeqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_setC</span> <span class="nv">f</span> <span class="nv">Y</span> : ~` (f @^-<span class="mi">1</span>` Y) = f @^-<span class="mi">1</span>` (~` Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>662</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` f @^-<span class="mi">1</span>` Y = f @^-<span class="mi">1</span>` (~` Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6a5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; a; <span class="nb">split</span>=&gt; nAfa ?; <span class="nb">apply</span>: nAfa.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_subset</span> <span class="nv">f</span> <span class="nv">Y1</span> <span class="nv">Y2</span> : Y1 `&lt;=` Y2 -&gt; f @^-<span class="mi">1</span>` Y1 `&lt;=` f @^-<span class="mi">1</span>` Y2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>69b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Y1 `&lt;=` Y2 -&gt; f @^-<span class="mi">1</span>` Y1 `&lt;=` f @^-<span class="mi">1</span>` Y2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6aa</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Y12 t /Y12.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">nonempty_preimage_setI</span> <span class="nv">f</span> <span class="nv">Y1</span> <span class="nv">Y2</span> :
  (f @^-<span class="mi">1</span>` (Y1 `&amp;` Y2)) !=set0 &lt;-&gt; (f @^-<span class="mi">1</span>` Y1 `&amp;` f @^-<span class="mi">1</span>` Y2) !=set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>69b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` (Y1 `&amp;` Y2) !=set0 &lt;-&gt;
f @^-<span class="mi">1</span>` Y1 `&amp;` f @^-<span class="mi">1</span>` Y2 !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6af</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; <span class="nb">case</span>=&gt; t ?; <span class="kr">exists</span> <span class="nv">t</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_bigcup</span> {<span class="nv">I</span>} (<span class="nv">P</span> : <span class="nb">set</span> I) <span class="nv">f</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> rT) :
  f @^-<span class="mi">1</span>` (\bigcup_ (i <span class="kr">in</span> P) F i) = \bigcup_(i <span class="kr">in</span> P) (f @^-<span class="mi">1</span>` F i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT, rT, I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><q>46a</q><br><q>5b5</q><br><span><var>F</var><span class="hyp-type"><b>: </b><span>I -&gt; <span class="nb">set</span> rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` (\bigcup_(i <span class="kr">in</span> P) F i) =
\bigcup_(i <span class="kr">in</span> P) f @^-<span class="mi">1</span>` F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6b4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/predeqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_bigcap</span> {<span class="nv">I</span>} (<span class="nv">P</span> : <span class="nb">set</span> I) <span class="nv">f</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> rT) :
  f @^-<span class="mi">1</span>` (\bigcap_ (i <span class="kr">in</span> P) F i) = \bigcap_(i <span class="kr">in</span> P) (f @^-<span class="mi">1</span>` F i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b6</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` (\bigcap_(i <span class="kr">in</span> P) F i) =
\bigcap_(i <span class="kr">in</span> P) f @^-<span class="mi">1</span>` F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6bc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/predeqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_preimage</span> {<span class="nv">I</span> <span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">F</span> <span class="nv">G</span> : I -&gt; T) :
  {<span class="kr">in</span> D, F =<span class="mi">1</span> G} -&gt; D `&amp;` F @^-<span class="mi">1</span>` A = D `&amp;` G @^-<span class="mi">1</span>` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT, rT, I, T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> I</span></span></span><br><q>a</q><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span>I -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{<span class="kr">in</span> D, F =<span class="mi">1</span> G} -&gt; D `&amp;` F @^-<span class="mi">1</span>` A = D `&amp;` G @^-<span class="mi">1</span>` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6c1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; eqFG; <span class="nb">apply</span>/predeqP =&gt; i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>6c4</q><br><q>6c5</q><br><q>a</q><br><q>6c6</q><br><span><var>eqFG</var><span class="hyp-type"><b>: </b><span>{<span class="kr">in</span> D, F =<span class="mi">1</span> G}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(D `&amp;` F @^-<span class="mi">1</span>` A) i &lt;-&gt; (D `&amp;` G @^-<span class="mi">1</span>` A) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; [] [Di FAi]; <span class="nb">split</span>; <span class="nb">rewrite</span> /preimage//= (eqFG,=^~eqFG) <span class="nl">?inE</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notin_setI_preimage</span> <span class="nv">T</span> <span class="nv">R</span> <span class="nv">D</span> (<span class="nv">f</span> : T -&gt; R) <span class="nv">i</span> :
  i \notin f @` D -&gt; D `&amp;` f @^-<span class="mi">1</span>` [<span class="nb">set</span> i] = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT, rT, T, R</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><q>65</q><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T -&gt; R</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i \notin [<span class="nb">set</span> f x | x <span class="kr">in</span> D] -&gt;
D `&amp;` f @^-<span class="mi">1</span>` [<span class="nb">set</span> i] = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6d1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> notin_set/=; <span class="nb">apply</span>: contra_notP =&gt; /eqP/set0P[t [Dt fit]]; <span class="kr">exists</span> <span class="nv">t</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">comp_preimage</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> (<span class="nv">A</span> : <span class="nb">set</span> T3) (<span class="nv">g</span> : T1 -&gt; T2) (<span class="nv">f</span> : T2 -&gt; T3) :
  (f \o g) @^-<span class="mi">1</span>` A = g @^-<span class="mi">1</span>` (f @^-<span class="mi">1</span>` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT, rT, T1, T2, T3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T3</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>T1 -&gt; T2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T2 -&gt; T3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f \o g) @^-<span class="mi">1</span>` A = g @^-<span class="mi">1</span>` (f @^-<span class="mi">1</span>` A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6da</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_id</span> <span class="nv">T</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : id @^-<span class="mi">1</span>` A = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT, rT, T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id @^-<span class="mi">1</span>` A = A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6e4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_comp</span> <span class="nv">T1</span> <span class="nv">T2</span> (<span class="nv">g</span> : T1 -&gt; rT) (<span class="nv">f</span> : T2 -&gt; rT) (<span class="nv">C</span> : <span class="nb">set</span> T1) :
  f @^-<span class="mi">1</span>` [<span class="nb">set</span> g x | x <span class="kr">in</span> C] = [<span class="nb">set</span> x | f x \<span class="kr">in</span> g @` C].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>68d</q><br><span><var>g</var><span class="hyp-type"><b>: </b><span>T1 -&gt; rT</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T2 -&gt; rT</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` [<span class="nb">set</span> g x | x <span class="kr">in</span> C] =
[<span class="nb">set</span> x | f x \<span class="kr">in</span> [<span class="nb">set</span> g x | x <span class="kr">in</span> C]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6eb</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>68d</q><br><q>6ee</q><br><q>6ef</q><br><q>6f0</q><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists2</span> x : T1, C x &amp; g x = f t) -&gt;
f t \<span class="kr">in</span> [<span class="nb">set</span> g x | x <span class="kr">in</span> C]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>6f6</q><label class="goal-separator"><hr></label><div class="goal-conclusion">f t \<span class="kr">in</span> [<span class="nb">set</span> g x | x <span class="kr">in</span> C] -&gt;
<span class="kr">exists2</span> x : T1, C x &amp; g x = f t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; -[r Cr &lt;-]; <span class="nb">rewrite</span> inE;  <span class="kr">exists</span> <span class="nv">r</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6f6</q><span class="goal-separator"><hr></span><q>6fb</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> inE =&gt; -[r Cr &lt;-]; <span class="kr">exists</span> <span class="nv">r</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage_setI_eq0</span> (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">Y1</span> <span class="nv">Y2</span> : <span class="nb">set</span> rT) :
  f @^-<span class="mi">1</span>` (Y1 `&amp;` Y2) = set0 &lt;-&gt; f @^-<span class="mi">1</span>` Y1 `&amp;` f @^-<span class="mi">1</span>` Y2 = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>69b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` (Y1 `&amp;` Y2) = set0 &lt;-&gt;
f @^-<span class="mi">1</span>` Y1 `&amp;` f @^-<span class="mi">1</span>` Y2 = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>700</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; <span class="nb">apply</span>: contraPP =&gt; /eqP/set0P/(nonempty_preimage_setI f _ _).<span class="mi">2</span>/set0P/eqP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage0eq</span> (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">Y</span> : <span class="nb">set</span> rT) : Y = set0 -&gt; f @^-<span class="mi">1</span>` Y = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>662</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Y = set0 -&gt; f @^-<span class="mi">1</span>` Y = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>705</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">rewrite</span> preimage_set0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage0</span> {<span class="nv">T</span> <span class="nv">R</span>} {<span class="nv">f</span> : T -&gt; R} {<span class="nv">A</span> : <span class="nb">set</span> R} :
  A `&amp;` range f `&lt;=` set0 -&gt; f @^-<span class="mi">1</span>` A = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>6d4</q><br><q>6d5</q><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` range f `&lt;=` set0 -&gt; f @^-<span class="mi">1</span>` A = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>70a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -subset0 =&gt; + x /= Afx =&gt; /(_ (f x))[]; <span class="nb">split</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage10P</span> {<span class="nv">T</span> <span class="nv">R</span>} {<span class="nv">f</span> : T -&gt; R} {<span class="nv">x</span>} : ~ range f x &lt;-&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> x] = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>6d4</q><br><q>6d5</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ range f x &lt;-&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> x] = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>711</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span> =&gt; [fx|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> preimage0// =&gt; ? [-&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>713</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f @^-<span class="mi">1</span>` [<span class="nb">set</span> x] = set0 -&gt; ~ range f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: contraPnot =&gt; -[t _ &lt;-] /seteqP[+ _] =&gt; /(_ t) /=.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">preimage10</span> {<span class="nv">T</span> <span class="nv">R</span>} {<span class="nv">f</span> : T -&gt; R} {<span class="nv">x</span>} : ~ range f x -&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> x] = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>713</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ range f x -&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> x] = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>71c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/preimage10P.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">image_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> sub_image_setI {aT rT f A B} t _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image2_subset</span> {<span class="nv">aT</span> <span class="nv">bT</span> <span class="nv">rT</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : aT -&gt; bT -&gt; rT)
    (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> aT) (<span class="nv">C</span> <span class="nv">D</span> : <span class="nb">set</span> bT) : A `&lt;=` B -&gt; C `&lt;=` D -&gt;
  [<span class="nb">set</span> f x y | x <span class="kr">in</span> A &amp; y <span class="kr">in</span> C] `&lt;=` [<span class="nb">set</span> f x y | x <span class="kr">in</span> B &amp; y <span class="kr">in</span> D].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT, bT, rT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>aT -&gt; bT -&gt; rT</span></span></span><br><q>5e2</q><br><span><var>C, D</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> bT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt;
C `&lt;=` D -&gt;
[<span class="nb">set</span> f x y | x <span class="kr">in</span> A &amp; y <span class="kr">in</span> C]
`&lt;=` [<span class="nb">set</span> f x y | x <span class="kr">in</span> B &amp; y <span class="kr">in</span> D]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>721</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; AB CD; <span class="nb">rewrite</span> !image2E; <span class="nb">apply</span>: image_subset; <span class="bp">exact</span>: setSM.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_comp</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> (<span class="nv">f</span> : T1 -&gt; T2) (<span class="nv">g</span> : T2 -&gt; T3) <span class="nv">A</span> :
  g @` (f @` A) = (g \o f) @` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T1, T2, T3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T1 -&gt; T2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>T2 -&gt; T3</span></span></span><br><q>448</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> g x | x <span class="kr">in</span> [<span class="nb">set</span> f x | x <span class="kr">in</span> A]] =
[<span class="nb">set</span> (g \o f) x | x <span class="kr">in</span> A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>72a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [x [b [a Aa] &lt;- &lt;-]|x [a Aa] &lt;-];
  [<span class="nb">apply</span>/imageP |<span class="nb">apply</span>/imageP/imageP].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subKimage</span> {<span class="nv">T</span> <span class="nv">T&#39;</span>} {<span class="nv">P</span> : <span class="nb">set</span> (<span class="nb">set</span> T&#39;)} (<span class="nv">f</span> : T -&gt; T&#39;) (<span class="nv">g</span> : T&#39; -&gt; T) :
  cancel f g -&gt; [<span class="nb">set</span> A | P (f @` A)] `&lt;=` [<span class="nb">set</span> g @` A | A <span class="kr">in</span> P].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c4</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (<span class="nb">set</span> T&#39;)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T -&gt; T&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>T&#39; -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel f g -&gt;
[<span class="nb">set</span> A | P [<span class="nb">set</span> f x | x <span class="kr">in</span> A]]
`&lt;=` [<span class="nb">set</span> [<span class="nb">set</span> g x | x <span class="kr">in</span> A] | A <span class="kr">in</span> P]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>733</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ? A; <span class="kr">exists</span> (<span class="nv">f</span> @` A); <span class="nb">rewrite</span> <span class="nl">?image_comp</span> <span class="nl">?eq_image_id</span>/=.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subimageK</span> <span class="nv">T</span> <span class="nv">T&#39;</span> (<span class="nv">P</span> : <span class="nb">set</span> (<span class="nb">set</span> T&#39;)) (<span class="nv">f</span> : T -&gt; T&#39;) (<span class="nv">g</span> : T&#39; -&gt; T) :
  cancel g f -&gt; [<span class="nb">set</span> g @` A | A <span class="kr">in</span> P] `&lt;=` [<span class="nb">set</span> A | P (f @` A)].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>735</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel g f -&gt;
[<span class="nb">set</span> [<span class="nb">set</span> g x | x <span class="kr">in</span> A] | A <span class="kr">in</span> P]
`&lt;=` [<span class="nb">set</span> A | P [<span class="nb">set</span> f x | x <span class="kr">in</span> A]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>73c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; gK _ [B /= ? &lt;-]; <span class="nb">rewrite</span> image_comp eq_image_id/=.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_imageK</span> {<span class="nv">T</span> <span class="nv">T&#39;</span>} {<span class="nv">P</span> : <span class="nb">set</span> (<span class="nb">set</span> T&#39;)} (<span class="nv">f</span> : T -&gt; T&#39;) (<span class="nv">g</span> : T&#39; -&gt; T) :
    cancel f g -&gt; cancel g f -&gt;
  [<span class="nb">set</span> g @` A | A <span class="kr">in</span> P] = [<span class="nb">set</span> A | P (f @` A)].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>735</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel f g -&gt;
cancel g f -&gt;
[<span class="nb">set</span> [<span class="nb">set</span> g x | x <span class="kr">in</span> A] | A <span class="kr">in</span> P] =
[<span class="nb">set</span> A | P [<span class="nb">set</span> f x | x <span class="kr">in</span> A]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>741</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; fK gK; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>; [<span class="nb">apply</span>: subimageK | <span class="nb">apply</span>: subKimage].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_set0</span> {<span class="nv">T</span>} : some @` set0 = set0 :&gt; <span class="nb">set</span> (option T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> set0] = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>746</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -subset0 =&gt; x [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_set1</span> {<span class="nv">T</span>} (<span class="nv">x</span> : T) : some @` [<span class="nb">set</span> x] = [<span class="nb">set</span> some x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> [<span class="nb">set</span> x]] = [<span class="nb">set</span> Some x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>74b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [_ [_ -&gt; &lt;-]|_ -&gt;]//=; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_setC</span> {<span class="nv">T</span>} (<span class="nv">A</span> : <span class="nb">set</span> T) : some @` (~` A) = [<span class="nb">set</span>~ None] `\` (some @` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> ~` A] =
[<span class="nb">set</span>~ None] `\` [<span class="nb">set</span> Some x | x <span class="kr">in</span> A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>750</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [x nAx &lt;-]; <span class="nb">split</span>=&gt; // -[y /[<span class="nb">swap</span>]-[-&gt;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>~ None] `\` [<span class="nb">set</span> Some x | x <span class="kr">in</span> A]
`&lt;=` [<span class="nb">set</span> Some x | x <span class="kr">in</span> ~` A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [x [_ exAx]|[/(_ erefl)//]]; <span class="kr">exists</span> <span class="nv">x</span> =&gt; // Ax; <span class="nb">apply</span>: exAx; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_setT</span> {<span class="nv">T</span>} : some @` [<span class="nb">set</span>: T] = [<span class="nb">set</span>~ None].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">range Some = [<span class="nb">set</span>~ None]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>759</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -[setT]setCK some_setC setCT some_set0 setD0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_setI</span> {<span class="nv">T</span>} (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : some @` (A `&amp;` B) = some @` A `&amp;` some @` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> A `&amp;` B] =
[<span class="nb">set</span> Some x | x <span class="kr">in</span> A] `&amp;` [<span class="nb">set</span> Some x | x <span class="kr">in</span> B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>75e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [x [Ax Bx] &lt;-]; <span class="nb">split</span>; <span class="kr">exists</span> <span class="nv">x</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> A] `&amp;` [<span class="nb">set</span> Some x | x <span class="kr">in</span> B]
`&lt;=` [<span class="nb">set</span> Some x | x <span class="kr">in</span> A `&amp;` B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; _ [[x + &lt;-] [y By []]] =&gt; /[<span class="nb">swap</span>]&lt;- Ay; <span class="kr">exists</span> <span class="nv">y</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_setU</span> {<span class="nv">T</span>} (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : some @` (A `|` B) = some @` A `|` some @` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> A `|` B] =
[<span class="nb">set</span> Some x | x <span class="kr">in</span> A] `|` [<span class="nb">set</span> Some x | x <span class="kr">in</span> B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>767</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -[_ `|` _]setCK setCU some_setC some_setI setDIr -!some_setC !setCK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_setD</span> {<span class="nv">T</span>} (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : some @` (A `\` B) = (some @` A) `\` (some @` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> A `\` B] =
[<span class="nb">set</span> Some x | x <span class="kr">in</span> A] `\` [<span class="nb">set</span> Some x | x <span class="kr">in</span> B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>76c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> some_setI some_setC setIDA setIidl// =&gt; _ [? _ &lt;-].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_image_some</span> {<span class="nv">T</span>} (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : some @` A `&lt;=` some @` B -&gt; A `&lt;=` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> A] `&lt;=` [<span class="nb">set</span> Some x | x <span class="kr">in</span> B] -&gt;
A `&lt;=` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>771</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; + x Ax =&gt; /(_ (Some x))[|y By [&lt;-]]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_image_someP</span> {<span class="nv">T</span>} (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : some @` A `&lt;=` some @` B &lt;-&gt; A `&lt;=` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> A] `&lt;=` [<span class="nb">set</span> Some x | x <span class="kr">in</span> B] &lt;-&gt;
A `&lt;=` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>776</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; [/sub_image_some//|/image_subset].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_some_inj</span> {<span class="nv">T</span>} (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : some @` A = some @` B -&gt; A = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> A] = [<span class="nb">set</span> Some x | x <span class="kr">in</span> B] -&gt; A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>77b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; e; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="nb">apply</span>: sub_image_some; <span class="nb">rewrite</span> e.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_set_eq0</span> {<span class="nv">T</span>} (<span class="nv">A</span> : <span class="nb">set</span> T) : some @` A = set0 &lt;-&gt; A = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> A] = set0 &lt;-&gt; A = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>780</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [|-&gt;]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> some_set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> A] = set0 -&gt; A = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -!subset0 =&gt; A0 x Ax; <span class="nb">apply</span>: (A0 (some x)); <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_preimage</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">A</span> : <span class="nb">set</span> rT) :
  some @` (f @^-<span class="mi">1</span>` A) = omap f @^-<span class="mi">1</span>` (some @` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><q>5b5</q><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> f @^-<span class="mi">1</span>` A] =
omap f @^-<span class="mi">1</span>` [<span class="nb">set</span> Some x | x <span class="kr">in</span> A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>789</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [a Afa &lt;-]; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">a</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>78b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">omap f @^-<span class="mi">1</span>` [<span class="nb">set</span> Some x | x <span class="kr">in</span> A]
`&lt;=` [<span class="nb">set</span> Some x | x <span class="kr">in</span> f @^-<span class="mi">1</span>` A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [x|] [a Aa //= [afx]]; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">rewrite</span> // -afx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_image</span> {<span class="nv">aT</span> <span class="nv">rT</span>} (<span class="nv">f</span> : aT -&gt; rT) (<span class="nv">A</span> : <span class="nb">set</span> aT) :
  some @` (f @` A) = omap f @` (some @` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>64d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> [<span class="nb">set</span> f x | x <span class="kr">in</span> A]] =
[<span class="nb">set</span> omap f x | x <span class="kr">in</span> [<span class="nb">set</span> Some x | x <span class="kr">in</span> A]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>794</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !image_comp.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">disj_set_some</span> {<span class="nv">T</span>} {<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T} :
  [disjoint some @` A &amp; some @` B] = [disjoint A &amp; B].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[disjoint
   [<span class="nb">set</span> Some x | x <span class="kr">in</span> A]
 &amp; [<span class="nb">set</span> Some x | x <span class="kr">in</span> B]] = [disjoint A &amp; B]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>799</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/disj_setPS/disj_setPS; <span class="nb">rewrite</span> -some_setI -some_set0 sub_image_someP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">bigop_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span> <span class="nv">I</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">i</span> : I) (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">F</span> <span class="nv">G</span> : I -&gt; <span class="nb">set</span> T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_sup</span> <span class="nv">i</span> <span class="nv">P</span> <span class="nv">F</span> : P i -&gt; F i `&lt;=` \bigcup_(j <span class="kr">in</span> P) F j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><q>6ce</q><br><q>46a</q><br><span><var>F</var><span class="hyp-type"><b>: </b><span>I -&gt; <span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P i -&gt; F i `&lt;=` \bigcup_(j <span class="kr">in</span> P) F j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>79e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Pi a Fia; <span class="kr">exists</span> <span class="nv">i</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_inf</span> <span class="nv">i</span> <span class="nv">P</span> <span class="nv">F</span> : P i -&gt; \bigcap_(j <span class="kr">in</span> P) F j `&lt;=` F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7a0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P i -&gt; \bigcap_(j <span class="kr">in</span> P) F j `&lt;=` F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7a6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Pi a /(_ i); <span class="nb">apply</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_bigcup_r</span> <span class="nv">P</span> : {homo (<span class="kr">fun</span> <span class="nv">x</span> : I -&gt; <span class="nb">set</span> T =&gt; \bigcup_(i <span class="kr">in</span> P) x i)
  : F G / [<span class="nb">set</span> F i | i <span class="kr">in</span> P] `&lt;=` [<span class="nb">set</span> G i | i <span class="kr">in</span> P] &gt;-&gt; F `&lt;=` G}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo (<span class="kr">fun</span> <span class="nv">x</span> : I -&gt; <span class="nb">set</span> T =&gt; \bigcup_(i <span class="kr">in</span> P) x i) : F G / 
[<span class="nb">set</span> F i | i <span class="kr">in</span> P] `&lt;=` [<span class="nb">set</span> G i | i <span class="kr">in</span> P] &gt;-&gt; F
                                               `&lt;=` G}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7ab</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; F G FG t [i Pi Fit]; <span class="nb">have</span> := FG (F i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span>I -&gt; <span class="nb">set</span> T</span></span></span><br><span><var>FG</var><span class="hyp-type"><b>: </b><span>[<span class="nb">set</span> F i | i <span class="kr">in</span> P] `&lt;=` [<span class="nb">set</span> G i | i <span class="kr">in</span> P]</span></span></span><br><q>26b</q><br><q>6ce</q><br><span><var>Pi</var><span class="hyp-type"><b>: </b><span>P i</span></span></span><br><span><var>Fit</var><span class="hyp-type"><b>: </b><span>F i t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([<span class="nb">set</span> F i | i <span class="kr">in</span> P] (F i) -&gt; [<span class="nb">set</span> G i | i <span class="kr">in</span> P] (F i)) -&gt;
(\bigcup_(i <span class="kr">in</span> P) G i) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /(_ (ex_intro2 _ _ _ Pi erefl))[j Pj ji]; <span class="kr">exists</span> <span class="nv">j</span> =&gt; //; <span class="nb">rewrite</span> ji.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_bigcap_r</span> <span class="nv">P</span> : {homo (<span class="kr">fun</span> <span class="nv">x</span> : I -&gt; <span class="nb">set</span> T =&gt; \bigcap_(i <span class="kr">in</span> P) x i)
  : F G / [<span class="nb">set</span> F i | i <span class="kr">in</span> P] `&lt;=` [<span class="nb">set</span> G i | i <span class="kr">in</span> P] &gt;-&gt; G `&lt;=` F}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo (<span class="kr">fun</span> <span class="nv">x</span> : I -&gt; <span class="nb">set</span> T =&gt; \bigcap_(i <span class="kr">in</span> P) x i) : F G / 
[<span class="nb">set</span> F i | i <span class="kr">in</span> P] `&lt;=` [<span class="nb">set</span> G i | i <span class="kr">in</span> P] &gt;-&gt; G
                                               `&lt;=` F}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7ba</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; F G FG t Gt i Pi; <span class="nb">have</span> [|j Pj &lt;-] := FG (F i); [<span class="kr">exists</span> <span class="nv">i</span>|<span class="nb">apply</span>: Gt].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_bigcupr</span> <span class="nv">P</span> <span class="nv">F</span> <span class="nv">G</span> : (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = G i) -&gt;
  \bigcup_(i <span class="kr">in</span> P) F i = \bigcup_(i <span class="kr">in</span> P) G i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>7b4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = G i) -&gt;
\bigcup_(i <span class="kr">in</span> P) F i = \bigcup_(i <span class="kr">in</span> P) G i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7bf</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; FG; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="nb">apply</span>: subset_bigcup_r;
  <span class="nb">move</span>=&gt; A [i ? &lt;-]; <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">rewrite</span> FG.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_bigcapr</span> <span class="nv">P</span> <span class="nv">F</span> <span class="nv">G</span> : (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = G i) -&gt;
  \bigcap_(i <span class="kr">in</span> P) F i = \bigcap_(i <span class="kr">in</span> P) G i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7c1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = G i) -&gt;
\bigcap_(i <span class="kr">in</span> P) F i = \bigcap_(i <span class="kr">in</span> P) G i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7c5</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; FG; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="nb">apply</span>: subset_bigcap_r;
  <span class="nb">move</span>=&gt; A [i ? &lt;-]; <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">rewrite</span> FG.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setC_bigcup</span> <span class="nv">P</span> <span class="nv">F</span> : ~` (\bigcup_(i <span class="kr">in</span> P) F i) = \bigcap_(i <span class="kr">in</span> P) ~` F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>7a2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~` (\bigcup_(i <span class="kr">in</span> P) F i) = \bigcap_(i <span class="kr">in</span> P) ~` F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7ca</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [t PFt i Pi ?|t PFt [i Pi ?]];
  [<span class="nb">apply</span> PFt; <span class="kr">exists</span> <span class="nv">i</span> | <span class="bp">exact</span>: (PFt _ Pi)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setC_bigcap</span> <span class="nv">P</span> <span class="nv">F</span> : ~` (\bigcap_(i <span class="kr">in</span> P) (F i)) = \bigcup_(i <span class="kr">in</span> P) ~` F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` (\bigcap_(i <span class="kr">in</span> P) F i) = \bigcup_(i <span class="kr">in</span> P) ~` F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7d0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setC_bigcup setCK.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> P) F i = \bigcap_(i <span class="kr">in</span> P) ~` ~` F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: eq_bigcapr =&gt; ?; <span class="nb">rewrite</span> setCK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">image_bigcup</span> <span class="nv">rT</span> <span class="nv">P</span> <span class="nv">F</span> (<span class="nv">f</span> : T -&gt; rT) :
  f @` (\bigcup_(i <span class="kr">in</span> P) (F i)) = \bigcup_(i <span class="kr">in</span> P) f @` F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, I, rT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><q>46a</q><br><q>7a2</q><br><q>1c</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> f x | x <span class="kr">in</span> \bigcup_(i <span class="kr">in</span> P) F i] =
\bigcup_(i <span class="kr">in</span> P) [<span class="nb">set</span> f x | x <span class="kr">in</span> F i]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7d9</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [_/= [x [i Pi Fix &lt;-]]|]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7db</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) [<span class="nb">set</span> f x | x <span class="kr">in</span> F i]
`&lt;=` [<span class="nb">set</span> f x | x <span class="kr">in</span> \bigcup_(i <span class="kr">in</span> P) F i]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; _ [i Pi [x Fix &lt;-]]; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; <span class="kr">exists</span> <span class="nv">i</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">some_bigcap</span> <span class="nv">P</span> <span class="nv">F</span> : some @` (\bigcap_(i <span class="kr">in</span> P) (F i)) =
  [<span class="nb">set</span>~ None] `&amp;` \bigcap_(i <span class="kr">in</span> P) some @` F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> \bigcap_(i <span class="kr">in</span> P) F i] =
[<span class="nb">set</span>~ None]
`&amp;` \bigcap_(i <span class="kr">in</span> P) [<span class="nb">set</span> Some x | x <span class="kr">in</span> F i]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7e4</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/seteqP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> Some x | x <span class="kr">in</span> \bigcap_(i <span class="kr">in</span> P) F i]
`&lt;=` [<span class="nb">set</span>~ None]
     `&amp;` \bigcap_(i <span class="kr">in</span> P) [<span class="nb">set</span> Some x | x <span class="kr">in</span> F i]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>7cc</q><label class="goal-separator"><hr></label><div class="goal-conclusion">[<span class="nb">set</span>~ None]
`&amp;` \bigcap_(i <span class="kr">in</span> P) [<span class="nb">set</span> Some x | x <span class="kr">in</span> F i]
`&lt;=` [<span class="nb">set</span> Some x | x <span class="kr">in</span> \bigcap_(i <span class="kr">in</span> P) F i]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; _ [x Fx &lt;-]; <span class="nb">split</span>=&gt; // i; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; <span class="nb">apply</span>: Fx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><q>7ee</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [x|[//=]] [_ Fx]; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //= i /Fx [y ? [&lt;-]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_set_type</span> <span class="nv">P</span> <span class="nv">F</span> : \bigcup_(i <span class="kr">in</span> P) F i = \bigcup_(j : P) F (val j).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) F i = \bigcup_j F (val j)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7f3</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; [[i/= /set_mem Pi] _ Fix]; <span class="kr">exists</span> <span class="nv">i</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>7a2</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(i <span class="kr">in</span> P) F i) x -&gt; (\bigcup_j F (val j)) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [i Pi Fix]; <span class="kr">exists</span> (<span class="nv">SigSub</span> (mem_set Pi)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_bigcupl</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">F</span> : P `&lt;=&gt;` Q -&gt;
  \bigcup_(i <span class="kr">in</span> P) F i = \bigcup_(i <span class="kr">in</span> Q) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> I</span></span></span><br><q>7a2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P `&lt;=&gt;` Q -&gt;
\bigcup_(i <span class="kr">in</span> P) F i = \bigcup_(i <span class="kr">in</span> Q) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7fd</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /seteqP-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_bigcapl</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">F</span> : P `&lt;=&gt;` Q -&gt;
  \bigcap_(i <span class="kr">in</span> P) F i = \bigcap_(i <span class="kr">in</span> Q) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7ff</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P `&lt;=&gt;` Q -&gt;
\bigcap_(i <span class="kr">in</span> P) F i = \bigcap_(i <span class="kr">in</span> Q) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>804</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /seteqP-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_bigcup</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">F</span> <span class="nv">G</span> : P `&lt;=&gt;` Q -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = G i) -&gt;
  \bigcup_(i <span class="kr">in</span> P) F i = \bigcup_(i <span class="kr">in</span> Q) G i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>800</q><br><q>7b4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P `&lt;=&gt;` Q -&gt;
(<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = G i) -&gt;
\bigcup_(i <span class="kr">in</span> P) F i = \bigcup_(i <span class="kr">in</span> Q) G i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>809</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /eq_bigcupl&lt;- /eq_bigcupr-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_bigcap</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">F</span> <span class="nv">G</span> : P `&lt;=&gt;` Q -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = G i) -&gt;
  \bigcap_(i <span class="kr">in</span> P) F i = \bigcap_(i <span class="kr">in</span> Q) G i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>80b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P `&lt;=&gt;` Q -&gt;
(<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = G i) -&gt;
\bigcap_(i <span class="kr">in</span> P) F i = \bigcap_(i <span class="kr">in</span> Q) G i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>80f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /eq_bigcapl&lt;- /eq_bigcapr-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcupU</span> <span class="nv">P</span> <span class="nv">F</span> <span class="nv">G</span> : \bigcup_(i <span class="kr">in</span> P) (F i `|` G i) =
  (\bigcup_(i <span class="kr">in</span> P) F i) `|` (\bigcup_(i <span class="kr">in</span> P) G i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7c1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) (F i `|` G i) =
\bigcup_(i <span class="kr">in</span> P) F i `|` \bigcup_(i <span class="kr">in</span> P) G i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>814</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span>/predeqP =&gt; x; <span class="nb">split</span>=&gt; [[i Pi [Fix|Gix]]|[[i Pi Fix]|[i Pi Gix]]];
  <span class="bp">by</span> [<span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">i</span>|<span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">i</span>|<span class="kr">exists</span> <span class="nv">i</span> =&gt;//; <span class="nb">left</span>|<span class="kr">exists</span> <span class="nv">i</span> =&gt;//; <span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcapI</span> <span class="nv">P</span> <span class="nv">F</span> <span class="nv">G</span> : \bigcap_(i <span class="kr">in</span> P) (F i `&amp;` G i) =
  (\bigcap_(i <span class="kr">in</span> P) F i) `&amp;` (\bigcap_(i <span class="kr">in</span> P) G i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7c1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> P) (F i `&amp;` G i) =
\bigcap_(i <span class="kr">in</span> P) F i `&amp;` \bigcap_(i <span class="kr">in</span> P) G i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>819</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> !(setCI, setC_bigcap) -bigcupU.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7c1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) ~` (F i `&amp;` G i) =
\bigcup_(i <span class="kr">in</span> P) (~` F i `|` ~` G i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: eq_bigcupr =&gt; *; <span class="nb">rewrite</span> setCI.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_const</span> <span class="nv">P</span> <span class="nv">A</span> : P !=set0 -&gt; \bigcup_(_ <span class="kr">in</span> P) A = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P !=set0 -&gt; \bigcup_(_ <span class="kr">in</span> P) A = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>822</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; j ?; <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [[i //]|Ax]; <span class="kr">exists</span> <span class="nv">j</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_const</span> <span class="nv">P</span> <span class="nv">A</span> : P !=set0 -&gt; \bigcap_(_ <span class="kr">in</span> P) A = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>824</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P !=set0 -&gt; \bigcap_(_ <span class="kr">in</span> P) A = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>828</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; PN0; <span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setC_bigcap bigcup_const.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcapIl</span> <span class="nv">P</span> <span class="nv">F</span> <span class="nv">A</span> : P !=set0 -&gt;
  \bigcap_(i <span class="kr">in</span> P) (F i `&amp;` A) = \bigcap_(i <span class="kr">in</span> P) F i `&amp;` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>7a2</q><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P !=set0 -&gt;
\bigcap_(i <span class="kr">in</span> P) (F i `&amp;` A) =
\bigcap_(i <span class="kr">in</span> P) F i `&amp;` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>82d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; PN0; <span class="nb">rewrite</span> bigcapI bigcap_const.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcapIr</span> <span class="nv">P</span> <span class="nv">F</span> <span class="nv">A</span> : P !=set0 -&gt;
  \bigcap_(i <span class="kr">in</span> P) (A `&amp;` F i) = A `&amp;` \bigcap_(i <span class="kr">in</span> P) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>82f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P !=set0 -&gt;
\bigcap_(i <span class="kr">in</span> P) (A `&amp;` F i) =
A `&amp;` \bigcap_(i <span class="kr">in</span> P) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>833</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; PN0; <span class="nb">rewrite</span> bigcapI bigcap_const.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcupUl</span> <span class="nv">P</span> <span class="nv">F</span> <span class="nv">A</span> : P !=set0 -&gt;
  \bigcup_(i <span class="kr">in</span> P) (F i `|` A) = \bigcup_(i <span class="kr">in</span> P) F i `|` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>82f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P !=set0 -&gt;
\bigcup_(i <span class="kr">in</span> P) (F i `|` A) =
\bigcup_(i <span class="kr">in</span> P) F i `|` A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>838</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; PN0; <span class="nb">rewrite</span> bigcupU bigcup_const.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcupUr</span> <span class="nv">P</span> <span class="nv">F</span> <span class="nv">A</span> : P !=set0 -&gt;
  \bigcup_(i <span class="kr">in</span> P) (A `|` F i) = A `|` \bigcup_(i <span class="kr">in</span> P) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>82f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P !=set0 -&gt;
\bigcup_(i <span class="kr">in</span> P) (A `|` F i) =
A `|` \bigcup_(i <span class="kr">in</span> P) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>83d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; PN0; <span class="nb">rewrite</span> bigcupU bigcup_const.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_set0</span> <span class="nv">F</span> : \bigcup_(i <span class="kr">in</span> set0) F i = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> set0) F i = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>842</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; a // [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_set1</span> <span class="nv">F</span> <span class="nv">i</span> : \bigcup_(j <span class="kr">in</span> [<span class="nb">set</span> i]) F j = F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br><q>6ce</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(j <span class="kr">in</span> [<span class="nb">set</span> i]) F j = F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>848</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; ? =&gt; [[] ? -&gt; //|]; <span class="kr">exists</span> <span class="nv">i</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_set0</span> <span class="nv">F</span> : \bigcap_(i <span class="kr">in</span> set0) F i = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>844</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> set0) F i = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>84e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; a // [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_set1</span> <span class="nv">F</span> <span class="nv">i</span> : \bigcap_(j <span class="kr">in</span> [<span class="nb">set</span> i]) F j = F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>84a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(j <span class="kr">in</span> [<span class="nb">set</span> i]) F j = F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>853</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; ?; [<span class="bp">exact</span>|<span class="nb">move</span>=&gt; ? ? -&gt;].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_nonempty</span> <span class="nv">P</span> <span class="nv">F</span> :
  (\bigcup_(i <span class="kr">in</span> P) F i !=set0) &lt;-&gt; <span class="kr">exists2</span> i, P i &amp; F i !=set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) F i !=set0 &lt;-&gt;
(<span class="kr">exists2</span> i : I, P i &amp; F i !=set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>858</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>=&gt; [[t [i ? ?]]|[j ? [t ?]]]; <span class="bp">by</span> [<span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="kr">exists</span> <span class="nv">t</span>| <span class="kr">exists</span> <span class="nv">t</span>, j].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup0</span> <span class="nv">P</span> <span class="nv">F</span> :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = set0) -&gt; \bigcup_(i <span class="kr">in</span> P) F i = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = set0) -&gt;
\bigcup_(i <span class="kr">in</span> P) F i = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>85d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; PF; <span class="nb">rewrite</span> -subset0 =&gt; t -[i /PF -&gt;].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap0</span> <span class="nv">P</span> <span class="nv">F</span> :
  (<span class="kr">exists2</span> i, P i &amp; F i = set0) -&gt; \bigcap_(i <span class="kr">in</span> P) F i = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists2</span> i : I, P i &amp; F i = set0) -&gt;
\bigcap_(i <span class="kr">in</span> P) F i = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>862</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [i Pi]; <span class="nb">rewrite</span> -!subset0 =&gt; Fi t Ft; <span class="nb">apply</span>/Fi/Ft.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcapT</span> <span class="nv">P</span> <span class="nv">F</span> :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = setT) -&gt; \bigcap_(i <span class="kr">in</span> P) F i = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = [<span class="nb">set</span>: T]) -&gt;
\bigcap_(i <span class="kr">in</span> P) F i = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>867</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; PF; <span class="nb">rewrite</span> -subTset =&gt; t -[i /PF -&gt;].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcupT</span> <span class="nv">P</span> <span class="nv">F</span> :
  (<span class="kr">exists2</span> i, P i &amp; F i = setT) -&gt; \bigcup_(i <span class="kr">in</span> P) F i = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists2</span> i : I, P i &amp; F i = [<span class="nb">set</span>: T]) -&gt;
\bigcup_(i <span class="kr">in</span> P) F i = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>86c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [i Pi F0]; <span class="nb">rewrite</span> -subTset =&gt; t; <span class="kr">exists</span> <span class="nv">i</span>; <span class="nb">rewrite</span> <span class="nl">?F0</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup0P</span> <span class="nv">P</span> <span class="nv">F</span> :
  (\bigcup_(i <span class="kr">in</span> P) F i = set0) &lt;-&gt; <span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) F i = set0 &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>871</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [|/bigcup0//]; <span class="nb">rewrite</span> -subset0 =&gt; F0 i Pi; <span class="nb">rewrite</span> -subset0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>7a2</q><br><span><var>F0</var><span class="hyp-type"><b>: </b><span>\bigcup_(i <span class="kr">in</span> P) F i `&lt;=` set0</span></span></span><br><q>6ce</q><br><q>7b6</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F i `&lt;=` set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; t Ft; <span class="nb">apply</span>: F0; <span class="kr">exists</span> <span class="nv">i</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcapTP</span> <span class="nv">P</span> <span class="nv">F</span> :
  (\bigcap_(i <span class="kr">in</span> P) F i = setT) &lt;-&gt; <span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> P) F i = [<span class="nb">set</span>: T] &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i = [<span class="nb">set</span>: T])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>87c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [|/bigcapT//]; <span class="nb">rewrite</span> -subTset =&gt; FT i Pi; <span class="nb">rewrite</span> -subTset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>7a2</q><br><span><var>FT</var><span class="hyp-type"><b>: </b><span>[<span class="nb">set</span>: T] `&lt;=` \bigcap_(i <span class="kr">in</span> P) F i</span></span></span><br><q>6ce</q><br><q>7b6</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>: T] `&lt;=` F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; t _; <span class="nb">apply</span>: FT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setI_bigcupr</span> <span class="nv">F</span> <span class="nv">P</span> <span class="nv">A</span> :
  A `&amp;` \bigcup_(i <span class="kr">in</span> P) F i = \bigcup_(i <span class="kr">in</span> P) (A `&amp;` F i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br><q>46a</q><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` \bigcup_(i <span class="kr">in</span> P) F i =
\bigcup_(i <span class="kr">in</span> P) (A `&amp;` F i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>887</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [[At [k ? ?]]|[k ? [At ?]]];
  <span class="bp">by</span> [<span class="kr">exists</span> <span class="nv">k</span> |<span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">k</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setI_bigcupl</span> <span class="nv">F</span> <span class="nv">P</span> <span class="nv">A</span> :
  \bigcup_(i <span class="kr">in</span> P) F i `&amp;` A = \bigcup_(i <span class="kr">in</span> P) (F i `&amp;` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>889</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) F i `&amp;` A =
\bigcup_(i <span class="kr">in</span> P) (F i `&amp;` A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>88d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setIC setI_bigcupr//; <span class="nb">under</span> eq_bigcupr <span class="kp">do</span> <span class="nb">rewrite</span> setIC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setU_bigcapr</span> <span class="nv">F</span> <span class="nv">P</span> <span class="nv">A</span> :
  A `|` \bigcap_(i <span class="kr">in</span> P) F i = \bigcap_(i <span class="kr">in</span> P) (A `|` F i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>889</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` \bigcap_(i <span class="kr">in</span> P) F i =
\bigcap_(i <span class="kr">in</span> P) (A `|` F i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>892</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setCU !setC_bigcap setI_bigcupr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>889</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) (~` A `&amp;` ~` F i) =
\bigcup_(i <span class="kr">in</span> P) ~` (A `|` F i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">under</span> eq_bigcupr <span class="kp">do</span> <span class="nb">rewrite</span> -setCU.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setU_bigcapl</span> <span class="nv">F</span> <span class="nv">P</span> <span class="nv">A</span> :
  \bigcap_(i <span class="kr">in</span> P) F i `|` A = \bigcap_(i <span class="kr">in</span> P) (F i `|` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>889</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> P) F i `|` A =
\bigcap_(i <span class="kr">in</span> P) (F i `|` A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>89b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUC setU_bigcapr//; <span class="nb">under</span> eq_bigcapr <span class="kp">do</span> <span class="nb">rewrite</span> setUC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_mkcond</span> <span class="nv">P</span> <span class="nv">F</span> :
  \bigcup_(i <span class="kr">in</span> P) F i = \bigcup_i <span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) F i =
\bigcup_i (<span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8a0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [[i Pi Fix]|[i _]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>7a2</q><br><q>b</q><br><q>6ce</q><br><q>7b6</q><br><span><var>Fix</var><span class="hyp-type"><b>: </b><span>F i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_i (<span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> set0)) x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>7a2</q><br><q>b</q><br><q>6ce</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> set0) x -&gt;
(\bigcup_(i <span class="kr">in</span> P) F i) x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> (inE, notin_set).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8ac</q><span class="goal-separator"><hr></span><q>8ad</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: ifPn; <span class="nb">rewrite</span> (inE, notin_set) =&gt; Pi Fix; <span class="kr">exists</span> <span class="nv">i</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_mkcondr</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">F</span> :
  \bigcup_(i <span class="kr">in</span> P `&amp;` Q) F i = \bigcup_(i <span class="kr">in</span> P) <span class="kr">if</span> i \<span class="kr">in</span> Q <span class="kr">then</span> F i <span class="kr">else</span> set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7ff</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P `&amp;` Q) F i =
\bigcup_(i <span class="kr">in</span> P) (<span class="kr">if</span> i \<span class="kr">in</span> Q <span class="kr">then</span> F i <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8b2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> bigcup_mkcond [RHS]bigcup_mkcond; <span class="nb">apply</span>: eq_bigcupr =&gt; i _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>800</q><br><q>7a2</q><br><q>6ce</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> i \<span class="kr">in</span> P `&amp;` Q <span class="kr">then</span> F i <span class="kr">else</span> set0) =
(<span class="kr">if</span> i \<span class="kr">in</span> P
 <span class="kr">then</span> <span class="kr">if</span> i \<span class="kr">in</span> Q <span class="kr">then</span> F i <span class="kr">else</span> set0
 <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> in_setI; <span class="nb">case</span>: (i \<span class="kr">in</span> P) (i \<span class="kr">in</span> Q) =&gt; [] [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_mkcondl</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">F</span> :
  \bigcup_(i <span class="kr">in</span> P `&amp;` Q) F i = \bigcup_(i <span class="kr">in</span> Q) <span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7ff</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P `&amp;` Q) F i =
\bigcup_(i <span class="kr">in</span> Q) (<span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8bc</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> bigcup_mkcond [RHS]bigcup_mkcond; <span class="nb">apply</span>: eq_bigcupr =&gt; i _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8b9</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> i \<span class="kr">in</span> P `&amp;` Q <span class="kr">then</span> F i <span class="kr">else</span> set0) =
(<span class="kr">if</span> i \<span class="kr">in</span> Q
 <span class="kr">then</span> <span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> set0
 <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> in_setI; <span class="nb">case</span>: (i \<span class="kr">in</span> P) (i \<span class="kr">in</span> Q) =&gt; [] [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_mkcond</span> <span class="nv">F</span> <span class="nv">P</span> :
  \bigcap_(i <span class="kr">in</span> P) F i = \bigcap_i <span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br><q>46a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> P) F i =
\bigcap_i (<span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> [<span class="nb">set</span>: T])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8c5</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> !setC_bigcap bigcup_mkcond; <span class="nb">apply</span>: eq_bigcupr =&gt; i _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br><q>46a</q><br><q>6ce</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> ~` F i <span class="kr">else</span> set0) =
~` (<span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> [<span class="nb">set</span>: T])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> <span class="nl">?setCT</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_mkcondr</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">F</span> :
  \bigcap_(i <span class="kr">in</span> P `&amp;` Q) F i = \bigcap_(i <span class="kr">in</span> P) <span class="kr">if</span> i \<span class="kr">in</span> Q <span class="kr">then</span> F i <span class="kr">else</span> setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7ff</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> P `&amp;` Q) F i =
\bigcap_(i <span class="kr">in</span> P) (<span class="kr">if</span> i \<span class="kr">in</span> Q <span class="kr">then</span> F i <span class="kr">else</span> [<span class="nb">set</span>: T])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8d0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> bigcap_mkcond [RHS]bigcap_mkcond; <span class="nb">apply</span>: eq_bigcapr =&gt; i _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8b9</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> i \<span class="kr">in</span> P `&amp;` Q <span class="kr">then</span> F i <span class="kr">else</span> [<span class="nb">set</span>: T]) =
(<span class="kr">if</span> i \<span class="kr">in</span> P
 <span class="kr">then</span> <span class="kr">if</span> i \<span class="kr">in</span> Q <span class="kr">then</span> F i <span class="kr">else</span> [<span class="nb">set</span>: T]
 <span class="kr">else</span> [<span class="nb">set</span>: T])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> in_setI; <span class="nb">case</span>: (i \<span class="kr">in</span> P) (i \<span class="kr">in</span> Q) =&gt; [] [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_mkcondl</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">F</span> :
  \bigcap_(i <span class="kr">in</span> P `&amp;` Q) F i = \bigcap_(i <span class="kr">in</span> Q) <span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7ff</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> P `&amp;` Q) F i =
\bigcap_(i <span class="kr">in</span> Q) (<span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> [<span class="nb">set</span>: T])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8d9</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> bigcap_mkcond [RHS]bigcap_mkcond; <span class="nb">apply</span>: eq_bigcapr =&gt; i _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8b9</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> i \<span class="kr">in</span> P `&amp;` Q <span class="kr">then</span> F i <span class="kr">else</span> [<span class="nb">set</span>: T]) =
(<span class="kr">if</span> i \<span class="kr">in</span> Q
 <span class="kr">then</span> <span class="kr">if</span> i \<span class="kr">in</span> P <span class="kr">then</span> F i <span class="kr">else</span> [<span class="nb">set</span>: T]
 <span class="kr">else</span> [<span class="nb">set</span>: T])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> in_setI; <span class="nb">case</span>: (i \<span class="kr">in</span> P) (i \<span class="kr">in</span> Q) =&gt; [] [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_imset1</span> <span class="nv">P</span> (<span class="nv">f</span> : I -&gt; T) : \bigcup_(x <span class="kr">in</span> P) [<span class="nb">set</span> f x] = f @` P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><span><var>f</var><span class="hyp-type"><b>: </b><span>I -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(x <span class="kr">in</span> P) [<span class="nb">set</span> f x] = [<span class="nb">set</span> f x | x <span class="kr">in</span> P]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8e2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt;[a [i ?]-&gt;| a [i ?]&lt;-]; [<span class="nb">apply</span>: imageP | <span class="kr">exists</span> <span class="nv">i</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_setU</span> <span class="nv">F</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="nb">set</span> I) :
  \bigcup_(i <span class="kr">in</span> X `|` Y) F i = \bigcup_(i <span class="kr">in</span> X) F i `|` \bigcup_(i <span class="kr">in</span> Y) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> (X `|` Y)) F i =
\bigcup_(i <span class="kr">in</span> X) F i `|` \bigcup_(i <span class="kr">in</span> Y) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8e9</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [[z]|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br><q>8ec</q><br><q>26b</q><br><span><var>z</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X `|` Y) z -&gt;
F z t -&gt;
(\bigcup_(i <span class="kr">in</span> X) F i `|` \bigcup_(i <span class="kr">in</span> Y) F i) t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br><q>8ec</q><br><q>26b</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">(\bigcup_(i <span class="kr">in</span> X) F i `|` \bigcup_(i <span class="kr">in</span> Y) F i) t -&gt;
(\bigcup_(i <span class="kr">in</span> (X `|` Y)) F i) t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [Xz|Yz]; [<span class="nb">left</span>|<span class="nb">right</span>]; <span class="kr">exists</span> <span class="nv">z</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8f7</q><span class="goal-separator"><hr></span><q>8f8</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [[z Xz Fzy]|[z Yz Fxz]]; <span class="kr">exists</span> <span class="nv">z</span> =&gt; //; [<span class="nb">left</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_setU</span> <span class="nv">F</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="nb">set</span> I) :
  \bigcap_(i <span class="kr">in</span> X `|` Y) F i = \bigcap_(i <span class="kr">in</span> X) F i `&amp;` \bigcap_(i <span class="kr">in</span> Y) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8eb</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> (X `|` Y)) F i =
\bigcap_(i <span class="kr">in</span> X) F i `&amp;` \bigcap_(i <span class="kr">in</span> Y) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8fd</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> !(setCI, setC_bigcap) bigcup_setU.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_setU1</span> <span class="nv">F</span> (<span class="nv">x</span> : I) (<span class="nv">X</span> : <span class="nb">set</span> I) :
  \bigcup_(i <span class="kr">in</span> x |` X) F i = F x `|` \bigcup_(i <span class="kr">in</span> X) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> (x |` X)) F i =
F x `|` \bigcup_(i <span class="kr">in</span> X) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>902</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> bigcup_setU bigcup_set1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_setU1</span> <span class="nv">F</span> (<span class="nv">x</span> : I) (<span class="nv">X</span> : <span class="nb">set</span> I) :
  \bigcap_(i <span class="kr">in</span> x |` X) F i = F x `&amp;` \bigcap_(i <span class="kr">in</span> X) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>904</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> (x |` X)) F i =
F x `&amp;` \bigcap_(i <span class="kr">in</span> X) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>90a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> bigcap_setU bigcap_set1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_setD1</span> (<span class="nv">x</span> : I) <span class="nv">F</span> (<span class="nv">X</span> : <span class="nb">set</span> I) : X x -&gt;
  \bigcup_(i <span class="kr">in</span> X) F i = F x `|` \bigcup_(i <span class="kr">in</span> X `\ x) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>905</q><br><q>7a2</q><br><q>906</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X x -&gt;
\bigcup_(i <span class="kr">in</span> X) F i =
F x `|` \bigcup_(i <span class="kr">in</span> X `\ x) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>90f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Xx; <span class="nb">rewrite</span> -bigcup_setU1 setD1K.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_setD1</span> (<span class="nv">x</span> : I) <span class="nv">F</span> (<span class="nv">X</span> : <span class="nb">set</span> I) : X x -&gt;
  \bigcap_(i <span class="kr">in</span> X) F i = F x `&amp;` \bigcap_(i <span class="kr">in</span> X `\ x) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>911</q><span class="goal-separator"><hr></span><div class="goal-conclusion">X x -&gt;
\bigcap_(i <span class="kr">in</span> X) F i =
F x `&amp;` \bigcap_(i <span class="kr">in</span> X `\ x) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>915</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Xx; <span class="nb">rewrite</span> -bigcap_setU1 setD1K.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setC_bigsetU</span> <span class="nv">U</span> (<span class="nv">s</span> : seq T) (<span class="nv">f</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">P</span> : pred T) :
   (~` \big[setU/set0]_(t &lt;- s | P t) f t) = \big[setI/setT]_(t &lt;- s | P t) ~` f t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, I, U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>seq T</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="nb">set</span> U</span></span></span><br><q>10c</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~` (\big[setU/set0]_(t &lt;- s | P t) f t) =
\big[setI/[<span class="nb">set</span>: U]]_(t &lt;- s | P t) ~` f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>91a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">elim</span>/big_rec2: _ =&gt; [|i X Y Pi &lt;-]; <span class="nb">rewrite</span> <span class="nl">?setC0</span> <span class="nl">?setCU</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setC_bigsetI</span> <span class="nv">U</span> (<span class="nv">s</span> : seq T) (<span class="nv">f</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">P</span> : pred T) :
   (~` \big[setI/setT]_(t &lt;- s | P t) f t) = \big[setU/set0]_(t &lt;- s | P t) ~` f t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~` (\big[setI/[<span class="nb">set</span>: U]]_(t &lt;- s | P t) f t) =
\big[setU/set0]_(t &lt;- s | P t) ~` f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>923</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">elim</span>/big_rec2: _ =&gt; [|i X Y Pi &lt;-]; <span class="nb">rewrite</span> <span class="nl">?setCT</span> <span class="nl">?setCI</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcupDr</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">A</span> : <span class="nb">set</span> T) : P !=set0 -&gt;
  \bigcap_(i <span class="kr">in</span> P) (A `\` F i) = A `\` \bigcup_(i <span class="kr">in</span> P) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>889</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P !=set0 -&gt;
\bigcap_(i <span class="kr">in</span> P) (A `\` F i) =
A `\` \bigcup_(i <span class="kr">in</span> P) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>928</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; PN0; <span class="nb">rewrite</span> setDE setC_bigcup -bigcapIr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setD_bigcupl</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">A</span> : <span class="nb">set</span> T) :
  \bigcup_(i <span class="kr">in</span> P) F i `\` A = \bigcup_(i <span class="kr">in</span> P) (F i `\` A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>889</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) F i `\` A =
\bigcup_(i <span class="kr">in</span> P) (F i `\` A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>92d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setDE setI_bigcupl; <span class="nb">under</span> eq_bigcupr <span class="kp">do</span> <span class="nb">rewrite</span> -setDE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_bigcup_dep</span> {<span class="nv">J</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : I -&gt; J -&gt; <span class="nb">set</span> T) (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">Q</span> : I -&gt; <span class="nb">set</span> J) :
  \bigcup_(i <span class="kr">in</span> P) \bigcup_(j <span class="kr">in</span> Q i) F i j =
  \bigcup_(k <span class="kr">in</span> P `*`` Q) F k.<span class="mi">1</span> k.<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, I, J</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>I -&gt; J -&gt; <span class="nb">set</span> T</span></span></span><br><q>46a</q><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>I -&gt; <span class="nb">set</span> J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) \bigcup_(j <span class="kr">in</span> Q i) F i j =
\bigcup_(k <span class="kr">in</span> P `*`` Q) F k.<span class="mi">1</span> k.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>932</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/predeqP =&gt; x; <span class="nb">split</span>=&gt; [[i Pi [j Pj Fijx]]|]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">i</span>, j).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>935</q><br><q>936</q><br><q>46a</q><br><q>937</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(k <span class="kr">in</span> P `*`` Q) F k.<span class="mi">1</span> k.<span class="mi">2</span>) x -&gt;
(\bigcup_(i <span class="kr">in</span> P) \bigcup_(j <span class="kr">in</span> Q i) F i j) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [[/= i j] [Pi Qj] Fijx]; <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="kr">exists</span> <span class="nv">j</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_bigcup</span> {<span class="nv">J</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : I -&gt; J -&gt; <span class="nb">set</span> T) (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">Q</span> : <span class="nb">set</span> J) :
  \bigcup_(i <span class="kr">in</span> P) \bigcup_(j <span class="kr">in</span> Q) F i j =
  \bigcup_(k <span class="kr">in</span> P `*` Q) F k.<span class="mi">1</span> k.<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>935</q><br><q>936</q><br><q>46a</q><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) \bigcup_(j <span class="kr">in</span> Q) F i j =
\bigcup_(k <span class="kr">in</span> P `*` Q) F k.<span class="mi">1</span> k.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>940</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: bigcup_bigcup_dep.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcupID</span> (<span class="nv">Q</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">P</span> : <span class="nb">set</span> I) :
  \bigcup_(i <span class="kr">in</span> P) F i =
    (\bigcup_(i <span class="kr">in</span> P `&amp;` Q) F i) `|` (\bigcup_(i <span class="kr">in</span> P `&amp;` ~` Q) F i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> I</span></span></span><br><q>7a2</q><br><q>46a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> P) F i =
\bigcup_(i <span class="kr">in</span> P `&amp;` Q) F i
`|` \bigcup_(i <span class="kr">in</span> P `&amp;` ~` Q) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>947</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_setU -setIUr setUv setIT.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcapID</span> (<span class="nv">Q</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">P</span> : <span class="nb">set</span> I) :
  \bigcap_(i <span class="kr">in</span> P) F i =
    (\bigcap_(i <span class="kr">in</span> P `&amp;` Q) F i) `&amp;` (\bigcap_(i <span class="kr">in</span> P `&amp;` ~` Q) F i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>949</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> P) F i =
\bigcap_(i <span class="kr">in</span> P `&amp;` Q) F i
`&amp;` \bigcap_(i <span class="kr">in</span> P `&amp;` ~` Q) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>94e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -bigcap_setU -setIUr setUv setIT.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">bigop_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> bigcup_setD1 {T I} x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> bigcap_setD1 {T I} x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bigcup2</span> <span class="nv">T</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : nat -&gt; <span class="nb">set</span> T :=
  <span class="kr">fun</span> <span class="nv">i</span> =&gt; <span class="kr">if</span> i == <span class="mi">0</span> <span class="kr">then</span> A <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> <span class="kr">then</span> B <span class="kr">else</span> set0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> bigcup2 T A B n /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup2E</span> <span class="nv">T</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : \bigcup_i (bigcup2 A B) i = A `|` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_i bigcup2 A B i = A `|` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>953</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [|[At|Bt]]; [|<span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>|<span class="bp">by</span> <span class="kr">exists</span> <span class="mi">1</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><q>26b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_i bigcup2 A B i) t -&gt; (A `|` B) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; -[_ At|[_ Bt|//]]; [<span class="nb">left</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup2inE</span> <span class="nv">T</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : \bigcup_(i &lt; <span class="mi">2</span>) (bigcup2 A B) i = A `|` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i &lt; <span class="mi">2</span>) bigcup2 A B i = A `|` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>95d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [|[At|Bt]]; [|<span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>|<span class="bp">by</span> <span class="kr">exists</span> <span class="mi">1</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>95a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(i &lt; <span class="mi">2</span>) bigcup2 A B i) t -&gt; (A `|` B) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; -[_ At|[_ Bt|//]]; [<span class="nb">left</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bigcap2</span> <span class="nv">T</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : nat -&gt; <span class="nb">set</span> T :=
  <span class="kr">fun</span> <span class="nv">i</span> =&gt; <span class="kr">if</span> i == <span class="mi">0</span> <span class="kr">then</span> A <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> <span class="kr">then</span> B <span class="kr">else</span> setT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> bigcap2 T A B n /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap2E</span> <span class="nv">T</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : \bigcap_i (bigcap2 A B) i = A `&amp;` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_i bigcap2 A B i = A `&amp;` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>966</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setC_bigcap setCI -bigcup2E /bigcap2 /bigcup2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_i
   ~`
   (<span class="kr">if</span> i == <span class="mi">0</span>
    <span class="kr">then</span> A
    <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> <span class="kr">then</span> B <span class="kr">else</span> [<span class="nb">set</span>: T]) =
\bigcup_i
   (<span class="kr">if</span> i == <span class="mi">0</span>
    <span class="kr">then</span> ~` A
    <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> <span class="kr">then</span> ~` B <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: eq_bigcupr =&gt; -[|[|[]]]//=; <span class="nb">rewrite</span> setCT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap2inE</span> <span class="nv">T</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : \bigcap_(i &lt; <span class="mi">2</span>) (bigcap2 A B) i = A `&amp;` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i &lt; <span class="mi">2</span>) bigcap2 A B i = A `&amp;` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>96f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setC_bigcap setCI -bigcup2inE /bigcap2 /bigcup2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i &lt; <span class="mi">2</span>)
   ~`
   (<span class="kr">if</span> i == <span class="mi">0</span>
    <span class="kr">then</span> A
    <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> <span class="kr">then</span> B <span class="kr">else</span> [<span class="nb">set</span>: T]) =
\bigcup_(i &lt; <span class="mi">2</span>)
   (<span class="kr">if</span> i == <span class="mi">0</span>
    <span class="kr">then</span> ~` A
    <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> <span class="kr">then</span> ~` B <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: eq_bigcupr =&gt; // -[|[|[]]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_sub</span> <span class="nv">T</span> <span class="nv">I</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">P</span> : <span class="nb">set</span> I) :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i `&lt;=` D) -&gt; \bigcup_(i <span class="kr">in</span> P) F i `&lt;=` D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>7a2</q><br><q>65</q><br><q>46a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span> : I, P i -&gt; F i `&lt;=` D) -&gt;
\bigcup_(i <span class="kr">in</span> P) F i `&lt;=` D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>978</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; FD t [n Pn Fnt]; <span class="nb">apply</span>: (FD n).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_bigcap</span> <span class="nv">T</span> <span class="nv">I</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">P</span> : <span class="nb">set</span> I) :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; D `&lt;=` F i) -&gt; D `&lt;=` \bigcap_(i <span class="kr">in</span> P) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>97a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span> : I, P i -&gt; D `&lt;=` F i) -&gt;
D `&lt;=` \bigcap_(i <span class="kr">in</span> P) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>97e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; DF t Dt n Pn; <span class="nb">apply</span>: DF.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_bigcup</span> <span class="nv">T</span> <span class="nv">I</span> [P : <span class="nb">set</span> I] [F G : I -&gt; <span class="nb">set</span> T] :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i `&lt;=` G i) -&gt;
  \bigcup_(i <span class="kr">in</span> P) F i `&lt;=` \bigcup_(i <span class="kr">in</span> P) G i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7c1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span> : I, P i -&gt; F i `&lt;=` G i) -&gt;
\bigcup_(i <span class="kr">in</span> P) F i `&lt;=` \bigcup_(i <span class="kr">in</span> P) G i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>983</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; FG; <span class="nb">apply</span>: bigcup_sub =&gt; i Pi + /(FG _ Pi); <span class="nb">apply</span>: bigcup_sup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_bigcap</span> <span class="nv">T</span> <span class="nv">I</span> [P : <span class="nb">set</span> I] [F G : I -&gt; <span class="nb">set</span> T] :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; F i `&lt;=` G i) -&gt;
  \bigcap_(i <span class="kr">in</span> P) F i `&lt;=` \bigcap_(i <span class="kr">in</span> P) G i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7c1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span> : I, P i -&gt; F i `&lt;=` G i) -&gt;
\bigcap_(i <span class="kr">in</span> P) F i `&lt;=` \bigcap_(i <span class="kr">in</span> P) G i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>988</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; FG; <span class="nb">apply</span>: sub_bigcap =&gt; i Pi x Fx; <span class="nb">apply</span>: FG =&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>46a</q><br><q>7b4</q><br><q>6ce</q><br><q>7b6</q><br><q>b</q><br><span><var>Fx</var><span class="hyp-type"><b>: </b><span>(\bigcap_(i <span class="kr">in</span> P) F i) x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: bigcap_inf Fx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_image</span> {<span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">I</span>} (<span class="nv">P</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> rT) :
  \bigcup_(x <span class="kr">in</span> f @` P) F x = \bigcup_(x <span class="kr">in</span> P) F (f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>6b7</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> aT</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>aT -&gt; I</span></span></span><br><q>6b8</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(x <span class="kr">in</span> [<span class="nb">set</span> f x | x <span class="kr">in</span> P]) F x =
\bigcup_(x <span class="kr">in</span> P) F (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>993</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; x; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>=&gt; j [] i pi &lt;- Xfix; <span class="kr">exists</span> <span class="nv">i</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>6b7</q><br><q>996</q><br><q>997</q><br><q>6b8</q><br><q>681</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(x <span class="kr">in</span> P) F (f x)) x -&gt;
(\bigcup_(x <span class="kr">in</span> [<span class="nb">set</span> f x | x <span class="kr">in</span> P]) F x) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; i Pi Ffix; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">i</span>); [<span class="kr">exists</span> <span class="nv">i</span>|].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_set_type</span> {<span class="nv">I</span> <span class="nv">T</span>} (<span class="nv">P</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
   \bigcap_(i <span class="kr">in</span> P) F i = \bigcap_(j : P) F (val j).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I, T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><q>46a</q><br><q>7a2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> P) F i = \bigcap_j F (val j)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9a0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> !setC_bigcap bigcup_set_type.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_image</span> {<span class="nv">aT</span> <span class="nv">rT</span> <span class="nv">I</span>} (<span class="nv">P</span> : <span class="nb">set</span> aT) (<span class="nv">f</span> : aT -&gt; I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> rT) :
  \bigcap_(x <span class="kr">in</span> f @` P) F x = \bigcap_(x <span class="kr">in</span> P) F (f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>995</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(x <span class="kr">in</span> [<span class="nb">set</span> f x | x <span class="kr">in</span> P]) F x =
\bigcap_(x <span class="kr">in</span> P) F (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9a7</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> !setC_bigcap bigcup_image.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_fset</span> {<span class="nv">I</span> : choiceType} {<span class="nv">U</span> : <span class="kt">Type</span>}
    (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> U) (<span class="nv">X</span> : {fset I}) :
  \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span> i | i \<span class="kr">in</span> X]) F i = \big[setU/set0]_(i &lt;- X) F i :&gt; <span class="nb">set</span> U.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span>choiceType</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>I -&gt; <span class="nb">set</span> U</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>{fset I}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` X]) F i =
\big[setU/set0]_(i &lt;- X) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9ac</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>/finSet_rect: X =&gt; X IHX; <span class="nb">have</span> [-&gt;|[x xX]] := fset_0Vmem X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9af</q><br><q>9b0</q><br><q>9b1</q><br><q>9b2</q><br><span><var>IHX</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y</span> : {fset I},
(Y `&lt;` X)%fset -&gt; \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` Y]) F i = \big[setU/set0]_(i &lt;- Y) F i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` fset0]) F i =
\big[setU/set0]_(i &lt;- fset0) F i</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9af</q><br><q>9b0</q><br><q>9b1</q><br><q>9b2</q><br><q>9b9</q><br><q>905</q><br><span><var>xX</var><span class="hyp-type"><b>: </b><span>x \<span class="kr">in</span> X</span></span></span><br></div><label class="goal-separator"><hr></label><q>9b3</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> big_seq_fset0 -subset0 =&gt; x [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>9bd</q><span class="goal-separator"><hr></span><q>9b3</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -(fsetD1K xX) set_fsetU set_fset1 big_fsetU1 <span class="nl">?inE</span> <span class="nl">?eqxx</span>//=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>9bd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> (x |` [<span class="nb">set</span>` (X `\ x)%fset])) F i =
F x `|` \big[setU/set0]_(i &lt;- (X `\ x)%fset) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> bigcup_setU1 IHX// fproperD1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_fset</span> {<span class="nv">I</span> : choiceType} {<span class="nv">U</span> : <span class="kt">Type</span>}
    (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> U) (<span class="nv">X</span> : {fset I}) :
  \bigcap_(i <span class="kr">in</span> [<span class="nb">set</span> i | i \<span class="kr">in</span> X]) F i = \big[setI/setT]_(i &lt;- X) F i :&gt; <span class="nb">set</span> U.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>9ae</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> [<span class="nb">set</span>` X]) F i =
\big[setI/[<span class="nb">set</span>: U]]_(i &lt;- X) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9c7</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setC_bigcap setC_bigsetI bigcup_fset.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_fsetU1</span> {<span class="nv">T</span> <span class="nv">U</span> : choiceType} (<span class="nv">F</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">x</span> : T) (<span class="nv">X</span> : {fset T}) :
  \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span> j | j \<span class="kr">in</span> x |` X]%fset) F i =
  F x `|` \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span> j | j \<span class="kr">in</span> X]) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, U</var><span class="hyp-type"><b>: </b><span>choiceType</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="nb">set</span> U</span></span></span><br><q>b</q><br><span><var>X</var><span class="hyp-type"><b>: </b><span>{fset T}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` (x |` X)%fset]) F i =
F x `|` \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` X]) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9cc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> set_fsetU1 bigcup_setU1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_fsetU1</span> {<span class="nv">T</span> <span class="nv">U</span> : choiceType} (<span class="nv">F</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">x</span> : T) (<span class="nv">X</span> : {fset T}) :
  \bigcap_(i <span class="kr">in</span> [<span class="nb">set</span> j | j \<span class="kr">in</span> x |` X]%fset) F i =
  F x `&amp;` \bigcap_(i <span class="kr">in</span> [<span class="nb">set</span> j | j \<span class="kr">in</span> X]) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>9ce</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i <span class="kr">in</span> [<span class="nb">set</span>` (x |` X)%fset]) F i =
F x `&amp;` \bigcap_(i <span class="kr">in</span> [<span class="nb">set</span>` X]) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9d5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> set_fsetU1 bigcap_setU1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_fsetD1</span> {<span class="nv">T</span> <span class="nv">U</span> : choiceType} (<span class="nv">x</span> : T) (<span class="nv">F</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">X</span> : {fset T}) :
    x \<span class="kr">in</span> X -&gt;
  \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span> i | i \<span class="kr">in</span> X]%fset) F i =
  F x `|` \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span> i | i \<span class="kr">in</span> X `\ x]%fset) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9cf</q><br><q>b</q><br><q>9d0</q><br><q>9d1</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x \<span class="kr">in</span> X -&gt;
\bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` X]) F i =
F x `|` \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` (X `\ x)%fset]) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9da</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Xx; <span class="nb">rewrite</span> (bigcup_setD1 x)// set_fsetD1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> bigcup_fsetD1 {T U} x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_fsetD1</span> {<span class="nv">T</span> <span class="nv">U</span> : choiceType} (<span class="nv">x</span> : T) (<span class="nv">F</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">X</span> : {fset T}) :
    x \<span class="kr">in</span> X -&gt;
  \bigcap_(i <span class="kr">in</span> [<span class="nb">set</span> i | i \<span class="kr">in</span> X]%fset) F i =
  F x `&amp;` \bigcap_(i <span class="kr">in</span> [<span class="nb">set</span> i | i \<span class="kr">in</span> X `\ x]%fset) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>9dc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">x \<span class="kr">in</span> X -&gt;
\bigcap_(i <span class="kr">in</span> [<span class="nb">set</span>` X]) F i =
F x `&amp;` \bigcap_(i <span class="kr">in</span> [<span class="nb">set</span>` (X `\ x)%fset]) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9e0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Xx; <span class="nb">rewrite</span> (bigcap_setD1 x)// set_fsetD1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> bigcup_fsetD1 {T U} x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">bigcup_set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">T</span> : choiceType) (<span class="nv">U</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_set_cond</span> (<span class="nv">s</span> : seq T) (<span class="nv">f</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">P</span> : pred T) :
  \bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) (f t) =
  \big[setU/set0]_(t &lt;- s | P t) (f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91e</q><br><q>91f</q><br><q>10c</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t =
\big[setU/set0]_(t &lt;- s | P t) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9e5</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: s =&gt; [/=|h s ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> set_nil bigcup_set0 big_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91f</q><br><q>10c</q><br><q>4ad</q><br><q>91e</q><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t =
\big[setU/set0]_(t &lt;- s | P t) f t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> h :: s) &amp;&amp; P x]) f t =
\big[setU/set0]_(t &lt;- (h :: s) | P t) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> big_cons -ih predeqE =&gt; u; <span class="nb">split</span>=&gt; [[t /andP[]]|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91f</q><br><q>10c</q><br><q>4ad</q><br><q>91e</q><br><q>9ee</q><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br><q>26b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t \<span class="kr">in</span> h :: s -&gt;
P t -&gt;
f t u -&gt;
(<span class="kr">if</span> P h
 <span class="kr">then</span>
  f h
  `|` \bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t
 <span class="kr">else</span> \bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t) u</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91f</q><br><q>10c</q><br><q>4ad</q><br><q>91e</q><br><q>9ee</q><br><q>9f4</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> P h
 <span class="kr">then</span>
  f h
  `|` \bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t
 <span class="kr">else</span> \bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t) u -&gt;
(\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> h :: s) &amp;&amp; P x]) f t) u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>9f1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> inE =&gt; /orP[/eqP -&gt;{t} -&gt; fhu|ts Pt ftu]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91f</q><br><q>10c</q><br><q>4ad</q><br><q>91e</q><br><q>9ee</q><br><q>9f4</q><br><q>26b</q><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>t \<span class="kr">in</span> s</span></span></span><br><span><var>Pt</var><span class="hyp-type"><b>: </b><span>P t</span></span></span><br><span><var>ftu</var><span class="hyp-type"><b>: </b><span>f t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> P h
 <span class="kr">then</span>
  f h
  `|` \bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t
 <span class="kr">else</span> \bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t) u</div></blockquote><q>9f6</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: ifPn =&gt; Ph; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">t</span> =&gt; //; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91f</q><br><q>10c</q><br><q>4ad</q><br><q>91e</q><br><q>9ee</q><br><q>9f4</q><br><q>26b</q><br><q>9ff</q><br><q>a00</q><br><q>a01</q><br><span><var>Ph</var><span class="hyp-type"><b>: </b><span>~~ P h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t) u</div></blockquote><q>9f6</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">t</span> =&gt; //; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>9f8</q><span class="goal-separator"><hr></span><q>9f9</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>a0a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: ifPn =&gt; [Ph [fhu|[t /andP[ts Pt] ftu]]|Ph [t /andP[ts Pt ftu]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91f</q><br><q>10c</q><br><q>4ad</q><br><q>91e</q><br><q>9ee</q><br><q>9f4</q><br><span><var>Ph</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br><span><var>fhu</var><span class="hyp-type"><b>: </b><span>f h u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> h :: s) &amp;&amp; P x]) f t) u</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91f</q><br><q>10c</q><br><q>4ad</q><br><q>91e</q><br><q>9ee</q><br><q>9f4</q><br><q>a11</q><br><q>26b</q><br><q>9ff</q><br><q>a00</q><br><q>a01</q><br></div><label class="goal-separator"><hr></label><q>a13</q></blockquote><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91f</q><br><q>10c</q><br><q>4ad</q><br><q>91e</q><br><q>9ee</q><br><q>9f4</q><br><q>a07</q><br><q>26b</q><br><q>9ff</q><br><q>a00</q><br><q>a01</q><br></div><label class="goal-separator"><hr></label><q>a13</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><q>a0e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">h</span> =&gt; //; <span class="nb">apply</span>/andP; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> mem_head.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a16</q><span class="goal-separator"><hr></span><q>a13</q></blockquote><div class="alectryon-extra-goals"><q>a17</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><q>a1b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">t</span> =&gt; //; <span class="nb">apply</span>/andP; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> inE orbC ts.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a18</q><span class="goal-separator"><hr></span><q>a13</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><q>a20</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">t</span> =&gt; //; <span class="nb">apply</span>/andP; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> inE orbC ts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_set</span> (<span class="nv">s</span> : seq T) (<span class="nv">f</span> : T -&gt; <span class="nb">set</span> U) :
  \bigcup_(t <span class="kr">in</span> [<span class="nb">set</span>` s]) (f t) = \big[setU/set0]_(t &lt;- s) (f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>9b0</q><br><q>91e</q><br><q>91f</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span>` s]) f t =
\big[setU/set0]_(t &lt;- s) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a24</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -(bigcup_set_cond s f xpredT); <span class="nb">congr</span> (\bigcup_(t <span class="kr">in</span> mkset _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a26</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; x \<span class="kr">in</span> s) =
(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; (x \<span class="kr">in</span> s) &amp;&amp; true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; t; <span class="nb">rewrite</span> andbT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_set_cond</span> (<span class="nv">s</span> : seq T) (<span class="nv">f</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">P</span> : pred T) :
  \bigcap_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) (f t) =
  \big[setI/setT]_(t &lt;- s | P t) (f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>9e7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(t <span class="kr">in</span> [<span class="nb">set</span> x | (x \<span class="kr">in</span> s) &amp;&amp; P x]) f t =
\big[setI/[<span class="nb">set</span>: U]]_(t &lt;- s | P t) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a2e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setC_bigcap setC_bigsetI bigcup_set_cond.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_set</span> (<span class="nv">s</span> : seq T) (<span class="nv">f</span> : T -&gt; <span class="nb">set</span> U) :
  \bigcap_(t <span class="kr">in</span> [<span class="nb">set</span>` s]) (f t) = \big[setI/setT]_(t &lt;- s) (f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a26</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(t <span class="kr">in</span> [<span class="nb">set</span>` s]) f t =
\big[setI/[<span class="nb">set</span>: U]]_(t &lt;- s) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a33</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setC_bigcap setC_bigsetI bigcup_set.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">bigcup_set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_pred</span> [T : finType] [U : <span class="kt">Type</span>] (P : {pred T}) (f : T -&gt; <span class="nb">set</span> U) :
  \bigcup_(t <span class="kr">in</span> [<span class="nb">set</span>` P]) f t = \big[setU/set0]_(t <span class="kr">in</span> P) f t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span>finType</span></span></span><br><q>9b0</q><br><q>577</q><br><q>91f</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span>` P]) f t =
\big[setU/set0]_(t <span class="kr">in</span> P) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a38</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/predeqP =&gt; u; <span class="nb">split</span>=&gt; [[x Px fxu]|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> (bigD1 x)//; <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a3b</q><br><q>9b0</q><br><q>577</q><br><q>91f</q><br><q>9f4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\big[setU/set0]_(t <span class="kr">in</span> P) f t) u -&gt;
(\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span>` P]) f t) u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; /mem_set; <span class="nb">rewrite</span> (@big_morph _ _ (<span class="kr">fun</span> <span class="nv">X</span> =&gt; u \<span class="kr">in</span> X) false orb).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a41</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\big[orb/false]_(i <span class="kr">in</span> P) (u \<span class="kr">in</span> f i) -&gt;
(\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span>` P]) f t) u</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>a41</q><label class="goal-separator"><hr></label><div class="goal-conclusion">{morph (<span class="kr">fun</span> <span class="nv">X</span> : set_predType U =&gt; u \<span class="kr">in</span> X) : x y / 
x `|` y &gt;-&gt; x || y}</div></blockquote><blockquote class="alectryon-goal"><q>a41</q><label class="goal-separator"><hr></label><div class="goal-conclusion">(u \<span class="kr">in</span> set0) = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>a44</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> big_has_cond =&gt; /hasP[x _ /andP[xP]]; <span class="nb">rewrite</span> inE =&gt; ufx; <span class="kr">exists</span> <span class="nv">x</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a41</q><span class="goal-separator"><hr></span><q>a49</q></blockquote><div class="alectryon-extra-goals"><q>a4a</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>a4e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /= x y; <span class="nb">apply</span>/idP/orP; <span class="nb">rewrite</span> !inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a41</q><span class="goal-separator"><hr></span><q>a4b</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>a53</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> in_set0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">smallest</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span>} (<span class="nv">C</span> : <span class="nb">set</span> T -&gt; <span class="kt">Prop</span>) (<span class="nv">G</span> : <span class="nb">set</span> T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">smallest</span> := \bigcap_(A <span class="kr">in</span> [<span class="nb">set</span> M | C M /\ G `&lt;=` M]) A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_smallest</span> <span class="nv">X</span> : X `&lt;=` G -&gt; X `&lt;=` smallest.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>G, X</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X `&lt;=` G -&gt; X `&lt;=` smallest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a57</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; XG A /XG GA Y /= [PY]; <span class="nb">apply</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_gen_smallest</span> : G `&lt;=` smallest.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a5a</q><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G `&lt;=` smallest</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a5f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: sub_smallest.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">smallest_sub</span> <span class="nv">X</span> : C X -&gt; G `&lt;=` X -&gt; smallest `&lt;=` X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a59</q><span class="goal-separator"><hr></span><div class="goal-conclusion">C X -&gt; G `&lt;=` X -&gt; smallest `&lt;=` X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a66</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; XC GX A; <span class="nb">apply</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">smallest_id</span> : C G -&gt; smallest = G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a61</q><span class="goal-separator"><hr></span><div class="goal-conclusion">C G -&gt; smallest = G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a6b</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Cs; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>; [<span class="nb">apply</span>: smallest_sub|<span class="nb">apply</span>: sub_smallest].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">smallest</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> sub_gen_smallest : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_smallest2r</span> {<span class="nv">T</span>} (<span class="nv">C</span> : <span class="nb">set</span> T-&gt; <span class="kt">Prop</span>) <span class="nv">G1</span> <span class="nv">G2</span> :
   C (smallest C G2) -&gt; G1 `&lt;=` G2 -&gt; smallest C G1 `&lt;=` smallest C G2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a5a</q><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C (smallest C G2) -&gt;
G1 `&lt;=` G2 -&gt; smallest C G1 `&lt;=` smallest C G2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a70</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">apply</span>: smallest_sub=&gt; //; <span class="nb">apply</span>: sub_smallest.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_smallest2l</span> {<span class="nv">T</span>} (<span class="nv">C1</span> <span class="nv">C2</span> : <span class="nb">set</span> T -&gt; <span class="kt">Prop</span>) :
   (<span class="kr">forall</span> <span class="nv">G</span>, C2 G -&gt; C1 G) -&gt;
   <span class="kr">forall</span> <span class="nv">G</span>, smallest C1 G `&lt;=` smallest C2 G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">G</span> : <span class="nb">set</span> T, C2 G -&gt; C1 G) -&gt;
<span class="kr">forall</span> <span class="nv">G</span> : <span class="nb">set</span> T, smallest C1 G `&lt;=` smallest C2 G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a77</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; C12 G X sX M [/C12 C1M GM]; <span class="nb">apply</span>: sX.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">bigop_nat_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">F</span> : nat -&gt; <span class="nb">set</span> T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_mkord</span> <span class="nv">n</span> <span class="nv">F</span> : \bigcup_(i &lt; n) F i = \big[setU/set0]_(i &lt; n) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>4c5</q><br><span><var>F</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i &lt; n) F i = \big[setU/set0]_(i &lt; n) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a7e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -(big_mkord xpredT F) -bigcup_set.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a80</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_(i &lt; n) F i =
\bigcup_(t <span class="kr">in</span> [<span class="nb">set</span>` index_iota <span class="mi">0</span> n]) F t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: eq_bigcupl; <span class="nb">split</span>=&gt; i; <span class="nb">rewrite</span> /= mem_index_iota leq0n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_mkord</span> <span class="nv">n</span> <span class="nv">F</span> : \bigcap_(i &lt; n) F i = \big[setI/setT]_(i &lt; n) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a80</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_(i &lt; n) F i = \big[setI/[<span class="nb">set</span>: T]]_(i &lt; n) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a89</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setC_bigsetI setC_bigcap bigcup_mkord.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigsetU_sup</span> <span class="nv">i</span> <span class="nv">n</span> <span class="nv">F</span> : (i &lt; n)%N -&gt; F i `&lt;=` \big[setU/set0]_(j &lt; n) F j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>i, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><q>a81</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt; n -&gt; F i `&lt;=` \big[setU/set0]_(j &lt; n) F j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a8e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: n =&gt; // n ni; <span class="nb">rewrite</span> -bigcup_mkord; <span class="bp">exact</span>/bigcup_sup.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigsetU_bigcup</span> <span class="nv">F</span> <span class="nv">n</span> : \big[setU/set0]_(i &lt; n) F i `&lt;=` \bigcup_k F k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a81</q><br><q>4c5</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\big[setU/set0]_(i &lt; n) F i `&lt;=` \bigcup_k F k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a95</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_mkord =&gt; x [k _ Fkx]; <span class="kr">exists</span> <span class="nv">k</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigsetU_bigcup2</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
   \big[setU/set0]_(i &lt; <span class="mi">2</span>) bigcup2 A B i = A `|` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\big[setU/set0]_(i &lt; <span class="mi">2</span>) bigcup2 A B i = A `|` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a9b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_mkord bigcup2inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigsetI_bigcap2</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
   \big[setI/setT]_(i &lt; <span class="mi">2</span>) bigcap2 A B i = A `&amp;` B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\big[setI/[<span class="nb">set</span>: T]]_(i &lt; <span class="mi">2</span>) bigcap2 A B i = A `&amp;` B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>aa0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -bigcap_mkord bigcap2inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcup_splitn</span> <span class="nv">n</span> <span class="nv">F</span> :
  \bigcup_i F i = \big[setU/set0]_(i &lt; n) F i `|` \bigcup_i F (n + i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a80</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_i F i =
\big[setU/set0]_(i &lt; n) F i `|` \bigcup_i F (n + i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>aa5</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -bigcup_mkord -(bigcup_image _ (addn n)) -bigcup_setU.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a80</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcup_i F i =
\bigcup_(i <span class="kr">in</span> (`I_n `|` range (addn n))) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: eq_bigcupl; <span class="nb">split</span>=&gt; // k _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>4c5</q><br><q>a81</q><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(`I_n `|` range (addn n)) k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [ltkn|lenk] := ltnP k n; [<span class="nb">left</span> =&gt; //|<span class="nb">right</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>4c5</q><br><q>a81</q><br><q>ab1</q><br><span><var>lenk</var><span class="hyp-type"><b>: </b><span>n &lt;= k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">range (addn n) k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">k</span> - n); <span class="nb">rewrite</span> // subnKC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigcap_splitn</span> <span class="nv">n</span> <span class="nv">F</span> :
  \bigcap_i F i = \big[setI/setT]_(i &lt; n) F i `&amp;` \bigcap_i F (n + i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a80</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\bigcap_i F i =
\big[setI/[<span class="nb">set</span>: T]]_(i &lt; n) F i
`&amp;` \bigcap_i F (n + i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>aba</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: setC_inj; <span class="nb">rewrite</span> setCI !setC_bigcap (bigcup_splitn n) setC_bigsetI.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_bigsetU</span> <span class="nv">F</span> :
  {homo (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \big[setU/set0]_(i &lt; n) F i) : n m / (n &lt;= m) &gt;-&gt; n `&lt;=` m}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a81</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \big[setU/set0]_(i &lt; n) F i) : n m / 
n &lt;= m &gt;-&gt; n `&lt;=` m}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>abf</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; m n mn; <span class="nb">rewrite</span> -!bigcup_mkord =&gt; x [i im Fix].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a81</q><br><q>4e7</q><br><span><var>mn</var><span class="hyp-type"><b>: </b><span>m &lt;= n</span></span></span><br><q>b</q><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>im</var><span class="hyp-type"><b>: </b><span>`I_m i</span></span></span><br><q>8a8</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(i &lt; n) F i) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //=; <span class="nb">rewrite</span> (leq_trans im).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_bigsetI</span> <span class="nv">F</span> :
  {homo (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \big[setI/setT]_(i &lt; n) F i) : n m / (n &lt;= m) &gt;-&gt; m `&lt;=` n}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ac1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \big[setI/[<span class="nb">set</span>: T]]_(i &lt; n) F i) : n m / 
n &lt;= m &gt;-&gt; m `&lt;=` n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>acd</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; m n mn; <span class="nb">rewrite</span> -setCS !setC_bigsetI.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a81</q><br><q>4e7</q><br><q>ac8</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\big[setU/set0]_t ~` F t `&lt;=` \big[setU/set0]_t ~` F t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (@subset_bigsetU (setC \o F)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_bigsetU_cond</span> (<span class="nv">P</span> : pred nat) <span class="nv">F</span> :
  {homo (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \big[setU/set0]_(i &lt; n | P i) F i)
    : n m / (n &lt;= m) &gt;-&gt; n `&lt;=` m}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pred nat</span></span></span><br><q>a81</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
       \big[setU/set0]_(i &lt; n | P i) F i) : n m / 
n &lt;= m &gt;-&gt; n `&lt;=` m}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ad7</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; n m nm; <span class="nb">rewrite</span> big_mkcond [<span class="kr">in</span> X <span class="kr">in</span> _ `&lt;=` X]big_mkcond/=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>ada</q><br><q>a81</q><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>nm</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\big[setU/set0]_(i &lt; n) (<span class="kr">if</span> P i <span class="kr">then</span> F i <span class="kr">else</span> set0)
`&lt;=` \big[setU/set0]_(i &lt; m) (<span class="kr">if</span> P i
                              <span class="kr">then</span> F i
                              <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (@subset_bigsetU (<span class="kr">fun</span> <span class="nv">i</span> =&gt; <span class="kr">if</span> P i <span class="kr">then</span> F i <span class="kr">else</span> _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_bigsetI_cond</span> (<span class="nv">P</span> : pred nat) <span class="nv">F</span> :
  {homo (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \big[setI/setT]_(i &lt; n | P i) F i)
    : n m / (n &lt;= m) &gt;-&gt; m `&lt;=` n}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ad9</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
       \big[setI/[<span class="nb">set</span>: T]]_(i &lt; n | P i) F i) : n m / 
n &lt;= m &gt;-&gt; m `&lt;=` n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ae5</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; n m nm; <span class="nb">rewrite</span> big_mkcond [<span class="kr">in</span> X <span class="kr">in</span> _ `&lt;=` X]big_mkcond/=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ae0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\big[setI/[<span class="nb">set</span>: T]]_(i &lt; m) (<span class="kr">if</span> P i
                             <span class="kr">then</span> F i
                             <span class="kr">else</span> [<span class="nb">set</span>: T])
`&lt;=` \big[setI/[<span class="nb">set</span>: T]]_(i &lt; n) (<span class="kr">if</span> P i
                                  <span class="kr">then</span> F i
                                  <span class="kr">else</span> [<span class="nb">set</span>: T])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (@subset_bigsetI (<span class="kr">fun</span> <span class="nv">i</span> =&gt; <span class="kr">if</span> P i <span class="kr">then</span> F i <span class="kr">else</span> _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">bigop_nat_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_subset1</span> {<span class="nv">T</span>} (<span class="nv">A</span> : <span class="nb">set</span> T) := <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, A x -&gt; A y -&gt; x = y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_fun</span> {<span class="nv">T1</span> <span class="nv">T2</span>} (<span class="nv">f</span> : T1 -&gt; T2 -&gt; <span class="kt">Prop</span>) := Logic.<span class="kp">all</span> (is_subset1 \o f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_total</span> {<span class="nv">T1</span> <span class="nv">T2</span>} (<span class="nv">f</span> : T1 -&gt; T2 -&gt; <span class="kt">Prop</span>) := Logic.<span class="kp">all</span> (nonempty \o f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_totalfun</span> {<span class="nv">T1</span> <span class="nv">T2</span>} (<span class="nv">f</span> : T1 -&gt; T2 -&gt; <span class="kt">Prop</span>) :=
  <span class="kr">forall</span> <span class="nv">x</span>, f x !=set0 /\ is_subset1 (f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">xget</span> {<span class="nv">T</span> : choiceType} <span class="nv">x0</span> (<span class="nv">P</span> : <span class="nb">set</span> T) : T :=
  <span class="kr">if</span> pselect (<span class="kr">exists</span> <span class="nv">x</span> : T, `[&lt;P x&gt;]) <span class="kr">isn&#39;t</span> <span class="nb">left</span> exP <span class="kr">then</span> x0
  <span class="kr">else</span> projT1 (sigW exP).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">xget_spec</span> {<span class="nv">T</span> : choiceType} <span class="nv">x0</span> (<span class="nv">P</span> : <span class="nb">set</span> T) : T -&gt; <span class="kt">Prop</span> -&gt; <span class="kt">Type</span> :=
| XGetSome x of x = xget x0 P &amp; P x : xget_spec x0 P x <span class="kt">True</span>
| XGetNone of (<span class="kr">forall</span> <span class="nv">x</span>, ~ P x) : xget_spec x0 P x0 <span class="kt">False</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xgetP</span> {<span class="nv">T</span> : choiceType} <span class="nv">x0</span> (<span class="nv">P</span> : <span class="nb">set</span> T) :
  xget_spec x0 P (xget x0 P) (P (xget x0 P)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xget_spec x0 P (xget x0 P) (P (xget x0 P))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>aee</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: (erefl (xget x0 P)); <span class="nb">set</span> y := {<span class="mi">2</span>}(xget x0 P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>af1</q><br><q>af2</q><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>xget x0 P</span></span><span class="hyp-type"><b>: </b><span>T</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xget x0 P = y -&gt;
xget_spec x0 P (xget x0 P) (P (xget x0 P))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /xget; <span class="nb">case</span>: pselect =&gt; /= [?|neqP _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>af1</q><br><q>af2</q><br><q>af9</q><br><span><var>_a_</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">x</span> : T, `[&lt; P x &gt;]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(@sval) T (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; `[&lt; P x &gt;]) (sigW _a_) = y -&gt;
xget_spec x0 P
  ((@sval) T (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; `[&lt; P x &gt;]) (sigW _a_))
  (P ((@sval) T (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; `[&lt; P x &gt;]) (sigW _a_)))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>af1</q><br><q>af2</q><br><q>af9</q><br><span><var>neqP</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists</span> <span class="nv">x</span> : T, `[&lt; P x &gt;])</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">xget_spec x0 P x0 (P x0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: sigW =&gt; x /= /asboolP Px; <span class="nb">rewrite</span> [P x]propT //; <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b03</q><span class="goal-separator"><hr></span><q>b05</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">suff</span> NP x : ~ P x <span class="bp">by</span> <span class="nb">rewrite</span> [P x0]propF //; <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>af1</q><br><q>af2</q><br><q>af9</q><br><q>b04</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: contra_not neqP =&gt; Px; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">apply</span>/asboolP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xgetPex</span> {<span class="nv">T</span> : choiceType} <span class="nv">x0</span> (<span class="nv">P</span> : <span class="nb">set</span> T) : (<span class="kr">exists</span> <span class="nv">x</span>, P x) -&gt; P (xget x0 P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>af0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">x</span> : T, P x) -&gt; P (xget x0 P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b0f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: xgetP=&gt; // NP [x /NP].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xgetI</span> {<span class="nv">T</span> : choiceType} <span class="nv">x0</span> (<span class="nv">P</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T): P x -&gt; P (xget x0 P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>af1</q><br><q>af2</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x -&gt; P (xget x0 P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b14</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Px; <span class="nb">apply</span>: xgetPex; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xget_subset1</span> {<span class="nv">T</span> : choiceType} <span class="nv">x0</span> (<span class="nv">P</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T) :
  P x -&gt; is_subset1 P -&gt; xget x0 P = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b16</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P x -&gt; is_subset1 P -&gt; xget x0 P = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b1a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Px /(_ _ _ (xgetI x0 Px) Px).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xget_unique</span>  {<span class="nv">T</span> : choiceType} <span class="nv">x0</span> (<span class="nv">P</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T) :
  P x -&gt; (<span class="kr">forall</span> <span class="nv">y</span>, P y -&gt; y = x) -&gt; xget x0 P = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b16</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P x -&gt; (<span class="kr">forall</span> <span class="nv">y</span> : T, P y -&gt; y = x) -&gt; xget x0 P = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b1f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /xget_subset1 gPx eqx; <span class="nb">apply</span>: gPx=&gt; y z /eqx-&gt; /eqx.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xgetPN</span> {<span class="nv">T</span> : choiceType} <span class="nv">x0</span> (<span class="nv">P</span> : <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">x</span>, ~ P x) -&gt; xget x0 P = x0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>af0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x) -&gt; xget x0 P = x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b24</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: xgetP =&gt; // x _ Px /(_ x).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fun_of_rel</span> {<span class="nv">aT</span>} {<span class="nv">rT</span> : choiceType} (<span class="nv">f0</span> : aT -&gt; rT)
  (<span class="nv">f</span> : aT -&gt; rT -&gt; <span class="kt">Prop</span>) := <span class="kr">fun</span> <span class="nv">x</span> =&gt; xget (f0 x) (f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fun_of_relP</span> {<span class="nv">aT</span>} {<span class="nv">rT</span> : choiceType} (<span class="nv">f</span> : aT -&gt; rT -&gt; <span class="kt">Prop</span>) (<span class="nv">f0</span> : aT -&gt; rT) <span class="nv">a</span> :
  f a !=set0 -&gt; f a (fun_of_rel f0 f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rT</var><span class="hyp-type"><b>: </b><span>choiceType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>aT -&gt; rT -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>aT -&gt; rT</span></span></span><br><q>5b7</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a !=set0 -&gt; f a (fun_of_rel f0 f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b29</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [b fab]; <span class="nb">rewrite</span> /fun_of_rel; <span class="nb">apply</span>: xgetI fab.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fun_of_rel_uniq</span> {<span class="nv">aT</span>} {<span class="nv">rT</span> : choiceType}
    (<span class="nv">f</span> : aT -&gt; rT -&gt; <span class="kt">Prop</span>) (<span class="nv">f0</span> : aT -&gt; rT) <span class="nv">a</span> :
  is_subset1 (f a) -&gt; <span class="kr">forall</span> <span class="nv">b</span>, f a b -&gt;  fun_of_rel f0 f a = b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b2b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subset1 (f a) -&gt;
<span class="kr">forall</span> <span class="nv">b</span> : rT, f a b -&gt; fun_of_rel f0 f a = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b33</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; fa1 b /xget_subset1 xgeteq; <span class="nb">rewrite</span> /fun_of_rel xgeteq.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forall_sig</span> <span class="nv">T</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">P</span> : {x | x \<span class="kr">in</span> A} -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">u</span> : {x | x \<span class="kr">in</span> A}, P u) =
  (<span class="kr">forall</span> <span class="nv">u</span> : T, <span class="kr">forall</span> (<span class="nv">a</span> : A u), P (exist _ u (mem_set a))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span>{x : T | x \<span class="kr">in</span> A} -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">u</span> : {x : T | x \<span class="kr">in</span> A}, P u) =
(<span class="kr">forall</span> (<span class="nv">u</span> : T) (<span class="nv">a</span> : A u),
 P (exist (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; x \<span class="kr">in</span> A) u (mem_set a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b38</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [+ u a|PA [u a]]; <span class="kp">first</span> <span class="bp">exact</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br><q>b3b</q><br><span><var>PA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">u</span> : T) (<span class="nv">a</span> : A u),
P (exist (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; x \<span class="kr">in</span> A) u (mem_set a))</span></span></span><br><q>6c</q><br><span><var>a</var><span class="hyp-type"><b>: </b><span>u \<span class="kr">in</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (exist (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; x \<span class="kr">in</span> A) u a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> Au : A u <span class="bp">by</span> <span class="nb">rewrite</span> inE <span class="kr">in</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>a</q><br><q>b3b</q><br><q>b42</q><br><q>6c</q><br><q>b43</q><br><span><var>Au</var><span class="hyp-type"><b>: </b><span>A u</span></span></span><br></div><span class="goal-separator"><hr></span><q>b44</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (Prop_irrelevance a (mem_set Au)); <span class="nb">apply</span>: PA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_setP</span> {<span class="nv">U</span>} (<span class="nv">A</span> : <span class="nb">set</span> U) (<span class="nv">P</span> : U -&gt; <span class="kt">Prop</span>) :
  {<span class="kr">in</span> A, <span class="kr">forall</span> <span class="nv">x</span>, P x} &lt;-&gt; <span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9b0</q><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> U</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>U -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{<span class="kr">in</span> A, <span class="kr">forall</span> <span class="nv">x</span> : U, P x} &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : U, A x -&gt; P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b4b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; AP x; <span class="nb">have</span> := AP x; <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_set2P</span> {<span class="nv">U</span> <span class="nv">V</span>} (<span class="nv">A</span> : <span class="nb">set</span> U) (<span class="nv">B</span> : <span class="nb">set</span> V) (<span class="nv">P</span> : U -&gt; V -&gt; <span class="kt">Prop</span>) :
  {<span class="kr">in</span> A &amp; B, <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x y} &lt;-&gt; (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, A x -&gt; B y -&gt; P x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><q>b4e</q><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> V</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>U -&gt; V -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{<span class="kr">in</span> A &amp; B, <span class="kr">forall</span> (<span class="nv">x</span> : U) (<span class="nv">y</span> : V), P x y} &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">x</span> : U) (<span class="nv">y</span> : V), A x -&gt; B y -&gt; P x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b53</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; AP x y; <span class="nb">have</span> := AP x y; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in1TT</span> [T1] [P1 : T1 -&gt; <span class="kt">Prop</span>] :
  {<span class="kr">in</span> [<span class="nb">set</span>: T1], <span class="kr">forall</span> <span class="nv">x</span> : T1, P1 x : <span class="kt">Prop</span>} -&gt; <span class="kr">forall</span> <span class="nv">x</span> : T1, P1 x : <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span>T1 -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{<span class="kr">in</span> [<span class="nb">set</span>: T1], <span class="kr">forall</span> <span class="nv">x</span> : T1, P1 x : <span class="kt">Prop</span>} -&gt;
<span class="kr">forall</span> <span class="nv">x</span> : T1, P1 x : <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b5c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; + *; <span class="nb">apply</span>; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in2TT</span> [T1 T2] [P2 : T1 -&gt; T2 -&gt; <span class="kt">Prop</span>] :
  {<span class="kr">in</span> [<span class="nb">set</span>: T1] &amp; [<span class="nb">set</span>: T2], <span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2), P2 x y : <span class="kt">Prop</span>} -&gt;
  <span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2), P2 x y : <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T1, T2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P2</var><span class="hyp-type"><b>: </b><span>T1 -&gt; T2 -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{<span class="kr">in</span> [<span class="nb">set</span>: T1] &amp; [<span class="nb">set</span>: T2],
  <span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2), P2 x y : <span class="kt">Prop</span>} -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2), P2 x y : <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b64</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; + *; <span class="nb">apply</span>; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in3TT</span> [T1 T2 T3] [P3 : T1 -&gt; T2 -&gt; T3 -&gt; <span class="kt">Prop</span>] :
  {<span class="kr">in</span> [<span class="nb">set</span>: T1] &amp; [<span class="nb">set</span>: T2] &amp; [<span class="nb">set</span>: T3], <span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2) (<span class="nv">z</span> : T3), P3 x y z : <span class="kt">Prop</span>} -&gt;
  <span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2) (<span class="nv">z</span> : T3), P3 x y z : <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>72d</q><br><span><var>P3</var><span class="hyp-type"><b>: </b><span>T1 -&gt; T2 -&gt; T3 -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{<span class="kr">in</span> [<span class="nb">set</span>: T1] &amp; [<span class="nb">set</span>: T2] &amp; [<span class="nb">set</span>: T3],
  <span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2) (<span class="nv">z</span> : T3), P3 x y z : <span class="kt">Prop</span>} -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2) (<span class="nv">z</span> : T3), P3 x y z : <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b6c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; + *; <span class="nb">apply</span>; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">inTT_bij</span> [T1 T2 : <span class="kt">Type</span>] [f : T1 -&gt; T2] :
  {<span class="kr">in</span> [<span class="nb">set</span>: T1], bijective f} -&gt; bijective f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>72e</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{<span class="kr">in</span> [<span class="nb">set</span>: T1], bijective f} -&gt; bijective f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b73</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; [g /in1TT + /in1TT +]; <span class="kr">exists</span> <span class="nv">g</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Pointed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">point_of</span> (<span class="nv">T</span> : <span class="kt">Type</span>) := T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">T</span> : <span class="kt">Type</span>) := <span class="kn">Class</span> {
  base : Choice.class_of T;
  mixin : point_of T
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ClassDef</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Structure</span> <span class="nf">type</span> := Pack { sort; _ : class_of sort }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of cT <span class="kr">in</span> c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack T c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of xT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Choice.class_of.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pack</span> <span class="nv">m</span> :=
  <span class="kr">fun</span> <span class="nv">bT</span> <span class="nv">b</span> <span class="nv">of</span> <span class="nv">phant_id</span> (<span class="nv">Choice</span>.class bT) <span class="nv">b</span> =&gt; @Pack T (<span class="kn">Class</span> <span class="nf">b</span> <span class="nv">m</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ClassDef</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Choice.class_of.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; point_of.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">eqType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">choiceType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">pointedType</span> := type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">PointedType</span> T m := (@pack T m _ _ idfun).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;pointedType&#39; &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> :=  (@clone T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;pointedType&#39;  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) : form_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;pointedType&#39; &#39;of&#39; T ]&quot;</span> := (@clone T _ _ id)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;pointedType&#39;  &#39;of&#39;  T ]&quot;</span>) : form_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Pointed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Pointed.Exports.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">point</span> {<span class="nv">M</span> : pointedType} : M := Pointed.mixin (Pointed.class M).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">arrow_pointedType</span> (T : <span class="kt">Type</span>) (T&#39; : pointedType) :=
  PointedType (T -&gt; T&#39;) (<span class="kr">fun</span>=&gt; point).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">dep_arrow_pointedType</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">T&#39;</span> : T -&gt; pointedType) :=
  Pointed.Pack
   (Pointed.<span class="kn">Class</span> (dep_arrow_choiceClass T&#39;) (<span class="kr">fun</span> <span class="nv">i</span> =&gt; @point (T&#39; i))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">unit_pointedType</span> := PointedType unit tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">bool_pointedType</span> := PointedType bool false.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Prop_pointedType</span> := PointedType <span class="kt">Prop</span> <span class="kt">False</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">nat_pointedType</span> := PointedType nat <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">prod_pointedType</span> (T T&#39; : pointedType) :=
  PointedType (T * T&#39;) (point, point).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">matrix_pointedType</span> m n (T : pointedType) :=
  PointedType &#39;M[T]_(m, n) (\matrix_(_, _) point)%R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">option_pointedType</span> (T : choiceType) := PointedType (option T) None.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">pointed_fset</span> {T : choiceType} := PointedType {fset T} fset0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">get</span> := (xget point).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;get&#39; x | E ]&quot;</span> := (get [<span class="nb">set</span> x | E])
  (<span class="kn">at level</span> <span class="mi">0</span>, x name, <span class="kn">format</span> <span class="s2">&quot;[ &#39;get&#39;  x  |  E ]&quot;</span>, <span class="kn">only printing</span>) : form_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;get&#39; x : T | E ]&quot;</span> := (get (<span class="kr">fun</span> <span class="nv">x</span> : T  =&gt; E))
  (<span class="kn">at level</span> <span class="mi">0</span>, x name, <span class="kn">format</span> <span class="s2">&quot;[ &#39;get&#39;  x  :  T  |  E ]&quot;</span>, <span class="kn">only parsing</span>) : form_scope.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="kn">format</span> modifier has no effect <span class="kr">for</span> <span class="kp">only</span>-parsing
notations. [discarded-<span class="kn">format</span>-<span class="kp">only</span>-parsing,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;get&#39; x | E ]&quot;</span> := (get (<span class="kr">fun</span> <span class="nv">x</span> =&gt; E))
  (<span class="kn">at level</span> <span class="mi">0</span>, x name, <span class="kn">format</span> <span class="s2">&quot;[ &#39;get&#39;  x  |  E ]&quot;</span>) : form_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">PointedTheory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span> : pointedType}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">getPex</span> (<span class="nv">P</span> : <span class="nb">set</span> T) : (<span class="kr">exists</span> <span class="nv">x</span>, P x) -&gt; P (get P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span>pointedType</span></span></span><br><q>af2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">x</span> : T, P x) -&gt; P [get x : _ | P x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b7a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (xgetPex point).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">getI</span> (<span class="nv">P</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T): P x -&gt; P (get P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b7d</q><br><q>af2</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x -&gt; P [get x : _ | P x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b81</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (xgetI point).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">get_subset1</span> (<span class="nv">P</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T) : P x -&gt; is_subset1 P -&gt; get P = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b83</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P x -&gt; is_subset1 P -&gt; [get x : _ | P x] = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b87</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (xget_subset1 point).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">get_unique</span> (<span class="nv">P</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T) :
   P x -&gt; (<span class="kr">forall</span> <span class="nv">y</span>, P y -&gt; y = x) -&gt; get P = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b83</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P x -&gt;
(<span class="kr">forall</span> <span class="nv">y</span> : T, P y -&gt; y = x) -&gt; [get x : _ | P x] = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b8c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (xget_unique point).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">getPN</span> (<span class="nv">P</span> : <span class="nb">set</span> T) : (<span class="kr">forall</span> <span class="nv">x</span>, ~ P x) -&gt; get P = point.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b7c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x) -&gt; [get x : _ | P x] = point</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b91</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (xgetPN point).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">setT0</span> : setT != set0 :&gt; <span class="nb">set</span> T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b7d</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span>: T] != set0 :&gt; <span class="nb">set</span> T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b96</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/eqP =&gt; /seteqP[] /(_ point) /(_ Logic.I).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">PointedTheory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">squashed</span> <span class="nv">T</span> : <span class="kt">Prop</span> := squash (x : T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> squash {T} x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;$| T |&quot;</span> := (squashed T) : form_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;squash&quot;</span> <span class="kp">uconstr</span>(x) := (<span class="kr">exists</span>; <span class="nb">refine</span> x) ||
   <span class="kr">match goal with</span> |- $| <span class="nl">?T</span> | =&gt; <span class="kr">exists</span>; <span class="nb">refine</span> [the T of x] <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">unsquash</span> {<span class="nv">T</span>} (<span class="nv">s</span> : $|T|) : T :=
  projT1 (cid (<span class="kr">let</span>: squash x := s <span class="kr">in</span> @ex_intro T _ x isT)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">unsquashK</span> {<span class="nv">T</span>} : cancel (@unsquash T) squash.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel unsquash squash</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b9c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Empty types *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Empty</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mixin_of</span> <span class="nv">T</span> := T -&gt; <span class="kt">False</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">EqMixin</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : mixin_of T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eq_op</span> (<span class="nv">x</span> <span class="nv">y</span> : T) := true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_opP</span> : Equality.axiom eq_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mixin_of T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equality.axiom eq_op</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ba1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqMixin</span> := EqMixin eq_opP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">EqMixin</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ChoiceMixin</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : mixin_of T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">find</span> <span class="nv">of</span> <span class="nv">pred</span> <span class="nv">T</span> &amp; nat : option T := None.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">findP</span> (<span class="nv">P</span> : pred T) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : T) :  find P n = Some x -&gt; P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>ba4</q><br><q>10c</q><br><q>4c5</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find P n = Some x -&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ba8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ex_find</span> (<span class="nv">P</span> : pred T) : (<span class="kr">exists</span> <span class="nv">x</span> : T, P x) -&gt; <span class="kr">exists</span> <span class="nv">n</span> : nat, find P n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>ba4</q><br><q>10c</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">x</span> : T, P x) -&gt; <span class="kr">exists</span> <span class="nv">n</span> : nat, find P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bae</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_find</span> (<span class="nv">P</span> <span class="nv">Q</span> : pred T) : P =<span class="mi">1</span> Q -&gt; find P =<span class="mi">1</span> find Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>ba4</q><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pred T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P =<span class="mi">1</span> Q -&gt; find P =<span class="mi">1</span> find Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bb4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">choiceMixin</span> := Choice.Mixin findP ex_find eq_find.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ChoiceMixin</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">CountMixin</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : mixin_of T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pickle</span> : T -&gt; nat := <span class="kr">fun</span>=&gt; <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">unpickle</span> : nat -&gt; option T := <span class="kr">fun</span>=&gt; None.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">pickleK</span> : pcancel pickle unpickle.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ba3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">pcancel pickle unpickle</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bbb</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">countMixin</span> := CountMixin pickleK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CountMixin</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">FinMixin</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">T</span> : countType) (<span class="nv">m</span> : mixin_of T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fin_axiom</span> : Finite.axiom ([::] : seq T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span>countType</span></span></span><br><q>ba4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite.axiom ([::] : seq T)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bc0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">finMixin</span> := FinMixin fin_axiom.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">FinMixin</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ClassDef</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Primitive Projections</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">class_of</span> <span class="nv">T</span> := <span class="kn">Class</span> {
  base : Finite.class_of T;
  mixin : mixin_of T
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Primitive Projections</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Finite.class_of.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Structure</span> <span class="nf">type</span> : <span class="kt">Type</span> := Pack {sort; _ : class_of sort}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c <span class="kr">as</span> cT&#39; := cT <span class="kr">return</span> class_of cT&#39; <span class="kr">in</span> c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack T c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pack</span> (<span class="nv">m0</span> : mixin_of T) :=
  <span class="kr">fun</span> <span class="nv">bT</span> <span class="nv">b</span> &amp; phant_id (Finite.class bT) b =&gt;
  <span class="kr">fun</span> <span class="nv">m</span> &amp; phant_id m0 m =&gt; Pack (@<span class="kn">Class</span> <span class="nf">T</span> <span class="nv">b</span> <span class="nv">m</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT class.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT class.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">countType</span> := @Countable.Pack cT class.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">finType</span> := @Finite.Pack cT class.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ClassDef</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Import</span> Exports.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Finite.class_of.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; mixin_of.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">eqType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">choiceType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">countType</span> : type &gt;-&gt; Countable.type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">countType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">finType</span> : type &gt;-&gt; Finite.type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">finType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">emptyType</span> := type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">EmptyType</span> T m := (@pack T m _ _ id _ id).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;emptyType&#39; &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> := (@clone T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;emptyType&#39;  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) : form_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;emptyType&#39; &#39;of&#39; T ]&quot;</span> := (@clone T _ _ id)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;emptyType&#39;  &#39;of&#39;  T ]&quot;</span>) : form_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">eqMixin</span> : mixin_of &gt;-&gt; Equality.mixin_of.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [mixin; eqMixin] : class_of &gt;-&gt; Equality.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[base; Finite.base; Choice.base] : class_of &gt;-&gt; Equality.mixin_of.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">choiceMixin</span> : mixin_of &gt;-&gt; Choice.mixin_of.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [mixin; choiceMixin] : class_of &gt;-&gt; Choice.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[base; Finite.base; Choice.mixin] : class_of &gt;-&gt; Choice.mixin_of.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">countMixin</span> : mixin_of &gt;-&gt; Countable.mixin_of.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [mixin; countMixin] : class_of &gt;-&gt; Countable.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[base; Finite.mixin; Finite.mixin_base] : class_of &gt;-&gt; Countable.mixin_of.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">End</span> <span class="nf">Exports</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [mixin; eqMixin] : class_of &gt;-&gt; Equality.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[base; Finite.base; Choice.base] : class_of &gt;-&gt; Equality.mixin_of.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [mixin; choiceMixin] : class_of &gt;-&gt; Choice.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[base; Finite.base; Choice.mixin] : class_of &gt;-&gt; Choice.mixin_of.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [mixin; countMixin] : class_of &gt;-&gt; Countable.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[base; Finite.mixin; Finite.mixin_base] : class_of &gt;-&gt; Countable.mixin_of.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Empty</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Export</span> Empty.Exports.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Empty.mixin; Empty.eqMixin] : Empty.class_of &gt;-&gt; Equality.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[Empty.base; Finite.base; Choice.base] : Empty.class_of &gt;-&gt; Equality.mixin_of.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Empty.mixin; Empty.choiceMixin] : Empty.class_of &gt;-&gt; Choice.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[Empty.base; Finite.base; Choice.mixin] : Empty.class_of &gt;-&gt; Choice.mixin_of.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Empty.mixin; Empty.countMixin] : Empty.class_of &gt;-&gt; Countable.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[Empty.base; Finite.mixin; Finite.mixin_base] : Empty.class_of &gt;-&gt; Countable.mixin_of.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">False_emptyMixin</span> : Empty.mixin_of <span class="kt">False</span> := id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">False_eqType</span> := EqType <span class="kt">False</span> False_emptyMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">False_choiceType</span> := ChoiceType <span class="kt">False</span> False_emptyMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">False_countType</span> := CountType <span class="kt">False</span> False_emptyMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">False_finType</span> := FinType <span class="kt">False</span> (Empty.finMixin False_emptyMixin).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">False_emptyType</span> := EmptyType <span class="kt">False</span> False_emptyMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">void_emptyMixin</span> : Empty.mixin_of void := @of_void _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">void_emptyType</span> := EmptyType void void_emptyMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">no</span> {<span class="nv">T</span> : emptyType} : T -&gt; <span class="kt">False</span> :=
  <span class="kr">let</span>: Empty.Pack _ (Empty.<span class="kn">Class</span> <span class="nf">_</span> <span class="nv">f</span>) := T <span class="kr">in</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">any</span> {<span class="nv">T</span> : emptyType} {<span class="nv">U</span>}  : T -&gt; U := @False_rect _ \o no.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">empty_eq0</span> {<span class="nv">T</span> : emptyType} : all_equal_to (set0 : <span class="nb">set</span> T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span>emptyType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">all_equal_to (set0 : <span class="nb">set</span> T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bcc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; X; <span class="nb">apply</span>/setF_eq0/no.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">quasi_canonical_of</span> <span class="nv">T</span> <span class="nv">C</span> (<span class="nv">sort</span> : C -&gt; T) (<span class="nv">alt</span>  : emptyType -&gt; T):=
    <span class="kr">forall</span> (<span class="nv">G</span> : T -&gt; <span class="kt">Type</span>), (<span class="kr">forall</span> <span class="nv">s</span> : emptyType, G (alt s)) -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, G (sort x)) -&gt;
  <span class="kr">forall</span> <span class="nv">x</span>, G x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">quasi_canonical_</span> sort alt := (@quasi_canonical_of _ _ sort alt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">quasi_canonical</span> T C := (@quasi_canonical_of T C id id).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">qcanon</span> <span class="nv">T</span> <span class="nv">C</span> (<span class="nv">sort</span> : C -&gt; T) (<span class="nv">alt</span> : emptyType -&gt; T) :
    (<span class="kr">forall</span> <span class="nv">x</span>, (<span class="kr">exists</span> <span class="nv">y</span> : emptyType, alt y = x) + (<span class="kr">exists</span> <span class="nv">y</span>, sort y = x)) -&gt;
  quasi_canonical_ sort alt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>sort</var><span class="hyp-type"><b>: </b><span>C -&gt; T</span></span></span><br><span><var>alt</var><span class="hyp-type"><b>: </b><span>emptyType -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T,
 (<span class="kr">exists</span> <span class="nv">y</span> : emptyType, alt y = x) +
 (<span class="kr">exists</span> <span class="nv">y</span> : C, sort y = x)) -&gt;
quasi_canonical_ sort alt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bd3</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; + G Cx Gs x =&gt; /(_ x)[/cid[y &lt;-]|/cid[y &lt;-]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> qcanon {T C sort alt} x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">choicePpointed</span> : quasi_canonical choiceType pointedType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">quasi_canonical_ [eta Pointed.choiceType]
  [eta Empty.choiceType]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bdc</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: qcanon =&gt; T; <span class="nb">have</span> [/unsquash x|/(_ (squash _)) TF] := pselect $|T|.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>56b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">exists</span> <span class="nv">y</span> : emptyType, y = T) +
 (<span class="kr">exists</span> <span class="nv">y</span> : pointedType, y = T))%type</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><span><var>TF</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">False</span></span></span></span><br></div><label class="goal-separator"><hr></label><q>be3</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="kr">exists</span> (<span class="nv">PointedType</span> <span class="nv">T</span> <span class="nv">x</span>); <span class="nb">case</span>: T x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>be6</q><span class="goal-separator"><hr></span><q>be3</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>be6</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">y</span> : emptyType, y = T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">pose</span> cT := CountType _ (TF : Empty.mixin_of T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>be7</q><br><span><var>cT</var><span><span class="hyp-body"><b>:= </b><span>CountType T (TF : Empty.mixin_of T)</span></span><span class="hyp-type"><b>: </b><span>countType</span></span></span></span><br></div><span class="goal-separator"><hr></span><q>bee</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">pose</span> fM := Empty.finMixin (TF : Empty.mixin_of cT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49e</q><br><q>be7</q><br><q>bf3</q><br><span><var>fM</var><span><span class="hyp-body"><b>:= </b><span>Empty.finMixin (TF : Empty.mixin_of cT)</span></span><span class="hyp-type"><b>: </b><span>Finite.mixin_of cT</span></span></span></span><br></div><span class="goal-separator"><hr></span><q>bee</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> (<span class="nv">EmptyType</span> (FinType _ fM) TF) =&gt; //=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>bf7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">EmptyType T TF = T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: T TF @cT @fM.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eqPpointed</span> : quasi_canonical eqType pointedType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">quasi_canonical_ [eta Pointed.eqType]
  [eta Empty.eqType]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bfe</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: qcanon; <span class="nb">elim</span>/eqPchoice; <span class="nb">elim</span>/choicePpointed =&gt; [[T F]|T];
   [<span class="nb">left</span>; <span class="kr">exists</span> (<span class="nv">Empty</span>.Pack F) | <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">T</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">Ppointed</span> : quasi_canonical <span class="kt">Type</span> pointedType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">quasi_canonical_ [eta Pointed.sort] [eta Empty.sort]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c03</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: qcanon; <span class="nb">elim</span>/Peq; <span class="nb">elim</span>/eqPpointed =&gt; [[T F]|T];
   [<span class="nb">left</span>; <span class="kr">exists</span> (<span class="nv">Empty</span>.Pack F) | <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">T</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">partitions</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trivIset</span> <span class="nv">T</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :=
  <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : I, D i -&gt; D j -&gt; F i `&amp;` F j !=set0 -&gt; i = j.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_mkcond</span> <span class="nv">T</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
  trivIset D F &lt;-&gt; trivIset setT (<span class="kr">fun</span> <span class="nv">i</span> =&gt; <span class="kr">if</span> i \<span class="kr">in</span> D <span class="kr">then</span> F i <span class="kr">else</span> set0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7a2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D F &lt;-&gt;
trivIset [<span class="nb">set</span>: I]
  (<span class="kr">fun</span> <span class="nv">i</span> : I =&gt; <span class="kr">if</span> i \<span class="kr">in</span> D <span class="kr">then</span> F i <span class="kr">else</span> set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c08</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [tA i j _ _|tA i j Di Dj]; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7a2</q><br><span><var>tA</var><span class="hyp-type"><b>: </b><span>trivIset [<span class="nb">set</span>: I]
  (<span class="kr">fun</span> <span class="nv">i</span> : I =&gt; <span class="kr">if</span> i \<span class="kr">in</span> D <span class="kr">then</span> F i <span class="kr">else</span> set0)</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>Dj</var><span class="hyp-type"><b>: </b><span>D j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F i `&amp;` F j !=set0 -&gt; i = j</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7a2</q><br><span><var>tA</var><span class="hyp-type"><b>: </b><span>trivIset D F</span></span></span><br><q>c12</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> i \<span class="kr">in</span> D <span class="kr">then</span> F i <span class="kr">else</span> set0)
`&amp;` (<span class="kr">if</span> j \<span class="kr">in</span> D <span class="kr">then</span> F j <span class="kr">else</span> set0) !=set0 -&gt; i = j</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> := tA i j Logic.I Logic.I; <span class="nb">rewrite</span> !mem_set.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c18</q><span class="goal-separator"><hr></span><q>c1a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: ifPn =&gt; iD; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> set0I =&gt; -[].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7a2</q><br><q>c19</q><br><q>c12</q><br><span><var>iD</var><span class="hyp-type"><b>: </b><span>i \<span class="kr">in</span> D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F i `&amp;` (<span class="kr">if</span> j \<span class="kr">in</span> D <span class="kr">then</span> F j <span class="kr">else</span> set0) !=set0 -&gt;
i = j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; [jD /tA|jD]; [<span class="nb">apply</span>; <span class="bp">exact</span>: set_mem|<span class="nb">rewrite</span> setI0 =&gt; -[]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_set0</span> {<span class="nv">I</span> <span class="nv">T</span>} (<span class="nv">D</span> : <span class="nb">set</span> I) : trivIset D (<span class="kr">fun</span>=&gt; set0 : <span class="nb">set</span> T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9a3</q><br><q>6c5</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D (<span class="kr">fun</span>=&gt; set0 : <span class="nb">set</span> T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c25</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; i j Di Dj; <span class="nb">rewrite</span> setI0 =&gt; /set0P; <span class="nb">rewrite</span> eqxx.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIsetP</span> {<span class="nv">T</span>} {<span class="nv">I</span> : eqType} {<span class="nv">D</span> : <span class="nb">set</span> I} {<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T} :
  trivIset D F &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : I, D i -&gt; D j -&gt; i != j -&gt; F i `&amp;` F j = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>I</var><span class="hyp-type"><b>: </b><span>eqType</span></span></span><br><q>6c5</q><br><q>7a2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D F &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : I,
 D i -&gt; D j -&gt; i != j -&gt; F i `&amp;` F j = set0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c2b</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; tDF i j Di Dj; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: contraNeq =&gt; /set0P/tDF-&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>c2e</q><br><q>6c5</q><br><q>7a2</q><br><span><var>tDF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : I, D i -&gt; D j -&gt; i != j -&gt; F i `&amp;` F j = set0</span></span></span><br><q>c12</q><br><q>c13</q><br><q>c14</q><br></div><span class="goal-separator"><hr></span><q>c15</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /set0P; <span class="nb">apply</span>: contraNeq =&gt; /tDF-&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_bigsetUI</span> <span class="nv">T</span> (<span class="nv">D</span> : {pred nat}) (<span class="nv">F</span> : nat -&gt; <span class="nb">set</span> T) : trivIset D F -&gt;
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, D m -&gt; n &lt;= m -&gt; \big[setU/set0]_(i &lt; n | D i) F i `&amp;` F m = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>D</var><span class="hyp-type"><b>: </b><span>{pred nat}</span></span></span><br><q>a81</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; D x) F -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
D m -&gt;
n &lt;= m -&gt;
\big[setU/set0]_(i &lt; n | D i) F i `&amp;` F m = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c37</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; /trivIsetP tA; <span class="nb">elim</span> =&gt; [|n IHn] m Dm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>c3a</q><br><q>a81</q><br><span><var>tA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat_eqType,
D i -&gt; D j -&gt; i != j -&gt; F i `&amp;` F j = set0</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Dm</var><span class="hyp-type"><b>: </b><span>D m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= m -&gt;
\big[setU/set0]_(i &lt; <span class="mi">0</span> | D i) F i `&amp;` F m = set0</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>c3a</q><br><q>a81</q><br><q>c41</q><br><q>4c5</q><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : nat,
D m -&gt; n &lt;= m -&gt; \big[setU/set0]_(i &lt; n | D i) F i `&amp;` F m = set0</span></span></span><br><q>c42</q><br><q>c43</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">n &lt; m -&gt;
\big[setU/set0]_(i &lt; n.+<span class="mi">1</span> | D i) F i `&amp;` F m = set0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> big_ord0 set0I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c47</q><span class="goal-separator"><hr></span><q>c49</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; lt_nm; <span class="nb">rewrite</span> big_mkcond/= big_ord_recr -big_mkcond/=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>c3a</q><br><q>a81</q><br><q>c41</q><br><q>4c5</q><br><q>c48</q><br><q>c42</q><br><q>c43</q><br><span><var>lt_nm</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\big[setU/set0]_(i &lt; n | D i) F i
 `|` (<span class="kr">if</span> D n <span class="kr">then</span> F n <span class="kr">else</span> set0)) `&amp;` F m = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> setIUl IHn <span class="mi">1</span><span class="nl">?ltnW</span>// set0U.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c50</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> D n <span class="kr">then</span> F n <span class="kr">else</span> set0) `&amp;` F m = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; [Dn|NDn]; <span class="nb">rewrite</span> <span class="nl">?set0I</span>// tA// ltn_eqF.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_setIl</span> (<span class="nv">T</span> <span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">G</span> : I -&gt; <span class="nb">set</span> T) :
  trivIset D F -&gt; trivIset D (<span class="kr">fun</span> <span class="nv">i</span> =&gt; G i `&amp;` F i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7b4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D F -&gt; trivIset D (<span class="kr">fun</span> <span class="nv">i</span> : I =&gt; G i `&amp;` F i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c58</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; tF i j Di Dj [x [[Gix Fix] [Gjx Fjx]]]; <span class="nb">apply</span> tF =&gt; //; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_setIr</span> (<span class="nv">T</span> <span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">G</span> : I -&gt; <span class="nb">set</span> T) :
  trivIset D F -&gt; trivIset D (<span class="kr">fun</span> <span class="nv">i</span> =&gt; F i `&amp;` G i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c5a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D F -&gt; trivIset D (<span class="kr">fun</span> <span class="nv">i</span> : I =&gt; F i `&amp;` G i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c5e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; tF i j Di Dj [x [[Fix Gix] [Fjx Gjx]]]; <span class="nb">apply</span> tF =&gt; //; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_trivIset</span> <span class="nv">I</span> <span class="nv">T</span> (<span class="nv">D</span> <span class="nv">D&#39;</span> : <span class="nb">set</span> I) (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
  D `&lt;=` D&#39; -&gt; trivIset D&#39; F -&gt; trivIset D F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9a3</q><br><span><var>D, D'</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> I</span></span></span><br><q>7a2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D `&lt;=` D&#39; -&gt; trivIset D&#39; F -&gt; trivIset D F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c63</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; DD&#39; Ftriv i j /DD&#39; + /DD&#39; + /Ftriv-&gt;//.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_bigcup2</span> <span class="nv">T</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
  (A `&amp;` B = set0) = trivIset setT (bigcup2 A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `&amp;` B = set0) = trivIset [<span class="nb">set</span>: nat] (bigcup2 A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c6a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/propext; <span class="nb">split</span>=&gt; [AB0|/trivIsetP/(_ <span class="mi">0</span> <span class="mi">1</span> Logic.I Logic.I erefl)//].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>b3</q><br><span><var>AB0</var><span class="hyp-type"><b>: </b><span>A `&amp;` B = set0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset [<span class="nb">set</span>: nat] (bigcup2 A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/trivIsetP =&gt; -[/=|]; <span class="nb">rewrite</span> /bigcup2 /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c71</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">j</span> : nat,
<span class="kt">True</span> -&gt;
<span class="kt">True</span> -&gt;
<span class="mi">0</span> != j -&gt;
A
`&amp;` (<span class="kr">if</span> j == <span class="mi">0</span> <span class="kr">then</span> A <span class="kr">else</span> <span class="kr">if</span> j == <span class="mi">1</span> <span class="kr">then</span> B <span class="kr">else</span> set0) =
set0</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>c71</q><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">j</span> : nat,
<span class="kt">True</span> -&gt;
<span class="kt">True</span> -&gt;
n.+<span class="mi">1</span> != j -&gt;
(<span class="kr">if</span> n.+<span class="mi">1</span> == <span class="mi">1</span> <span class="kr">then</span> B <span class="kr">else</span> set0)
`&amp;` (<span class="kr">if</span> j == <span class="mi">0</span> <span class="kr">then</span> A <span class="kr">else</span> <span class="kr">if</span> j == <span class="mi">1</span> <span class="kr">then</span> B <span class="kr">else</span> set0) =
set0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>c75</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [//|[_ _ _ //|j _ _ _]]; <span class="nb">rewrite</span> setI0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c71</q><span class="goal-separator"><hr></span><q>c7a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>c7d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; [[j _ _|]|i j _ _ _]; [<span class="bp">by</span> <span class="nb">rewrite</span> setIC| |<span class="bp">by</span> <span class="nb">rewrite</span> set0I].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c71</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
<span class="kt">True</span> -&gt;
<span class="kt">True</span> -&gt;
<span class="mi">1</span> != n.+<span class="mi">1</span> -&gt;
(<span class="kr">if</span> <span class="mi">1</span> == <span class="mi">1</span> <span class="kr">then</span> B <span class="kr">else</span> set0)
`&amp;` (<span class="kr">if</span> n.+<span class="mi">1</span> == <span class="mi">0</span>
     <span class="kr">then</span> A
     <span class="kr">else</span> <span class="kr">if</span> n.+<span class="mi">1</span> == <span class="mi">1</span> <span class="kr">then</span> B <span class="kr">else</span> set0) = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [//|j _ _ _]; <span class="nb">rewrite</span> setI0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_image</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">I&#39;</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; I&#39;) (<span class="nv">F</span> : I&#39; -&gt; <span class="nb">set</span> T) :
  trivIset D (F \o f) -&gt; trivIset (f @` D) F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, I, I'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><q>6c5</q><br><span><var>f</var><span class="hyp-type"><b>: </b><span>I -&gt; I&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>I&#39; -&gt; <span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D (F \o f) -&gt; trivIset [<span class="nb">set</span> f x | x <span class="kr">in</span> D] F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c85</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; trivF i j [{}i Di &lt;-] [{}j Dj &lt;-] Ffij; <span class="nb">congr</span> (f _); <span class="nb">apply</span>: trivF.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> trivIset_image {T I I&#39;} D f F.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_comp</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">I&#39;</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; I&#39;) (<span class="nv">F</span> : I&#39; -&gt; <span class="nb">set</span> T) :
    {<span class="kr">in</span> D &amp;, injective f} -&gt;
  trivIset D (F \o f) = trivIset (f @` D) F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{<span class="kr">in</span> D &amp;, injective f} -&gt;
trivIset D (F \o f) = trivIset [<span class="nb">set</span> f x | x <span class="kr">in</span> D] F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c8e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; finj; <span class="nb">apply</span>/propext; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: trivIset_image.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c88</q><br><q>6c5</q><br><q>c89</q><br><q>c8a</q><br><span><var>finj</var><span class="hyp-type"><b>: </b><span>{<span class="kr">in</span> D &amp;, injective f}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset [<span class="nb">set</span> f x | x <span class="kr">in</span> D] F -&gt; trivIset D (F \o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; trivF i j Di Dj Ffij; <span class="nb">apply</span>: finj; <span class="nb">rewrite</span> <span class="nl">?in_setE</span>//.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c88</q><br><q>6c5</q><br><q>c89</q><br><q>c8a</q><br><span><var>trivF</var><span class="hyp-type"><b>: </b><span>trivIset [<span class="nb">set</span> f x | x <span class="kr">in</span> D] F</span></span></span><br><q>c12</q><br><q>c13</q><br><q>c14</q><br><span><var>Ffij</var><span class="hyp-type"><b>: </b><span>(F \o f) i `&amp;` (F \o f) j !=set0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f i = f j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: trivF =&gt; //=; [<span class="kr">exists</span> <span class="nv">i</span>| <span class="kr">exists</span> <span class="nv">j</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_preimage1</span> {<span class="nv">aT</span> <span class="nv">rT</span>} <span class="nv">D</span> (<span class="nv">f</span> : aT -&gt; rT) :
  trivIset D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> x]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5b4</q><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> rT</span></span></span><br><q>5b5</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D (<span class="kr">fun</span> <span class="nv">x</span> : rT =&gt; f @^-<span class="mi">1</span>` [<span class="nb">set</span> x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ca0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; y z _ _ [x [&lt;- &lt;-]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_preimage1_in</span> {<span class="nv">aT</span>} {<span class="nv">rT</span> : choiceType} (<span class="nv">D</span> : <span class="nb">set</span> rT) (<span class="nv">A</span> : <span class="nb">set</span> aT)
  (<span class="nv">f</span> : aT -&gt; rT) : trivIset D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; A `&amp;` f @^-<span class="mi">1</span>` [<span class="nb">set</span> x]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b2c</q><br><q>b2d</q><br><q>ca3</q><br><q>5b6</q><br><q>5b5</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D (<span class="kr">fun</span> <span class="nv">x</span> : rT =&gt; A `&amp;` f @^-<span class="mi">1</span>` [<span class="nb">set</span> x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ca7</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; y z _ _ [x [[_ &lt;-] [_ &lt;-]]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cover</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">D</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) := \bigcup_(i <span class="kr">in</span> D) F i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">coverE</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">D</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) : cover D F = \bigcup_(i <span class="kr">in</span> D) F i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c0a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cover D F = \bigcup_(i <span class="kr">in</span> D) F i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>cad</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">cover_restr</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">D&#39;</span> <span class="nv">D</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
  D `&lt;=` D&#39; -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, D&#39; i -&gt; ~ D i -&gt; F i = set0) -&gt;
  cover D F = cover D&#39; F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> I</span></span></span><br><q>7a2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D `&lt;=` D&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">i</span> : I, D&#39; i -&gt; ~ D i -&gt; F i = set0) -&gt;
cover D F = cover D&#39; F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>cb2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; DD&#39; D&#39;DF; <span class="nb">rewrite</span> /cover eqEsubset; <span class="nb">split</span>=&gt; [r [i Di Fit]|r [i D&#39;i Fit]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>cb5</q><br><q>7a2</q><br><span><var>DD'</var><span class="hyp-type"><b>: </b><span>D `&lt;=` D&#39;</span></span></span><br><span><var>D'DF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I, D&#39; i -&gt; ~ D i -&gt; F i = set0</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><q>6ce</q><br><q>c13</q><br><span><var>Fit</var><span class="hyp-type"><b>: </b><span>F i r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_(i <span class="kr">in</span> D&#39;) F i) r</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>cb5</q><br><q>7a2</q><br><q>cbc</q><br><q>cbd</q><br><q>cbe</q><br><q>6ce</q><br><span><var>D'i</var><span class="hyp-type"><b>: </b><span>D&#39; i</span></span></span><br><q>cbf</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">(\bigcup_(i <span class="kr">in</span> D) F i) r</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>cb9</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [D&#39;i|] := pselect (D&#39; i); [<span class="kr">exists</span> <span class="nv">i</span> | <span class="nb">have</span> := DD&#39; _ Di].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>cc3</q><span class="goal-separator"><hr></span><q>cc5</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>cc8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [Di|Di] := pselect (D i); [<span class="kr">exists</span> <span class="nv">i</span> | <span class="nb">move</span>: Fit; <span class="nb">rewrite</span> (D&#39;DF i)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eqcover_r</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">D</span> (<span class="nv">F</span> <span class="nv">G</span> : I -&gt; <span class="nb">set</span> T) :
  [<span class="nb">set</span> F i | i <span class="kr">in</span> D] = [<span class="nb">set</span> G i | i <span class="kr">in</span> D] -&gt;
  cover D F = cover D G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c5a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> F i | i <span class="kr">in</span> D] = [<span class="nb">set</span> G i | i <span class="kr">in</span> D] -&gt;
cover D F = cover D G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ccc</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; FG.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7b4</q><br><span><var>FG</var><span class="hyp-type"><b>: </b><span>[<span class="nb">set</span> F i | i <span class="kr">in</span> D] = [<span class="nb">set</span> G i | i <span class="kr">in</span> D]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cover D F = cover D G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [t [i Di Fit]|t [i Di Git]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7b4</q><br><q>cd4</q><br><q>26b</q><br><q>6ce</q><br><q>c13</q><br><q>7b7</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cover D G t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7b4</q><br><q>cd4</q><br><q>26b</q><br><q>6ce</q><br><q>c13</q><br><span><var>Git</var><span class="hyp-type"><b>: </b><span>G i t</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">cover D F t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [j Dj GF] : [<span class="nb">set</span> G i | i <span class="kr">in</span> D] (F i) <span class="bp">by</span> <span class="nb">rewrite</span> -FG /mkset; <span class="kr">exists</span> <span class="nv">i</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7b4</q><br><q>cd4</q><br><q>26b</q><br><q>6ce</q><br><q>c13</q><br><q>7b7</q><br><span><var>j</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><q>c14</q><br><span><var>GF</var><span class="hyp-type"><b>: </b><span>G j = F i</span></span></span><br></div><span class="goal-separator"><hr></span><q>cda</q></blockquote><q>cdb</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">j</span> =&gt; //; <span class="nb">rewrite</span> GF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>cdd</q><span class="goal-separator"><hr></span><q>cdf</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [j Dj GF] : [<span class="nb">set</span> F i | i <span class="kr">in</span> D] (G i) <span class="bp">by</span> <span class="nb">rewrite</span> FG /mkset; <span class="kr">exists</span> <span class="nv">i</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>6c5</q><br><q>7b4</q><br><q>cd4</q><br><q>26b</q><br><q>6ce</q><br><q>c13</q><br><q>cde</q><br><q>ce4</q><br><q>c14</q><br><span><var>GF</var><span class="hyp-type"><b>: </b><span>F j = G i</span></span></span><br></div><span class="goal-separator"><hr></span><q>cdf</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">j</span> =&gt; //; <span class="nb">rewrite</span> GF.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">partition</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">D</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">A</span> : <span class="nb">set</span> T) :=
  [/\ cover D F = A, trivIset D F &amp; <span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; F i !=set0].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pblock_index</span> <span class="nv">T</span> (<span class="nv">I</span> : pointedType) <span class="nv">D</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">x</span> : T) :=
  [get i | D i /\ F i x].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pblock</span> <span class="nv">T</span> (<span class="nv">I</span> : pointedType) <span class="nv">D</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">x</span> : T) :=
  F (pblock_index D F x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* TODO: theory of trivIset, cover, partition, pblock_index and pblock *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">trivIsets</span> X := (trivIset X id).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_sets</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">D</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
  trivIset D F -&gt; trivIsets [<span class="nb">set</span> F i | i <span class="kr">in</span> D].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c0a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D F -&gt; trivIsets [<span class="nb">set</span> F i | i <span class="kr">in</span> D]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>cef</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: trivIset_image.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_widen</span> <span class="nv">T</span> <span class="nv">I</span> <span class="nv">D&#39;</span> <span class="nv">D</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) :
<span class="c">(*  D `&lt;=` D&#39; -&gt; (forall i, D i -&gt; ~ D&#39; i -&gt; F i !=set0) -&gt;*)</span>
  D `&lt;=` D&#39; -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, D&#39; i -&gt; ~ D i -&gt; F i = set0) -&gt;
  trivIset D F = trivIset D&#39; F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>cb4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">D `&lt;=` D&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">i</span> : I, D&#39; i -&gt; ~ D i -&gt; F i = set0) -&gt;
trivIset D F = trivIset D&#39; F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>cf4</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; DD&#39; DD&#39;F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>cb5</q><br><q>7a2</q><br><q>cbc</q><br><span><var>DD'F</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I, D&#39; i -&gt; ~ D i -&gt; F i = set0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D F = trivIset D&#39; F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [DF i j D&#39;i D&#39;j FiFj0|D&#39;F i j Di Dj FiFj0].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>cb5</q><br><q>7a2</q><br><q>cbc</q><br><q>cfc</q><br><span><var>DF</var><span class="hyp-type"><b>: </b><span>trivIset D F</span></span></span><br><q>c12</q><br><q>cc4</q><br><span><var>D'j</var><span class="hyp-type"><b>: </b><span>D&#39; j</span></span></span><br><span><var>FiFj0</var><span class="hyp-type"><b>: </b><span>F i `&amp;` F j !=set0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i = j</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>cb5</q><br><q>7a2</q><br><q>cbc</q><br><q>cfc</q><br><span><var>D'F</var><span class="hyp-type"><b>: </b><span>trivIset D&#39; F</span></span></span><br><q>c12</q><br><q>c13</q><br><q>c14</q><br><q>d04</q><br></div><label class="goal-separator"><hr></label><q>d05</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [Di|Di] := pselect (D i); <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>cb5</q><br><q>7a2</q><br><q>cbc</q><br><q>cfc</q><br><q>d02</q><br><q>c12</q><br><q>cc4</q><br><q>d03</q><br><q>d04</q><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>~ D i</span></span></span><br></div><span class="goal-separator"><hr></span><q>d05</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>cb5</q><br><q>7a2</q><br><q>cbc</q><br><q>cfc</q><br><q>d02</q><br><q>c12</q><br><q>cc4</q><br><q>d03</q><br><q>d04</q><br><q>c13</q><br></div><label class="goal-separator"><hr></label><q>d05</q></blockquote><q>d07</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: FiFj0; <span class="nb">rewrite</span> (DD&#39;F i) // set0I =&gt; /set0P; <span class="nb">rewrite</span> eqxx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d11</q><span class="goal-separator"><hr></span><q>d05</q></blockquote><q>d06</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [Dj|Dj] := pselect (D j).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>cb5</q><br><q>7a2</q><br><q>cbc</q><br><q>cfc</q><br><q>d02</q><br><q>c12</q><br><q>cc4</q><br><q>d03</q><br><q>d04</q><br><q>c13</q><br><q>c14</q><br></div><span class="goal-separator"><hr></span><q>d05</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>7a1</q><br><q>cb5</q><br><q>7a2</q><br><q>cbc</q><br><q>cfc</q><br><q>d02</q><br><q>c12</q><br><q>cc4</q><br><q>d03</q><br><q>d04</q><br><q>c13</q><br><span><var>Dj</var><span class="hyp-type"><b>: </b><span>~ D j</span></span></span><br></div><label class="goal-separator"><hr></label><q>d05</q></blockquote><q>d07</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>d16</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">exact</span>: DF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d1b</q><span class="goal-separator"><hr></span><q>d05</q></blockquote><q>d06</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>d1f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: FiFj0; <span class="nb">rewrite</span> (DD&#39;F j) // setI0 =&gt; /set0P; <span class="nb">rewrite</span> eqxx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d08</q><span class="goal-separator"><hr></span><q>d05</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> D&#39;F =&gt; //; <span class="nb">apply</span> DD&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">perm_eq_trivIset</span> {<span class="nv">T</span> : eqType} (<span class="nv">s1</span> <span class="nv">s2</span> : seq (<span class="nb">set</span> T)) (<span class="nv">D</span> : <span class="nb">set</span> nat) :
  [<span class="nb">set</span> k | (k &lt; size s1)] `&lt;=` D -&gt; perm_eq s1 s2 -&gt;
  trivIset D (<span class="kr">fun</span> <span class="nv">i</span> =&gt; nth set0 s1 i) -&gt; trivIset D (<span class="kr">fun</span> <span class="nv">i</span> =&gt; nth set0 s2 i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>seq (<span class="nb">set</span> T)</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_(size s1) `&lt;=` D -&gt;
perm_eq s1 s2 -&gt;
trivIset D [eta nth set0 s1] -&gt;
trivIset D [eta nth set0 s2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>d26</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; s1D; <span class="nb">rewrite</span> perm_sym =&gt; /(perm_iotaP set0)[s ss1 s12] /trivIsetP ts1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><q>d29</q><br><q>d2a</q><br><span><var>s1D</var><span class="hyp-type"><b>: </b><span>`I_(size s1) `&lt;=` D</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>seq nat_eqType</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>perm_eq s (iota <span class="mi">0</span> (size s1))</span></span></span><br><span><var>s12</var><span class="hyp-type"><b>: </b><span>s2 = [seq nth set0 s1 i | i &lt;- s]</span></span></span><br><span><var>ts1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat_eqType,
D i -&gt; D j -&gt; i != j -&gt; nth set0 s1 i `&amp;` nth set0 s1 j = set0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset D [eta nth set0 s2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/trivIsetP =&gt; i j Di Dj ij.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><q>d29</q><br><q>d2a</q><br><q>d31</q><br><q>d32</q><br><q>d33</q><br><q>d34</q><br><q>d35</q><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>nat_eqType</span></span></span><br><q>c13</q><br><q>c14</q><br><span><var>ij</var><span class="hyp-type"><b>: </b><span>i != j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth set0 s2 i `&amp;` nth set0 s2 j = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}s12 {s2}; <span class="nb">have</span> [si|si] := ltnP i (size s); <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>seq (<span class="nb">set</span> T)</span></span></span><br><q>d2a</q><br><q>d31</q><br><q>d32</q><br><q>d33</q><br><q>d35</q><br><q>d3b</q><br><q>c13</q><br><q>c14</q><br><q>d3c</q><br><span><var>si</var><span class="hyp-type"><b>: </b><span>size s &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth set0 [seq nth set0 s1 i | i &lt;- s] i
`&amp;` nth set0 [seq nth set0 s1 i | i &lt;- s] j = set0</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><q>d42</q><br><q>d2a</q><br><q>d31</q><br><q>d32</q><br><q>d33</q><br><q>d35</q><br><q>d3b</q><br><q>c13</q><br><q>c14</q><br><q>d3c</q><br><span><var>si</var><span class="hyp-type"><b>: </b><span>i &lt; size s</span></span></span><br></div><label class="goal-separator"><hr></label><q>d44</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (nth_default set0) <span class="nl">?size_map</span>// set0I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d47</q><span class="goal-separator"><hr></span><q>d44</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> (nth_map O) //; <span class="nb">have</span> [sj|sj] := ltnP j (size s); <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><q>d42</q><br><q>d2a</q><br><q>d31</q><br><q>d32</q><br><q>d33</q><br><q>d35</q><br><q>d3b</q><br><q>c13</q><br><q>c14</q><br><q>d3c</q><br><q>d48</q><br><span><var>sj</var><span class="hyp-type"><b>: </b><span>size s &lt;= j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth set0 s1 (nth <span class="mi">0</span> s i)
`&amp;` nth set0 [seq nth set0 s1 i | i &lt;- s] j = set0</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><q>d42</q><br><q>d2a</q><br><q>d31</q><br><q>d32</q><br><q>d33</q><br><q>d35</q><br><q>d3b</q><br><q>c13</q><br><q>c14</q><br><q>d3c</q><br><q>d48</q><br><span><var>sj</var><span class="hyp-type"><b>: </b><span>j &lt; size s</span></span></span><br></div><label class="goal-separator"><hr></label><q>d51</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (nth_default set0) <span class="nl">?size_map</span>// setI0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d54</q><span class="goal-separator"><hr></span><q>d51</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> nth_mem k : k &lt; size s -&gt; nth O s k \<span class="kr">in</span> iota <span class="mi">0</span> (size s1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><q>d42</q><br><q>d2a</q><br><q>d31</q><br><q>d32</q><br><q>d33</q><br><q>d35</q><br><q>d3b</q><br><q>c13</q><br><q>c14</q><br><q>d3c</q><br><q>d48</q><br><q>d55</q><br><q>ab1</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k &lt; size s -&gt; nth <span class="mi">0</span> s k \<span class="kr">in</span> iota <span class="mi">0</span> (size s1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><q>d42</q><br><q>d2a</q><br><q>d31</q><br><q>d32</q><br><q>d33</q><br><q>d35</q><br><q>d3b</q><br><q>c13</q><br><q>c14</q><br><q>d3c</q><br><q>d48</q><br><q>d55</q><br><span><var>nth_mem</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat,
k &lt; size s -&gt; nth <span class="mi">0</span> s k \<span class="kr">in</span> iota <span class="mi">0</span> (size s1)</span></span></span><br></div><label class="goal-separator"><hr></label><q>d51</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> -(perm_mem ss1) mem_nth.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d60</q><span class="goal-separator"><hr></span><q>d51</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> (nth_map O)// ts1 ?(nth_uniq,(perm_uniq ss1),iota_uniq)//; <span class="nb">apply</span>/s1D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d60</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`I_(size s1) (nth <span class="mi">0</span> s i)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>4a5</q><br><q>d42</q><br><q>d2a</q><br><q>d31</q><br><q>d32</q><br><q>d33</q><br><span><var>ts1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat_eqType,
D i -&gt;
D j -&gt;
i != j -&gt; nth set0 s1 i `&amp;` nth set0 s1 j = set0</span></span></span><br><q>d3b</q><br><q>c13</q><br><q>c14</q><br><q>d3c</q><br><q>d48</q><br><q>d55</q><br><q>d61</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">`I_(size s1) (nth <span class="mi">0</span> s j)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>d66</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> := nth_mem _ si; <span class="nb">rewrite</span> mem_iota leq0n add0n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d60</q><span class="goal-separator"><hr></span><q>d6d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>d70</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> := nth_mem _ sj; <span class="nb">rewrite</span> mem_iota leq0n add0n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">partitions</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[deprecated(note=<span class="s2">&quot;Use trivIset_setIl instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">trivIset_setI</span> := trivIset_setIl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">total_on</span> <span class="nv">T</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">R</span> : T -&gt; T -&gt; <span class="kt">Prop</span>) :=
  <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span>, A s -&gt; A t -&gt; R s t \/ R t s.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ZL</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">t0</span> : T) (<span class="nv">R</span> : T -&gt; T -&gt; <span class="kt">Prop</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> (<span class="nv">Rrefl</span> : <span class="kr">forall</span> <span class="nv">t</span>, R t t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> (<span class="nv">Rtrans</span> : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">s</span> <span class="nv">t</span>, R r s -&gt; R s t -&gt; R r t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> (<span class="nv">Rantisym</span> : <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span>, R s t -&gt; R t s -&gt; s = t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> (<span class="nv">tot_lub</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> T, total_on A R -&gt; <span class="kr">exists</span> <span class="nv">t</span>,
  (<span class="kr">forall</span> <span class="nv">s</span>, A s -&gt; R s t) /\ <span class="kr">forall</span> <span class="nv">r</span>, (<span class="kr">forall</span> <span class="nv">s</span>, A s -&gt; R s r) -&gt; R t r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> (<span class="nv">Rsucc</span> : <span class="kr">forall</span> <span class="nv">s</span>, <span class="kr">exists</span> <span class="nv">t</span>, R s t /\ s &lt;&gt; t /\
  <span class="kr">forall</span> <span class="nv">r</span>, R s r -&gt; R r t -&gt; r = s \/ r = t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">Teq</span> := @gen_eqMixin T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">Tch</span> := @gen_choiceMixin T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">Tp</span> := Pointed.Pack (Pointed.<span class="kn">Class</span> (Choice.<span class="kn">Class</span> <span class="nf">Teq</span> <span class="nv">Tch</span>) t0).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">lub</span> := <span class="kr">fun</span> <span class="nv">A</span> : {A : <span class="nb">set</span> T | total_on A R} =&gt;
  [get t : Tp | (<span class="kr">forall</span> <span class="nv">s</span>, sval A s -&gt; R s t) /\
    <span class="kr">forall</span> <span class="nv">r</span>, (<span class="kr">forall</span> <span class="nv">s</span>, sval A s -&gt; R s r) -&gt; R t r].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">succ</span> := <span class="kr">fun</span> <span class="nv">s</span> =&gt; [get t : Tp | R s t /\ s &lt;&gt; t /\
  <span class="kr">forall</span> <span class="nv">r</span>, R s r -&gt; R r t -&gt; r = s \/ r = t].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">tower</span> : <span class="nb">set</span> T :=
  | Lub : <span class="kr">forall</span> <span class="nv">A</span>, sval A `&lt;=` tower -&gt; tower (lub A)
  | Succ : <span class="kr">forall</span> <span class="nv">t</span>, tower t -&gt; tower (succ t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ZL&#39;</span> : <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>T -&gt; T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Rrefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : T, R t t</span></span></span><br><span><var>Rtrans</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> <span class="nv">s</span> <span class="nv">t</span> : T, R r s -&gt; R s t -&gt; R r t</span></span></span><br><span><var>Rantisym</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span> : T, R s t -&gt; R t s -&gt; s = t</span></span></span><br><span><var>tot_lub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> T,
total_on A R -&gt;
<span class="kr">exists</span> <span class="nv">t</span> : T,
  (<span class="kr">forall</span> <span class="nv">s</span> : T, A s -&gt; R s t) /\
  (<span class="kr">forall</span> <span class="nv">r</span> : T,
   (<span class="kr">forall</span> <span class="nv">s</span> : T, A s -&gt; R s r) -&gt; R t r)</span></span></span><br><span><var>Rsucc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : T,
<span class="kr">exists</span> <span class="nv">t</span> : T,
  R s t /\
  s &lt;&gt; t /\
  (<span class="kr">forall</span> <span class="nv">r</span> : T,
   R s r -&gt; R r t -&gt; r = s \/ r = t)</span></span></span><br><span><var>Teq</var><span><span class="hyp-body"><b>:= </b><span>gen_eqMixin</span></span><span class="hyp-type"><b>: </b><span>Equality.mixin_of T</span></span></span></span><br><span><var>Tch</var><span><span class="hyp-body"><b>:= </b><span>gen_choiceMixin</span></span><span class="hyp-type"><b>: </b><span>choiceMixin T</span></span></span></span><br><span><var>Tp</var><span><span class="hyp-body"><b>:= </b><span>Pointed.Pack
  {|
    Pointed.base :=
      {|
        Choice.base := Teq; Choice.mixin := Tch
      |};
    Pointed.mixin := t0
  |}</span></span><span class="hyp-type"><b>: </b><span>pointedType</span></span></span></span><br><span><var>lub</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">A</span> : {A : <span class="nb">set</span> T | total_on A R} =&gt;
[get t : Tp | (<span class="kr">forall</span> <span class="nv">s</span> : T,
               (@sval) (<span class="nb">set</span> T)
                 ((total_on (T:=T))^~ R) A s -&gt;
               R s t) /\
              (<span class="kr">forall</span> <span class="nv">r</span> : T,
               (<span class="kr">forall</span> <span class="nv">s</span> : T,
                (@sval) 
                  (<span class="nb">set</span> T) 
                  ((total_on (T:=T))^~ R) A s -&gt;
                R s r) -&gt; 
               R t r)]</span></span><span class="hyp-type"><b>: </b><span>{A : <span class="nb">set</span> T | total_on A R} -&gt; Tp</span></span></span></span><br><span><var>succ</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">s</span> : T =&gt;
[get t : Tp | R s t /\
              s &lt;&gt; t /\
              (<span class="kr">forall</span> <span class="nv">r</span> : T,
               R s r -&gt; R r t -&gt; r = s \/ r = t)]</span></span><span class="hyp-type"><b>: </b><span>T -&gt; Tp</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>d74</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> lub_ub (A : {A : <span class="nb">set</span> T | total_on A R}) :
  <span class="kr">forall</span> <span class="nv">s</span>, sval A s -&gt; R s (lub A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><span><var>A</var><span class="hyp-type"><b>: </b><span>{A : <span class="nb">set</span> T | total_on A R}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">s</span> : T,
(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt;
R s (lub A)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><span><var>lub_ub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : {A : <span class="nb">set</span> T | total_on A R})
  (<span class="nv">s</span> : T),
(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt;
R s (lub A)</span></span></span><br></div><label class="goal-separator"><hr></label><q>d83</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">suff</span> /getPex [] : <span class="kr">exists</span> <span class="nv">t</span> : Tp, (<span class="kr">forall</span> <span class="nv">s</span>, sval A s -&gt; R s t) /\
    <span class="kr">forall</span> <span class="nv">r</span>, (<span class="kr">forall</span> <span class="nv">s</span>, sval A s -&gt; R s r) -&gt; R t r <span class="bp">by</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d88</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : Tp,
  (<span class="kr">forall</span> <span class="nv">s</span> : T,
   (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt;
   R s t) /\
  (<span class="kr">forall</span> <span class="nv">r</span> : T,
   (<span class="kr">forall</span> <span class="nv">s</span> : T,
    (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt;
    R s r) -&gt; R t r)</div></blockquote><q>d8b</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: tot_lub; <span class="nb">apply</span>: (svalP A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d8d</q><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> lub_lub (A : {A : <span class="nb">set</span> T | total_on A R}) :
  <span class="kr">forall</span> <span class="nv">t</span>, (<span class="kr">forall</span> <span class="nv">s</span>, sval A s -&gt; R s t) -&gt; R (lub A) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d89</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T,
(<span class="kr">forall</span> <span class="nv">s</span> : T,
 (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt; R s t) -&gt;
R (lub A) t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><span><var>lub_lub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : {A : <span class="nb">set</span> T | total_on A R})
  (<span class="nv">t</span> : T),
(<span class="kr">forall</span> <span class="nv">s</span> : T,
 (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt;
 R s t) -&gt; R (lub A) t</span></span></span><br></div><label class="goal-separator"><hr></label><q>d83</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">suff</span> /getPex [] : <span class="kr">exists</span> <span class="nv">t</span> : Tp, (<span class="kr">forall</span> <span class="nv">s</span>, sval A s -&gt; R s t) /\
    <span class="kr">forall</span> <span class="nv">r</span>, (<span class="kr">forall</span> <span class="nv">s</span>, sval A s -&gt; R s r) -&gt; R t r <span class="bp">by</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d99</q><span class="goal-separator"><hr></span><q>d92</q></blockquote><q>d9b</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: tot_lub; <span class="nb">apply</span>: (svalP A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d9d</q><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> RS s : R s (succ s) /\ s &lt;&gt; succ s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><span><var>s</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R s (succ s) /\ s &lt;&gt; succ s</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><span><var>RS</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : T, R s (succ s) /\ s &lt;&gt; succ s</span></span></span><br></div><label class="goal-separator"><hr></label><q>d83</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> /getPex [? []] : <span class="kr">exists</span> <span class="nv">t</span> : Tp, R s t /\ s &lt;&gt; t /\
    <span class="kr">forall</span> <span class="nv">r</span>, R s r -&gt; R r t -&gt; r = s \/ r = t <span class="bp">by</span> <span class="nb">apply</span>: Rsucc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>dad</q><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> succS s : <span class="kr">forall</span> <span class="nv">t</span>, R s t -&gt; R t (succ s) -&gt; t = s \/ t = succ s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>da9</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T,
R s t -&gt; R t (succ s) -&gt; t = s \/ t = succ s</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><span><var>succS</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span> : T,
R s t -&gt; R t (succ s) -&gt; t = s \/ t = succ s</span></span></span><br></div><label class="goal-separator"><hr></label><q>d83</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> /getPex [? []] : <span class="kr">exists</span> <span class="nv">t</span> : Tp, R s t /\ s &lt;&gt; t /\
    <span class="kr">forall</span> <span class="nv">r</span>, R s r -&gt; R r t -&gt; r = s \/ r = t <span class="bp">by</span> <span class="nb">apply</span>: Rsucc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>db9</q><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">suff</span> Twtot : total_on tower R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><span><var>Twtot</var><span class="hyp-type"><b>: </b><span>total_on tower R</span></span></span><br></div><span class="goal-separator"><hr></span><q>d83</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>db9</q><label class="goal-separator"><hr></label><div class="goal-conclusion">total_on tower R</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [R_S] := RS (lub (exist _ tower Twtot)); <span class="nb">apply</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>dc2</q><br><span><var>R_S</var><span class="hyp-type"><b>: </b><span>R
  (lub
     (exist ((total_on (T:=T))^~ R) tower Twtot))
  (succ
     (lub
        (exist ((total_on (T:=T))^~ R) tower
           Twtot)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lub (exist ((total_on (T:=T))^~ R) tower Twtot) =
succ (lub (exist ((total_on (T:=T))^~ R) tower Twtot))</div></blockquote><q>dc3</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/Rantisym =&gt; //; <span class="nb">apply</span>/lub_ub/Succ/Lub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>db9</q><span class="goal-separator"><hr></span><q>dc5</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; s t Tws; <span class="nb">elim</span>: Tws t =&gt; {s} [A sATw ihA|s Tws ihs] t Twt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>d89</q><br><span><var>sATw</var><span class="hyp-type"><b>: </b><span>(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
`&lt;=` tower</span></span></span><br><span><var>ihA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : T,
(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A t -&gt;
<span class="kr">forall</span> <span class="nv">t0</span> : T, tower t0 -&gt; R t t0 \/ R t0 t</span></span></span><br><q>26b</q><br><span><var>Twt</var><span class="hyp-type"><b>: </b><span>tower t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (lub A) t \/ R t (lub A)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><span><var>Tws</var><span class="hyp-type"><b>: </b><span>tower s</span></span></span><br><span><var>ihs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : T, tower t -&gt; R s t \/ R t s</span></span></span><br><q>26b</q><br><q>dd5</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">R (succ s) t \/ R t (succ s)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [?|/asboolP] := pselect (<span class="kr">forall</span> <span class="nv">s</span>, sval A s -&gt; R s t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>d89</q><br><q>dd3</q><br><q>dd4</q><br><q>26b</q><br><q>dd5</q><br><span><var>_a_</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : T,
(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt;
R s t</span></span></span><br></div><span class="goal-separator"><hr></span><q>dd6</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>dd2</q><label class="goal-separator"><hr></label><div class="goal-conclusion">`[&lt; ~
    (<span class="kr">forall</span> <span class="nv">s</span> : T,
     (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt;
     R s t) &gt;] -&gt; R (lub A) t \/ R t (lub A)</div></blockquote><q>dd8</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span>: lub_lub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>dd2</q><span class="goal-separator"><hr></span><q>de4</q></blockquote><q>dd7</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> asbool_neg =&gt; /existsp_asboolPn [s /asboolP].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>d89</q><br><q>dd3</q><br><q>dd4</q><br><q>26b</q><br><q>dd5</q><br><q>da9</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; ~
    ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt;
     R s t) &gt;] -&gt; R (lub A) t \/ R t (lub A)</div></blockquote><q>dd7</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> asbool_neg =&gt; /imply_asboolPn [<span class="kn">As</span> nRst]; <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>d89</q><br><q>dd3</q><br><q>dd4</q><br><q>26b</q><br><q>dd5</q><br><q>da9</q><br><span><var>As</var><span class="hyp-type"><b>: </b><span>(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s</span></span></span><br><span><var>nRst</var><span class="hyp-type"><b>: </b><span>~ R s t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R t (lub A)</div></blockquote><q>dd7</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> /lub_ub := <span class="kn">As</span>; <span class="nb">apply</span>: Rtrans; <span class="nb">have</span> [] := ihA _ <span class="kn">As</span> _ Twt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>dd9</q><span class="goal-separator"><hr></span><q>ddc</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">suff</span> /(_ _ Twt) [Rts|RSst] : <span class="kr">forall</span> <span class="nv">r</span>, tower r -&gt; R r s \/ R (succ s) r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><q>dda</q><br><q>ddb</q><br><q>26b</q><br><q>dd5</q><br><span><var>Rts</var><span class="hyp-type"><b>: </b><span>R t s</span></span></span><br></div><span class="goal-separator"><hr></span><q>ddc</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><q>dda</q><br><q>ddb</q><br><q>26b</q><br><q>dd5</q><br><span><var>RSst</var><span class="hyp-type"><b>: </b><span>R (succ s) t</span></span></span><br></div><label class="goal-separator"><hr></label><q>ddc</q></blockquote><blockquote class="alectryon-goal"><q>dd9</q><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : T, tower r -&gt; R r s \/ R (succ s) r</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">apply</span>: Rtrans Rts _; <span class="nb">have</span> [] := RS s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>dfe</q><span class="goal-separator"><hr></span><q>ddc</q></blockquote><div class="alectryon-extra-goals"><q>e00</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>dd9</q><span class="goal-separator"><hr></span><q>e01</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; r; <span class="nb">elim</span>=&gt; {r} [A sATw ihA|r Twr ihr].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><q>dda</q><br><q>ddb</q><br><q>26b</q><br><q>dd5</q><br><q>d89</q><br><q>dd3</q><br><span><var>ihA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : T,
(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A t -&gt;
R t s \/ R (succ s) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (lub A) s \/ R (succ s) (lub A)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><q>dda</q><br><q>ddb</q><br><q>26b</q><br><q>dd5</q><br><q>cbe</q><br><span><var>Twr</var><span class="hyp-type"><b>: </b><span>tower r</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>R r s \/ R (succ s) r</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">R (succ r) s \/ R (succ s) (succ r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [?|/asboolP] := pselect (<span class="kr">forall</span> <span class="nv">r</span>, sval A r -&gt; R r s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><q>dda</q><br><q>ddb</q><br><q>26b</q><br><q>dd5</q><br><q>d89</q><br><q>dd3</q><br><q>e0d</q><br><span><var>_a_</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : T,
(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A r -&gt;
R r s</span></span></span><br></div><span class="goal-separator"><hr></span><q>e0e</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>e0c</q><label class="goal-separator"><hr></label><div class="goal-conclusion">`[&lt; ~
    (<span class="kr">forall</span> <span class="nv">r</span> : T,
     (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A r -&gt;
     R r s) &gt;] -&gt; R (lub A) s \/ R (succ s) (lub A)</div></blockquote><q>e10</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span>: lub_lub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e0c</q><span class="goal-separator"><hr></span><q>e1c</q></blockquote><q>e0f</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> asbool_neg =&gt; /existsp_asboolPn [r /asboolP].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><q>dda</q><br><q>ddb</q><br><q>26b</q><br><q>dd5</q><br><q>d89</q><br><q>dd3</q><br><q>e0d</q><br><q>cbe</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; ~
    ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A r -&gt;
     R r s) &gt;] -&gt; R (lub A) s \/ R (succ s) (lub A)</div></blockquote><q>e0f</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> asbool_neg =&gt; /imply_asboolPn [Ar nRrs]; <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><q>dda</q><br><q>ddb</q><br><q>26b</q><br><q>dd5</q><br><q>d89</q><br><q>dd3</q><br><q>e0d</q><br><q>cbe</q><br><span><var>Ar</var><span class="hyp-type"><b>: </b><span>(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A r</span></span></span><br><span><var>nRrs</var><span class="hyp-type"><b>: </b><span>~ R r s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (succ s) (lub A)</div></blockquote><q>e0f</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> /lub_ub := Ar; <span class="nb">apply</span>: Rtrans; <span class="nb">have</span> /ihA [] := Ar.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e11</q><span class="goal-separator"><hr></span><q>e14</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [Rrs|RSsr] := ihr; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">apply</span>: Rtrans RSsr _; <span class="nb">have</span> [] := RS r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><q>dda</q><br><q>ddb</q><br><q>26b</q><br><q>dd5</q><br><q>cbe</q><br><q>e12</q><br><q>e13</q><br><span><var>Rrs</var><span class="hyp-type"><b>: </b><span>R r s</span></span></span><br></div><span class="goal-separator"><hr></span><q>e14</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> : tower (succ r) <span class="bp">by</span> <span class="nb">apply</span>: Succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e32</q><span class="goal-separator"><hr></span><div class="goal-conclusion">tower (succ r) -&gt; R (succ r) s \/ R (succ s) (succ r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; /ihs [RsSr|]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>d7c</q><br><q>d7d</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d81</q><br><q>d82</q><br><q>d8e</q><br><q>d9e</q><br><q>dae</q><br><q>dba</q><br><q>da9</q><br><q>dda</q><br><q>ddb</q><br><q>26b</q><br><q>dd5</q><br><q>cbe</q><br><q>e12</q><br><q>e13</q><br><q>e33</q><br><span><var>RsSr</var><span class="hyp-type"><b>: </b><span>R s (succ r)</span></span></span><br></div><span class="goal-separator"><hr></span><q>e14</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [-&gt;|-&gt;] := succS _ _ Rrs RsSr; [<span class="nb">right</span>|<span class="nb">left</span>]; <span class="nb">apply</span>: Rrefl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ZL</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">Zorn</span> <span class="nv">T</span> (<span class="nv">R</span> : T -&gt; T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">t</span>, R t t) -&gt; (<span class="kr">forall</span> <span class="nv">r</span> <span class="nv">s</span> <span class="nv">t</span>, R r s -&gt; R s t -&gt; R r t) -&gt;
  (<span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span>, R s t -&gt; R t s -&gt; s = t) -&gt;
  (<span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> T, total_on A R -&gt; <span class="kr">exists</span> <span class="nv">t</span>, <span class="kr">forall</span> <span class="nv">s</span>, A s -&gt; R s t) -&gt;
  <span class="kr">exists</span> <span class="nv">t</span>, <span class="kr">forall</span> <span class="nv">s</span>, R t s -&gt; s = t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">t</span> : T, R t t) -&gt;
(<span class="kr">forall</span> <span class="nv">r</span> <span class="nv">s</span> <span class="nv">t</span> : T, R r s -&gt; R s t -&gt; R r t) -&gt;
(<span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span> : T, R s t -&gt; R t s -&gt; s = t) -&gt;
(<span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> T,
 total_on A R -&gt;
 <span class="kr">exists</span> <span class="nv">t</span> : T, <span class="kr">forall</span> <span class="nv">s</span> : T, A s -&gt; R s t) -&gt;
<span class="kr">exists</span> <span class="nv">t</span> : T, <span class="kr">forall</span> <span class="nv">s</span> : T, R t s -&gt; s = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>e3e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; Rrefl Rtrans Rantisym Rtot_max.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><span><var>Rtot_max</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> T,
total_on A R -&gt;
<span class="kr">exists</span> <span class="nv">t</span> : T, <span class="kr">forall</span> <span class="nv">s</span> : T, A s -&gt; R s t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : T, <span class="kr">forall</span> <span class="nv">s</span> : T, R t s -&gt; s = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> totR := ({A : <span class="nb">set</span> T | total_on A R}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><span><var>totR</var><span><span class="hyp-body"><b>:= </b><span>{A : <span class="nb">set</span> T | total_on A R}</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><q>e48</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> R&#39; := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> : totR =&gt; sval A `&lt;=` sval B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> : totR =&gt;
(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
`&lt;=` (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) B</span></span><span class="hyp-type"><b>: </b><span>totR -&gt; totR -&gt; <span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><q>e48</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> R&#39;refl A : R&#39; A A <span class="bp">by</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><span><var>R'refl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : totR, R&#39; A A</span></span></span><br></div><span class="goal-separator"><hr></span><q>e48</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> R&#39;trans A B C : R&#39; A B -&gt; R&#39; B C -&gt; R&#39; A C <span class="bp">by</span> <span class="nb">apply</span>: subset_trans.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><span><var>R'trans</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : totR,
R&#39; A B -&gt; R&#39; B C -&gt; R&#39; A C</span></span></span><br></div><span class="goal-separator"><hr></span><q>e48</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> R&#39;antisym A B : R&#39; A B -&gt; R&#39; B A -&gt; A = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>totR</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R&#39; A B -&gt; R&#39; B A -&gt; A = B</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><span><var>R'antisym</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : totR,
R&#39; A B -&gt; R&#39; B A -&gt; A = B</span></span></span><br></div><label class="goal-separator"><hr></label><q>e48</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /R&#39;; <span class="nb">case</span>: A; <span class="nb">case</span>: B =&gt; /= B totB A totA sAB sBA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br><span><var>totB</var><span class="hyp-type"><b>: </b><span>total_on B R</span></span></span><br><q>a</q><br><span><var>totA</var><span class="hyp-type"><b>: </b><span>total_on A R</span></span></span><br><q>36b</q><br><span><var>sBA</var><span class="hyp-type"><b>: </b><span>B `&lt;=` A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist ((total_on (T:=T))^~ R) A totA =
exist ((total_on (T:=T))^~ R) B totB</div></blockquote><q>e63</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: eq_exist; <span class="nb">rewrite</span> predeqE=&gt; ?; <span class="nb">split</span>=&gt; [/sAB|/sBA].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e65</q><span class="goal-separator"><hr></span><q>e48</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> R&#39;tot_lub A : total_on A R&#39; -&gt; <span class="kr">exists</span> <span class="nv">t</span>, (<span class="kr">forall</span> <span class="nv">s</span>, A s -&gt; R&#39; s t) /\
    <span class="kr">forall</span> <span class="nv">r</span>, (<span class="kr">forall</span> <span class="nv">s</span>, A s -&gt; R&#39; s r) -&gt; R&#39; t r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> totR</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">total_on A R&#39; -&gt;
<span class="kr">exists</span> <span class="nv">t</span> : totR,
  (<span class="kr">forall</span> <span class="nv">s</span> : totR, A s -&gt; R&#39; s t) /\
  (<span class="kr">forall</span> <span class="nv">r</span> : totR,
   (<span class="kr">forall</span> <span class="nv">s</span> : totR, A s -&gt; R&#39; s r) -&gt; R&#39; t r)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><span><var>R'tot_lub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> totR,
total_on A R&#39; -&gt;
<span class="kr">exists</span> <span class="nv">t</span> : totR,
  (<span class="kr">forall</span> <span class="nv">s</span> : totR, A s -&gt; R&#39; s t) /\
  (<span class="kr">forall</span> <span class="nv">r</span> : totR,
   (<span class="kr">forall</span> <span class="nv">s</span> : totR, A s -&gt; R&#39; s r) -&gt;
   R&#39; t r)</span></span></span><br></div><label class="goal-separator"><hr></label><q>e48</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; Atot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e77</q><br><span><var>Atot</var><span class="hyp-type"><b>: </b><span>total_on A R&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : totR,
  (<span class="kr">forall</span> <span class="nv">s</span> : totR, A s -&gt; R&#39; s t) /\
  (<span class="kr">forall</span> <span class="nv">r</span> : totR,
   (<span class="kr">forall</span> <span class="nv">s</span> : totR, A s -&gt; R&#39; s r) -&gt; R&#39; t r)</div></blockquote><q>e79</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> AUtot : total_on (\bigcup_(B <span class="kr">in</span> A) (sval B)) R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e80</q><span class="goal-separator"><hr></span><div class="goal-conclusion">total_on
  (\bigcup_(B <span class="kr">in</span> A)
      (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) B) R</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e77</q><br><q>e81</q><br><span><var>AUtot</var><span class="hyp-type"><b>: </b><span>total_on
  (\bigcup_(B <span class="kr">in</span> A)
      (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R)
        B) R</span></span></span><br></div><label class="goal-separator"><hr></label><q>e82</q></blockquote><q>e7a</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; s t [B AB Bs] [C AC Ct].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e77</q><br><q>e81</q><br><span><var>s, t</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>totR</span></span></span><br><span><var>AB</var><span class="hyp-type"><b>: </b><span>A B</span></span></span><br><span><var>Bs</var><span class="hyp-type"><b>: </b><span>(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) B s</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>totR</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>A C</span></span></span><br><span><var>Ct</var><span class="hyp-type"><b>: </b><span>(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) C t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R s t \/ R t s</div></blockquote><q>e87</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [/(_ _ Bs) Cs|/(_ _ Ct) Bt] := Atot _ _ AB AC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e77</q><br><q>e81</q><br><q>e8f</q><br><q>e90</q><br><q>e91</q><br><q>e92</q><br><q>e93</q><br><q>e94</q><br><q>e95</q><br><span><var>Cs</var><span class="hyp-type"><b>: </b><span>(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) C s</span></span></span><br></div><span class="goal-separator"><hr></span><q>e96</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e77</q><br><q>e81</q><br><q>e8f</q><br><q>e90</q><br><q>e91</q><br><q>e92</q><br><q>e93</q><br><q>e94</q><br><q>e95</q><br><span><var>Bt</var><span class="hyp-type"><b>: </b><span>(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) B t</span></span></span><br></div><label class="goal-separator"><hr></label><q>e96</q></blockquote><q>e88</q><q>e7a</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> /(_ _ _ Cs Ct) := svalP C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e9e</q><span class="goal-separator"><hr></span><q>e96</q></blockquote><q>e87</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> /(_ _ _ Bs Bt) := svalP B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e89</q><span class="goal-separator"><hr></span><q>e82</q></blockquote><q>e79</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> (<span class="nv">exist</span> <span class="nv">_</span> (\bigcup_(B <span class="kr">in</span> A) sval B) AUtot); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e89</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">s</span> : totR,
A s -&gt;
R&#39; s
  (exist ((total_on (T:=T))^~ R)
     (\bigcup_(B <span class="kr">in</span> A)
         (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) B)
     AUtot)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>e89</q><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : totR,
(<span class="kr">forall</span> <span class="nv">s</span> : totR, A s -&gt; R&#39; s r) -&gt;
R&#39;
  (exist ((total_on (T:=T))^~ R)
     (\bigcup_(B <span class="kr">in</span> A)
         (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) B)
     AUtot) r</div></blockquote><q>e7a</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; B ???; <span class="kr">exists</span> <span class="nv">B</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e89</q><span class="goal-separator"><hr></span><q>eac</q></blockquote><q>e79</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; B Bub ? /= [? /Bub]; <span class="nb">apply</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e7b</q><span class="goal-separator"><hr></span><q>e48</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: contrapT =&gt; nomax.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e7c</q><br><span><var>nomax</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists</span> <span class="nv">t</span> : T, <span class="kr">forall</span> <span class="nv">s</span> : T, R t s -&gt; s = t)</span></span></span><br></div><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> {}nomax t : <span class="kr">exists</span> <span class="nv">s</span>, R t s /\ s &lt;&gt; t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e7c</q><br><q>eb7</q><br><q>26b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">s</span> : T, R t s /\ s &lt;&gt; t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e7c</q><br><span><var>nomax</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : T, <span class="kr">exists</span> <span class="nv">s</span> : T, R t s /\ s &lt;&gt; t</span></span></span><br></div><label class="goal-separator"><hr></label><q>d83</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> /asboolP := nomax; <span class="nb">rewrite</span> asbool_neg =&gt; /forallp_asboolPn /(_ t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ebb</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (<span class="kr">forall</span> <span class="nv">s</span> : T, R t s -&gt; s = t) -&gt;
<span class="kr">exists</span> <span class="nv">s</span> : T, R t s /\ s &lt;&gt; t</div></blockquote><q>ebd</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; /asboolP; <span class="nb">rewrite</span> asbool_neg =&gt; /existsp_asboolPn [s].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e7c</q><br><q>eb7</q><br><span><var>t, s</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (R t s -&gt; s = t) -&gt; <span class="kr">exists</span> <span class="nv">s</span> : T, R t s /\ s &lt;&gt; t</div></blockquote><q>ebd</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /asboolP; <span class="nb">rewrite</span> asbool_neg =&gt; /imply_asboolPn []; <span class="kr">exists</span> <span class="nv">s</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ebf</q><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> tot0 : total_on set0 R <span class="bp">by</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>e7c</q><br><q>ec0</q><br><span><var>tot0</var><span class="hyp-type"><b>: </b><span>total_on set0 R</span></span></span><br></div><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (ZL&#39; (exist _ set0 tot0)) R&#39;tot_lub _ =&gt; // A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>d89</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : {A : <span class="nb">set</span> T | total_on A R},
  R&#39; A t /\
  A &lt;&gt; t /\
  (<span class="kr">forall</span> <span class="nv">r</span> : {A : <span class="nb">set</span> T | total_on A R},
   R&#39; A r -&gt; R&#39; r t -&gt; r = A \/ r = t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> /Rtot_max [t tub] := svalP A; <span class="nb">have</span> [s [Rts snet]] := nomax t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>d89</q><br><q>26b</q><br><span><var>tub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : T,
(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt;
R s t</span></span></span><br><q>da9</q><br><q>dfb</q><br><span><var>snet</var><span class="hyp-type"><b>: </b><span>s &lt;&gt; t</span></span></span><br></div><span class="goal-separator"><hr></span><q>ed7</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> Astot : total_on (sval A `|` [<span class="nb">set</span> s]) R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>edb</q><span class="goal-separator"><hr></span><div class="goal-conclusion">total_on
  ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
   `|` [<span class="nb">set</span> s]) R</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>d89</q><br><q>26b</q><br><q>edc</q><br><q>da9</q><br><q>dfb</q><br><q>edd</q><br><span><var>Astot</var><span class="hyp-type"><b>: </b><span>total_on
  ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
   `|` [<span class="nb">set</span> s]) R</span></span></span><br></div><label class="goal-separator"><hr></label><q>ed7</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; u v [Au|-&gt;]; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>d89</q><br><q>26b</q><br><q>edc</q><br><q>da9</q><br><q>dfb</q><br><q>edd</q><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A `|` [<span class="nb">set</span> s])
  v -&gt; R s v \/ R v s</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>d89</q><br><q>26b</q><br><q>edc</q><br><q>da9</q><br><q>dfb</q><br><q>edd</q><br><q>eea</q><br><span><var>Au</var><span class="hyp-type"><b>: </b><span>(@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A u</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A `|` [<span class="nb">set</span> s])
  v -&gt; R u v \/ R v u</div></blockquote><q>ee3</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [/tub Rvt|-&gt;]; <span class="nb">right</span>=&gt; //; <span class="nb">apply</span>: Rtrans Rts.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>eee</q><span class="goal-separator"><hr></span><q>ef0</q></blockquote><q>ee2</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; [Av|-&gt;]; [<span class="nb">apply</span>: (svalP A)|<span class="nb">left</span>] =&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>eee</q><span class="goal-separator"><hr></span><div class="goal-conclusion">R u s</div></blockquote><q>ee2</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Rtrans Rts; <span class="nb">apply</span>: tub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ee4</q><span class="goal-separator"><hr></span><q>ed7</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> (<span class="nv">exist</span> <span class="nv">_</span> (sval A `|` [<span class="nb">set</span> s]) Astot); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ee4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;&gt;
exist ((total_on (T:=T))^~ R)
  ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
   `|` [<span class="nb">set</span> s]) Astot /\
(<span class="kr">forall</span> <span class="nv">r</span> : {A : <span class="nb">set</span> T | total_on A R},
 R&#39; A r -&gt;
 R&#39; r
   (exist ((total_on (T:=T))^~ R)
      ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
       `|` [<span class="nb">set</span> s]) Astot) -&gt;
 r = A \/
 r =
 exist ((total_on (T:=T))^~ R)
   ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
    `|` [<span class="nb">set</span> s]) Astot)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [AeAs|[B Btot] sAB sBAs].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>d89</q><br><q>26b</q><br><q>edc</q><br><q>da9</q><br><q>dfb</q><br><q>edd</q><br><q>ee5</q><br><span><var>AeAs</var><span class="hyp-type"><b>: </b><span>A =
exist ((total_on (T:=T))^~ R)
  ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
   `|` [<span class="nb">set</span> s]) Astot</span></span></span><br></div><span class="goal-separator"><hr></span><q>d83</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>d89</q><br><q>26b</q><br><q>edc</q><br><q>da9</q><br><q>dfb</q><br><q>edd</q><br><q>ee5</q><br><q>e6b</q><br><span><var>Btot</var><span class="hyp-type"><b>: </b><span>total_on B R</span></span></span><br><span><var>sAB</var><span class="hyp-type"><b>: </b><span>R&#39; A (exist ((total_on (T:=T))^~ R) B Btot)</span></span></span><br><span><var>sBAs</var><span class="hyp-type"><b>: </b><span>R&#39; (exist ((total_on (T:=T))^~ R) B Btot)
  (exist ((total_on (T:=T))^~ R)
     ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
      `|` [<span class="nb">set</span> s]) Astot)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">exist ((total_on (T:=T))^~ R) B Btot = A \/
exist ((total_on (T:=T))^~ R) B Btot =
exist ((total_on (T:=T))^~ R)
  ((@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A
   `|` [<span class="nb">set</span> s]) Astot</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [/tub Rst|] := (pselect (sval A s)); <span class="kp">first</span> <span class="bp">exact</span>/snet/Rantisym.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f02</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (@sval) (<span class="nb">set</span> T) ((total_on (T:=T))^~ R) A s -&gt; <span class="kt">False</span></div></blockquote><q>f04</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> AeAs /=; <span class="nb">apply</span>; <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f06</q><span class="goal-separator"><hr></span><q>f0a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [Bs|nBs] := pselect (B s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>d89</q><br><q>26b</q><br><q>edc</q><br><q>da9</q><br><q>dfb</q><br><q>edd</q><br><q>ee5</q><br><q>e6b</q><br><q>f07</q><br><q>f08</q><br><q>f09</q><br><span><var>Bs</var><span class="hyp-type"><b>: </b><span>B s</span></span></span><br></div><span class="goal-separator"><hr></span><q>f0a</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>d89</q><br><q>26b</q><br><q>edc</q><br><q>da9</q><br><q>dfb</q><br><q>edd</q><br><q>ee5</q><br><q>e6b</q><br><q>f07</q><br><q>f08</q><br><q>f09</q><br><span><var>nBs</var><span class="hyp-type"><b>: </b><span>~ B s</span></span></span><br></div><label class="goal-separator"><hr></label><q>f0a</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">apply</span>: eq_exist; <span class="nb">rewrite</span> predeqE =&gt; r; <span class="nb">split</span>=&gt; [/sBAs|[/sAB|-&gt;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f19</q><span class="goal-separator"><hr></span><q>f0a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">left</span>; <span class="nb">case</span>: A tub Astot sBAs sAB =&gt; A Atot /= tub Astot sBAs sAB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>ec9</q><br><q>dfb</q><br><q>edd</q><br><q>e6b</q><br><q>f07</q><br><q>f1a</q><br><q>a</q><br><span><var>Atot</var><span class="hyp-type"><b>: </b><span>total_on A R</span></span></span><br><span><var>tub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : T, A s -&gt; R s t</span></span></span><br><span><var>Astot</var><span class="hyp-type"><b>: </b><span>total_on (A `|` [<span class="nb">set</span> s]) R</span></span></span><br><span><var>sBAs</var><span class="hyp-type"><b>: </b><span>R&#39; (exist ((total_on (T:=T))^~ R) B Btot)
  (exist ((total_on (T:=T))^~ R)
     (A `|` [<span class="nb">set</span> s]) Astot)</span></span></span><br><span><var>sAB</var><span class="hyp-type"><b>: </b><span>R&#39; (exist ((total_on (T:=T))^~ R) A Atot)
  (exist ((total_on (T:=T))^~ R) B Btot)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist ((total_on (T:=T))^~ R) B Btot =
exist ((total_on (T:=T))^~ R) A Atot</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: eq_exist; <span class="nb">rewrite</span> predeqE =&gt; r; <span class="nb">split</span>=&gt; [Br|/sAB] //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d78</q><br><q>d79</q><br><q>d7a</q><br><q>d7b</q><br><q>e47</q><br><q>e4d</q><br><q>e52</q><br><q>e57</q><br><q>e5c</q><br><q>e66</q><br><q>ec0</q><br><q>ed2</q><br><q>ec9</q><br><q>dfb</q><br><q>edd</q><br><q>e6b</q><br><q>f07</q><br><q>f1a</q><br><q>a</q><br><q>f22</q><br><q>f23</q><br><q>f24</q><br><q>f25</q><br><q>f26</q><br><q>cbe</q><br><span><var>Br</var><span class="hyp-type"><b>: </b><span>B r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> /sBAs [|ser] // := Br; <span class="nb">rewrite</span> ser <span class="kr">in</span> Br.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">premaximal</span> <span class="nv">T</span> (<span class="nv">R</span> : T -&gt; T -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T) :=
  <span class="kr">forall</span> <span class="nv">s</span>, R t s -&gt; R s t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ZL_preorder</span> <span class="nv">T</span> (<span class="nv">t0</span> : T) (<span class="nv">R</span> : T -&gt; T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">t</span>, R t t) -&gt; (<span class="kr">forall</span> <span class="nv">r</span> <span class="nv">s</span> <span class="nv">t</span>, R r s -&gt; R s t -&gt; R r t) -&gt;
  (<span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> T, total_on A R -&gt; <span class="kr">exists</span> <span class="nv">t</span>, <span class="kr">forall</span> <span class="nv">s</span>, A s -&gt; R s t) -&gt;
  <span class="kr">exists</span> <span class="nv">t</span>, premaximal R t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">t</span> : T, R t t) -&gt;
(<span class="kr">forall</span> <span class="nv">r</span> <span class="nv">s</span> <span class="nv">t</span> : T, R r s -&gt; R s t -&gt; R r t) -&gt;
(<span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> T,
 total_on A R -&gt;
 <span class="kr">exists</span> <span class="nv">t</span> : T, <span class="kr">forall</span> <span class="nv">s</span> : T, A s -&gt; R s t) -&gt;
<span class="kr">exists</span> <span class="nv">t</span> : T, premaximal R t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>f2f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> Teq := @gen_eqMixin T; <span class="nb">set</span> Tch := @gen_choiceMixin T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br></div><span class="goal-separator"><hr></span><q>f32</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> Tp := Pointed.Pack (Pointed.<span class="kn">Class</span> (Choice.<span class="kn">Class</span> <span class="nf">Teq</span> <span class="nv">Tch</span>) t0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br></div><span class="goal-separator"><hr></span><q>f32</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; Rrefl Rtrans tot_max.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><span><var>tot_max</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> T,
total_on A R -&gt;
<span class="kr">exists</span> <span class="nv">t</span> : T, <span class="kr">forall</span> <span class="nv">s</span> : T, A s -&gt; R s t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : T, premaximal R t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> eqR := <span class="kr">fun</span> <span class="nv">s</span> <span class="nv">t</span> =&gt; R s t /\ R t s; <span class="nb">set</span> ceqR := <span class="kr">fun</span> <span class="nv">s</span> =&gt; [<span class="nb">set</span> t | eqR s t].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><span><var>eqR</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">s</span> <span class="nv">t</span> : T =&gt; R s t /\ R t s</span></span><span class="hyp-type"><b>: </b><span>T -&gt; T -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>ceqR</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">s</span> : T =&gt; [<span class="nb">set</span> t | eqR s t]</span></span><span class="hyp-type"><b>: </b><span>T -&gt; <span class="nb">set</span> T</span></span></span></span><br></div><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> eqR_trans r s t : eqR r s -&gt; eqR s t -&gt; eqR r t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><span><var>r, s, t</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqR r s -&gt; eqR s t -&gt; eqR r t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><span><var>eqR_trans</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> <span class="nv">s</span> <span class="nv">t</span> : T,
eqR r s -&gt; eqR s t -&gt; eqR r t</span></span></span><br></div><label class="goal-separator"><hr></label><q>f41</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [Rrs Rsr] [Rst Rts]; <span class="nb">split</span>; [<span class="nb">apply</span>: Rtrans Rst|<span class="nb">apply</span>: Rtrans Rsr].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f50</q><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> ceqR_uniq s t : eqR s t -&gt; ceqR s = ceqR t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>e8f</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqR s t -&gt; ceqR s = ceqR t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><span><var>ceqR_uniq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span> : T, eqR s t -&gt; ceqR s = ceqR t</span></span></span><br></div><label class="goal-separator"><hr></label><q>f41</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; - [Rst Rts] r; <span class="nb">split</span>=&gt; [[Rr rR] | [Rr rR]]; <span class="nb">split</span>;
    <span class="kp">try</span> <span class="bp">exact</span>: Rtrans Rr; <span class="bp">exact</span>: Rtrans rR _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f5c</q><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> ceqRs := ceqR @` setT; <span class="nb">set</span> quotR := sig ceqRs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><span><var>ceqRs</var><span><span class="hyp-body"><b>:= </b><span>range ceqR</span></span><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (<span class="nb">set</span> T)</span></span></span></span><br><span><var>quotR</var><span><span class="hyp-body"><b>:= </b><span>{x : <span class="nb">set</span> T | ceqRs x}</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> ceqRP t : ceqRs (ceqR t) <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">t</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><span><var>ceqRP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : T, ceqRs (ceqR t)</span></span></span><br></div><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> lift := <span class="kr">fun</span> <span class="nv">t</span> =&gt; exist _ (ceqR t) (ceqRP t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><span><var>lift</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">t</span> : T =&gt; exist ceqRs (ceqR t) (ceqRP t)</span></span><span class="hyp-type"><b>: </b><span>T -&gt; {x : <span class="nb">set</span> T | ceqRs x}</span></span></span></span><br></div><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> lift_surj (A : quotR) : <span class="kr">exists</span> <span class="nv">t</span> : Tp, lift t = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><span><var>A</var><span class="hyp-type"><b>: </b><span>quotR</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : Tp, lift t = A</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><span><var>lift_surj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : quotR,
<span class="kr">exists</span> <span class="nv">t</span> : Tp, lift t = A</span></span></span><br></div><label class="goal-separator"><hr></label><q>f41</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: A =&gt; A [t Tt ctA]; <span class="kr">exists</span> <span class="nv">t</span>; <span class="nb">rewrite</span> /lift; <span class="nb">case</span> : _ / ctA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>a</q><br><q>26b</q><br><span><var>Tt</var><span class="hyp-type"><b>: </b><span>[<span class="nb">set</span>: T] t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist ceqRs (ceqR t) (ceqRP t) =
exist ceqRs (ceqR t)
  (ex_intro2 [eta [<span class="nb">set</span>: T]]
     (<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; ceqR x = ceqR t) t Tt
     (erefl (ceqR t)))</div></blockquote><q>f77</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">exact</span>/congr1/Prop_irrelevance.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f79</q><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> lift_inj s t : eqR s t -&gt; lift s = lift t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>e8f</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqR s t -&gt; lift s = lift t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><span><var>lift_inj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span> : T, eqR s t -&gt; lift s = lift t</span></span></span><br></div><label class="goal-separator"><hr></label><q>f41</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; eqRst; <span class="nb">apply</span>/eq_exist/ceqR_uniq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f8b</q><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> lift_eqR s t : lift s = lift t -&gt; eqR s t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>e8f</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift s = lift t -&gt; eqR s t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><span><var>lift_eqR</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span> : T, lift s = lift t -&gt; eqR s t</span></span></span><br></div><label class="goal-separator"><hr></label><q>f41</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; cst; <span class="nb">have</span> ceqst : ceqR s = ceqR t <span class="bp">by</span> <span class="nb">have</span> := congr1 sval cst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>e8f</q><br><span><var>cst</var><span class="hyp-type"><b>: </b><span>lift s = lift t</span></span></span><br><span><var>ceqst</var><span class="hyp-type"><b>: </b><span>ceqR s = ceqR t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqR s t</div></blockquote><q>f95</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> [_ s]ceqst; <span class="nb">split</span>; <span class="nb">apply</span>: Rrefl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f97</q><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> repr := <span class="kr">fun</span> <span class="nv">A</span> : quotR =&gt; get [<span class="nb">set</span> t : Tp | lift t = A].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><span><var>repr</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">A</span> : quotR =&gt;
[get x : _ | [<span class="nb">set</span> t | lift t = A] x]</span></span><span class="hyp-type"><b>: </b><span>quotR -&gt; Tp</span></span></span></span><br></div><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> repr_liftE t : eqR t (repr (lift t))
  <span class="bp">by</span> <span class="nb">apply</span>: lift_eqR; <span class="nb">have</span> -&gt; := getPex (lift_surj (lift t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><span><var>repr_liftE</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : T, eqR t (repr (lift t))</span></span></span><br></div><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> R&#39; := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> : quotR =&gt; R (repr A) (repr B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> : quotR =&gt; R (repr A) (repr B)</span></span><span class="hyp-type"><b>: </b><span>quotR -&gt; quotR -&gt; <span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> R&#39;refl A : R&#39; A A <span class="bp">by</span> <span class="nb">apply</span>: Rrefl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><span><var>R'refl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : quotR, R&#39; A A</span></span></span><br></div><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> R&#39;trans A B C : R&#39; A B -&gt; R&#39; B C -&gt; R&#39; A C <span class="bp">by</span> <span class="nb">apply</span>: Rtrans.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><span><var>R'trans</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : quotR,
R&#39; A B -&gt; R&#39; B C -&gt; R&#39; A C</span></span></span><br></div><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> R&#39;antisym A B : R&#39; A B -&gt; R&#39; B A -&gt; A = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>quotR</span></span></span><br></div><span class="goal-separator"><hr></span><q>e62</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><span><var>R'antisym</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : quotR,
R&#39; A B -&gt; R&#39; B A -&gt; A = B</span></span></span><br></div><label class="goal-separator"><hr></label><q>f41</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; RAB RBA; <span class="nb">have</span> [t tA] := lift_surj A; <span class="nb">have</span> [s sB] := lift_surj B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><q>fc0</q><br><span><var>RAB</var><span class="hyp-type"><b>: </b><span>R&#39; A B</span></span></span><br><span><var>RBA</var><span class="hyp-type"><b>: </b><span>R&#39; B A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tp</span></span></span><br><span><var>tA</var><span class="hyp-type"><b>: </b><span>lift t = A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Tp</span></span></span><br><span><var>sB</var><span class="hyp-type"><b>: </b><span>lift s = B</span></span></span><br></div><span class="goal-separator"><hr></span><q>dc</q></blockquote><q>fc1</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -tA -sB; <span class="nb">apply</span>: lift_inj; <span class="nb">apply</span> (eqR_trans _ _ _ (repr_liftE t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><q>fc0</q><br><q>fc9</q><br><q>fca</q><br><q>fcb</q><br><q>fcc</q><br><q>fcd</q><br><q>fce</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqR (repr (lift t)) s</div></blockquote><q>fc1</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> eAB : eqR (repr A) (repr B) <span class="bp">by</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><q>fc0</q><br><q>fc9</q><br><q>fca</q><br><q>fcb</q><br><q>fcc</q><br><q>fcd</q><br><q>fce</q><br><span><var>eAB</var><span class="hyp-type"><b>: </b><span>eqR (repr A) (repr B)</span></span></span><br></div><span class="goal-separator"><hr></span><q>fd3</q></blockquote><q>fc1</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> tA; <span class="nb">apply</span>: eqR_trans eAB _; <span class="nb">rewrite</span> -sB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><q>fc0</q><br><q>fc9</q><br><q>fca</q><br><q>fcb</q><br><q>fcc</q><br><q>fcd</q><br><q>fce</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqR (repr (lift s)) s</div></blockquote><q>fc1</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [] := repr_liftE s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>fc3</q><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [A Atot|A Amax] := Zorn R&#39;refl R&#39;trans R&#39;antisym.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><q>fc4</q><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> quotR</span></span></span><br><q>e81</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : quotR, <span class="kr">forall</span> <span class="nv">s</span> : quotR, A s -&gt; R&#39; s t</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><q>fc4</q><br><q>f75</q><br><span><var>Amax</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : quotR, R&#39; A s -&gt; s = A</span></span></span><br></div><label class="goal-separator"><hr></label><q>f41</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> /tot_max [t tmax] : total_on [<span class="nb">set</span> repr B | B <span class="kr">in</span> A] R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>fe4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">total_on [<span class="nb">set</span> repr B | B <span class="kr">in</span> A] R</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><q>fc4</q><br><q>fe5</q><br><q>e81</q><br><q>26b</q><br><span><var>tmax</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : T, [<span class="nb">set</span> repr B | B <span class="kr">in</span> A] s -&gt; R s t</span></span></span><br></div><label class="goal-separator"><hr></label><q>fe6</q></blockquote><q>fe8</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ?? [B AB &lt;-] [C AC &lt;-]; <span class="nb">apply</span>: Atot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ff1</q><span class="goal-separator"><hr></span><q>fe6</q></blockquote><q>fe7</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> (<span class="nv">lift</span> <span class="nv">t</span>) =&gt; B AB; <span class="nb">have</span> [Rt _] := repr_liftE t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><q>fc4</q><br><q>fe5</q><br><q>e81</q><br><q>26b</q><br><q>ff2</q><br><span><var>B</var><span class="hyp-type"><b>: </b><span>quotR</span></span></span><br><q>e91</q><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>R t (repr (lift t))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R&#39; B (lift t)</div></blockquote><q>fe7</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Rtrans Rt; <span class="nb">apply</span>: tmax; <span class="kr">exists</span> <span class="nv">B</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>fe9</q><span class="goal-separator"><hr></span><q>f41</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> (<span class="nv">repr</span> <span class="nv">A</span>) =&gt; t RAt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>d77</q><br><q>d78</q><br><q>d7e</q><br><q>d7f</q><br><q>d80</q><br><q>d79</q><br><q>d7a</q><br><q>f40</q><br><q>f46</q><br><q>f47</q><br><q>f51</q><br><q>f5d</q><br><q>f65</q><br><q>f66</q><br><q>f6b</q><br><q>f70</q><br><q>f7a</q><br><q>f8c</q><br><q>f98</q><br><q>fa7</q><br><q>fac</q><br><q>fb1</q><br><q>fb6</q><br><q>fbb</q><br><q>fc4</q><br><q>f75</q><br><q>fea</q><br><q>26b</q><br><span><var>RAt</var><span class="hyp-type"><b>: </b><span>R (repr A) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R t (repr A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> /Amax &lt;- : R&#39; A (lift t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1003</q><span class="goal-separator"><hr></span><div class="goal-conclusion">R&#39; A (lift t)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>1003</q><label class="goal-separator"><hr></label><div class="goal-conclusion">R t (repr (lift t))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [Rt _] := repr_liftE t; <span class="nb">apply</span>: Rtrans Rt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1003</q><span class="goal-separator"><hr></span><q>100c</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [] := repr_liftE t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UpperLowerTheory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Order.TTheory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">d</span> : unit) (<span class="nv">T</span> : porderType d).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ubound</span> <span class="nv">A</span> : <span class="nb">set</span> T := [<span class="nb">set</span> y | <span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; (x &lt;= y)%O].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lbound</span> <span class="nv">A</span> : <span class="nb">set</span> T := [<span class="nb">set</span> y | <span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; (y &lt;= x)%O].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ubP</span> <span class="nv">A</span> <span class="nv">x</span> : (<span class="kr">forall</span> <span class="nv">y</span>, A y -&gt; (y &lt;= x)%O) &lt;-&gt; ubound A x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><span><var>T</var><span class="hyp-type"><b>: </b><span>porderType d</span></span></span><br><q>a</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">y</span>, A y -&gt; (y &lt;= x)%O) &lt;-&gt; ubound A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1011</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lbP</span> <span class="nv">A</span> <span class="nv">x</span> : (<span class="kr">forall</span> <span class="nv">y</span>, A y -&gt; (x &lt;= y)%O) &lt;-&gt; lbound A x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1013</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">y</span>, A y -&gt; (x &lt;= y)%O) &lt;-&gt; lbound A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1018</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ub_set1</span> <span class="nv">x</span> <span class="nv">y</span> : ubound [<span class="nb">set</span> x] y = (x &lt;= y)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ubound [<span class="nb">set</span> x] y = (x &lt;= y)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>101d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [/(_ x erefl)//|xy z -&gt;].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lb_set1</span> <span class="nv">x</span> <span class="nv">y</span> : lbound [<span class="nb">set</span> x] y = (x &gt;= y)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>101f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">lbound [<span class="nb">set</span> x] y = (y &lt;= x)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1024</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [/(_ x erefl)//|xy z -&gt;].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lb_ub_set1</span> <span class="nv">x</span> <span class="nv">y</span> : lbound (ubound [<span class="nb">set</span> x]) y -&gt; (y &lt;= x)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>101f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">lbound (ubound [<span class="nb">set</span> x]) y -&gt; (y &lt;= x)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1029</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/(_ x); <span class="nb">apply</span>; <span class="nb">rewrite</span> ub_set1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ub_lb_set1</span> <span class="nv">x</span> <span class="nv">y</span> : ubound (lbound [<span class="nb">set</span> x]) y -&gt; (x &lt;= y)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>101f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">ubound (lbound [<span class="nb">set</span> x]) y -&gt; (x &lt;= y)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>102e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/(_ x); <span class="nb">apply</span>; <span class="nb">rewrite</span> lb_set1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lb_ub_refl</span> <span class="nv">x</span> : lbound (ubound [<span class="nb">set</span> x]) x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lbound (ubound [<span class="nb">set</span> x]) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1033</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; y; <span class="nb">apply</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ub_lb_refl</span> <span class="nv">x</span> : ubound (lbound [<span class="nb">set</span> x]) x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1035</q><span class="goal-separator"><hr></span><div class="goal-conclusion">ubound (lbound [<span class="nb">set</span> x]) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1039</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; y; <span class="nb">apply</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ub_lb_ub</span> <span class="nv">A</span> <span class="nv">x</span> <span class="nv">y</span> : ubound A y -&gt; lbound (ubound A) x -&gt; (x &lt;= y)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>a</q><br><q>1020</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ubound A y -&gt; lbound (ubound A) x -&gt; (x &lt;= y)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>103e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Ay; <span class="nb">apply</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lb_ub_lb</span> <span class="nv">A</span> <span class="nv">x</span> <span class="nv">y</span> : lbound A y -&gt; ubound (lbound A) x -&gt; (y &lt;= x)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1040</q><span class="goal-separator"><hr></span><div class="goal-conclusion">lbound A y -&gt; ubound (lbound A) x -&gt; (y &lt;= x)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1044</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Ey; <span class="nb">apply</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* down set (i.e., generated order ideal) *)</span>
<span class="c">(* i.e. down A := { x | exists y, y \in A /\ x &lt;= y} *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">down</span> <span class="nv">A</span> : <span class="nb">set</span> T := [<span class="nb">set</span> x | <span class="kr">exists</span> <span class="nv">y</span>, A y /\ (x &lt;= y)%O].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">has_ubound</span> <span class="nv">A</span> := ubound A !=set0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">has_sup</span> <span class="nv">A</span> := A !=set0 /\ has_ubound A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">has_lbound</span> <span class="nv">A</span> := lbound A !=set0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">has_inf</span> <span class="nv">A</span> := A !=set0 /\ has_lbound A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">has_ub_set1</span> <span class="nv">x</span> : has_ubound [<span class="nb">set</span> x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1035</q><span class="goal-separator"><hr></span><div class="goal-conclusion">has_ubound [<span class="nb">set</span> x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1049</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">rewrite</span> ub_set1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">has_inf0</span> : ~ has_inf (@set0 T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ has_inf set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>104e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /has_inf not_andP; <span class="nb">left</span>; <span class="nb">apply</span>/set0P/negP/negPn.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">has_sup0</span> : ~ has_sup (@set0 T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1050</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ has_sup set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1054</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /has_sup not_andP; <span class="nb">left</span>; <span class="nb">apply</span>/set0P/negP/negPn.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">has_sup1</span> <span class="nv">x</span> : has_sup [<span class="nb">set</span> x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1035</q><span class="goal-separator"><hr></span><div class="goal-conclusion">has_sup [<span class="nb">set</span> x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1059</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [<span class="kr">exists</span> <span class="nv">x</span> | <span class="kr">exists</span> <span class="nv">x</span> =&gt; y -&gt;].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">has_inf1</span> <span class="nv">x</span> : has_inf [<span class="nb">set</span> x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1035</q><span class="goal-separator"><hr></span><div class="goal-conclusion">has_inf [<span class="nb">set</span> x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>105e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [<span class="kr">exists</span> <span class="nv">x</span> | <span class="kr">exists</span> <span class="nv">x</span> =&gt; y -&gt;].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_has_lbound</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; has_lbound B -&gt; has_lbound A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>b3</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; has_lbound B -&gt; has_lbound A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1063</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; AB [l Bl]; <span class="kr">exists</span> <span class="nv">l</span> =&gt; a Aa; <span class="nb">apply</span>/Bl/AB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_has_ubound</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; has_ubound B -&gt; has_ubound A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1065</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` B -&gt; has_ubound B -&gt; has_ubound A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1069</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; AB [l Bl]; <span class="kr">exists</span> <span class="nv">l</span> =&gt; a Aa; <span class="nb">apply</span>/Bl/AB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">downP</span> <span class="nv">A</span> <span class="nv">x</span> : (<span class="kr">exists2</span> y, A y &amp; (x &lt;= y)%O) &lt;-&gt; down A x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1013</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists2</span> y : T, A y &amp; (x &lt;= y)%O) &lt;-&gt; down A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>106e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span> =&gt; [[y Ay xy]|[y [Ay xy]]]; [<span class="kr">exists</span> <span class="nv">y</span>| <span class="kr">exists</span> <span class="nv">y</span>].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isLub</span> <span class="nv">A</span> <span class="nv">m</span> := ubound A m /\ <span class="kr">forall</span> <span class="nv">b</span>, ubound A b -&gt; (m &lt;= b)%O.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">supremums</span> <span class="nv">A</span> := ubound A `&amp;` lbound (ubound A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">supremums1</span> <span class="nv">x</span> : supremums [<span class="nb">set</span> x] = [<span class="nb">set</span> x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1035</q><span class="goal-separator"><hr></span><div class="goal-conclusion">supremums [<span class="nb">set</span> x] = [<span class="nb">set</span> x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1073</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /supremums predeqE =&gt; y; <span class="nb">split</span> =&gt; [[]|-&gt;{y}]; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1035</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(ubound [<span class="nb">set</span> x] `&amp;` lbound (ubound [<span class="nb">set</span> x])) x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>101f</q><label class="goal-separator"><hr></label><div class="goal-conclusion">ubound [<span class="nb">set</span> x] y -&gt;
lbound (ubound [<span class="nb">set</span> x]) y -&gt; [<span class="nb">set</span> x] y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">rewrite</span> ub_set1|<span class="bp">exact</span>: lb_ub_refl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>101f</q><span class="goal-separator"><hr></span><q>107d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ub_set1 =&gt; xy /lb_ub_set1 yx; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le xy yx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">is_subset1_supremums</span> <span class="nv">A</span> : is_subset1 (supremums A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subset1 (supremums A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1082</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; x y [Ax xA] [Ay yA]; <span class="nb">apply</span>/eqP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>a</q><br><q>1020</q><br><span><var>Ax</var><span class="hyp-type"><b>: </b><span>ubound A x</span></span></span><br><span><var>xA</var><span class="hyp-type"><b>: </b><span>lbound (ubound A) x</span></span></span><br><span><var>Ay</var><span class="hyp-type"><b>: </b><span>ubound A y</span></span></span><br><span><var>yA</var><span class="hyp-type"><b>: </b><span>lbound (ubound A) y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x == y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eq_le (ub_lb_ub Ax yA) (ub_lb_ub Ay xA).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">supremum</span> <span class="nv">x0</span> <span class="nv">A</span> := <span class="kr">if</span> A == set0 <span class="kr">then</span> x0 <span class="kr">else</span> xget x0 (supremums A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">supremum_out</span> <span class="nv">x0</span> <span class="nv">A</span> : ~ has_sup A -&gt; supremum x0 A = x0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>af1</q><br><q>a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ has_sup A -&gt; supremum x0 A = x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1091</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; hsA; <span class="nb">rewrite</span> /supremum; <span class="nb">case</span>: ifPn =&gt; // /set0P[/= x Ax].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>af1</q><br><q>a</q><br><span><var>hsA</var><span class="hyp-type"><b>: </b><span>~ has_sup A</span></span></span><br><q>b</q><br><span><var>Ax</var><span class="hyp-type"><b>: </b><span>A x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xget x0 (supremums A) = x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: xgetP =&gt; //= _ -&gt; [uA _]; <span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>af1</q><br><q>a</q><br><q>109a</q><br><q>b</q><br><q>109b</q><br><span><var>uA</var><span class="hyp-type"><b>: </b><span>ubound A (xget x0 (supremums A))</span></span></span><br></div><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: hsA; <span class="nb">split</span>; [<span class="kr">exists</span> <span class="nv">x</span>|<span class="kr">exists</span> (<span class="nv">xget</span> <span class="nv">x0</span> (supremums A))].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">supremum0</span> <span class="nv">x0</span> : supremum x0 set0 = x0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>af1</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">supremum x0 set0 = x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10a3</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /supremum eqxx.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">supremum1</span> <span class="nv">x0</span> <span class="nv">x</span> : supremum x0 [<span class="nb">set</span> x] = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><span><var>x0, x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">supremum x0 [<span class="nb">set</span> x] = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10a9</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /supremum ifF; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10ab</q><span class="goal-separator"><hr></span><div class="goal-conclusion">([<span class="nb">set</span> x] == set0) = false</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>10ab</q><label class="goal-separator"><hr></label><div class="goal-conclusion">xget x0 (supremums [<span class="nb">set</span> x]) = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> predeqE =&gt; /(_ x)[+ _]; <span class="nb">apply</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10ab</q><span class="goal-separator"><hr></span><q>10b5</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> supremums1; <span class="nb">case</span>: xgetP =&gt; // /(_ x) /(_ erefl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">infimums</span> <span class="nv">A</span> := lbound A `&amp;` ubound (lbound A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">infimums1</span> <span class="nv">x</span> : infimums [<span class="nb">set</span> x] = [<span class="nb">set</span> x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1035</q><span class="goal-separator"><hr></span><div class="goal-conclusion">infimums [<span class="nb">set</span> x] = [<span class="nb">set</span> x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10ba</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /infimums predeqE =&gt; y; <span class="nb">split</span> =&gt; [[]|-&gt;{y}]; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1035</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(lbound [<span class="nb">set</span> x] `&amp;` ubound (lbound [<span class="nb">set</span> x])) x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>101f</q><label class="goal-separator"><hr></label><div class="goal-conclusion">lbound [<span class="nb">set</span> x] y -&gt;
ubound (lbound [<span class="nb">set</span> x]) y -&gt; [<span class="nb">set</span> x] y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">rewrite</span> lb_set1|<span class="nb">apply</span> ub_lb_refl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>101f</q><span class="goal-separator"><hr></span><q>10c4</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> lb_set1 =&gt; xy /ub_lb_set1 yx; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le xy yx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">is_subset1_infimums</span> <span class="nv">A</span> : is_subset1 (infimums A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1084</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subset1 (infimums A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10c9</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; x y [Ax xA] [Ay yA]; <span class="nb">apply</span>/eqP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>1014</q><br><q>a</q><br><q>1020</q><br><span><var>Ax</var><span class="hyp-type"><b>: </b><span>lbound A x</span></span></span><br><span><var>xA</var><span class="hyp-type"><b>: </b><span>ubound (lbound A) x</span></span></span><br><span><var>Ay</var><span class="hyp-type"><b>: </b><span>lbound A y</span></span></span><br><span><var>yA</var><span class="hyp-type"><b>: </b><span>ubound (lbound A) y</span></span></span><br></div><span class="goal-separator"><hr></span><q>108f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eq_le (lb_ub_lb Ax yA) (lb_ub_lb Ay xA).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">infimum</span> <span class="nv">x0</span> <span class="nv">A</span> := <span class="kr">if</span> A == set0 <span class="kr">then</span> x0 <span class="kr">else</span> xget x0 (infimums A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UpperLowerTheory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UpperLowerOrderTheory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Order.TTheory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">d</span> : unit) (<span class="nv">T</span> : orderType d).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ge_supremum_Nmem</span> <span class="nv">x0</span> <span class="nv">A</span> <span class="nv">t</span> :
  supremums A !=set0 -&gt; A t -&gt; (supremum x0 A &gt;= t)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><span><var>T</var><span class="hyp-type"><b>: </b><span>orderType d</span></span></span><br><q>af1</q><br><q>a</q><br><q>26b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">supremums A !=set0 -&gt; A t -&gt; (t &lt;= supremum x0 A)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10d6</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>=&gt; x Ax; <span class="nb">rewrite</span> /supremum; <span class="nb">case</span>: ifPn =&gt; [/eqP -&gt; //|_].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>10d9</q><br><q>af1</q><br><q>a</q><br><span><var>t, x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>Ax</var><span class="hyp-type"><b>: </b><span>supremums A x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A t -&gt; (t &lt;= xget x0 (supremums A))%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: xgetP =&gt; [y yA [uAy _]|/(_ x) //]; <span class="bp">exact</span>: uAy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">le_infimum_Nmem</span> <span class="nv">x0</span> <span class="nv">A</span> <span class="nv">t</span> :
  infimums A !=set0 -&gt; A t -&gt; (infimum x0 A &lt;= t)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10d8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">infimums A !=set0 -&gt; A t -&gt; (infimum x0 A &lt;= t)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10e4</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>=&gt; x Ex; <span class="nb">rewrite</span> /infimum; <span class="nb">case</span>: ifPn =&gt; [/eqP -&gt; //|_].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a</q><br><q>10d9</q><br><q>af1</q><br><q>a</q><br><q>10e0</q><br><span><var>Ex</var><span class="hyp-type"><b>: </b><span>infimums A x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A t -&gt; (xget x0 (infimums A) &lt;= t)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: xgetP =&gt; [y yE [uEy _]|/(_ x) //]; <span class="bp">exact</span>: uEy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UpperLowerOrderTheory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">nat_supremums_neq0</span> (<span class="nv">A</span> : <span class="nb">set</span> nat) : ubound A !=set0 -&gt; supremums A !=set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ubound A !=set0 -&gt; supremums A !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10ef</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span> =&gt; /=; <span class="nb">elim</span> =&gt; [A0|n ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">O</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10f2</q><br><q>4c5</q><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>ubound A n -&gt; supremums A !=set0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ubound A n.+<span class="mi">1</span> -&gt; supremums A !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (pselect (ubound A n)) =&gt; [/ih //|An {ih}] An1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10f2</q><br><q>4c5</q><br><span><var>An</var><span class="hyp-type"><b>: </b><span>~ ubound A n</span></span></span><br><span><var>An1</var><span class="hyp-type"><b>: </b><span>ubound A n.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">supremums A !=set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> <span class="nv">n</span>.+<span class="mi">1</span>; <span class="nb">split</span> =&gt; // m Am; <span class="nb">case</span>/existsNP : An =&gt; k /not_implyP[Ak /negP].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10f2</q><br><q>4c5</q><br><q>1100</q><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Order.NatOrder.porderType</span></span></span><br><span><var>Am</var><span class="hyp-type"><b>: </b><span>ubound A m</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Order.NatOrder.porderType</span></span></span><br><span><var>Ak</var><span class="hyp-type"><b>: </b><span>A k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ (k &lt;= n)%O -&gt; (n.+<span class="mi">1</span> &lt;= m)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -Order.TotalTheory.ltNge =&gt; kn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10f2</q><br><q>4c5</q><br><q>1100</q><br><q>1106</q><br><q>1107</q><br><q>1108</q><br><q>1109</q><br><span><var>kn</var><span class="hyp-type"><b>: </b><span>(n &lt; k)%O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n.+<span class="mi">1</span> &lt;= m)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (Order.POrderTheory.le_trans _ (Am _ Ak)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">meets</span> <span class="nv">T</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :=
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, F A -&gt; G B -&gt; A `&amp;` B !=set0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;F `#` G&quot;</span> := (meets F G) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">meets</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">meetsC</span> <span class="nv">T</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) : F `#` G = G `#` F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (<span class="nb">set</span> T)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F `#` G = G `#` F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1112</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">gen have</span> sFG : F G / F `#` G -&gt; G `#` F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1114</q><span class="goal-separator"><hr></span><div class="goal-conclusion">F `#` G -&gt; G `#` F</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><q>1115</q><br><span><var>sFG</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T), F `#` G -&gt; G `#` F</span></span></span><br></div><label class="goal-separator"><hr></label><q>1116</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; FG B A =&gt; /FG; <span class="nb">rewrite</span> setIC; <span class="nb">apply</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>111e</q><span class="goal-separator"><hr></span><q>1116</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>; <span class="nb">apply</span>: sFG.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sub_meets</span> <span class="nv">T</span> (<span class="nv">F</span> <span class="nv">F&#39;</span> <span class="nv">G</span> <span class="nv">G&#39;</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  F `&lt;=` F&#39; -&gt; G `&lt;=` G&#39; -&gt; F&#39; `#` G&#39; -&gt; F `#` G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>F, F', G, G'</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (<span class="nb">set</span> T)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F `&lt;=` F&#39; -&gt; G `&lt;=` G&#39; -&gt; F&#39; `#` G&#39; -&gt; F `#` G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1124</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; sF sG FG A B /sF FA /sG GB; <span class="nb">apply</span>: (FG A B).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">meetsSr</span> <span class="nv">T</span> (<span class="nv">F</span> <span class="nv">G</span> <span class="nv">G&#39;</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  G `&lt;=` G&#39; -&gt; F `#` G&#39; -&gt; F `#` G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>F, G, G'</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (<span class="nb">set</span> T)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G `&lt;=` G&#39; -&gt; F `#` G&#39; -&gt; F `#` G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>112b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: sub_meets.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">meetsSl</span> <span class="nv">T</span> (<span class="nv">G</span> <span class="nv">F</span> <span class="nv">F&#39;</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  F `&lt;=` F&#39; -&gt; F&#39; `#` G -&gt; F `#` G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>G, F, F'</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (<span class="nb">set</span> T)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F `&lt;=` F&#39; -&gt; F&#39; `#` G -&gt; F `#` G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1132</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /sub_meets; <span class="nb">apply</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">meets</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">set_display</span> : unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1139</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">SetOrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Internal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">SetOrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">le_def</span> <span class="nv">A</span> <span class="nv">B</span> : `[&lt; A `&lt;=` B &gt;] = (A `&amp;` B == A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; A `&lt;=` B &gt;] = (A `&amp;` B == A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>113e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/asboolP/eqP; <span class="nb">rewrite</span> setIidPl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lt_def</span> <span class="nv">A</span> <span class="nv">B</span> : `[&lt; A `&lt;` B &gt;] = (B != A) &amp;&amp; `[&lt; A `&lt;=` B &gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; A `&lt;` B &gt;] = (B != A) &amp;&amp; `[&lt; A `&lt;=` B &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1143</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span>/idP/idP =&gt; [/asboolP|/andP[BA /asboolP AB]]; <span class="nb">rewrite</span> properEneq eq_sym;
  <span class="bp">by</span> [<span class="nb">move</span>=&gt; [] -&gt; /asboolP|<span class="nb">apply</span>/asboolP].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">joinKI</span> <span class="nv">B</span> <span class="nv">A</span> : A `&amp;` (A `|` B) = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>9</q><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&amp;` (A `|` B) = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1148</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUC setKU.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">meetKU</span> <span class="nv">B</span> <span class="nv">A</span> : A `|` (A `&amp;` B) = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>114a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `|` A `&amp;` B = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>114f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setIC setKI.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">orderMixin</span> := @MeetJoinMixin _ _ (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> =&gt; `[&lt;proper A B&gt;]) setI
  setU le_def lt_def (@setIC _) (@setUC _) (@setIA _) (@setUA _) joinKI meetKU
  (@setIUl _) setIid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Canonical</span> <span class="nf">porderType</span> := POrderType set_display (<span class="nb">set</span> T) orderMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Canonical</span> <span class="nf">latticeType</span> := LatticeType (<span class="nb">set</span> T) orderMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Canonical</span> <span class="nf">distrLatticeType</span> := DistrLatticeType (<span class="nb">set</span> T) orderMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">SetOrder_sub0set</span> <span class="nv">A</span> : (set0 &lt;= A)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(set0 &lt;= A)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1154</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/asboolP; <span class="nb">apply</span>: sub0set.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">SetOrder_setTsub</span> <span class="nv">A</span> : (A &lt;= setT)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A &lt;= [<span class="nb">set</span>: T])%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1159</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/asboolP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Canonical</span> <span class="nf">bLatticeType</span> :=
  BLatticeType (<span class="nb">set</span> T) (Order.BLattice.Mixin SetOrder_sub0set).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Canonical</span> <span class="nf">tbLatticeType</span> :=
  TBLatticeType (<span class="nb">set</span> T) (Order.TBLattice.Mixin SetOrder_setTsub).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Canonical</span> <span class="nf">bDistrLatticeType</span> := [bDistrLatticeType of <span class="nb">set</span> T].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Canonical</span> <span class="nf">tbDistrLatticeType</span> := [tbDistrLatticeType of <span class="nb">set</span> T].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subKI</span> <span class="nv">A</span> <span class="nv">B</span> : B `&amp;` (A `\` B) = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">B `&amp;` (A `\` B) = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>115e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setDE setICA setICr setI0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">joinIB</span> <span class="nv">A</span> <span class="nv">B</span> : (A `&amp;` B) `|` A `\` B = A.</label><small class="alectryon-output"><div><q>42c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><q>42f</q><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> setUC -setDDr setDv setD0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Canonical</span> <span class="nf">cbDistrLatticeType</span> := CBDistrLatticeType (<span class="nb">set</span> T)
  (@CBDistrLatticeMixin _ _ (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> =&gt; A `\` B) subKI joinIB).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Canonical</span> <span class="nf">ctbDistrLatticeType</span> := CTBDistrLatticeType (<span class="nb">set</span> T)
  (@CTBDistrLatticeMixin _ _ _ (<span class="kr">fun</span> <span class="nv">A</span> =&gt; ~` A) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; esym (setTD x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">SetOrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Internal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Internal</span>.porderType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Internal</span>.latticeType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Internal</span>.distrLatticeType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Internal</span>.bLatticeType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Internal</span>.tbLatticeType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Internal</span>.bDistrLatticeType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Internal</span>.tbDistrLatticeType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Internal</span>.cbDistrLatticeType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Internal</span>.ctbDistrLatticeType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetEset</span> <span class="nv">A</span> <span class="nv">B</span> : (A &lt;= B)%O = (A `&lt;=` B) :&gt; <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A &lt;= B)%O = (A `&lt;=` B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1164</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> asboolE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">properEset</span> <span class="nv">A</span> <span class="nv">B</span> : (A &lt; B)%O = (A `&lt;` B) :&gt; <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A &lt; B)%O = (A `&lt;` B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1169</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> asboolE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subEset</span> <span class="nv">A</span> <span class="nv">B</span> : (A `\` B)%O = (A `\` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `\` B)%O = A `\` B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>116e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">complEset</span> <span class="nv">A</span> : (~` A)%O = ~` A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>91</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~` A)%O = ~` A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1173</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">botEset</span> : <span class="mi">0</span>%O = @set0 T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span>%O = set0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1178</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">topEset</span> : <span class="mi">1</span>%O = @setT T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e5</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>%O = [<span class="nb">set</span>: T]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>117d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">meetEset</span> <span class="nv">A</span> <span class="nv">B</span> : (A `&amp;` B)%O = (A `&amp;` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `&amp;` B)%O = A `&amp;` B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1182</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">joinEset</span> <span class="nv">A</span> <span class="nv">B</span> : (A `|` B)%O = (A `|` B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(A `|` B)%O = A `|` B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1187</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subsetPset</span> <span class="nv">A</span> <span class="nv">B</span> : reflect (A `&lt;=` B) (A &lt;= B)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (A `&lt;=` B) (A &lt;= B)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>118c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (iffP idP); <span class="nb">rewrite</span> subsetEset.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">properPset</span> <span class="nv">A</span> <span class="nv">B</span> : reflect (A `&lt;` B) (A &lt; B)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (A `&lt;` B) (A &lt; B)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1191</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (iffP idP); <span class="nb">rewrite</span> properEset.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">SetOrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> SetOrder.Exports.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">product</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">T1</span> <span class="nv">T2</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Type</span> <span class="nf">A</span> B : <span class="nb">set</span> (T1 * T2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_fst_set</span> : {homo @fst_set T1 T2 : A B / A `&lt;=` B}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo fst_set (T2:=T2) : A B / A `&lt;=` B &gt;-&gt; A `&lt;=` B}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1196</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B AB x [y Axy]; <span class="kr">exists</span> <span class="nv">y</span>; <span class="bp">exact</span>/AB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subset_snd_set</span> : {homo @snd_set T1 T2 : A B / A `&lt;=` B}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1198</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo snd_set (T2:=T2) : A B / A `&lt;=` B &gt;-&gt; A `&lt;=` B}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>119c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; A B AB x [y Axy]; <span class="kr">exists</span> <span class="nv">y</span>; <span class="bp">exact</span>/AB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fst_set_fst</span> <span class="nv">A</span> : A `&lt;=` A.`<span class="mi">1</span> \o fst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (T1 * T2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` A.`<span class="mi">1</span> \o fst</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11a1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [x y]; <span class="kr">exists</span> <span class="nv">y</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">snd_set_snd</span> <span class="nv">A</span>: A `&lt;=` A.`<span class="mi">2</span> \o snd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11a3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` A.`<span class="mi">2</span> \o snd</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11a8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [x y]; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fst_setM</span> (<span class="nv">X</span> : <span class="nb">set</span> T1) (<span class="nv">Y</span> : <span class="nb">set</span> T2) : (X `*` Y).`<span class="mi">1</span> `&lt;=` X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T1</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X `*` Y).`<span class="mi">1</span> `&lt;=` X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11ad</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x [y [//]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">snd_setM</span> (<span class="nv">X</span> : <span class="nb">set</span> T1) (<span class="nv">Y</span> : <span class="nb">set</span> T2) : (X `*` Y).`<span class="mi">2</span> `&lt;=` Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11af</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(X `*` Y).`<span class="mi">2</span> `&lt;=` Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11b5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x [y [//]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fst_setMR</span> (<span class="nv">X</span> : <span class="nb">set</span> T1) (<span class="nv">Y</span> : T1 -&gt; <span class="nb">set</span> T2) : (X `*`` Y).`<span class="mi">1</span> `&lt;=` X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>11b0</q><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>T1 -&gt; <span class="nb">set</span> T2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X `*`` Y).`<span class="mi">1</span> `&lt;=` X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11ba</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x [y [//]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">product</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">section</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">T1</span> <span class="nv">T2</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">A</span> : <span class="nb">set</span> (T1 * T2)) (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">xsection</span> <span class="nv">A</span> <span class="nv">x</span> := [<span class="nb">set</span> y | (x, y) \<span class="kr">in</span> A].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ysection</span> <span class="nv">A</span> <span class="nv">y</span> := [<span class="nb">set</span> x | (x, y) \<span class="kr">in</span> A].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xsection_snd_set</span> <span class="nv">A</span> <span class="nv">x</span> : xsection A x `&lt;=` A.`<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>11a4</q><br><q>471</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xsection A x `&lt;=` A.`<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11c1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; y Axy; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">rewrite</span> /xsection/= inE <span class="kr">in</span> Axy.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ysection_fst_set</span> <span class="nv">A</span> <span class="nv">y</span> : ysection A y `&lt;=` A.`<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>11a4</q><br><q>472</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ysection A y `&lt;=` A.`<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11c7</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x Axy; <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">rewrite</span> /ysection/= inE <span class="kr">in</span> Axy.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mem_xsection</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">A</span> : (y \<span class="kr">in</span> xsection A x) = ((x, y) \<span class="kr">in</span> A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>471</q><br><q>472</q><br><q>11a4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(y \<span class="kr">in</span> xsection A x) = ((x, y) \<span class="kr">in</span> A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11cd</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP/idP =&gt; [|]; [<span class="nb">rewrite</span> inE|<span class="nb">rewrite</span> /xsection !inE /= inE].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mem_ysection</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">A</span> : (x \<span class="kr">in</span> ysection A y) = ((x, y) \<span class="kr">in</span> A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11cf</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(x \<span class="kr">in</span> ysection A y) = ((x, y) \<span class="kr">in</span> A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11d3</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP/idP =&gt; [|]; [<span class="nb">rewrite</span> inE|<span class="nb">rewrite</span> /ysection !inE /= inE].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xsection0</span> <span class="nv">x</span> : xsection set0 x = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>471</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xsection set0 x = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11d8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE /xsection =&gt; y; <span class="nb">split</span> =&gt; //=; <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ysection0</span> <span class="nv">y</span> : ysection set0 y = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>472</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ysection set0 y = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11de</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE /ysection =&gt; x; <span class="nb">split</span> =&gt; //=; <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_xsectionM</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">x</span> : x \<span class="kr">in</span> X1 -&gt; xsection (X1 `*` X2) x = X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>set_predType T1</span></span></span><br><q>457</q><br><q>471</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x \<span class="kr">in</span> X1 -&gt; xsection (X1 `*` X2) x = X2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11e4</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; xX1; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [y /xsection_snd_set|]; <span class="kp">first</span> <span class="bp">exact</span>: snd_setM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>11e7</q><br><q>457</q><br><q>471</q><br><span><var>xX1</var><span class="hyp-type"><b>: </b><span>x \<span class="kr">in</span> X1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X2 `&lt;=` xsection (X1 `*` X2) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; y X2y; <span class="nb">rewrite</span> /xsection/= inE; <span class="nb">split</span>=&gt; //=; <span class="nb">rewrite</span> inE <span class="kr">in</span> xX1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_ysectionM</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">y</span> : y \<span class="kr">in</span> X2 -&gt; ysection (X1 `*` X2) y = X1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>456</q><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>set_predType T2</span></span></span><br><q>472</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y \<span class="kr">in</span> X2 -&gt; ysection (X1 `*` X2) y = X1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11f1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; yX2; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [x /ysection_fst_set|]; <span class="kp">first</span> <span class="bp">exact</span>: fst_setM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>456</q><br><q>11f4</q><br><q>472</q><br><span><var>yX2</var><span class="hyp-type"><b>: </b><span>y \<span class="kr">in</span> X2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X1 `&lt;=` ysection (X1 `*` X2) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x X1x; <span class="nb">rewrite</span> /ysection/= inE; <span class="nb">split</span>=&gt; //=; <span class="nb">rewrite</span> inE <span class="kr">in</span> yX2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notin_xsectionM</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">x</span> : x \notin X1 -&gt; xsection (X1 `*` X2) x = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11e6</q><span class="goal-separator"><hr></span><div class="goal-conclusion">x \notin X1 -&gt; xsection (X1 `*` X2) x = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11fe</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; xX1; <span class="nb">rewrite</span> /xsection /= predeqE =&gt; y; <span class="nb">split</span> =&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>11e7</q><br><q>457</q><br><q>471</q><br><span><var>xX1</var><span class="hyp-type"><b>: </b><span>x \notin X1</span></span></span><br><q>472</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="nb">set</span> y | (x, y) \<span class="kr">in</span> X1 `*` X2] y -&gt; set0 y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /xsection/= inE =&gt; -[] /=; <span class="nb">rewrite</span> notin_set <span class="kr">in</span> xX1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notin_ysectionM</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">y</span> : y \notin X2 -&gt; ysection (X1 `*` X2) y = set0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11f3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">y \notin X2 -&gt; ysection (X1 `*` X2) y = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1209</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; yX2; <span class="nb">rewrite</span> /xsection /= predeqE =&gt; x; <span class="nb">split</span> =&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>456</q><br><q>11f4</q><br><q>472</q><br><span><var>yX2</var><span class="hyp-type"><b>: </b><span>y \notin X2</span></span></span><br><q>471</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ysection (X1 `*` X2) y x -&gt; set0 x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /ysection/= inE =&gt; -[_]; <span class="nb">rewrite</span> notin_set <span class="kr">in</span> yX2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xsection_bigcup</span> (<span class="nv">F</span> : nat -&gt; <span class="nb">set</span> (T1 * T2)) <span class="nv">x</span> :
  xsection (\bigcup_n F n) x = \bigcup_n xsection (F n) x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><span><var>F</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="nb">set</span> (T1 * T2)</span></span></span><br><q>471</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xsection (\bigcup_n F n) x =
\bigcup_n xsection (F n) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1214</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE /xsection =&gt; y; <span class="nb">split</span> =&gt; [|[n _]] /=; <span class="nb">rewrite</span> inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1217</q><br><q>471</q><br><q>472</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_n F n) (x, y) -&gt;
(\bigcup_n [<span class="nb">set</span> y | (x, y) \<span class="kr">in</span> F n]) y</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1217</q><br><q>471</q><br><q>472</q><br><q>4c5</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">F n (x, y) -&gt; (x, y) \<span class="kr">in</span> \bigcup_n F n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; -[n _ Fnxy]; <span class="kr">exists</span> <span class="nv">n</span> =&gt; //=; <span class="nb">rewrite</span> inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1221</q><span class="goal-separator"><hr></span><q>1222</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Fnxy; <span class="nb">rewrite</span> inE; <span class="kr">exists</span> <span class="nv">n</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ysection_bigcup</span> (<span class="nv">F</span> : nat -&gt; <span class="nb">set</span> (T1 * T2)) <span class="nv">y</span> :
  ysection (\bigcup_n F n) y = \bigcup_n ysection (F n) y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1217</q><br><q>472</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ysection (\bigcup_n F n) y =
\bigcup_n ysection (F n) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1227</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> predeqE /ysection =&gt; x; <span class="nb">split</span> =&gt; [|[n _]] /=; <span class="nb">rewrite</span> inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1217</q><br><q>472</q><br><q>471</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(\bigcup_n F n) (x, y) -&gt;
(\bigcup_n [<span class="nb">set</span> x | (x, y) \<span class="kr">in</span> F n]) x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1217</q><br><q>472</q><br><q>471</q><br><q>4c5</q><br></div><label class="goal-separator"><hr></label><q>1222</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; -[n _ Fnxy]; <span class="kr">exists</span> <span class="nv">n</span> =&gt; //=; <span class="nb">rewrite</span> inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1233</q><span class="goal-separator"><hr></span><q>1222</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Fnxy; <span class="nb">rewrite</span> inE; <span class="kr">exists</span> <span class="nv">n</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_xsection</span> (<span class="nv">F</span> : nat -&gt; <span class="nb">set</span> (T1 * T2)) <span class="nv">x</span> : trivIset setT F -&gt;
  trivIset setT (<span class="kr">fun</span> <span class="nv">n</span> =&gt; xsection (F n) x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1216</q><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset [<span class="nb">set</span>: nat] F -&gt;
trivIset [<span class="nb">set</span>: nat] (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; xsection (F n) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1238</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; /trivIsetP h; <span class="nb">apply</span>/trivIsetP =&gt; i j _ _ ij.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1217</q><br><q>471</q><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat_eqType,
[<span class="nb">set</span>: nat] i -&gt;
[<span class="nb">set</span>: nat] j -&gt; i != j -&gt; F i `&amp;` F j = set0</span></span></span><br><q>d3b</q><br><q>d3c</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xsection (F i) x `&amp;` xsection (F j) x = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /xsection /= predeqE =&gt; y; <span class="nb">split</span> =&gt; //= -[]; <span class="nb">rewrite</span> !inE =&gt; Fixy Fjxy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1217</q><br><q>471</q><br><q>1240</q><br><q>d3b</q><br><q>d3c</q><br><q>472</q><br><span><var>Fixy</var><span class="hyp-type"><b>: </b><span>F i (x, y)</span></span></span><br><span><var>Fjxy</var><span class="hyp-type"><b>: </b><span>F j (x, y)</span></span></span><br></div><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> := h i j Logic.I Logic.I ij; <span class="nb">rewrite</span> predeqE =&gt; /(_ (x, y))[+ _]; <span class="nb">apply</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trivIset_ysection</span> (<span class="nv">F</span> : nat -&gt; <span class="nb">set</span> (T1 * T2)) <span class="nv">y</span> : trivIset setT F -&gt;
  trivIset setT (<span class="kr">fun</span> <span class="nv">n</span> =&gt; ysection (F n) y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1229</q><span class="goal-separator"><hr></span><div class="goal-conclusion">trivIset [<span class="nb">set</span>: nat] F -&gt;
trivIset [<span class="nb">set</span>: nat] (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ysection (F n) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1249</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; /trivIsetP h; <span class="nb">apply</span>/trivIsetP =&gt; i j _ _ ij.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1217</q><br><q>472</q><br><q>1240</q><br><q>d3b</q><br><q>d3c</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ysection (F i) y `&amp;` ysection (F j) y = set0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /ysection /= predeqE =&gt; x; <span class="nb">split</span> =&gt; //= -[]; <span class="nb">rewrite</span> !inE =&gt; Fixy Fjxy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1217</q><br><q>472</q><br><q>1240</q><br><q>d3b</q><br><q>d3c</q><br><q>471</q><br><q>1246</q><br><q>1247</q><br></div><span class="goal-separator"><hr></span><q>d83</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> := h i j Logic.I Logic.I ij; <span class="nb">rewrite</span> predeqE =&gt; /(_ (x, y))[+ _]; <span class="nb">apply</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">le_xsection</span> <span class="nv">x</span> : {homo xsection ^~ x : X Y / X `&lt;=` Y &gt;-&gt; X `&lt;=` Y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11da</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo xsection^~ x : X Y / X `&lt;=` Y &gt;-&gt; X `&lt;=` Y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1257</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; X Y XY y; <span class="nb">rewrite</span> /xsection /= <span class="mi">2</span>!inE =&gt; /XY.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">le_ysection</span> <span class="nv">y</span> : {homo ysection ^~ y : X Y / X `&lt;=` Y &gt;-&gt; X `&lt;=` Y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11e0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{homo ysection^~ y : X Y / X `&lt;=` Y &gt;-&gt; X `&lt;=` Y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>125c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; X Y XY x; <span class="nb">rewrite</span> /ysection /= <span class="mi">2</span>!inE =&gt; /XY.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xsectionI</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">x</span> : xsection (A `&amp;` B) x = xsection A x `&amp;` xsection B x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (T1 * T2)</span></span></span><br><q>471</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xsection (A `&amp;` B) x = xsection A x `&amp;` xsection B x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1261</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /xsection predeqE =&gt; y/=; <span class="nb">split</span>; <span class="nb">rewrite</span> !inE =&gt; -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ysectionI</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">y</span> : ysection (A `&amp;` B) y = ysection A y `&amp;` ysection B y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1264</q><br><q>472</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ysection (A `&amp;` B) y = ysection A y `&amp;` ysection B y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1268</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /ysection predeqE =&gt; x/=; <span class="nb">split</span>; <span class="nb">rewrite</span> !inE =&gt; -[].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xsectionD</span> <span class="nv">X</span> <span class="nv">Y</span> <span class="nv">x</span> : xsection (X `\` Y) x = xsection X x `\` xsection Y x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (T1 * T2)</span></span></span><br><q>471</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xsection (X `\` Y) x = xsection X x `\` xsection Y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>126e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE /xsection /= =&gt; y; <span class="nb">split</span>; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ysectionD</span> <span class="nv">X</span> <span class="nv">Y</span> <span class="nv">y</span> : ysection (X `\` Y) y = ysection X y `\` ysection Y y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>1271</q><br><q>472</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ysection (X `\` Y) y = ysection X y `\` ysection Y y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1275</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE /ysection /= =&gt; x; <span class="nb">split</span>; <span class="nb">rewrite</span> !inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">xsection_preimage_snd</span> (<span class="nv">B</span> : <span class="nb">set</span> T2) <span class="nv">x</span> : xsection (snd @^-<span class="mi">1</span>` B) x = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>44f</q><br><q>471</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xsection (snd @^-<span class="mi">1</span>` B) x = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>127b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="nb">move</span>=&gt; y/=; <span class="nb">rewrite</span> /xsection/= inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ysection_preimage_fst</span> (<span class="nv">A</span> : <span class="nb">set</span> T1) <span class="nv">y</span> : ysection (fst @^-<span class="mi">1</span>` A) y = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>b67</q><br><q>448</q><br><q>472</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ysection (fst @^-<span class="mi">1</span>` A) y = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1281</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="nb">move</span>=&gt; x/=; <span class="nb">rewrite</span> /ysection/= inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">section</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;B \; A&quot;</span> :=
  ([<span class="nb">set</span> xy | <span class="kr">exists2</span> z, A (xy.<span class="mi">1</span>, z) &amp; B (z, xy.<span class="mi">2</span>)]) : classical_set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_compose_subset</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">A</span> <span class="nv">C</span> : <span class="nb">set</span> (X * Y)) (<span class="nv">B</span> <span class="nv">D</span> : <span class="nb">set</span> (Y * X)) :
  A `&lt;=` C -&gt; B `&lt;=` D -&gt; A \; B `&lt;=` C \; D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (X * Y)</span></span></span><br><span><var>B, D</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (Y * X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A `&lt;=` C -&gt; B `&lt;=` D -&gt; A \; B `&lt;=` C \; D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1287</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; AsubC BD [x z] /= [y] Bxy Ayz; <span class="kr">exists</span> <span class="nv">y</span>; [<span class="bp">exact</span>: BD | <span class="bp">exact</span>: AsubC].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">set_compose_diag</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">E</span> : <span class="nb">set</span> (X * X)) :
  E \; range (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x, x)) = E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="nb">set</span> (X * X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E \; range (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (x, x)) = E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1290</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [[_ _] [_ [_ _ [&lt;- &lt;-//]]]|[x y] Exy]/=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1293</q><br><q>1294</q><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Exy</var><span class="hyp-type"><b>: </b><span>E (x, y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> z : X,
  <span class="kr">exists2</span> x0 : X, <span class="kt">True</span> &amp; (x0, x0) = (x, z) &amp; E (z, y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></article></body></html>