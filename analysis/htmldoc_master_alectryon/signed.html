<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>signed.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ssreflect ssrfun ssrbool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> ssrnat eqtype choice order ssralg ssrnum ssrint.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closedM;
                   GRing.smulr_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedM; GRing.smulr_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed.
New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.sdivr_closed_div;
                   GRing.divr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.sdivr_closedM; GRing.smulr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subalg_closedBM;
                   GRing.subring_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subalg_closedZ; GRing.submod_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divring_closed_div;
                   GRing.sdivr_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divring_closedBM; GRing.subring_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divalg_closedBdiv;
                   GRing.divring_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divalg_closedZ; GRing.subalg_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.Pred.subring_smul;
                   GRing.Pred.smul_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.Pred.subring_semi; GRing.Pred.semiring_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> mathcomp_extra.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ \* _&quot;</span> was already used <span class="kr">in</span> scope
ring_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;\- _&quot;</span> was already used <span class="kr">in</span> scope ring_scope.
[notation-overridden,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(******************************************************************************)</span>
<span class="c">(* This file develops tools to make the manipulation of numbers with a known  *)</span>
<span class="c">(* sign easier, thanks to canonical structures. This adds types like          *)</span>
<span class="c">(* {posnum R} for positive values in R, a notation e%:pos that infers the     *)</span>
<span class="c">(* positivity of expression e according to existing canonical instances and   *)</span>
<span class="c">(* %:num to cast back from type {posnum R} to R.                              *)</span>
<span class="c">(* For instance, given x, y : {posnum R}, we have                             *)</span>
<span class="c">(* ((x%:num + y%:num) / 2)%:pos : {posnum R} automatically inferred.          *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * types for values with known sign                                         *)</span>
<span class="c">(*    {posnum R} == interface type for elements in R that are positive; R     *)</span>
<span class="c">(*                  must have a zmodType structure.                           *)</span>
<span class="c">(*                  Allows to solve automatically goals of the form x &gt; 0 if  *)</span>
<span class="c">(*                  x is canonically a {posnum R}. {posnum R} is canonically  *)</span>
<span class="c">(*                  stable by common operations. All positive natural numbers *)</span>
<span class="c">(*                  ((n.+1)%:R) are also canonically in {posnum R}            *)</span>
<span class="c">(*    {nonneg R} == interface types for elements in R that are non-negative;  *)</span>
<span class="c">(*                  R must have a zmodType structure. Automatically solves    *)</span>
<span class="c">(*                  goals of the form x &gt;= 0. {nonneg R} is stable by         *)</span>
<span class="c">(*                  common operations. All natural numbers n%:R are also      *)</span>
<span class="c">(*                  canonically in {nonneg R}.                                *)</span>
<span class="c">(* {compare x0 &amp; nz &amp; cond} == more generic type of values comparing to       *)</span>
<span class="c">(*                  x0 : T according to nz and cond (see below). T must have  *)</span>
<span class="c">(*                  a porderType structure. This type is shown to be a        *)</span>
<span class="c">(*                  porderType. It is also an orderTpe, as soon as T is a     *)</span>
<span class="c">(*                  numDomainType.                                            *)</span>
<span class="c">(* {num R &amp; nz &amp; cond} == {compare 0%R : R &amp; nz &amp; cond}. T must have a        *)</span>
<span class="c">(*                  zmodType structure.                                       *)</span>
<span class="c">(*        {= x0} == {compare x0 &amp; ?=0 &amp; =0}                                   *)</span>
<span class="c">(*    {= x0 : T} == same with an explicit type T                              *)</span>
<span class="c">(*        {&gt; x0} == {compare x0 &amp; !=0 &amp; &gt;=0}                                  *)</span>
<span class="c">(*    {&gt; x0 : T} == same with an explicit type T                              *)</span>
<span class="c">(*        {&lt; x0} == {compare x0 &amp; !=0 &amp; &lt;=0}                                  *)</span>
<span class="c">(*    {&lt; x0 : T} == same with an explicit type T                              *)</span>
<span class="c">(*       {&gt;= x0} == {compare x0 &amp; ?=0 &amp; &gt;=0}                                  *)</span>
<span class="c">(*   {&gt;= x0 : T} == same with an explicit type T                              *)</span>
<span class="c">(*       {&lt;= x0} == {compare x0 &amp; ?=0 &amp; &lt;=0}                                  *)</span>
<span class="c">(*   {&lt;= x0 : T} == same with an explicit type T                              *)</span>
<span class="c">(*      {&gt;=&lt; x0} == {compare x0 &amp; ?=0 &amp; &gt;=&lt;0}                                 *)</span>
<span class="c">(*  {&gt;=&lt; x0 : T} == same with an explicit type T                              *)</span>
<span class="c">(*       {&gt;&lt; x0} == {compare x0 &amp; !=0 &amp; &gt;=&lt;0}                                 *)</span>
<span class="c">(*   {&gt;&lt; x0 : T} == same with an explicit type T                              *)</span>
<span class="c">(*       {!= x0} == {compare x0 &amp; !=0 &amp; &gt;?&lt;0}                                 *)</span>
<span class="c">(*   {!= x0 : T} == same with an explicit type T                              *)</span>
<span class="c">(*       {?= x0} == {compare x0 &amp; ?=0 &amp; &gt;?&lt;0}                                 *)</span>
<span class="c">(*   {?= x0 : T} == same with an explicit type T                              *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * casts from/to values with known sign                                     *)</span>
<span class="c">(*        x%:pos == explicitly casts x to {posnum R}, triggers the inference  *)</span>
<span class="c">(*                  of a {posnum R} structure for x.                          *)</span>
<span class="c">(*        x%:nng == explicitly casts x to {nonneg R}, triggers the inference  *)</span>
<span class="c">(*                  of a {nonneg R} structure for x.                          *)</span>
<span class="c">(*        x%:sgn == explicitly casts x to the most precise known              *)</span>
<span class="c">(*                  {compare x0 &amp; nz &amp; cond} according to existing canonical  *)</span>
<span class="c">(*                  instances.                                                *)</span>
<span class="c">(*        x%:num == explicit cast from {compare x0 &amp; nz &amp; cond} to R. In      *)</span>
<span class="c">(*                  particular this works from {posnum R} and {nonneg R} to R.*)</span>
<span class="c">(*     x%:posnum == explicit cast from {posnum R} to R.                       *)</span>
<span class="c">(*     x%:nngnum == explicit cast from {nonneg R} to R.                       *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * nullity conditions nz                                                    *)</span>
<span class="c">(* All nz above can be the following (in scope snum_nullity_scope delimited   *)</span>
<span class="c">(* by %snum_nullity)                                                          *)</span>
<span class="c">(*           !=0 == to encode x != 0                                          *)</span>
<span class="c">(*           ?=0 == unknown nullity                                           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * reality conditions cond                                                  *)</span>
<span class="c">(* All cond above can be the following (in scope snum_sign_scope delimited by *)</span>
<span class="c">(* by %snum_sign)                                                             *)</span>
<span class="c">(*            =0 == to encode x == 0                                          *)</span>
<span class="c">(*           &gt;=0 == to encode x &gt;= 0                                          *)</span>
<span class="c">(*           &lt;=0 == to encode x &lt;= 0                                          *)</span>
<span class="c">(*          &gt;=&lt;0 == to encode x &gt;=&lt; 0                                         *)</span>
<span class="c">(*          &gt;?&lt;0 == unknown reality                                           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * sign proofs                                                              *)</span>
<span class="c">(*    [sgn of x] == proof that x is of sign inferred by x%:sgn                *)</span>
<span class="c">(*    [gt0 of x] == proof that x &gt; 0                                          *)</span>
<span class="c">(*    [lt0 of x] == proof that x &lt; 0                                          *)</span>
<span class="c">(*    [ge0 of x] == proof that x &gt;= 0                                         *)</span>
<span class="c">(*    [le0 of x] == proof that x &lt;= 0                                         *)</span>
<span class="c">(*   [cmp0 of x] == proof that 0 &gt;=&lt; x                                        *)</span>
<span class="c">(*   [neq0 of x] == proof that x != 0                                         *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * constructors                                                             *)</span>
<span class="c">(*   PosNum xgt0 == builds a {posnum R} from a proof xgt0 : x &gt; 0 where x : R *)</span>
<span class="c">(*   NngNum xge0 == builds a {posnum R} from a proof xgt0 : x &gt;= 0 where x : R*)</span>
<span class="c">(*   Signed.mk p == builds a {compare x0 &amp; nz &amp; cond} from a proof p that     *)</span>
<span class="c">(*                  some x satisfies sign conditions encoded by nz and cond   *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * misc                                                                     *)</span>
<span class="c">(*          !! x == triggers pretyping to fill the holes of the term x. The   *)</span>
<span class="c">(*                  main use case is to trigger typeclass inference in the    *)</span>
<span class="c">(*                  body of a ssreflect have := !! body.                      *)</span>
<span class="c">(*                  Credits: Enrico Tassi.                                    *)</span>
<span class="c">(*             2 == notation for 2%:R.                                        *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* --&gt; A number of canonical instances are provided for common operations, if *)</span>
<span class="c">(* your favorite operator is missing, look below for examples on how to add   *)</span>
<span class="c">(* the appropriate Canonical.                                                 *)</span>
<span class="c">(* --&gt; Canonical instances are also provided according to types, as a         *)</span>
<span class="c">(* fallback when no known operator appears in the expression. Look to         *)</span>
<span class="c">(* nat_snum below for an example on how to add your favorite type.            *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;compare&#39; x0 &amp; nz &amp; cond }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, x0 <span class="kn">at level</span> <span class="mi">200</span>, nz <span class="kn">at level</span> <span class="mi">200</span>,
   <span class="kn">format</span> <span class="s2">&quot;{ &#39;compare&#39;  x0  &amp;  nz  &amp;  cond }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;num&#39; R &amp; nz &amp; cond }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, R <span class="kn">at level</span> <span class="mi">200</span>, nz <span class="kn">at level</span> <span class="mi">200</span>,
   <span class="kn">format</span> <span class="s2">&quot;{ &#39;num&#39;  R  &amp;  nz  &amp;  cond }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ = x0 }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ =  x0 }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &gt; x0 }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &gt;  x0 }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &lt; x0 }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &lt;  x0 }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &gt;= x0 }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &gt;=  x0 }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &lt;= x0 }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &lt;=  x0 }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &gt;=&lt; x0 }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &gt;=&lt;  x0 }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &gt;&lt; x0 }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &gt;&lt;  x0 }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ != x0 }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ !=  x0 }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ ?= x0 }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ ?=  x0 }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ = x0 : T }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ =  x0  :  T }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &gt; x0 : T }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &gt;  x0  :  T }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &lt; x0 : T }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &lt;  x0  :  T }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &gt;= x0 : T }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &gt;=  x0  :  T }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &lt;= x0 : T }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &lt;=  x0  :  T }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &gt;=&lt; x0 : T }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &gt;=&lt;  x0  :  T }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &gt;&lt; x0 : T }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &gt;&lt;  x0  :  T }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ != x0 : T }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ !=  x0  :  T }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ ?= x0 : T }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ ?=  x0  :  T }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;=0&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;=0&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;&gt;=0&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;&gt;=0&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;&lt;=0&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;&lt;=0&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;&gt;=&lt;0&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;&gt;=&lt;0&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;&gt;?&lt;0&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;&gt;?&lt;0&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;!=0&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;!=0&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;?=0&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;?=0&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;x %:sgn&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;x %:sgn&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;x %:num&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;x %:num&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;x %:posnum&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;x %:posnum&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;x %:nngnum&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;x %:nngnum&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;sgn&#39; &#39;of&#39; x ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;sgn&#39; &#39;of&#39;  x ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;gt0&#39; &#39;of&#39; x ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;gt0&#39; &#39;of&#39;  x ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;lt0&#39; &#39;of&#39; x ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;lt0&#39; &#39;of&#39;  x ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;ge0&#39; &#39;of&#39; x ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;ge0&#39; &#39;of&#39;  x ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;le0&#39; &#39;of&#39; x ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;le0&#39; &#39;of&#39;  x ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;cmp0&#39; &#39;of&#39; x ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;cmp0&#39; &#39;of&#39;  x ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;neq0&#39; &#39;of&#39; x ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;neq0&#39; &#39;of&#39;  x ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;posnum&#39; R }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;posnum&#39;  R }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;nonneg&#39; R }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;nonneg&#39;  R }&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;x %:pos&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;x %:pos&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;x %:nng&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;x %:nng&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;!! x&quot;</span> (<span class="kn">at level</span> <span class="mi">100</span>, <span class="kn">only parsing</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="kn">only parsing</span> modifier has no effect <span class="kr">in</span> Reserved
<span class="kn">Notation</span>.
[irrelevant-reserved-notation-<span class="kp">only</span>-parsing,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Strict Implicit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Printing Implicit Defensive</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Order.TTheory Order.Syntax.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> GRing.Theory Num.Theory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> order_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> snum_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> snum_scope <span class="kr">with</span> snum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> snum_sign_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> snum_sign_scope <span class="kr">with</span> snum_sign.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> snum_nullity_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> snum_nullity_scope <span class="kr">with</span> snum_nullity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;!! x&quot;</span> := (<span class="kp">ltac</span>:(<span class="nb">refine</span> x)) (<span class="kn">only parsing</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* infer class to help typeclass inference on the fly *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">infer</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) := Infer : P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Mode</span> infer ! : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (infer _) =&gt; (<span class="bp">exact</span>) : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">inferP</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : P -&gt; infer P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P -&gt; infer P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Import</span> KnownSign.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">nullity</span> := NonZero | MaybeZero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">nullity_bool</span> nz := <span class="kr">if</span> nz <span class="kr">is</span> NonZero <span class="kr">then</span> true <span class="kr">else</span> false.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">nz_of_bool</span> <span class="nv">b</span> := <span class="kr">if</span> b <span class="kr">then</span> NonZero <span class="kr">else</span> MaybeZero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">sign</span> := EqZero | NonNeg | NonPos.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">real</span> := Sign of sign | AnySign.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">reality</span> := Real of real | Arbitrary.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wider_nullity</span> <span class="nv">xnz</span> <span class="nv">ynz</span> :=
  <span class="kr">match</span> xnz, ynz <span class="kr">with</span>
  | MaybeZero, _
  | NonZero, NonZero =&gt; true
  | NonZero, MaybeZero =&gt; false
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wider_sign</span> <span class="nv">xs</span> <span class="nv">ys</span> :=
  <span class="kr">match</span> xs, ys <span class="kr">with</span>
  | NonNeg, NonNeg | NonNeg, EqZero
  | NonPos, NonPos | NonPos, EqZero
  | EqZero, EqZero =&gt; true
  | NonNeg, NonPos | NonPos, NonNeg
  | EqZero, NonPos | EqZero, NonNeg =&gt; false
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wider_real</span> <span class="nv">xr</span> <span class="nv">yr</span> :=
  <span class="kr">match</span> xr, yr <span class="kr">with</span>
  | AnySign, _ =&gt; true
  | Sign sx, Sign sy =&gt; wider_sign sx sy
  | Sign _, AnySign =&gt; false
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wider_reality</span> <span class="nv">xr</span> <span class="nv">yr</span> :=
  <span class="kr">match</span> xr, yr <span class="kr">with</span>
  | Arbitrary, _ =&gt; true
  | Real xr, Real yr =&gt; wider_real xr yr
  | Real _, Arbitrary =&gt; false
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">KnownSign</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Signed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Signed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">disp</span> : unit) (<span class="nv">T</span> : porderType disp) (<span class="nv">x0</span> : T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Coercion</span> <span class="nf">is_real</span> r := <span class="kr">if</span> r <span class="kr">is</span> Real _ <span class="kr">then</span> true <span class="kr">else</span> false.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">reality_cond</span> (<span class="nv">n</span> : reality) (<span class="nv">x</span> : T) :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | Real (Sign EqZero) =&gt; x == x0
  | Real (Sign NonNeg) =&gt; x &gt;= x0
  | Real (Sign NonPos) =&gt; x &lt;= x0
  | Real AnySign       =&gt; (x0 &lt;= x) || (x &lt;= x0)
  | Arbitary           =&gt; true
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">def</span> (<span class="nv">nz</span> : nullity) (<span class="nv">cond</span> : reality) := Def {
  r :&gt; T;
  #[canonical=no]
  P : (nz ==&gt; (r != x0)) &amp;&amp; reality_cond cond r
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Signed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">spec</span> x0 nz cond x :=
  ((nullity_bool nz%snum_nullity ==&gt; (x != x0))
   &amp;&amp; (reality_cond x0 cond%snum_sign x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">typ</span> <span class="nv">d</span> <span class="nv">nz</span> <span class="nv">cond</span> := Typ {
  sort : porderType d;
  #[canonical=no]
  sort_x0 : sort;
  #[canonical=no]
  allP : <span class="kr">forall</span> <span class="nv">x</span> : sort, spec sort_x0 nz cond x
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mk</span> {<span class="nv">d</span> <span class="nv">T</span>} <span class="nv">x0</span> <span class="nv">nz</span> <span class="nv">cond</span> <span class="nv">r</span> <span class="nv">P</span> : @def d T x0 nz cond :=
  @Def d T x0 nz cond r P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">from</span> {<span class="nv">d</span> <span class="nv">T</span> <span class="nv">x0</span> <span class="nv">nz</span> <span class="nv">cond</span>}
  {<span class="nv">x</span> : @def d T x0 nz cond} (<span class="nv">phx</span> : phantom T x) := x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fromP</span> {<span class="nv">d</span> <span class="nv">T</span> <span class="nv">x0</span> <span class="nv">nz</span> <span class="nv">cond</span>}
  {<span class="nv">x</span> : @def d T x0 nz cond} (<span class="nv">phx</span> : phantom T x) := P x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">Sign</span> : sign &gt;-&gt; real.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">Real</span> : real &gt;-&gt; reality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">is_real</span> : reality &gt;-&gt; bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Bind Scope</span> snum_sign_scope <span class="kr">with</span> sign.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Bind Scope</span> snum_sign_scope <span class="kr">with</span> reality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Bind Scope</span> snum_nullity_scope <span class="kr">with</span> nullity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;=0&quot;</span> := EqZero : snum_sign_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&gt;=0&quot;</span> := NonNeg : snum_sign_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&lt;=0&quot;</span> := NonPos : snum_sign_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&gt;=&lt;0&quot;</span> := AnySign : snum_sign_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&gt;?&lt;0&quot;</span> := Arbitrary : snum_sign_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;!=0&quot;</span> := NonZero : snum_nullity_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;?=0&quot;</span> := MaybeZero : snum_nullity_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &#39;compare&#39; x0 &amp; nz &amp; cond }&quot;</span> := (def x0 nz cond) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &#39;num&#39; R &amp; nz &amp; cond }&quot;</span> := (def (<span class="mi">0</span>%R : R) nz cond) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ = x0 : T }&quot;</span> := (def (x0 : T) MaybeZero EqZero) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &gt; x0 : T }&quot;</span> := (def (x0 : T) NonZero NonNeg) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &lt; x0 : T }&quot;</span> := (def (x0 : T) NonZero NonPos) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &gt;= x0 : T }&quot;</span> := (def (x0 : T) MaybeZero NonNeg) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &lt;= x0 : T }&quot;</span> := (def (x0 : T) MaybeZero NonPos) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &gt;&lt; x0 : T }&quot;</span> := (def (x0 : T) NonZero Real) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &gt;=&lt; x0 : T }&quot;</span> := (def (x0 : T) MaybeZero Real) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ != x0 : T }&quot;</span> := (def (x0 : T) NonZero Arbitrary) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ ?= x0 : T }&quot;</span> := (def (x0 : T) MaybeZero Arbitrary) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ = x0 }&quot;</span> := (def x0 MaybeZero EqZero) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &gt; x0 }&quot;</span> := (def x0 NonZero NonNeg) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &lt; x0 }&quot;</span> := (def x0 NonZero NonPos) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &gt;= x0 }&quot;</span> := (def x0 MaybeZero NonNeg) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &lt;= x0 }&quot;</span> := (def x0 MaybeZero NonPos) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &gt;&lt; x0 }&quot;</span> := (def x0 NonZero Real) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &gt;=&lt; x0 }&quot;</span> := (def x0 MaybeZero Real) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ != x0 }&quot;</span> := (def x0 NonZero Arbitrary) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ ?= x0 }&quot;</span> := (def x0 MaybeZero Arbitrary) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x %:sgn&quot;</span> := (<span class="kn">from</span> (Phantom _ x)) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;sgn&#39; &#39;of&#39; x ]&quot;</span> := (fromP (Phantom _ x)) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">num</span> := r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x %:num&quot;</span> := (r x) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">posnum</span> (<span class="nv">R</span> : numDomainType) <span class="nv">of</span> <span class="nv">phant</span> <span class="nv">R</span> := {&gt; <span class="mi">0</span>%R : R}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &#39;posnum&#39; R }&quot;</span> := (@posnum _ (Phant R))  : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x %:posnum&quot;</span> := (@num _ _ <span class="mi">0</span>%R !=<span class="mi">0</span> &gt;=<span class="mi">0</span> x) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">nonneg</span> (<span class="nv">R</span> : numDomainType) <span class="nv">of</span> <span class="nv">phant</span> <span class="nv">R</span> := {&gt;= <span class="mi">0</span>%R : R}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &#39;nonneg&#39; R }&quot;</span> := (@nonneg _ (Phant R))  : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x %:nngnum&quot;</span> := (@num _ _ <span class="mi">0</span>%R ?=<span class="mi">0</span> &gt;=<span class="mi">0</span> x) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;2&quot;</span> := <span class="mi">2</span>%:R : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> r {disp T x0 nz cond}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Signed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Signed.Exports.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">POrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">d</span> : unit) (<span class="nv">T</span> : porderType d) (<span class="nv">x0</span> : T) (<span class="nv">nz</span> : nullity) (<span class="nv">cond</span> : reality).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">sT</span> := {<span class="nb">compare</span> x0 &amp; nz &amp; cond}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">signed_subType</span> := [subType <span class="kr">for</span> @Signed.r d T x0 nz cond].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">signed_eqMixin</span> := [eqMixin of sT <span class="bp">by</span> &lt;:].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">signed_eqType</span> := EqType sT signed_eqMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">signed_choiceMixin</span> := [choiceMixin of sT <span class="bp">by</span> &lt;:].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">signed_choiceType</span> := ChoiceType sT signed_choiceMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">signed_porderMixin</span> := [porderMixin of sT <span class="bp">by</span> &lt;:].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">signed_porderType</span> := POrderType d sT signed_porderMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">POrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">top_typ_subproof</span> <span class="nv">d</span> (<span class="nv">T</span> : porderType d) (<span class="nv">x0</span> <span class="nv">x</span> : T) :
  Signed.spec x0 ?=<span class="mi">0</span> &gt;?&lt;<span class="mi">0</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d</var><span class="hyp-type"><b>: </b><span>unit</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>porderType d</span></span></span><br><span><var>x0, x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(?=<span class="mi">0</span>%snum_nullity ==&gt; (x != x0)) &amp;&amp;
Signed.reality_cond x0 &gt;?&lt;<span class="mi">0</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">top_typ</span> d (T : porderType d) (x0 : T) :=
  Signed.Typ (top_typ_subproof x0).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">real_domain_typ_subproof</span> (<span class="nv">R</span> : realDomainType) (<span class="nv">x</span> : R) :
  Signed.spec <span class="mi">0</span>%R ?=<span class="mi">0</span> &gt;=&lt;<span class="mi">0</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>realDomainType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(?=<span class="mi">0</span>%snum_nullity ==&gt; (x != <span class="mi">0</span>%R)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span>%R &gt;=&lt;<span class="mi">0</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>14</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /= -realE num_real.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">real_domain_typ</span> (R : realDomainType) :=
  Signed.Typ (@real_domain_typ_subproof R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">real_field_typ_subproof</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">x</span> : R) :
  Signed.spec <span class="mi">0</span>%R ?=<span class="mi">0</span> &gt;=&lt;<span class="mi">0</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>realFieldType</span></span></span><br><q>18</q><br></div><span class="goal-separator"><hr></span><q>19</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: real_domain_typ_subproof.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">real_field_typ</span> (R : realFieldType) :=
  Signed.Typ (@real_field_typ_subproof R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">nat_typ_subproof</span> (<span class="nv">x</span> : nat) : Signed.spec <span class="mi">0</span>%N ?=<span class="mi">0</span> &gt;=<span class="mi">0</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(?=<span class="mi">0</span>%snum_nullity ==&gt; (x != <span class="mi">0</span>%N)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span>%N &gt;=<span class="mi">0</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>22</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">nat_typ</span> := Signed.Typ nat_typ_subproof.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">typ_snum_subproof</span> <span class="nv">d</span> <span class="nv">nz</span> <span class="nv">cond</span> (<span class="nv">xt</span> : Signed.typ d nz cond)
    (<span class="nv">x</span> : Signed.sort xt) :
  Signed.spec (Signed.sort_x0 xt) nz cond x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>e</q><br><span><var>nz</var><span class="hyp-type"><b>: </b><span>nullity</span></span></span><br><span><var>cond</var><span class="hyp-type"><b>: </b><span>reality</span></span></span><br><span><var>xt</var><span class="hyp-type"><b>: </b><span>Signed.typ d nz cond</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Signed.sort xt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(nz ==&gt; (x != Signed.sort_x0 xt)) &amp;&amp;
Signed.reality_cond (Signed.sort_x0 xt) cond x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>29</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: xt x =&gt; [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* This adds _ &lt;- Signed.r ( typ_snum )</span>
<span class="c">   to canonical projections (c.f., Print Canonical Projections</span>
<span class="c">   Signed.r) meaning that if no other canonical instance (with a</span>
<span class="c">   registered head symbol) is found, a canonical instance of</span>
<span class="c">   Signed.typ, like the ones above, will be looked for. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">typ_snum</span> d nz cond (xt : Signed.typ d nz cond) (x : Signed.sort xt) :=
  Signed.mk (typ_snum_subproof x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Section Order. *)</span>
<span class="c">(* Variables (d : unit) (T : orderType d) (x0 : T) (nz : nullity) (cond : reality). *)</span>
<span class="c">(* Local Notation sT := {compare x0 &amp; nz &amp; cond}. *)</span>

<span class="c">(* Lemma signed_le_total : totalPOrderMixin [porderType of sT]. *)</span>
<span class="c">(* Proof. by move=&gt; x y; apply: le_total. Qed. *)</span>

<span class="c">(* Canonical signed_latticeType := LatticeType sT signed_le_total. *)</span>
<span class="c">(* Canonical signed_distrLatticeType := DistrLatticeType sT signed_le_total. *)</span>
<span class="c">(* Canonical signed_orderType := OrderType sT signed_le_total. *)</span>

<span class="c">(* End Order. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">unify</span> {<span class="nv">T</span>} <span class="nv">f</span> (<span class="nv">x</span> <span class="nv">y</span> : T) := Unify : f x y = true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Mode</span> <span class="nb">unify</span> - - - + : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">unify&#39;</span> {<span class="nv">T</span>} <span class="nv">f</span> (<span class="nv">x</span> <span class="nv">y</span> : T) := Unify&#39; : f x y = true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">unify&#39;P</span> {<span class="nv">T</span>} <span class="nv">f</span> (<span class="nv">x</span> <span class="nv">y</span> : T) : unify&#39; f x y -&gt; <span class="nb">unify</span> f x y := id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (unify&#39; _ _ _) =&gt; <span class="nb">vm_compute</span>; <span class="bp">reflexivity</span> : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">unify_nz</span> nzx nzy :=
  (<span class="nb">unify</span> wider_nullity nzx%snum_nullity nzy%snum_nullity).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">unify_r</span> rx ry :=
  (<span class="nb">unify</span> wider_reality rx%snum_sign ry%snum_sign).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">anysign_wider_real</span> <span class="nv">sign</span> : unify_r (Real AnySign) (Real sign).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>sign</var><span class="hyp-type"><b>: </b><span>real</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_r &gt;=&lt;<span class="mi">0</span> sign</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>33</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">any_reality_wider_eq0</span> <span class="nv">cond</span> : unify_r cond =<span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2d</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_r cond =<span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: cond =&gt; [[[]|]|].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Theory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">d</span> : unit} {<span class="nv">T</span> : porderType d} {<span class="nv">x0</span> : T}
  {<span class="nv">nz</span> : nullity} {<span class="nv">cond</span> : reality}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">sT</span> := {<span class="nb">compare</span> x0 &amp; nz &amp; cond}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Type</span> <span class="nf">x</span> : sT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">signed_intro</span> {<span class="nv">x</span>} : x%:num = x%:num :&gt; T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>e</q><br><q>f</q><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><q>2c</q><br><q>2d</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>sT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x%:num = x%:num</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>40</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bottom</span> <span class="nv">x</span> : unify_nz !=<span class="mi">0</span> nz -&gt; unify_r =<span class="mi">0</span> cond -&gt; <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_nz !=<span class="mi">0</span> nz -&gt; unify_r =<span class="mi">0</span> cond -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>48</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: x =&gt; [x /= /andP[]]; <span class="nb">move</span>: cond nz =&gt; [[[]|]|] [] //= /[<span class="nb">swap</span>] -&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">gt0</span> <span class="nv">x</span> : unify_nz !=<span class="mi">0</span> nz -&gt; unify_r &gt;=<span class="mi">0</span> cond -&gt; x0 &lt; x%:num :&gt; T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_nz !=<span class="mi">0</span> nz -&gt;
unify_r &gt;=<span class="mi">0</span> cond -&gt; (x0 : T) &lt; (x%:num : T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: x =&gt; [x /= /andP[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>e</q><br><q>f</q><br><q>43</q><br><q>2c</q><br><q>2d</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nz ==&gt; (x != x0) -&gt;
Signed.reality_cond x0 cond x -&gt;
unify_nz !=<span class="mi">0</span> nz -&gt; unify_r &gt;=<span class="mi">0</span> cond -&gt; x0 &lt; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: cond nz =&gt; [[[]|]|] [] //=; <span class="nb">rewrite</span> lt_def =&gt; -&gt; // /eqP -&gt; /=.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">le0F</span> <span class="nv">x</span> : unify_nz !=<span class="mi">0</span> nz -&gt; unify_r &gt;=<span class="mi">0</span> cond -&gt; x%:num &lt;= x0 :&gt; T = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_nz !=<span class="mi">0</span> nz -&gt;
unify_r &gt;=<span class="mi">0</span> cond -&gt; ((x%:num : T) &lt;= (x0 : T)) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>58</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">rewrite</span> lt_geF//; <span class="nb">apply</span>: gt0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lt0</span> <span class="nv">x</span> : unify_nz !=<span class="mi">0</span> nz -&gt; unify_r &lt;=<span class="mi">0</span> cond -&gt; x%:num &lt; x0 :&gt; T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_nz !=<span class="mi">0</span> nz -&gt;
unify_r &lt;=<span class="mi">0</span> cond -&gt; (x%:num : T) &lt; (x0 : T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: x =&gt; [x /= /andP[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>54</q><span class="goal-separator"><hr></span><div class="goal-conclusion">nz ==&gt; (x != x0) -&gt;
Signed.reality_cond x0 cond x -&gt;
unify_nz !=<span class="mi">0</span> nz -&gt; unify_r &lt;=<span class="mi">0</span> cond -&gt; x &lt; x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: cond nz =&gt; [[[]|]|] [] //=; <span class="nb">rewrite</span> lt_def [x0 == _]eq_sym =&gt; -&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>54</q><span class="goal-separator"><hr></span><div class="goal-conclusion">x == x0 -&gt;
unify_nz !=<span class="mi">0</span> !=<span class="mi">0</span> -&gt;
unify_r &lt;=<span class="mi">0</span> =<span class="mi">0</span> -&gt; true &amp;&amp; (x &lt;= x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /eqP -&gt; /=.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ge0F</span> <span class="nv">x</span> : unify_nz !=<span class="mi">0</span> nz -&gt; unify_r &lt;=<span class="mi">0</span> cond -&gt; x0 &lt;= x%:num :&gt; T = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_nz !=<span class="mi">0</span> nz -&gt;
unify_r &lt;=<span class="mi">0</span> cond -&gt; ((x0 : T) &lt;= (x%:num : T)) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">rewrite</span> lt_geF//; <span class="nb">apply</span>: lt0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ge0</span> <span class="nv">x</span> : unify_r &gt;=<span class="mi">0</span> cond -&gt; x0 &lt;= x%:num :&gt; T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_r &gt;=<span class="mi">0</span> cond -&gt; (x0 : T) &lt;= (x%:num : T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: x =&gt; [x /= /andP[]]; <span class="nb">move</span>: cond nz =&gt; [[[]|]|] [] //= _ /eqP -&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lt0F</span> <span class="nv">x</span> : unify_r &gt;=<span class="mi">0</span> cond -&gt; x%:num &lt; x0 :&gt; T = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_r &gt;=<span class="mi">0</span> cond -&gt; ((x%:num : T) &lt; (x0 : T)) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>74</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> le_gtF//; <span class="nb">apply</span>: ge0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">le0</span> <span class="nv">x</span> : unify_r &lt;=<span class="mi">0</span> cond -&gt; x0 &gt;= x%:num :&gt; T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_r &lt;=<span class="mi">0</span> cond -&gt; (x%:num : T) &lt;= (x0 : T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>79</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: x =&gt; [x /= /andP[]]; <span class="nb">move</span>: cond nz =&gt; [[[]|]|] [] //= _ /eqP -&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">gt0F</span> <span class="nv">x</span> : unify_r &lt;=<span class="mi">0</span> cond -&gt; x0 &lt; x%:num :&gt; T = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_r &lt;=<span class="mi">0</span> cond -&gt; ((x0 : T) &lt; (x%:num : T)) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> le_gtF//; <span class="nb">apply</span>: le0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">cmp0</span> <span class="nv">x</span> : unify_r (Real AnySign) cond -&gt; (x0 &gt;=&lt; x%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_r &gt;=&lt;<span class="mi">0</span> cond -&gt; x0 &gt;=&lt; x%:num</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>83</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: x =&gt; [x /= /andP[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>54</q><span class="goal-separator"><hr></span><div class="goal-conclusion">nz ==&gt; (x != x0) -&gt;
Signed.reality_cond x0 cond x -&gt;
unify_r &gt;=&lt;<span class="mi">0</span> cond -&gt; x0 &gt;=&lt; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: cond nz =&gt; [[[]|]|] [] //= _;
  <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">move</span>=&gt; /eqP -&gt;; <span class="nb">rewrite</span> comparablexx];
  <span class="nb">move</span>=&gt; sx; <span class="nb">rewrite</span> /Order.comparable sx// orbT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">neq0</span> <span class="nv">x</span> : unify_nz !=<span class="mi">0</span> nz -&gt; x%:num != x0 :&gt; T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_nz !=<span class="mi">0</span> nz -&gt; x%:num != x0 :&gt; T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: x =&gt; [x /= /andP[]]; <span class="nb">move</span>: cond nz =&gt; [[[]|]|] [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq0F</span> <span class="nv">x</span> : unify_nz !=<span class="mi">0</span> nz -&gt; x%:num == x0 :&gt; T = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_nz !=<span class="mi">0</span> nz -&gt; (x%:num == x0 :&gt; T) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>91</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /neq0-/(_ x)/negPf-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq0</span> <span class="nv">x</span> : unify_r =<span class="mi">0</span> cond -&gt; x%:num = x0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>42</q><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_r =<span class="mi">0</span> cond -&gt; x%:num = x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>96</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: x =&gt; [x /= /andP[_]]; <span class="nb">move</span>: cond nz =&gt; [[[]|]|] [] //= /eqP -&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">widen_signed_subproof</span> <span class="nv">x</span> <span class="nv">nz&#39;</span> <span class="nv">cond&#39;</span> :
  unify_nz nz&#39; nz -&gt; unify_r cond&#39; cond -&gt;
  Signed.spec x0 nz&#39; cond&#39; x%:num.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>e</q><br><q>f</q><br><q>43</q><br><q>2c</q><br><q>2d</q><br><q>44</q><br><span><var>nz'</var><span class="hyp-type"><b>: </b><span>nullity</span></span></span><br><span><var>cond'</var><span class="hyp-type"><b>: </b><span>reality</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">unify_nz nz&#39; nz -&gt;
unify_r cond&#39; cond -&gt;
(nz&#39; ==&gt; (x%:num != x0)) &amp;&amp;
Signed.reality_cond x0 cond&#39; x%:num</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9b</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: x =&gt; [x /= /andP[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>e</q><br><q>f</q><br><q>43</q><br><q>2c</q><br><q>2d</q><br><q>9e</q><br><q>9f</q><br><q>55</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nz ==&gt; (x != x0) -&gt;
Signed.reality_cond x0 cond x -&gt;
unify_nz nz&#39; nz -&gt;
unify_r cond&#39; cond -&gt;
(nz&#39; ==&gt; (x != x0)) &amp;&amp; Signed.reality_cond x0 cond&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: cond nz cond&#39; nz&#39; =&gt; [[[]|]|] [] [[[]|]|] [] //= nz&#39;&#39; cond&#39;&#39;;
   <span class="nb">rewrite</span> <span class="nl">?nz&#39;&#39;</span> <span class="nl">?cond&#39;&#39;</span> <span class="nl">?orbT</span> //; <span class="nb">move</span>: cond&#39;&#39; nz&#39;&#39; =&gt; /eqP -&gt;; <span class="nb">rewrite</span> lexx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">widen_signed</span> <span class="nv">x</span> <span class="nv">nz&#39;</span> <span class="nv">cond&#39;</span>
    (<span class="nv">unz</span> : unify_nz nz&#39; nz) (<span class="nv">ucond</span> : unify_r cond&#39; cond) :=
  Signed.mk (widen_signed_subproof x unz ucond).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">widen_signedE</span> <span class="nv">x</span> (<span class="nv">unz</span> : unify_nz nz nz) (<span class="nv">ucond</span> : unify_r cond cond) :
  @widen_signed x nz cond unz ucond = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>e</q><br><q>f</q><br><q>43</q><br><q>2c</q><br><q>2d</q><br><q>44</q><br><span><var>unz</var><span class="hyp-type"><b>: </b><span>unify_nz nz nz</span></span></span><br><span><var>ucond</var><span class="hyp-type"><b>: </b><span>unify_r cond cond</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">widen_signed x unz ucond = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/val_inj.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">posE</span> (<span class="nv">x</span> : sT) (<span class="nv">unz</span> : unify_nz !=<span class="mi">0</span> nz) (<span class="nv">ucond</span> : unify_r &gt;=<span class="mi">0</span> cond) :
  (widen_signed x%:num%:sgn unz ucond)%:num = x%:num.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>e</q><br><q>f</q><br><q>43</q><br><q>2c</q><br><q>2d</q><br><q>44</q><br><span><var>unz</var><span class="hyp-type"><b>: </b><span>unify_nz !=<span class="mi">0</span> nz</span></span></span><br><span><var>ucond</var><span class="hyp-type"><b>: </b><span>unify_r &gt;=<span class="mi">0</span> cond</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(widen_signed (x%:num)%:sgn unz ucond)%:num = x%:num</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">nngE</span> (<span class="nv">x</span> : sT) (<span class="nv">unz</span> : unify_nz ?=<span class="mi">0</span> nz) (<span class="nv">ucond</span> : unify_r &gt;=<span class="mi">0</span> cond) :
  (widen_signed x%:num%:sgn unz ucond)%:num = x%:num.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>e</q><br><q>f</q><br><q>43</q><br><q>2c</q><br><q>2d</q><br><q>44</q><br><span><var>unz</var><span class="hyp-type"><b>: </b><span>unify_nz ?=<span class="mi">0</span> nz</span></span></span><br><q>b4</q><br></div><span class="goal-separator"><hr></span><q>b5</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Theory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> bottom {d T x0 nz cond} _ {_ _}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> gt0 {d T x0 nz cond} _ {_ _}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> le0F {d T x0 nz cond} _ {_ _}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> lt0 {d T x0 nz cond} _ {_ _}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> ge0F {d T x0 nz cond} _ {_ _}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> ge0 {d T x0 nz cond} _ {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> lt0F {d T x0 nz cond} _ {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> le0 {d T x0 nz cond} _ {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> gt0F {d T x0 nz cond} _ {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> cmp0 {d T x0 nz cond} _ {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> neq0 {d T x0 nz cond} _ {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> eq0F {d T x0 nz cond} _ {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> eq0 {d T x0 nz cond} _ {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> widen_signed {d T x0 nz cond} _ {_ _ _ _}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> widen_signedE {d T x0 nz cond} _ {_ _}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> posE {d T x0 nz cond} _ {_ _}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> nngE {d T x0 nz cond} _ {_ _}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;gt0&#39; &#39;of&#39; x ]&quot;</span> := (<span class="kp">ltac</span>:(<span class="nb">refine</span> (gt0 x%:sgn))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">This notation contains <span class="kn">Ltac</span> <span class="nf">expressions</span>: it will not
be used <span class="kr">for</span> printing.
[non-reversible-notation,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;lt0&#39; &#39;of&#39; x ]&quot;</span> := (<span class="kp">ltac</span>:(<span class="nb">refine</span> (lt0 x%:sgn))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">This notation contains <span class="kn">Ltac</span> <span class="nf">expressions</span>: it will not
be used <span class="kr">for</span> printing.
[non-reversible-notation,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;ge0&#39; &#39;of&#39; x ]&quot;</span> := (<span class="kp">ltac</span>:(<span class="nb">refine</span> (ge0 x%:sgn))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">This notation contains <span class="kn">Ltac</span> <span class="nf">expressions</span>: it will not
be used <span class="kr">for</span> printing.
[non-reversible-notation,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;le0&#39; &#39;of&#39; x ]&quot;</span> := (<span class="kp">ltac</span>:(<span class="nb">refine</span> (le0 x%:sgn))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">This notation contains <span class="kn">Ltac</span> <span class="nf">expressions</span>: it will not
be used <span class="kr">for</span> printing.
[non-reversible-notation,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;cmp0&#39; &#39;of&#39; x ]&quot;</span> := (<span class="kp">ltac</span>:(<span class="nb">refine</span> (cmp0 x%:sgn))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">This notation contains <span class="kn">Ltac</span> <span class="nf">expressions</span>: it will not
be used <span class="kr">for</span> printing.
[non-reversible-notation,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;neq0&#39; &#39;of&#39; x ]&quot;</span> := (<span class="kp">ltac</span>:(<span class="nb">refine</span> (neq0 x%:sgn))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">This notation contains <span class="kn">Ltac</span> <span class="nf">expressions</span>: it will not
be used <span class="kr">for</span> printing.
[non-reversible-notation,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="mi">0</span>%R &lt; _)%O) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: gt0] : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt; <span class="mi">0</span>%R)%O) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: lt0] : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="mi">0</span>%R &lt;= _)%O) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: ge0] : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt;= <span class="mi">0</span>%R)%O) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: le0] : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ \<span class="kr">is</span> Num.real)) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: cmp0] : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="mi">0</span>%R &gt;=&lt; _)%O) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: cmp0] : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ != <span class="mi">0</span>%R)%O) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: neq0] : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x %:pos&quot;</span> := (widen_signed x%:sgn : {posnum _}) (<span class="kn">only parsing</span>)
  : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x %:nng&quot;</span> := (widen_signed x%:sgn : {nonneg _}) (<span class="kn">only parsing</span>)
  : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x %:pos&quot;</span> := (@widen_signed _ _ _ _ _
    (@Signed.<span class="kn">from</span> _ _ _ _ _ _ (Phantom _ x)) !=<span class="mi">0</span> (Real (Sign &gt;=<span class="mi">0</span>)) _ _)
  (<span class="kn">only printing</span>) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x %:nng&quot;</span> := (@widen_signed _ _ _ _ _
    (@Signed.<span class="kn">from</span> _ _ _ _ _ _ (Phantom _ x)) ?=<span class="mi">0</span> (Real (Sign &gt;=<span class="mi">0</span>)) _ _)
  (<span class="kn">only printing</span>) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Order</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">nz</span> : nullity) (<span class="nv">r</span> : real).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">nR</span> := {num R &amp; nz &amp; r}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">signed_le_total</span> : totalPOrderMixin [porderType of nR].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>numDomainType</span></span></span><br><q>2c</q><br><span><var>r</var><span class="hyp-type"><b>: </b><span>real</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">totalPOrderMixin [porderType of {num R &amp; nz &amp; r}]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x y; <span class="nb">apply</span>: real_comparable =&gt; /=.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">signed_latticeType</span> := LatticeType nR signed_le_total.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">signed_distrLatticeType</span> := DistrLatticeType nR signed_le_total.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">signed_orderType</span> := OrderType nR signed_le_total.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Order</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">POrderStability</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">disp</span> : unit} {<span class="nv">T</span> : porderType disp} {<span class="nv">x0</span> : T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">min_nonzero_subdef</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality) :=
  nz_of_bool
    (xnz &amp;&amp; ynz
     || xnz &amp;&amp; yr &amp;&amp; <span class="kr">match</span> xr <span class="kr">with</span> Real (Sign &lt;=<span class="mi">0</span>) =&gt; true | _ =&gt; false <span class="kr">end</span>
     || ynz &amp;&amp; <span class="kr">match</span> yr <span class="kr">with</span> Real (Sign &lt;=<span class="mi">0</span>) =&gt; true | _ =&gt; false <span class="kr">end</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> min_nonzero_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">min_reality_subdef</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality) : reality :=
  <span class="kr">match</span> xr, yr <span class="kr">with</span>
  | Real (Sign =<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>)
  | Real (Sign =<span class="mi">0</span>), Real (Sign &gt;=<span class="mi">0</span>)
  | Real (Sign &gt;=<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>) =&gt; =<span class="mi">0</span>
  | Real (Sign &gt;=<span class="mi">0</span>), Real (Sign &gt;=<span class="mi">0</span>) =&gt; &gt;=<span class="mi">0</span>
  | Real (Sign &lt;=<span class="mi">0</span>), Real _
  | Real _, Real (Sign &lt;=<span class="mi">0</span>) =&gt; &lt;=<span class="mi">0</span>
  | Real _, Real _ =&gt; &gt;=&lt;<span class="mi">0</span>
  | _, _ =&gt; &gt;?&lt;<span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> min_reality_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">min_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality)
    (<span class="nv">x</span> : {<span class="nb">compare</span> x0 &amp; xnz &amp; xr}) (<span class="nv">y</span> : {<span class="nb">compare</span> x0 &amp; ynz &amp; yr})
    (<span class="nv">rnz</span> := min_nonzero_subdef xnz ynz xr yr)
    (<span class="nv">rrl</span> := min_reality_subdef xnz ynz xr yr) :
  Signed.spec x0 rnz rrl (Order.min x%:num y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>disp</var><span class="hyp-type"><b>: </b><span>unit</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>porderType disp</span></span></span><br><q>43</q><br><span><var>xnz, ynz</var><span class="hyp-type"><b>: </b><span>nullity</span></span></span><br><span><var>xr, yr</var><span class="hyp-type"><b>: </b><span>reality</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> x0 &amp; xnz &amp; xr}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> x0 &amp; ynz &amp; yr}</span></span></span><br><span><var>rnz</var><span><span class="hyp-body"><b>:= </b><span>min_nonzero_subdef xnz ynz xr yr</span></span><span class="hyp-type"><b>: </b><span>nullity</span></span></span></span><br><span><var>rrl</var><span><span class="hyp-body"><b>:= </b><span>min_reality_subdef xnz ynz xr yr</span></span><span class="hyp-type"><b>: </b><span>reality</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (Order.min x%:num y%:num != x0)) &amp;&amp;
Signed.reality_cond x0 rrl (Order.min x%:num y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>cc</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>cf</q><br><q>d0</q><br><q>43</q><br><q>d1</q><br><q>d2</q><br><q>d3</q><br><q>d4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">min_nonzero_subdef xnz ynz xr yr ==&gt;
(Order.min x%:num y%:num != x0)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>dc</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Signed.reality_cond x0
  (min_reality_subdef xnz ynz xr yr)
  (Order.min x%:num y%:num)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//= x y; <span class="nb">rewrite</span> /Order.min;
    <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom y)
        |<span class="bp">by</span> <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> <span class="nl">?eq0F</span>// =&gt; xlty;
            <span class="nb">have</span> := !! lt_trans xlty (lt0 y); <span class="nb">rewrite</span> lt_neqAle =&gt; /andP[]
        |<span class="bp">by</span> <span class="nb">rewrite</span> ifT <span class="nl">?eq0F</span>//; <span class="nb">apply</span>: lt_le_trans (ge0 y); <span class="bp">exact</span>: lt0
        |<span class="bp">by</span> <span class="nb">have</span> := !! le0 y;
            <span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[-&gt;|]; <span class="nb">rewrite</span> <span class="nl">?lt0</span> <span class="nl">?eq0F</span>//;
            <span class="nb">case</span>: ifP =&gt; _; <span class="nb">rewrite</span> <span class="nl">?eq0F</span>// lt_neqAle =&gt; /andP[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>cf</q><br><q>d0</q><br><q>43</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> x0 &amp; !=<span class="mi">0</span> &amp; &lt;=<span class="mi">0</span>}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> x0 &amp; ?=<span class="mi">0</span> &amp; &gt;=&lt;<span class="mi">0</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> (x%:num &lt; y%:num)%O <span class="kr">then</span> x%:num <span class="kr">else</span> y%:num) != x0</div></blockquote><q>de</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> /orP[x0ley|] := !! cmp0 y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>cf</q><br><q>d0</q><br><q>43</q><br><q>e5</q><br><q>e6</q><br><span><var>x0ley</var><span class="hyp-type"><b>: </b><span>(x0 &lt;= y%:num)%O</span></span></span><br></div><span class="goal-separator"><hr></span><q>e7</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>e4</q><label class="goal-separator"><hr></label><div class="goal-conclusion">(y%:num &lt;= x0)%O -&gt;
(<span class="kr">if</span> (x%:num &lt; y%:num)%O <span class="kr">then</span> x%:num <span class="kr">else</span> y%:num) != x0</div></blockquote><q>df</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ifT <span class="nl">?eq0F</span>//; <span class="nb">apply</span>: lt_le_trans x0ley; <span class="bp">exact</span>: lt0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e4</q><span class="goal-separator"><hr></span><q>ef</q></blockquote><q>de</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[-&gt;|]; <span class="nb">rewrite</span> <span class="nl">?lt0</span> <span class="nl">?eq0F</span>//.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(y%:num &lt; x0)%O -&gt;
(<span class="kr">if</span> (x%:num &lt; y%:num)%O <span class="kr">then</span> x%:num <span class="kr">else</span> y%:num) != x0</div></blockquote><q>de</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: ifP =&gt; _; <span class="nb">rewrite</span> <span class="nl">?eq0F</span>// lt_neqAle =&gt; /andP[].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>dc</q><span class="goal-separator"><hr></span><q>e0</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//= x y;
  <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom y)
      |<span class="bp">by</span> <span class="nb">apply</span>: comparable_minr; <span class="bp">exact</span>: cmp0
      |<span class="bp">by</span> <span class="nb">rewrite</span> minEle; <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> ge0
      |<span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?eq0</span> minEle <span class="nl">?ge0</span>
      |<span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?eq0</span> minElt; <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> <span class="nl">?eq0</span>// lt0F
      |<span class="bp">by</span> <span class="nb">rewrite</span> minEle; <span class="nb">case</span>: ifP =&gt; [xlty|]; <span class="nb">rewrite</span> <span class="nl">?le0</span>//;
          <span class="nb">apply</span>: (le_trans xlty); <span class="nb">rewrite</span> le0
      |<span class="bp">by</span> <span class="nb">have</span> /orP[x0ley|] := !! cmp0 y;
          [<span class="nb">rewrite</span> minEle ifT <span class="nl">?le0</span>//; <span class="nb">apply</span>: le_trans x0ley; <span class="bp">exact</span>: le0
          |<span class="nb">rewrite</span> minEle; <span class="nb">case</span>: ifP =&gt; //; <span class="bp">exact</span>: le_trans]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">min_snum</span> (xnz ynz : nullity) (xr yr : reality)
    (x : {<span class="nb">compare</span> x0 &amp; xnz &amp; xr}) (y : {<span class="nb">compare</span> x0 &amp; ynz &amp; yr}) :=
  Signed.mk (min_snum_subproof x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">max_nonzero_subdef</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality) :=
  nz_of_bool
    (xnz &amp;&amp; ynz
     || xnz &amp;&amp; <span class="kr">match</span> xr <span class="kr">with</span> Real (Sign &gt;=<span class="mi">0</span>) =&gt; true | _ =&gt; false <span class="kr">end</span>
     || ynz &amp;&amp; xr &amp;&amp; <span class="kr">match</span> yr <span class="kr">with</span> Real (Sign &gt;=<span class="mi">0</span>) =&gt; true | _ =&gt; false <span class="kr">end</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> max_nonzero_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">max_reality_subdef</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality) : reality :=
  <span class="kr">match</span> xr, yr <span class="kr">with</span>
  | Real (Sign =<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>)
  | Real (Sign =<span class="mi">0</span>), Real (Sign &lt;=<span class="mi">0</span>)
  | Real (Sign &lt;=<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>) =&gt; =<span class="mi">0</span>
  | Real (Sign &lt;=<span class="mi">0</span>), Real (Sign &lt;=<span class="mi">0</span>) =&gt; &lt;=<span class="mi">0</span>
  | Real (Sign &gt;=<span class="mi">0</span>), Real _
  | Real _, Real (Sign &gt;=<span class="mi">0</span>) =&gt; &gt;=<span class="mi">0</span>
  | Real _, Real _ =&gt; &gt;=&lt;<span class="mi">0</span>
  | _, _ =&gt; &gt;?&lt;<span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> max_reality_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">max_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality)
    (<span class="nv">x</span> : {<span class="nb">compare</span> x0 &amp; xnz &amp; xr}) (<span class="nv">y</span> : {<span class="nb">compare</span> x0 &amp; ynz &amp; yr})
    (<span class="nv">rnz</span> := max_nonzero_subdef xnz ynz xr yr)
    (<span class="nv">rrl</span> := max_reality_subdef xnz ynz xr yr) :
  Signed.spec x0 rnz rrl (Order.max x%:num y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>cf</q><br><q>d0</q><br><q>43</q><br><q>d1</q><br><q>d2</q><br><q>d3</q><br><q>d4</q><br><span><var>rnz</var><span><span class="hyp-body"><b>:= </b><span>max_nonzero_subdef xnz ynz xr yr</span></span><span class="hyp-type"><b>: </b><span>nullity</span></span></span></span><br><span><var>rrl</var><span><span class="hyp-body"><b>:= </b><span>max_reality_subdef xnz ynz xr yr</span></span><span class="hyp-type"><b>: </b><span>reality</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (Order.max x%:num y%:num != x0)) &amp;&amp;
Signed.reality_cond x0 rrl (Order.max x%:num y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>fb</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>dc</q><span class="goal-separator"><hr></span><div class="goal-conclusion">max_nonzero_subdef xnz ynz xr yr ==&gt;
(Order.max x%:num y%:num != x0)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>dc</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Signed.reality_cond x0
  (max_reality_subdef xnz ynz xr yr)
  (Order.max x%:num y%:num)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//= x y; <span class="nb">rewrite</span> maxElt;
    <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom y)
        |<span class="bp">by</span> <span class="nb">case</span>: ifP =&gt; [xlty|]; <span class="nb">rewrite</span> <span class="nl">?eq0F</span>//;
            <span class="kp">do</span> [<span class="nb">suff</span> : (x0 &lt; y%:num)%O <span class="bp">by</span> <span class="nb">rewrite</span> lt_def =&gt; /andP[]];
            <span class="nb">apply</span>: le_lt_trans xlty; <span class="bp">exact</span>: ge0
        |<span class="bp">by</span> <span class="nb">rewrite</span> ifT <span class="nl">?eq0F</span>//; <span class="nb">apply</span>: le_lt_trans (gt0 y); <span class="bp">exact</span>: le0
        |<span class="bp">by</span> <span class="nb">have</span> := !! ge0 x;
            <span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[&lt;-|]; <span class="nb">rewrite</span> <span class="nl">?gt0</span> <span class="nl">?eq0F</span>//;
            <span class="nb">case</span>: ifP =&gt; _; <span class="nb">rewrite</span> <span class="nl">?eq0F</span>// lt_def =&gt; /andP[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>cf</q><br><q>d0</q><br><q>43</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> x0 &amp; ?=<span class="mi">0</span> &amp; &gt;=&lt;<span class="mi">0</span>}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> x0 &amp; !=<span class="mi">0</span> &amp; &gt;=<span class="mi">0</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> (x%:num &lt; y%:num)%O <span class="kr">then</span> y%:num <span class="kr">else</span> x%:num) != x0</div></blockquote><q>106</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> /orP[|xlex0] := !! cmp0 x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(x0 &lt;= x%:num)%O -&gt;
(<span class="kr">if</span> (x%:num &lt; y%:num)%O <span class="kr">then</span> y%:num <span class="kr">else</span> x%:num) != x0</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>cf</q><br><q>d0</q><br><q>43</q><br><q>10d</q><br><q>10e</q><br><span><var>xlex0</var><span class="hyp-type"><b>: </b><span>(x%:num &lt;= x0)%O</span></span></span><br></div><label class="goal-separator"><hr></label><q>10f</q></blockquote><q>107</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[&lt;-|]; <span class="nb">rewrite</span> <span class="nl">?gt0</span> <span class="nl">?eq0F</span>//.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(x0 &lt; x%:num)%O -&gt;
(<span class="kr">if</span> (x%:num &lt; y%:num)%O <span class="kr">then</span> y%:num <span class="kr">else</span> x%:num) != x0</div></blockquote><q>114</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: ifP =&gt; _; <span class="nb">rewrite</span> <span class="nl">?eq0F</span>// lt_def =&gt; /andP[].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>116</q><span class="goal-separator"><hr></span><q>10f</q></blockquote><q>106</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ifT <span class="nl">?eq0F</span>//; <span class="nb">apply</span>: (le_lt_trans xlex0); <span class="bp">exact</span>: gt0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>dc</q><span class="goal-separator"><hr></span><q>108</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//= x y;
  <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom y)
      |<span class="bp">by</span> <span class="nb">apply</span>: comparable_maxr; <span class="bp">exact</span>: cmp0
      |<span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?eq0</span> maxEle <span class="nl">?le0</span>
      |<span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?eq0</span> maxElt ifF// le_gtF// le0
      |<span class="bp">by</span> <span class="nb">rewrite</span> maxEle; <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> <span class="nl">?ge0</span>//; <span class="bp">exact</span>/le_trans/ge0
      |<span class="bp">by</span> <span class="nb">rewrite</span> maxElt; <span class="nb">case</span>: ifP =&gt; [xlty|]; <span class="nb">rewrite</span> <span class="nl">?le0</span>//
      |<span class="bp">by</span> <span class="nb">have</span> /orP[|xlex0] := !! cmp0 x;
          [<span class="nb">rewrite</span> maxEle; <span class="nb">case</span>: ifP =&gt; // /[<span class="nb">swap</span>]; <span class="bp">exact</span>: le_trans
          |<span class="nb">rewrite</span> maxEle ifT <span class="nl">?ge0</span>//; <span class="nb">apply</span>: (le_trans xlex0); <span class="bp">exact</span>: ge0]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">max_snum</span> (xnz ynz : nullity) (xr yr : reality)
    (x : {<span class="nb">compare</span> x0 &amp; xnz &amp; xr}) (y : {<span class="nb">compare</span> x0 &amp; ynz &amp; yr}) :=
  Signed.mk (max_snum_subproof x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">POrderStability</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">NumDomainStability</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : numDomainType}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">zero_snum_subproof</span> : Signed.spec <span class="mi">0</span> ?=<span class="mi">0</span> =<span class="mi">0</span> (<span class="mi">0</span> : R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(?=<span class="mi">0</span>%snum_nullity ==&gt; ((<span class="mi">0</span> : R) != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> =<span class="mi">0</span> (<span class="mi">0</span> : R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>123</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: eqxx.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">zero_snum</span> := Signed.mk zero_snum_subproof.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">one_snum_subproof</span> : Signed.spec <span class="mi">0</span> !=<span class="mi">0</span> &gt;=<span class="mi">0</span> (<span class="mi">1</span> : R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>125</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(!=<span class="mi">0</span>%snum_nullity ==&gt; ((<span class="mi">1</span> : R) != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> &gt;=<span class="mi">0</span> (<span class="mi">1</span> : R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>129</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /= oner_eq0 ler01.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">one_snum</span> := Signed.mk one_snum_subproof.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">opp_reality_subdef</span> (<span class="nv">xnz</span> : nullity) (<span class="nv">xr</span> : reality) : reality :=
  <span class="kr">match</span> xr <span class="kr">with</span>
  | Real (Sign =<span class="mi">0</span>) =&gt; =<span class="mi">0</span>
  | Real (Sign &gt;=<span class="mi">0</span>) =&gt; &lt;=<span class="mi">0</span>
  | Real (Sign &lt;=<span class="mi">0</span>) =&gt; &gt;=<span class="mi">0</span>
  | Real AnySign    =&gt; &gt;=&lt;<span class="mi">0</span>
  | Arbitrary              =&gt; &gt;?&lt;<span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">opp_snum_subproof</span> (<span class="nv">xnz</span> : nullity) (<span class="nv">xr</span> : reality)
    (<span class="nv">x</span> : {num R &amp; xnz &amp; xr}) (<span class="nv">r</span> := opp_reality_subdef xnz xr) :
  Signed.spec <span class="mi">0</span> xnz r (- x%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><span><var>xnz</var><span class="hyp-type"><b>: </b><span>nullity</span></span></span><br><span><var>xr</var><span class="hyp-type"><b>: </b><span>reality</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{num R &amp; xnz &amp; xr}</span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>opp_reality_subdef xnz xr</span></span><span class="hyp-type"><b>: </b><span>reality</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(xnz ==&gt; (- x%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> r (- x%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>12e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> {}/r; <span class="nb">case</span>: xr x =&gt; [[[]|]|]//= [r]/=;
   <span class="nb">rewrite</span> oppr_eq0 ?(oppr_ge0, oppr_le0)// orbC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">opp_snum</span> (xnz : nullity) (xr : reality) (x : {num R &amp; xnz &amp; xr}) :=
  Signed.mk (opp_snum_subproof x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_samesign_subdef</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality) :=
  <span class="kr">match</span> xr, yr <span class="kr">with</span>
  | Real (Sign &gt;=<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>)
  | Real (Sign =<span class="mi">0</span>), Real (Sign &gt;=<span class="mi">0</span>)
  | Real (Sign &lt;=<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>)
  | Real (Sign =<span class="mi">0</span>), Real (Sign &lt;=<span class="mi">0</span>)
  | Real (Sign =<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>)
  | Real (Sign &gt;=<span class="mi">0</span>), Real (Sign &gt;=<span class="mi">0</span>)
  | Real (Sign &lt;=<span class="mi">0</span>), Real (Sign &lt;=<span class="mi">0</span>) =&gt; true
  | _, _ =&gt; false
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_nonzero_subdef</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality) :=
  nz_of_bool (add_samesign_subdef xnz ynz xr yr &amp;&amp; (xnz || ynz)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> add_nonzero_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_reality_subdef</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality) : reality :=
  <span class="kr">match</span> xr, yr <span class="kr">with</span>
  | Real (Sign =<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>) =&gt; =<span class="mi">0</span>
  | Real (Sign &gt;=<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>)
  | Real (Sign =<span class="mi">0</span>), Real (Sign &gt;=<span class="mi">0</span>)
  | Real (Sign &gt;=<span class="mi">0</span>), Real (Sign &gt;=<span class="mi">0</span>) =&gt; &gt;=<span class="mi">0</span>
  | Real (Sign &lt;=<span class="mi">0</span>), Real (Sign =<span class="mi">0</span>)
  | Real (Sign =<span class="mi">0</span>), Real (Sign &lt;=<span class="mi">0</span>)
  | Real (Sign &lt;=<span class="mi">0</span>), Real (Sign &lt;=<span class="mi">0</span>) =&gt; &lt;=<span class="mi">0</span>
  | Real _, Real _ =&gt; &gt;=&lt;<span class="mi">0</span>
  | _, _ =&gt; &gt;?&lt;<span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> add_reality_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">add_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality)
    (<span class="nv">x</span> : {num R &amp; xnz &amp; xr}) (<span class="nv">y</span> : {num R &amp; ynz &amp; yr})
    (<span class="nv">rnz</span> := add_nonzero_subdef xnz ynz xr yr)
    (<span class="nv">rrl</span> := add_reality_subdef xnz ynz xr yr) :
  Signed.spec <span class="mi">0</span> rnz rrl (x%:num + y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>d1</q><br><q>d2</q><br><q>133</q><br><span><var>y</var><span class="hyp-type"><b>: </b><span>{num R &amp; ynz &amp; yr}</span></span></span><br><span><var>rnz</var><span><span class="hyp-body"><b>:= </b><span>add_nonzero_subdef xnz ynz xr yr</span></span><span class="hyp-type"><b>: </b><span>nullity</span></span></span></span><br><span><var>rrl</var><span><span class="hyp-body"><b>:= </b><span>add_reality_subdef xnz ynz xr yr</span></span><span class="hyp-type"><b>: </b><span>reality</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (x%:num + y%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> rrl (x%:num + y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>138</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>d1</q><br><q>d2</q><br><q>133</q><br><q>13b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">add_nonzero_subdef xnz ynz xr yr ==&gt;
(x%:num + y%:num != <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>143</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Signed.reality_cond <span class="mi">0</span>
  (add_reality_subdef xnz ynz xr yr) (x%:num + y%:num)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//= x y;
  <span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">1</span><span class="nl">?addr_ss_eq0</span> ?(eq0F, ge0, le0, andbF, orbT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>143</q><span class="goal-separator"><hr></span><q>147</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> addr_le0 a b : a &lt;= <span class="mi">0</span> -&gt; b &lt;= <span class="mi">0</span> -&gt; a + b &lt;= <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>d1</q><br><q>d2</q><br><q>133</q><br><q>13b</q><br><span><var>_t_</var><span class="hyp-type"><b>: </b><span>numDomainType</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>_t_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a &lt;= <span class="mi">0</span> -&gt; b &lt;= <span class="mi">0</span> -&gt; a + b &lt;= <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>d1</q><br><q>d2</q><br><q>133</q><br><q>13b</q><br><span><var>addr_le0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">t</span> : numDomainType) (<span class="nv">a</span> <span class="nv">b</span> : t),
a &lt;= <span class="mi">0</span> -&gt; b &lt;= <span class="mi">0</span> -&gt; a + b &lt;= <span class="mi">0</span></span></span></span><br></div><label class="goal-separator"><hr></label><q>147</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -!oppr_ge0 opprD; <span class="nb">apply</span>: addr_ge0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>154</q><span class="goal-separator"><hr></span><q>147</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//= x y;
  <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">rewrite</span> addr_ge0|<span class="bp">by</span> <span class="nb">rewrite</span> addr_le0|<span class="bp">by</span> <span class="nb">rewrite</span> -realE realD
      |<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom y)|<span class="bp">by</span> <span class="nb">rewrite</span> !eq0 addr0].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">add_snum</span> (xnz ynz : nullity) (xr yr : reality)
    (x : {num R &amp; xnz &amp; xr}) (y : {num R &amp; ynz &amp; yr}) :=
  Signed.mk (add_snum_subproof x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mul_nonzero_subdef</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality) :=
  nz_of_bool (xnz &amp;&amp; ynz).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> mul_nonzero_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mul_reality_subdef</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality) : reality :=
  <span class="kr">match</span> xr, yr <span class="kr">with</span>
  | Real (Sign =<span class="mi">0</span>), _ | _, Real (Sign =<span class="mi">0</span>) =&gt; =<span class="mi">0</span>
  | Real (Sign &gt;=<span class="mi">0</span>), Real (Sign &gt;=<span class="mi">0</span>)
  | Real (Sign &lt;=<span class="mi">0</span>), Real (Sign &lt;=<span class="mi">0</span>) =&gt; &gt;=<span class="mi">0</span>
  | Real (Sign &gt;=<span class="mi">0</span>), Real (Sign &lt;=<span class="mi">0</span>)
  | Real (Sign &lt;=<span class="mi">0</span>), Real (Sign &gt;=<span class="mi">0</span>) =&gt; &lt;=<span class="mi">0</span>
  | Real _,          Real _          =&gt; &gt;=&lt;<span class="mi">0</span>
  | _ , _                            =&gt; &gt;?&lt;<span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> mul_reality_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mul_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality)
    (<span class="nv">x</span> : {num R &amp; xnz &amp; xr}) (<span class="nv">y</span> : {num R &amp; ynz &amp; yr})
    (<span class="nv">rnz</span> := mul_nonzero_subdef xnz ynz xr yr)
    (<span class="nv">rrl</span> := mul_reality_subdef xnz ynz xr yr) :
  Signed.spec <span class="mi">0</span> rnz rrl (x%:num * y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>d1</q><br><q>d2</q><br><q>133</q><br><q>13b</q><br><span><var>rnz</var><span><span class="hyp-body"><b>:= </b><span>mul_nonzero_subdef xnz ynz xr yr</span></span><span class="hyp-type"><b>: </b><span>nullity</span></span></span></span><br><span><var>rrl</var><span><span class="hyp-body"><b>:= </b><span>mul_reality_subdef xnz ynz xr yr</span></span><span class="hyp-type"><b>: </b><span>reality</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (x%:num * y%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> rrl (x%:num * y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>15a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>143</q><span class="goal-separator"><hr></span><div class="goal-conclusion">mul_nonzero_subdef xnz ynz xr yr ==&gt;
(x%:num * y%:num != <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>143</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Signed.reality_cond <span class="mi">0</span>
  (mul_reality_subdef xnz ynz xr yr) (x%:num * y%:num)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []// x y;
     <span class="nb">rewrite</span> mulf_neq0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>143</q><span class="goal-separator"><hr></span><q>167</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []/= x y //;
   <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">rewrite</span> mulr_ge0|<span class="bp">by</span> <span class="nb">rewrite</span> mulr_le0_ge0
       |<span class="bp">by</span> <span class="nb">rewrite</span> mulr_ge0_le0|<span class="bp">by</span> <span class="nb">rewrite</span> mulr_le0|<span class="bp">by</span> <span class="nb">rewrite</span> -realE realM
       |<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom y)|<span class="bp">by</span> <span class="nb">rewrite</span> eq0 <span class="nl">?mulr0</span>// mul0r].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">mul_snum</span> (xnz ynz : nullity) (xr yr : reality)
    (x : {num R &amp; xnz &amp; xr}) (y : {num R &amp; ynz &amp; yr}) :=
  Signed.mk (mul_snum_subproof x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">natmul_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">nnz</span> : nullity) (<span class="nv">xr</span> <span class="nv">nr</span> : reality)
    (<span class="nv">x</span> : {num R &amp; xnz &amp; xr}) (<span class="nv">n</span> : {<span class="nb">compare</span> <span class="mi">0</span>%N &amp; nnz &amp; nr})
    (<span class="nv">rnz</span> := mul_nonzero_subdef xnz nnz xr nr)
    (<span class="nv">rrl</span> := mul_reality_subdef xnz nnz xr nr) :
  Signed.spec <span class="mi">0</span> rnz rrl (x%:num *+ n%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><span><var>xnz, nnz</var><span class="hyp-type"><b>: </b><span>nullity</span></span></span><br><span><var>xr, nr</var><span class="hyp-type"><b>: </b><span>reality</span></span></span><br><q>133</q><br><span><var>n</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> <span class="mi">0</span>%N &amp; nnz &amp; nr}</span></span></span><br><span><var>rnz</var><span><span class="hyp-body"><b>:= </b><span>mul_nonzero_subdef xnz nnz xr nr</span></span><span class="hyp-type"><b>: </b><span>nullity</span></span></span></span><br><span><var>rrl</var><span><span class="hyp-body"><b>:= </b><span>mul_reality_subdef xnz nnz xr nr</span></span><span class="hyp-type"><b>: </b><span>reality</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (x%:num *+ n%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> rrl (x%:num *+ n%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>16c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>16f</q><br><q>170</q><br><q>133</q><br><q>171</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul_nonzero_subdef xnz nnz xr nr ==&gt;
(x%:num *+ n%:num != <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>179</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Signed.reality_cond <span class="mi">0</span>
  (mul_reality_subdef xnz nnz xr nr)
  (x%:num *+ n%:num)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: xr nr xnz nnz x n =&gt; [[[]|]|] [[[]|]|] [] []// x n;
     <span class="nb">rewrite</span> mulrn_eq0//= <span class="nl">?eq0F</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>179</q><span class="goal-separator"><hr></span><q>17d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: xr nr xnz nnz x n =&gt; [[[]|]|] [[[]|]|] [] []/= x [[|n]//= _] //;
  <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom n)
      |<span class="bp">by</span> <span class="nb">rewrite</span> mulrn_wge0|<span class="bp">by</span> <span class="nb">rewrite</span> mulrn_wle0|<span class="bp">by</span> <span class="nb">rewrite</span> eq0 mul0rn
      |<span class="bp">by</span> <span class="nb">apply</span>: real_comparable; <span class="nb">rewrite</span> <span class="nl">?real0</span> <span class="nl">?realrMn</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">natmul_snum</span> (xnz nnz : nullity) (xr nr : reality)
    (x : {num R &amp; xnz &amp; xr}) (n : {<span class="nb">compare</span> <span class="mi">0</span>%N &amp; nnz &amp; nr}) :=
  Signed.mk (natmul_snum_subproof x n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">intmul_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">nnz</span> : nullity) (<span class="nv">xr</span> <span class="nv">nr</span> : reality)
    (<span class="nv">x</span> : {num R &amp; xnz &amp; xr}) (<span class="nv">n</span> : {num int &amp; nnz &amp; nr})
    (<span class="nv">rnz</span> := mul_nonzero_subdef xnz nnz xr nr)
    (<span class="nv">rrl</span> := mul_reality_subdef xnz nnz xr nr) :
  Signed.spec <span class="mi">0</span> rnz rrl (x%:num *~ n%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>16f</q><br><q>170</q><br><q>133</q><br><span><var>n</var><span class="hyp-type"><b>: </b><span>{num int &amp; nnz &amp; nr}</span></span></span><br><q>172</q><br><q>173</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (x%:num *~ n%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> rrl (x%:num *~ n%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>182</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>16f</q><br><q>170</q><br><q>133</q><br><q>185</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul_nonzero_subdef xnz nnz xr nr ==&gt;
(x%:num *~ n%:num != <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>18b</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Signed.reality_cond <span class="mi">0</span>
  (mul_reality_subdef xnz nnz xr nr)
  (x%:num *~ n%:num)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: xr nr xnz nnz x n =&gt; [[[]|]|] [[[]|]|] [] []// x n;
     <span class="nb">rewrite</span> mulrz_neq0//= <span class="nl">?neq0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>18b</q><span class="goal-separator"><hr></span><q>18f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: xr nr xnz nnz x n =&gt; [[[]|]|] [[[]|]|] [] []/= x n //;
  <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom n)
      |<span class="bp">by</span> <span class="nb">rewrite</span> mulrz_ge0|<span class="bp">by</span> <span class="nb">rewrite</span> mulrz_le0_ge0|<span class="bp">by</span> <span class="nb">rewrite</span> eq0 mul0rz
      |<span class="bp">by</span> <span class="nb">rewrite</span> mulrz_ge0_le0|<span class="bp">by</span> <span class="nb">rewrite</span> mulrz_le0|<span class="bp">by</span> <span class="nb">rewrite</span> eq0 mulr0z
      |<span class="bp">by</span> <span class="nb">rewrite</span> -realE rpredMz//; <span class="nb">apply</span>: cmp0].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">intmul_snum</span> (xnz nnz : nullity) (xr nr : reality)
    (x : {num R &amp; xnz &amp; xr}) (n : {num int &amp; nnz &amp; nr}) :=
  Signed.mk (intmul_snum_subproof x n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">inv_snum_subproof</span> (<span class="nv">xnz</span> : nullity) (<span class="nv">xr</span> : reality)
    (<span class="nv">x</span> : {num R &amp; xnz &amp; xr}) :
  Signed.spec <span class="mi">0</span> xnz xr (x%:num^-<span class="mi">1</span> : R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>131</q><br><q>132</q><br><q>133</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(xnz ==&gt; ((x%:num^-<span class="mi">1</span> : R) != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> xr (x%:num^-<span class="mi">1</span> : R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>194</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: xr x =&gt; [[[]|]|]//= [r]/=;
   <span class="nb">rewrite</span> invr_eq0 ?(invr_ge0, invr_le0) <span class="nl">?realV</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">inv_snum</span> (xnz : nullity) (xr : reality) (x : {num R &amp; xnz &amp; xr}) :=
  Signed.mk (inv_snum_subproof x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">exprn_nonzero_subdef</span> (<span class="nv">xnz</span> <span class="nv">nnz</span> : nullity)
    (<span class="nv">xr</span> <span class="nv">nr</span> : reality) : nullity :=
  nz_of_bool (xnz || <span class="kr">match</span> nr <span class="kr">with</span> Real (Sign =<span class="mi">0</span>) =&gt; true | _ =&gt; false <span class="kr">end</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> exprn_nonzero_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">exprn_reality_subdef</span> (<span class="nv">xnz</span> <span class="nv">nnz</span> : nullity)
    (<span class="nv">xr</span> <span class="nv">nr</span> : reality) : reality :=
  <span class="kr">match</span> xr, nr <span class="kr">with</span>
  | _, Real (Sign =<span class="mi">0</span>) =&gt; &gt;=<span class="mi">0</span>
  | Real (Sign =<span class="mi">0</span>), _ =&gt; (<span class="kr">if</span> nnz <span class="kr">then</span> =<span class="mi">0</span> <span class="kr">else</span> &gt;=<span class="mi">0</span>)%snum_sign
  | Real (Sign &gt;=<span class="mi">0</span>), _ =&gt; &gt;=<span class="mi">0</span>
  | Real _, _ =&gt; &gt;=&lt;<span class="mi">0</span>
  | _, _ =&gt; &gt;?&lt;<span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> exprn_reality_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">exprn_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">nnz</span> : nullity) (<span class="nv">xr</span> <span class="nv">nr</span> : reality)
    (<span class="nv">x</span> : {num R &amp; xnz &amp; xr}) (<span class="nv">n</span> : {<span class="nb">compare</span> <span class="mi">0</span>%N &amp; nnz &amp; nr})
    (<span class="nv">rnz</span> := exprn_nonzero_subdef xnz nnz xr nr)
    (<span class="nv">rrl</span> := exprn_reality_subdef xnz nnz xr nr) :
  Signed.spec <span class="mi">0</span> rnz rrl (x%:num ^+ n%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>16f</q><br><q>170</q><br><q>133</q><br><q>171</q><br><span><var>rnz</var><span><span class="hyp-body"><b>:= </b><span>exprn_nonzero_subdef xnz nnz xr nr</span></span><span class="hyp-type"><b>: </b><span>nullity</span></span></span></span><br><span><var>rrl</var><span><span class="hyp-body"><b>:= </b><span>exprn_reality_subdef xnz nnz xr nr</span></span><span class="hyp-type"><b>: </b><span>reality</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (x%:num ^+ n%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> rrl (x%:num ^+ n%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>19a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>179</q><span class="goal-separator"><hr></span><div class="goal-conclusion">exprn_nonzero_subdef xnz nnz xr nr ==&gt;
(x%:num ^+ n%:num != <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>179</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Signed.reality_cond <span class="mi">0</span>
  (exprn_reality_subdef xnz nnz xr nr)
  (x%:num ^+ n%:num)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: xr nr xnz nnz x n =&gt; [[[]|]|] [[[]|]|] [] []// x n;
    <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom n)];
    <span class="nb">rewrite</span> expf_eq0/= <span class="nl">?eq0</span>// <span class="nl">?eq0F</span> <span class="nl">?andbF</span>//.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>179</q><span class="goal-separator"><hr></span><q>1a7</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: xr nr xnz nnz x n =&gt; [[[]|]|] [[[]|]|] [] []/= x [[|n]//= _] //;
  <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom n)|<span class="bp">by</span> <span class="nb">rewrite</span> [_ || _]realX
      |<span class="bp">by</span> <span class="nb">rewrite</span> eq0 expr0n|<span class="bp">exact</span>: exprn_ge0|<span class="bp">by</span> <span class="nb">rewrite</span> expr0 ler01].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">exprn_snum</span> (xnz nnz : nullity) (xr nr : reality)
    (x : {num R &amp; xnz &amp; xr}) (n : {<span class="nb">compare</span> <span class="mi">0</span>%N &amp; nnz &amp; nr}) :=
  Signed.mk (exprn_snum_subproof x n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">norm_snum_subproof</span> {<span class="nv">V</span> : normedZmodType R} (<span class="nv">x</span> : V) :
  Signed.spec <span class="mi">0</span> ?=<span class="mi">0</span> &gt;=<span class="mi">0</span> `|x|.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><span><var>V</var><span class="hyp-type"><b>: </b><span>normedZmodType R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(?=<span class="mi">0</span>%snum_nullity ==&gt; (`|x| != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> &gt;=<span class="mi">0</span> `|x|</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1ac</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /=.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">norm_snum</span> {V : normedZmodType R} (x : V) :=
  Signed.mk (norm_snum_subproof x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">NumDomainStability</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">RcfStability</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : rcfType}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sqrt_nonzero_subdef</span> (<span class="nv">xnz</span> : nullity) (<span class="nv">xr</span> : reality) :=
  <span class="kr">if</span> xr <span class="kr">is</span> Real (Sign &gt;=<span class="mi">0</span>) <span class="kr">then</span> xnz <span class="kr">else</span> MaybeZero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> sqrt_nonzero_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sqrt_snum_subproof</span> <span class="nv">xnz</span> <span class="nv">xr</span> (<span class="nv">x</span> : {num R &amp; xnz &amp; xr})
    (<span class="nv">nz</span> := sqrt_nonzero_subdef xnz xr) :
  Signed.spec <span class="mi">0</span> nz &gt;=<span class="mi">0</span> (Num.sqrt x%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>rcfType</span></span></span><br><q>131</q><br><q>132</q><br><q>133</q><br><span><var>nz</var><span><span class="hyp-body"><b>:= </b><span>sqrt_nonzero_subdef xnz xr</span></span><span class="hyp-type"><b>: </b><span>nullity</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(nz ==&gt; (Num.sqrt x%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> &gt;=<span class="mi">0</span> (Num.sqrt x%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1b4</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> {}/nz; <span class="nb">case</span>: xnz xr x =&gt; -[[[]|]|]//= x;
   <span class="nb">rewrite</span> /= sqrtr_ge0// andbT sqrtr_eq0 le0F.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">sqrt_snum</span> xnz xr (x : {num R &amp; xnz &amp; xr}) :=
  Signed.mk (sqrt_snum_subproof x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">RcfStability</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">NumClosedStability</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : numClosedFieldType}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sqrtC_reality_subdef</span> (<span class="nv">xnz</span> : nullity) (<span class="nv">xr</span> : reality) : reality :=
  <span class="kr">match</span> xr <span class="kr">with</span>
  | Real (Sign =<span class="mi">0</span>) =&gt; =<span class="mi">0</span>
  | Real (Sign &gt;=<span class="mi">0</span>) =&gt; &gt;=<span class="mi">0</span>
  | _ =&gt; &gt;?&lt;<span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> sqrtC_reality_subdef /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sqrtC_snum_subproof</span> <span class="nv">xnz</span> <span class="nv">xr</span> (<span class="nv">x</span> : {num R &amp; xnz &amp; xr})
    (<span class="nv">r</span> := sqrtC_reality_subdef xnz xr) :
  Signed.spec <span class="mi">0</span> xnz r (sqrtC x%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>numClosedFieldType</span></span></span><br><q>131</q><br><q>132</q><br><q>133</q><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>sqrtC_reality_subdef xnz xr</span></span><span class="hyp-type"><b>: </b><span>reality</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(xnz ==&gt; (sqrtC x%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> r (sqrtC x%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1bc</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}/r; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1bf</q><br><q>131</q><br><q>132</q><br><q>133</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xnz ==&gt; (sqrtC x%:num != <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>1c6</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Signed.reality_cond <span class="mi">0</span> (sqrtC_reality_subdef xnz xr)
  (sqrtC x%:num)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> sqrtC_eq0; <span class="nb">case</span>: xr xnz x =&gt; [[[]|]|] [] /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1c6</q><span class="goal-separator"><hr></span><q>1ca</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: xr xnz x =&gt; [[[]|]|] []//= x; <span class="nb">rewrite</span> <span class="nl">?sqrtC_ge0</span>// sqrtC_eq0 eq0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">sqrtC_snum</span> xnz xr (x : {num R &amp; xnz &amp; xr}) :=
  Signed.mk (sqrtC_snum_subproof x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">NumClosedStability</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">NatStability</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Type</span> (n : nat).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">nat_snum_subproof</span> <span class="nv">n</span> : Signed.spec <span class="mi">0</span> ?=<span class="mi">0</span> &gt;=<span class="mi">0</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(?=<span class="mi">0</span>%snum_nullity ==&gt; (n != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> &gt;=<span class="mi">0</span> n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1cf</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">nat_snum</span> n := Signed.mk (nat_snum_subproof n).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Ignoring canonical projection to _ <span class="bp">by</span> Signed.r <span class="kr">in</span>
nat_snum: redundant <span class="kr">with</span> typ_snum
[redundant-canonical-projection,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">zeron_snum_subproof</span> : Signed.spec <span class="mi">0</span> ?=<span class="mi">0</span> =<span class="mi">0</span> <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(?=<span class="mi">0</span>%snum_nullity ==&gt; (<span class="mi">0</span> != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> =<span class="mi">0</span> <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1d7</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">zeron_snum</span> := Signed.mk zeron_snum_subproof.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">succn_snum_subproof</span> <span class="nv">n</span> : Signed.spec <span class="mi">0</span> !=<span class="mi">0</span> &gt;=<span class="mi">0</span> n.+<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1d1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(!=<span class="mi">0</span>%snum_nullity ==&gt; (n.+<span class="mi">1</span> != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> &gt;=<span class="mi">0</span> n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1dc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">succn_snum</span> n := Signed.mk (succn_snum_subproof n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">double_snum_subproof</span> <span class="nv">nz</span> <span class="nv">r</span> (<span class="nv">x</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; nz &amp; r}) :
  Signed.spec <span class="mi">0</span> nz r x%:num.*<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c</q><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reality</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> <span class="mi">0</span> &amp; nz &amp; r}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(nz ==&gt; ((x%:num).*<span class="mi">2</span> != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> r (x%:num).*<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1e1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span>  <span class="nb">move</span>: nz r x =&gt; [] [[[]|]|] [[|n]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">double_snum</span> nz r x :=
  Signed.mk (@double_snum_subproof nz r x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">addn_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality)
    (<span class="nv">x</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (<span class="nv">y</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; ynz &amp; yr})
    (<span class="nv">rnz</span> := add_nonzero_subdef xnz ynz xr yr)
    (<span class="nv">rrl</span> := add_reality_subdef xnz ynz xr yr) :
  Signed.spec <span class="mi">0</span> rnz rrl (x%:num + y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d1</q><br><q>d2</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> <span class="mi">0</span> &amp; ynz &amp; yr}</span></span></span><br><q>13c</q><br><q>13d</q><br></div><span class="goal-separator"><hr></span><q>13e</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1e9</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>;
<span class="bp">by</span> <span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//= [[|x]//= _] [[|y]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">addn_snum</span> (xnz ynz : nullity) (xr yr : reality)
    (x : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (y : {<span class="nb">compare</span> <span class="mi">0</span> &amp; ynz &amp; yr}) :=
  Signed.mk (addn_snum_subproof x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">muln_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality)
    (<span class="nv">x</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (<span class="nv">y</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; ynz &amp; yr})
    (<span class="nv">rnz</span> := mul_nonzero_subdef xnz ynz xr yr)
    (<span class="nv">rrl</span> := mul_reality_subdef xnz ynz xr yr) :
  Signed.spec <span class="mi">0</span> rnz rrl (x%:num * y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d1</q><br><q>d2</q><br><q>1ec</q><br><q>1ed</q><br><q>15d</q><br><q>15e</q><br></div><span class="goal-separator"><hr></span><q>15f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1f0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>;
<span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//=;
<span class="bp">by</span> <span class="nb">move</span>=&gt; [[|x]//= _] [[|y]//= _]; <span class="nb">rewrite</span> muln0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">muln_snum</span> (xnz ynz : nullity) (xr yr : reality)
    (x : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (y : {<span class="nb">compare</span> <span class="mi">0</span> &amp; ynz &amp; yr}) :=
  Signed.mk (muln_snum_subproof x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">expn_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">nnz</span> : nullity) (<span class="nv">xr</span> <span class="nv">nr</span> : reality)
    (<span class="nv">x</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (<span class="nv">n</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; nnz &amp; nr})
    (<span class="nv">rnz</span> := exprn_nonzero_subdef xnz nnz xr nr)
    (<span class="nv">rrl</span> := exprn_reality_subdef xnz nnz xr nr) :
  Signed.spec <span class="mi">0</span> rnz rrl (x%:num ^ n%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>16f</q><br><q>170</q><br><q>1ec</q><br><span><var>n</var><span class="hyp-type"><b>: </b><span>{<span class="nb">compare</span> <span class="mi">0</span> &amp; nnz &amp; nr}</span></span></span><br><q>19d</q><br><q>19e</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (x%:num ^ n%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> rrl (x%:num ^ n%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1f5</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>16f</q><br><q>170</q><br><q>1ec</q><br><q>1f8</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exprn_nonzero_subdef xnz nnz xr nr ==&gt;
(x%:num ^ n%:num != <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>1fe</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Signed.reality_cond <span class="mi">0</span>
  (exprn_reality_subdef xnz nnz xr nr)
  (x%:num ^ n%:num)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: xr nr xnz nnz x n =&gt; [[[]|]|] [[[]|]|] [] []// x n;
    <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom n)
        |<span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?eq0</span> <span class="nl">?expn0</span>// expn_eq0 <span class="nl">?eq0F</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1fe</q><span class="goal-separator"><hr></span><q>202</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: xr nr xnz nnz x n =&gt; [[[]|]|] [[[]|]|] [] []/= x [[|n]//= _] //;
  <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">case</span>: (bottom x)|<span class="bp">by</span> <span class="nb">case</span>: (bottom n)|<span class="bp">by</span> <span class="nb">rewrite</span> eq0 exp0n].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">expn_snum</span> (xnz nnz : nullity) (xr nr : reality)
    (x : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (n : {<span class="nb">compare</span> <span class="mi">0</span> &amp; nnz &amp; nr}) :=
  Signed.mk (expn_snum_subproof x n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">minn_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality)
    (<span class="nv">x</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (<span class="nv">y</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; ynz &amp; yr})
    (<span class="nv">rnz</span> := min_nonzero_subdef xnz ynz xr yr)
    (<span class="nv">rrl</span> := min_reality_subdef xnz ynz xr yr) :
  Signed.spec <span class="mi">0</span> rnz rrl (min x%:num y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d1</q><br><q>d2</q><br><q>1ec</q><br><q>1ed</q><br><q>d5</q><br><q>d6</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (Nat.min x%:num y%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> rrl (Nat.min x%:num y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>207</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>;
<span class="bp">by</span> <span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//= [[|x]//= _] [[|y]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">minn_snum</span> (xnz ynz : nullity) (xr yr : reality)
    (x : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (y : {<span class="nb">compare</span> <span class="mi">0</span> &amp; ynz &amp; yr}) :=
  Signed.mk (minn_snum_subproof x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">maxn_snum_subproof</span> (<span class="nv">xnz</span> <span class="nv">ynz</span> : nullity) (<span class="nv">xr</span> <span class="nv">yr</span> : reality)
    (<span class="nv">x</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (<span class="nv">y</span> : {<span class="nb">compare</span> <span class="mi">0</span> &amp; ynz &amp; yr})
    (<span class="nv">rnz</span> := max_nonzero_subdef xnz ynz xr yr)
    (<span class="nv">rrl</span> := max_reality_subdef xnz ynz xr yr) :
  Signed.spec <span class="mi">0</span> rnz rrl (maxn x%:num y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d1</q><br><q>d2</q><br><q>1ec</q><br><q>1ed</q><br><q>fe</q><br><q>ff</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rnz ==&gt; (maxn x%:num y%:num != <span class="mi">0</span>)) &amp;&amp;
Signed.reality_cond <span class="mi">0</span> rrl (maxn x%:num y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>20d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> {}/rnz {}/rrl; <span class="nb">apply</span>/andP; <span class="nb">split</span>;
<span class="nb">move</span>: xr yr xnz ynz x y =&gt; [[[]|]|] [[[]|]|] [] []//=;
<span class="bp">by</span> <span class="nb">move</span>=&gt; [[|x]//= _] [[|y]//= _]; <span class="nb">rewrite</span> maxnSS.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">maxn_snum</span> (xnz ynz : nullity) (xr yr : reality)
    (x : {<span class="nb">compare</span> <span class="mi">0</span> &amp; xnz &amp; xr}) (y : {<span class="nb">compare</span> <span class="mi">0</span> &amp; ynz &amp; yr}) :=
  Signed.mk (maxn_snum_subproof x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">End</span> <span class="nf">NatStability</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Ignoring canonical projection to _ <span class="bp">by</span> Signed.r <span class="kr">in</span>
nat_snum: redundant <span class="kr">with</span> typ_snum
[redundant-canonical-projection,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Morph0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">cond</span> : reality}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">nR</span> := {num R &amp; ?=<span class="mi">0</span> &amp; cond}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> : nR.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">num</span> := (@num _ _ (<span class="mi">0</span> : R) ?=<span class="mi">0</span> cond).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_eq0</span> <span class="nv">x</span> : (x%:num == <span class="mi">0</span>) = (x == (widen_signed <span class="mi">0</span>%:sgn : nR)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>2d</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{num R &amp; ?=<span class="mi">0</span> &amp; cond}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x%:num == <span class="mi">0</span>) =
(x == (widen_signed <span class="mi">0</span>%:sgn : {num R &amp; ?=<span class="mi">0</span> &amp; cond}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>214</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Morph0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Morph</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">d</span> : unit} {<span class="nv">T</span> : porderType d} {<span class="nv">x0</span> : T} {<span class="nv">nz</span> : nullity} {<span class="nv">cond</span> : reality}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">sT</span> := {<span class="nb">compare</span> x0 &amp; nz &amp; cond}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> : sT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">num</span> := (@num _ _ x0 nz cond).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_eq</span> : {mono num : x y / x == y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>e</q><br><q>f</q><br><q>43</q><br><q>2c</q><br><q>2d</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{mono num : x y / x == y &gt;-&gt; x == y}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>21b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_le</span> : {mono num : x y / (x &lt;= y)%O}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>21d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{mono num : x y / (x &lt;= y)%O &gt;-&gt; (x &lt;= y)%O}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>221</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_lt</span> : {mono num : x y / (x &lt; y)%O}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>21d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{mono num : x y / (x &lt; y)%O &gt;-&gt; (x &lt; y)%O}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>226</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_min</span> : {morph num : x y / Order.min x y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>21d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph num : x y / Order.min x y &gt;-&gt; Order.min x y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>22b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x y; <span class="nb">rewrite</span> !minEle num_le -fun_if.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_max</span> : {morph num : x y / Order.max x y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>21d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph num : x y / Order.max x y &gt;-&gt; Order.max x y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>230</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x y; <span class="nb">rewrite</span> !maxEle num_le -fun_if.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Morph</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">MorphNum</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">nz</span> : nullity} {<span class="nv">cond</span> : reality}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">nR</span> := {num R &amp; nz &amp; cond}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">a</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : nR).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">num</span> := (@num _ _ (<span class="mi">0</span> : R) nz cond).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_abs_eq0</span> <span class="nv">a</span> : (`|a|%:nng == <span class="mi">0</span>%:nng) = (a == <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>2c</q><br><q>2d</q><br><span><var>a</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(`|a|%:nng == <span class="mi">0</span>%:nng :&gt; {nonneg R}) = (a == <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>235</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -normr_eq0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">MorphNum</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">MorphReal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">nz</span> : nullity} {<span class="nv">r</span> : real}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">nR</span> := {num R &amp; nz &amp; r}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Type</span> <span class="nf">x</span> y : nR.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">num</span> := (@num _ _ (<span class="mi">0</span> : R) nz r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_le_maxr</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">y</span> :
  a &lt;= Num.max x%:num y%:num = (a &lt;= x%:num) || (a &lt;= y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>2c</q><br><q>c8</q><br><q>238</q><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>{num R &amp; nz &amp; r}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a &lt;= Num.max x%:num y%:num) =
(a &lt;= x%:num) || (a &lt;= y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>23c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -comparable_le_maxr// real_comparable.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_le_maxl</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">y</span> :
  Num.max x%:num  y%:num &lt;= a = (x%:num &lt;= a) &amp;&amp; (y%:num &lt;= a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(Num.max x%:num y%:num &lt;= a) =
(x%:num &lt;= a) &amp;&amp; (y%:num &lt;= a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>243</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -comparable_le_maxl// real_comparable.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_le_minr</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">y</span> :
  a &lt;= Num.min x%:num y%:num = (a &lt;= x%:num) &amp;&amp; (a &lt;= y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(a &lt;= Num.min x%:num y%:num) =
(a &lt;= x%:num) &amp;&amp; (a &lt;= y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>248</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -comparable_le_minr// real_comparable.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_le_minl</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">y</span> :
  Num.min x%:num y%:num &lt;= a = (x%:num &lt;= a) || (y%:num &lt;= a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(Num.min x%:num y%:num &lt;= a) =
(x%:num &lt;= a) || (y%:num &lt;= a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>24d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -comparable_le_minl// real_comparable.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_lt_maxr</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">y</span> :
  a &lt; Num.max x%:num y%:num = (a &lt; x%:num) || (a &lt; y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(a &lt; Num.max x%:num y%:num) =
(a &lt; x%:num) || (a &lt; y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>252</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -comparable_lt_maxr// real_comparable.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_lt_maxl</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">y</span> :
  Num.max x%:num  y%:num &lt; a = (x%:num &lt; a) &amp;&amp; (y%:num &lt; a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(Num.max x%:num y%:num &lt; a) =
(x%:num &lt; a) &amp;&amp; (y%:num &lt; a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>257</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -comparable_lt_maxl// real_comparable.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_lt_minr</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">y</span> :
  a &lt; Num.min x%:num y%:num = (a &lt; x%:num) &amp;&amp; (a &lt; y%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(a &lt; Num.min x%:num y%:num) =
(a &lt; x%:num) &amp;&amp; (a &lt; y%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>25c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -comparable_lt_minr// real_comparable.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_lt_minl</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">y</span> :
  Num.min x%:num y%:num &lt; a = (x%:num &lt; a) || (y%:num &lt; a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(Num.min x%:num y%:num &lt; a) =
(x%:num &lt; a) || (y%:num &lt; a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>261</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -comparable_lt_minl// real_comparable.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">MorphReal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">MorphGe0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">nz</span> : nullity}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">nR</span> := {num R &amp; ?=<span class="mi">0</span> &amp; &gt;=<span class="mi">0</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Type</span> <span class="nf">x</span> y : nR.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">num</span> := (@num _ _ (<span class="mi">0</span> : R) ?=<span class="mi">0</span> &gt;=<span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_abs_le</span> <span class="nv">a</span> <span class="nv">x</span> : <span class="mi">0</span> &lt;= a -&gt; (`|a|%:nng &lt;= x) = (a &lt;= x%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>2c</q><br><q>238</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{num R &amp; ?=<span class="mi">0</span> &amp; &gt;=<span class="mi">0</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= a -&gt;
((`|a|%:nng : {nonneg R}) &lt;= x) = (a &lt;= x%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>266</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; a0; <span class="nb">rewrite</span> -num_le//= ger0_norm.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">num_abs_lt</span> <span class="nv">a</span> <span class="nv">x</span> : <span class="mi">0</span> &lt;= a -&gt; (`|a|%:nng &lt; x) = (a &lt; x%:num).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>268</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= a -&gt;
((`|a|%:nng : {nonneg R}) &lt; x) = (a &lt; x%:num)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>26d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; a0; <span class="nb">rewrite</span> -num_lt/= ger0_norm.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">MorphGe0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Posnum</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">x</span> : R) (<span class="nv">x_gt0</span> : <span class="mi">0</span> &lt; x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">posnum_subdef</span> : (x != <span class="mi">0</span>) &amp;&amp; (<span class="mi">0</span> &lt;= x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>18</q><br><span><var>x_gt0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x != <span class="mi">0</span>) &amp;&amp; (<span class="mi">0</span> &lt;= x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>272</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -lt_def.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PosNum</span> : {posnum R} := @Signed.mk _ _ <span class="mi">0</span> !=<span class="mi">0</span> &gt;=<span class="mi">0</span> _ posnum_subdef.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Posnum</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">NngNum</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">x</span> : R) (<span class="nv">x_ge0</span> : <span class="mi">0</span> &lt;= x) : {nonneg R} :=
  (@Signed.mk _ _ <span class="mi">0</span> ?=<span class="mi">0</span> &gt;=<span class="mi">0</span> x x_ge0).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">posnum_spec</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">x</span> : R) :
  R -&gt; bool -&gt; bool -&gt; bool -&gt; <span class="kt">Type</span> :=
| IsPosnum (p : {posnum R}) : posnum_spec x (p%:num) false true true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">posnumP</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">x</span> : R) : <span class="mi">0</span> &lt; x -&gt;
  posnum_spec x x (x == <span class="mi">0</span>) (<span class="mi">0</span> &lt;= x) (<span class="mi">0</span> &lt; x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>18</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; x -&gt; posnum_spec x x (x == <span class="mi">0</span>) (<span class="mi">0</span> &lt;= x) (<span class="mi">0</span> &lt; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>279</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; x_gt0; <span class="nb">case</span>: real_ltgt0P (x_gt0) =&gt; []; <span class="nb">rewrite</span> <span class="nl">?gtr0_real</span> // =&gt; _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>274</q><span class="goal-separator"><hr></span><div class="goal-conclusion">posnum_spec x x false true true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -[x]/(PosNum x_gt0)%:num; <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">nonneg_spec</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">x</span> : R) : R -&gt; bool -&gt; <span class="kt">Type</span> :=
| IsNonneg (p : {nonneg R}) : nonneg_spec x (p%:num) true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">nonnegP</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">x</span> : R) : <span class="mi">0</span> &lt;= x -&gt; nonneg_spec x x (<span class="mi">0</span> &lt;= x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>27b</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= x -&gt; nonneg_spec x x (<span class="mi">0</span> &lt;= x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>283</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; xge0; <span class="nb">rewrite</span> xge0 -[x]/(NngNum xge0)%:num; <span class="nb">constructor</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Section PosnumOrder. *)</span>
<span class="c">(* Variables (R : numDomainType). *)</span>
<span class="c">(* Local Notation nR := {posnum R}. *)</span>

<span class="c">(* Lemma posnum_le_total : totalPOrderMixin [porderType of nR]. *)</span>
<span class="c">(* Proof. by move=&gt; x y; apply: real_comparable. Qed. *)</span>

<span class="c">(* Canonical posnum_latticeType := LatticeType nR posnum_le_total. *)</span>
<span class="c">(* Canonical posnum_distrLatticeType := DistrLatticeType nR posnum_le_total. *)</span>
<span class="c">(* Canonical posnum_orderType := OrderType nR posnum_le_total. *)</span>

<span class="c">(* End PosnumOrder. *)</span>

<span class="c">(* Section NonnegOrder. *)</span>
<span class="c">(* Variables (R : numDomainType). *)</span>
<span class="c">(* Local Notation nR := {nonneg R}. *)</span>

<span class="c">(* Lemma nonneg_le_total : totalPOrderMixin [porderType of nR]. *)</span>
<span class="c">(* Proof. by move=&gt; x y; apply: real_comparable. Qed. *)</span>

<span class="c">(* Canonical nonneg_latticeType := LatticeType nR nonneg_le_total. *)</span>
<span class="c">(* Canonical nonneg_distrLatticeType := DistrLatticeType nR nonneg_le_total. *)</span>
<span class="c">(* Canonical nonneg_orderType := OrderType nR nonneg_le_total. *)</span>

<span class="c">(* End NonnegOrder. *)</span>

<span class="c">(* These proofs help integrate more arithmetic with signed.v. The issue is    *)</span>
<span class="c">(* Terms like `0 &lt; 1-q` with subtraction don&#39;t work well. So we hide the      *)</span>
<span class="c">(* subtractions behind `PosNum` and `NngNum` constructors, see sequences.v    *)</span>
<span class="c">(* for examples.                                                              *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">onem_signed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">R</span> : numDomainType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> <span class="nv">r</span> : R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">onem_PosNum</span> <span class="nv">r</span> (<span class="nv">r1</span> : r &lt; <span class="mi">1</span>) : `<span class="mi">1</span>-r = (PosNum (onem_gt0 r1))%:num.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>r &lt; <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`<span class="mi">1</span>-r = (PosNum (onem_gt0 r1))%:num</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>288</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">onemX_NngNum</span> <span class="nv">r</span> (<span class="nv">r1</span> : r &lt;= <span class="mi">1</span>) (<span class="nv">r0</span> : <span class="mi">0</span> &lt;= r) <span class="nv">n</span> :
  `<span class="mi">1</span>-(r ^+ n) = (NngNum (onemX_ge0 n r0 r1))%:num.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>c7</q><br><q>28b</q><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>r &lt;= <span class="mi">1</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= r</span></span></span><br><q>1d2</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`<span class="mi">1</span>-(r ^+ n) = (NngNum (onemX_ge0 n r0 r1))%:num</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>290</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">onem_signed</span>.</span></span></pre></article></body></html>