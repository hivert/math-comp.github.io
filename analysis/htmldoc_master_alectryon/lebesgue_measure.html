<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>lebesgue_measure.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect ssralg ssrnum ssrint interval.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predI _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predU _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predD _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predC _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ preim _ of _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closedM;
                   GRing.smulr_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedM; GRing.smulr_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed.
New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.sdivr_closed_div;
                   GRing.divr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.sdivr_closedM; GRing.smulr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subalg_closedBM;
                   GRing.subring_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subalg_closedZ; GRing.submod_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divring_closed_div;
                   GRing.sdivr_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divring_closedBM; GRing.subring_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divalg_closedBdiv;
                   GRing.divring_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divalg_closedZ; GRing.subalg_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.Pred.subring_smul;
                   GRing.Pred.smul_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.Pred.subring_semi; GRing.Pred.semiring_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> finmap fingroup perm rat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> boolp classical_sets functions.
<span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> cardinality fsbigop mathcomp_extra.
<span class="kn">Require Import</span> reals ereal signed topology numfun normedtype.
<span class="kn">From</span> HB <span class="kn">Require Import</span> structures.
<span class="kn">Require Import</span> sequences esum <span class="kn">measure</span> real_interval realfun.

<span class="sd">(******************************************************************************)</span>
<span class="c">(*                            Lebesgue Measure                                *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* This file contains a formalization of the Lebesgue measure using the       *)</span>
<span class="c">(* Caratheodory&#39;s theorem available in measure.v and further develops the     *)</span>
<span class="c">(* theory of measurable functions.                                            *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* Main reference:                                                            *)</span>
<span class="c">(* - Daniel Li, Int√©gration et applications, 2016                             *)</span>
<span class="c">(* - Achim Klenke, Probability Theory 2nd edition, 2014                       *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*             hlength A == length of the hull of the set of real numbers A   *)</span>
<span class="c">(*                 ocitv == set of open-closed intervals ]x, y] where         *)</span>
<span class="c">(*                            x and y are real numbers                        *)</span>
<span class="c">(*      lebesgue_measure == the Lebesgue measure                              *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*              ps_infty == inductive definition of the powerset              *)</span>
<span class="c">(*                          {0, {-oo}, {+oo}, {-oo,+oo}}                      *)</span>
<span class="c">(*         emeasurable G == sigma-algebra over \bar R built out of the        *)</span>
<span class="c">(*                          measurables G of a sigma-algebra over R           *)</span>
<span class="c">(*     elebesgue_measure == the Lebesgue measure extended to \bar R           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* The modules RGenOInfty, RGenInftyO, RGenCInfty, RGenOpens provide proofs   *)</span>
<span class="c">(* of equivalence between the sigma-algebra generated by list of intervals    *)</span>
<span class="c">(* and the sigma-algebras generated by open rays, closed rays, and open       *)</span>
<span class="c">(* intervals.                                                                 *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* The modules ErealGenOInfty, ErealGenCInfty, ErealGenInftyO provide proofs  *)</span>
<span class="c">(* of equivalence between emeasurable and the sigma-algebras generated open   *)</span>
<span class="c">(* rays and closed rays.                                                      *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="kn">Set Implicit Arguments</span>.
<span class="kn">Unset Strict Implicit</span>.
<span class="kn">Unset Printing Implicit Defensive</span>.
<span class="kn">Import</span> Order.TTheory GRing.Theory Num.Def Num.Theory.
<span class="kn">Import</span> numFieldTopology.Exports.

<span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.

<span class="kn">Reserved Notation</span> <span class="s2">&quot;R .-ocitv&quot;</span> (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">format</span> <span class="s2">&quot;R .-ocitv&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;R .-ocitv.-measurable&quot;</span>
 (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;R .-ocitv.-measurable&quot;</span>).

<span class="kn">Section</span> <span class="nf">hlength</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> <span class="nv">i</span> <span class="nv">j</span> : interval R.

<span class="kn">Definition</span> <span class="nf">hlength</span> (<span class="nv">A</span> : <span class="nb">set</span> R) : \bar R := <span class="kr">let</span> <span class="nv">i</span> := Rhull A <span class="kr">in</span> i.<span class="mi">2</span> - i.<span class="mi">1</span>.

<span class="kn">Lemma</span> <span class="nf">hlength0</span> : hlength (set0 : <span class="nb">set</span> R) = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /hlength Rhull0 /= subee. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hlength_singleton</span> (<span class="nv">r</span> : R) : hlength `[r, r] = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /hlength /= asboolT// sup_itvcc//= asboolT//.
<span class="bp">by</span> <span class="nb">rewrite</span> asboolT inf_itvcc//= <span class="nl">?subee</span>// inE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hlength_setT</span> : hlength setT = +oo%E :&gt; \bar R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /hlength RhullT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hlength_itv</span> <span class="nv">i</span> : hlength [<span class="nb">set</span>` i] = <span class="kr">if</span> i.<span class="mi">2</span> &gt; i.<span class="mi">1</span> <span class="kr">then</span> i.<span class="mi">2</span> - i.<span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">case</span>: ltP =&gt; [/lt_ereal_bnd/neitvP i12|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /hlength set_itvK.
<span class="nb">rewrite</span> le_eqVlt =&gt; /orP[|/lt_ereal_bnd i12]; <span class="nb">last first</span>.
  <span class="nb">rewrite</span> (_ : [<span class="nb">set</span>` i] = set0) <span class="nl">?hlength0</span>//.
  <span class="bp">by</span> <span class="nb">apply</span>/eqP/negPn; <span class="nb">rewrite</span> -/(neitv _) neitvE -leNgt (ltW i12).
<span class="nb">case</span>: i =&gt; -[ba a|[|]] [bb b|[|]] //=.
- <span class="nb">rewrite</span> /= =&gt; /eqP[-&gt;{b}]; <span class="nb">move</span>: ba bb =&gt; -[] []; <span class="kp">try</span>
    <span class="bp">by</span> <span class="nb">rewrite</span> set_itvE hlength0.
  <span class="bp">by</span> <span class="nb">rewrite</span> hlength_singleton.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> set_itvE hlength0.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> set_itvE hlength0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hlength_finite_fin_num</span> <span class="nv">i</span> : neitv i -&gt; hlength [<span class="nb">set</span>` i] &lt; +oo -&gt;
  ((i.<span class="mi">1</span> : \bar R) \<span class="kr">is</span> a fin_num) /\ ((i.<span class="mi">2</span> : \bar R) \<span class="kr">is</span> a fin_num).
<span class="kn">Proof</span>.
<span class="nb">move</span>: i =&gt; [[ba a|[]] [bb b|[]]] /neitvP //=; <span class="kp">do</span> <span class="nl">?by</span> <span class="nb">rewrite</span> <span class="nl">?set_itvE</span> <span class="nl">?eqxx</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> hlength_itv /= ltry.
<span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> hlength_itv /= ltNyr.
<span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> hlength_itv.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">finite_hlengthE</span> <span class="nv">i</span> : neitv i -&gt; hlength [<span class="nb">set</span>` i] &lt; +oo -&gt;
  hlength [<span class="nb">set</span>` i] = (fine i.<span class="mi">2</span>)%:E - (fine i.<span class="mi">1</span>)%:E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; i0 ioo; <span class="nb">have</span> [ri1 ri2] := hlength_finite_fin_num i0 ioo.
<span class="nb">rewrite</span> !fineK// hlength_itv; <span class="nb">case</span>: ifPn =&gt; //.
<span class="nb">rewrite</span> -leNgt le_eqVlt =&gt; /predU1P[-&gt;|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> subee.
<span class="bp">by</span> <span class="nb">move</span>/lt_ereal_bnd/ltW; <span class="nb">rewrite</span> leNgt; <span class="nb">move</span>: i0 =&gt; /neitvP =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hlength_infty_bnd</span> <span class="nv">b</span> <span class="nv">r</span> :
  hlength [<span class="nb">set</span>` Interval -oo%O (BSide b r)] = +oo :&gt; \bar R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> hlength_itv /= ltNyr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hlength_bnd_infty</span> <span class="nv">b</span> <span class="nv">r</span> :
  hlength [<span class="nb">set</span>` Interval (BSide b r) +oo%O] = +oo :&gt; \bar R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> hlength_itv /= ltry. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pinfty_hlength</span> <span class="nv">i</span> : hlength [<span class="nb">set</span>` i] = +oo -&gt;
  (<span class="kr">exists</span> <span class="nv">s</span> <span class="nv">r</span>, i = Interval -oo%O (BSide s r) \/ i = Interval (BSide s r) +oo%O)
  \/ i = `]-oo, +oo[.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> hlength_itv; <span class="nb">case</span>: i =&gt; -[ba a|[]] [bb b|[]] //= =&gt; [|_|_|].
- <span class="bp">by</span> <span class="nb">case</span>: ifPn.
- <span class="bp">by</span> <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">ba</span>, a; <span class="nb">right</span>.
- <span class="bp">by</span> <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">bb</span>, b; <span class="nb">left</span>.
- <span class="bp">by</span> <span class="nb">right</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hlength_ge0</span> <span class="nv">i</span> : <span class="mi">0</span> &lt;= hlength [<span class="nb">set</span>` i].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> hlength_itv; <span class="nb">case</span>: ifPn =&gt; //; <span class="nb">case</span>: (i.<span class="mi">1</span> : \bar _) =&gt; [r| |].
- <span class="bp">by</span> <span class="nb">rewrite</span> suber_ge0//; <span class="bp">exact</span>: ltW.
- <span class="bp">by</span> <span class="nb">rewrite</span> ltNge leey.
- <span class="bp">by</span> <span class="nb">case</span>: (i.<span class="mi">2</span> : \bar _) =&gt; //= [r _]; <span class="nb">rewrite</span> leey.
<span class="kn">Qed</span>.
<span class="kn">Local</span> <span class="kn">Hint Extern</span> <span class="mi">0</span> (<span class="mi">0</span>%:E &lt;= hlength _) =&gt; <span class="kp">solve</span>[<span class="nb">apply</span>: hlength_ge0] : core.

<span class="kn">Lemma</span> <span class="nf">hlength_Rhull</span> (<span class="nv">A</span> : <span class="nb">set</span> R) : hlength [<span class="nb">set</span>` Rhull A] = hlength A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /hlength Rhull_involutive. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">le_hlength_itv</span> <span class="nv">i</span> <span class="nv">j</span> : {subset i &lt;= j} -&gt; hlength [<span class="nb">set</span>` i] &lt;= hlength [<span class="nb">set</span>` j].
<span class="kn">Proof</span>.
<span class="nb">set</span> I := [<span class="nb">set</span>` i]; <span class="nb">set</span> J := [<span class="nb">set</span>` j].
<span class="nb">have</span> [-&gt;|/set0P I0] := eqVneq I set0; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> hlength0 hlength_ge0.
<span class="nb">have</span> [J0|/set0P J0] := eqVneq J set0.
  <span class="bp">by</span> <span class="nb">move</span>/subset_itvP; <span class="nb">rewrite</span> -/J J0 subset0 -/I =&gt; -&gt;.
<span class="nb">move</span>=&gt; /subset_itvP ij; <span class="nb">apply</span>: lee_sub =&gt; /=.
  <span class="nb">have</span> [ui|ui] := asboolP (has_ubound I).
    <span class="nb">have</span> [uj /=|uj] := asboolP (has_ubound J); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> leey.
    <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin le_sup // =&gt; r Ir; <span class="kr">exists</span> <span class="nv">r</span>; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: ij.
  <span class="nb">have</span> [uj /=|//] := asboolP (has_ubound J).
  <span class="bp">by</span> <span class="nb">move</span>: ui; <span class="nb">have</span> := subset_has_ubound ij uj.
<span class="nb">have</span> [lj /=|lj] := asboolP (has_lbound J); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> leNye.
<span class="nb">have</span> [li /=|li] := asboolP (has_lbound I); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>: li; <span class="nb">have</span> := subset_has_lbound ij lj.
<span class="nb">rewrite</span> lee_fin ler_oppl opprK le_sup// <span class="nl">?has_inf_supN</span>//; <span class="nb">last</span> <span class="bp">exact</span>/nonemptyN.
<span class="nb">move</span>=&gt; r [r&#39; Ir&#39; &lt;-{r}]; <span class="kr">exists</span> (- r&#39;)%R.
<span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">r&#39;</span> =&gt; //; <span class="nb">apply</span>: ij.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">le_hlength</span> : {homo hlength : A B / (A `&lt;=` B) &gt;-&gt; A &lt;= B}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; a b /le_Rhull /le_hlength_itv.
<span class="bp">by</span> <span class="nb">rewrite</span> (hlength_Rhull a) (hlength_Rhull b).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">hlength</span>.
<span class="kn">Arguments</span> hlength {R}.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (<span class="mi">0</span>%:E &lt;= hlength _) =&gt; <span class="kp">solve</span>[<span class="nb">apply</span>: hlength_ge0] : core.

<span class="kn">Section</span> <span class="nf">itv_semiRingOfSets</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> (<span class="nv">I</span> <span class="nv">J</span> <span class="nv">K</span> : <span class="nb">set</span> R).
<span class="kn">Definition</span> <span class="nf">ocitv_type</span> : <span class="kt">Type</span> := R.

<span class="kn">Definition</span> <span class="nf">ocitv</span> := [<span class="nb">set</span> `]x.<span class="mi">1</span>, x.<span class="mi">2</span>]%classic | x <span class="kr">in</span> [<span class="nb">set</span>: R * R]].

<span class="kn">Lemma</span> <span class="nf">is_ocitv</span> <span class="nv">a</span> <span class="nv">b</span> : ocitv `]a, b]%classic.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">a</span>, b); <span class="nb">split</span> =&gt; //=; <span class="nb">rewrite</span> in_itv/= andbT. <span class="kn">Qed</span>.
<span class="kn">Hint Extern</span> <span class="mi">0</span> (ocitv _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: is_ocitv] : core.

<span class="kn">Lemma</span> <span class="nf">ocitv0</span> : ocitv set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> (<span class="mi">1</span>, <span class="mi">0</span>); <span class="nb">rewrite</span> //= set_itv_ge <span class="nl">?bnd_simp</span>//= ltr10. <span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> ocitv0 : core.

<span class="kn">Lemma</span> <span class="nf">ocitvP</span> <span class="nv">X</span> : ocitv X &lt;-&gt; X = set0 \/ <span class="kr">exists2</span> x, x.<span class="mi">1</span> &lt; x.<span class="mi">2</span> &amp; X = `]x.<span class="mi">1</span>, x.<span class="mi">2</span>]%classic.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [[x _ &lt;-]|[-&gt;//|[x xlt -&gt;]]]//.
<span class="nb">case</span>: (boolP (x.<span class="mi">1</span> &lt; x.<span class="mi">2</span>)) =&gt; x12; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="bp">by</span> <span class="nb">left</span>; <span class="nb">rewrite</span> set_itv_ge.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ocitvD</span> : semi_setD_closed ocitv.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; _ _ [a _ &lt;-] /ocitvP[|[b ltb]] -&gt;.
  <span class="nb">rewrite</span> setD0; <span class="kr">exists</span> [<span class="nb">set</span> `]a.<span class="mi">1</span>, a.<span class="mi">2</span>]%classic].
  <span class="bp">by</span> <span class="nb">split</span>=&gt; [//|? -&gt;//||? ? -&gt; -&gt;//]; <span class="nb">rewrite</span> bigcup_set1.
<span class="nb">rewrite</span> setDE setCitv/= setIUr -!set_itvI.
<span class="nb">rewrite</span> /Order.meet/= /Order.meet/= /Order.join/=
         ?(andbF, orbF)/= ?(meetEtotal, joinEtotal).
<span class="nb">rewrite</span> -negb_or le_total/=; <span class="nb">set</span> c := minr _ _; <span class="nb">set</span> d := maxr _ _.
<span class="nb">have</span> <span class="kn">inside</span> : a.<span class="mi">1</span> &lt; c -&gt; d &lt; a.<span class="mi">2</span> -&gt; `]a.<span class="mi">1</span>, c] `&amp;` `]d, a.<span class="mi">2</span>] = set0.
  <span class="nb">rewrite</span> -subset0 lt_minr lt_maxl =&gt; /andP[a12 ab1] /andP[_ ba2] x /= [].
  <span class="nb">have</span> b1a2 : b.<span class="mi">1</span> &lt;= a.<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltW// (lt_trans ltb).
  <span class="nb">have</span> a1b2 : a.<span class="mi">1</span> &lt;= b.<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltW// (lt_trans _ ltb).
  <span class="nb">rewrite</span> /c /d (min_idPr _)// (max_idPr _)// !in_itv /=.
  <span class="nb">move</span>=&gt; /andP[a1x xb1] /andP[b2x xa2].
  <span class="bp">by</span> <span class="nb">have</span> := lt_le_trans b2x xb1; <span class="nb">case</span>: ltgtP ltb.
<span class="kr">exists</span> ((<span class="kr">if</span> a.<span class="mi">1</span> &lt; c <span class="kr">then</span> [<span class="nb">set</span> `]a.<span class="mi">1</span>, c]%classic] <span class="kr">else</span> set0) `|`
        (<span class="kr">if</span> d &lt; a.<span class="mi">2</span> <span class="kr">then</span> [<span class="nb">set</span> `]d, a.<span class="mi">2</span>]%classic] <span class="kr">else</span> set0)); <span class="nb">split</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> finite_setU; <span class="kp">do</span>! <span class="nb">case</span>: ifP.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? []; <span class="nb">case</span>: ifP =&gt; ? // -&gt;//=.
- <span class="bp">by</span> <span class="nb">rewrite</span> bigcup_setU; <span class="nb">congr</span> (_ `|` _);
     <span class="nb">case</span>: ifPn =&gt; ?; <span class="nb">rewrite</span> <span class="nl">?bigcup_set1</span> <span class="nl">?bigcup_set0</span>// set_itv_ge.
- <span class="nb">move</span>=&gt; I J/=; <span class="nb">case</span>: ifP =&gt; //= ac; <span class="nb">case</span>: ifP =&gt; //= da [] // -&gt; []// -&gt;.
    <span class="bp">by</span> <span class="nb">rewrite</span> <span class="kn">inside</span>// =&gt; -[].
  <span class="bp">by</span> <span class="nb">rewrite</span> setIC <span class="kn">inside</span>// =&gt; -[].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ocitvI</span> : setI_closed ocitv.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; _ _ [a _ &lt;-] [b _ &lt;-]; <span class="nb">rewrite</span> -set_itvI/=.
<span class="nb">rewrite</span> /Order.meet/= /Order.meet /Order.join/=
        ?(andbF, orbF)/= ?(meetEtotal, joinEtotal).
<span class="bp">by</span> <span class="nb">rewrite</span> -negb_or le_total/=.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">ocitv_display</span> : <span class="kt">Type</span> -&gt; measure_display. <span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> :=
  @isSemiRingOfSets.Build (ocitv_display R)
    ocitv_type (Pointed.class R) ocitv ocitv0 ocitvI ocitvD.

<span class="kn">Notation</span> <span class="s2">&quot;R .-ocitv&quot;</span> := (ocitv_display R) : measure_display_scope.
<span class="kn">Notation</span> <span class="s2">&quot;R .-ocitv.-measurable&quot;</span> := (measurable : <span class="nb">set</span> (<span class="nb">set</span> (ocitv_type))) :
  classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">hlength_ge0&#39;</span> (<span class="nv">I</span> : <span class="nb">set</span> ocitv_type) : (<span class="mi">0</span> &lt;= hlength I)%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -hlength0 le_hlength. <span class="kn">Qed</span>.

<span class="c">(* Unused *)</span>
<span class="c">(* Lemma hlength_semi_additive2 : semi_additive2 hlength. *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move=&gt; I J /ocitvP[|[a a12]] -&gt;; first by rewrite set0U hlength0 add0e. *)</span>
<span class="c">(* move=&gt; /ocitvP[|[b b12]] -&gt;; first by rewrite setU0 hlength0 adde0. *)</span>
<span class="c">(* rewrite -subset0 =&gt; + ab0 =&gt; /ocitvP[|[x x12] abx]. *)</span>
<span class="c">(*   by rewrite setU_eq0 =&gt; -[-&gt; -&gt;]; rewrite setU0 hlength0 adde0. *)</span>
<span class="c">(* rewrite abx !hlength_itv//= ?lte_fin a12 b12 x12/= -!EFinB -EFinD. *)</span>
<span class="c">(* wlog ab1 : a a12 b b12 ab0 abx / a.1 &lt;= b.1 =&gt; [hwlog|]. *)</span>
<span class="c">(*   have /orP[ab1|ba1] := le_total a.1 b.1; first by apply: hwlog. *)</span>
<span class="c">(*   by rewrite [in RHS]addrC; apply: hwlog =&gt; //; rewrite (setIC, setUC). *)</span>
<span class="c">(* have := ab0; rewrite subset0 -set_itv_meet/=. *)</span>
<span class="c">(* rewrite /Order.join /Order.meet/= ?(andbF, orbF)/= ?(meetEtotal, joinEtotal). *)</span>
<span class="c">(* rewrite -negb_or le_total/=; set c := minr _ _; set d := maxr _ _. *)</span>
<span class="c">(* move=&gt; /eqP/neitvP/=; rewrite bnd_simp/= /d/c (max_idPr _)// =&gt; /negP. *)</span>
<span class="c">(* rewrite -leNgt le_minl orbC lt_geF//= =&gt; {c} {d} a2b1. *)</span>
<span class="c">(* have ab i j : i \in `]a.1, a.2] -&gt; j \in `]b.1, b.2] -&gt; i &lt;= j. *)</span>
<span class="c">(*   by move=&gt; ia jb; rewrite (le_le_trans _ _ a2b1) ?(itvP ia) ?(itvP jb). *)</span>
<span class="c">(* have /(congr1 sup) := abx; rewrite sup_setU// ?sup_itv_bounded// =&gt; bx. *)</span>
<span class="c">(* have /(congr1 inf) := abx; rewrite inf_setU// ?inf_itv_bounded// =&gt; ax. *)</span>
<span class="c">(* rewrite -{}ax -{x}bx in abx x12 *. *)</span>
<span class="c">(* case: ltgtP a2b1 =&gt; // a2b1 _; last first. *)</span>
<span class="c">(*   by rewrite a2b1 [in RHS]addrC subrKA. *)</span>
<span class="c">(* exfalso; pose c := (a.2 + b.1) / 2%:R. *)</span>
<span class="c">(* have /predeqP/(_ c)[_ /(_ _)/Box[]] := abx. *)</span>
<span class="c">(*   apply: subset_itv_oo_oc; have := mid_in_itvoo a2b1. *)</span>
<span class="c">(*   by apply/subitvP; rewrite subitvE ?bnd_simp/= ?ltW. *)</span>
<span class="c">(* apply/not_orP; rewrite /= !in_itv/=. *)</span>
<span class="c">(* by rewrite lt_geF ?midf_lt//= andbF le_gtF ?midf_le//= ltW. *)</span>
<span class="c">(* Qed. *)</span>

<span class="kn">Lemma</span> <span class="nf">hlength_semi_additive</span> : semi_additive (hlength : <span class="nb">set</span> ocitv_type -&gt; _).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /= I n /(_ _)/cid2-/all_sig[b]/all_and2[_]/(_ _)/esym-/funext {I}-&gt;.
<span class="nb">move</span>=&gt; Itriv [[/= a1 a2] _] /esym /[dup] + -&gt;.
<span class="nb">rewrite</span> hlength_itv <span class="nl">?lte_fin</span>/= -EFinB.
<span class="nb">case</span>: ifPn =&gt; a12; <span class="nb">last first</span>.
  <span class="nb">pose</span> I i :=  `](b i).<span class="mi">1</span>, (b i).<span class="mi">2</span>]%classic.
  <span class="nb">rewrite</span> set_itv_ge//= -(bigcup_mkord _ I) /I =&gt; /bigcup0P I0.
  <span class="bp">by</span> <span class="nb">under</span> eq_bigr =&gt; i _ <span class="kp">do</span> <span class="nb">rewrite</span> I0//= hlength0; <span class="nb">rewrite</span> big1.
<span class="nb">set</span> A := `]a1, a2]%classic.
<span class="nb">rewrite</span> -bigcup_pred; <span class="nb">set</span> P := xpredT; <span class="nb">rewrite</span> (eq_bigl P)//.
<span class="nb">move</span>: P =&gt; P; <span class="nb">have</span> [p] := ubnP #|P|; <span class="nb">elim</span>: p =&gt; // p IHp <span class="kr">in</span> P a2 a12 A *.
<span class="nb">rewrite</span> ltnS =&gt; cP /esym AE.
<span class="nb">have</span> : A a2 <span class="bp">by</span> <span class="nb">rewrite</span> /A /= in_itv/= lexx andbT.
<span class="nb">rewrite</span> AE/= =&gt; -[i /= Pi] a2bi.
<span class="nb">case</span>: (boolP ((b i).<span class="mi">1</span> &lt; (b i).<span class="mi">2</span>)) =&gt; bi; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> itv_ge <span class="kr">in</span> a2bi.
<span class="nb">have</span> {}a2bi : a2 = (b i).<span class="mi">2</span>.
  <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le (itvP a2bi)/=.
  <span class="nb">suff</span>: A (b i).<span class="mi">2</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; /itvP-&gt;.
  <span class="bp">by</span> <span class="nb">rewrite</span> AE; <span class="kr">exists</span> <span class="nv">i</span>=&gt; //=; <span class="nb">rewrite</span> in_itv/= lexx andbT.
<span class="nb">rewrite</span> {a2}a2bi <span class="kr">in</span> a12 A AE *.
<span class="nb">rewrite</span> (bigD1 i)//= hlength_itv <span class="nl">?lte_fin</span>/= bi !EFinD -addeA.
<span class="nb">congr</span> (_ + _)%E; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> addeC -sube_eq// <span class="mi">1</span><span class="nl">?adde_defC</span>//.
<span class="nb">rewrite</span> <span class="nl">?EFinN</span> oppeK addeC; <span class="nb">apply</span>/eqP.
<span class="nb">case</span>: (eqVneq a1 (b i).<span class="mi">1</span>) =&gt; a1bi.
  <span class="nb">rewrite</span> {a1}a1bi <span class="kr">in</span> a12 A AE {IHp} *; <span class="nb">rewrite</span> subee <span class="nl">?big1</span>// =&gt; j.
  <span class="nb">move</span>=&gt; /andP[Pj Nji]; <span class="nb">rewrite</span> hlength_itv <span class="nl">?lte_fin</span>/=; <span class="nb">case</span>: ifPn =&gt; bj//.
  <span class="nb">exfalso</span>; <span class="nb">have</span> /trivIsetP/(_ j i I I Nji) := Itriv.
  <span class="nb">pose</span> m := ((b j).<span class="mi">1</span> + (b j).<span class="mi">2</span>) / <span class="mi">2</span>%:R.
  <span class="nb">have</span> mbj : `](b j).<span class="mi">1</span>, (b j).<span class="mi">2</span>]%classic m.
     <span class="bp">by</span> <span class="nb">rewrite</span> /= !in_itv/= ?(midf_lt, midf_le)//= ltW.
  <span class="nb">rewrite</span> -subset0 =&gt; /(_ m); <span class="nb">apply</span>; <span class="nb">split</span>=&gt; //.
  <span class="bp">by</span> <span class="nb">suff</span>: A m <span class="bp">by</span> []; <span class="nb">rewrite</span> AE; <span class="kr">exists</span> <span class="nv">j</span> =&gt; //.
<span class="nb">have</span> a1b2 j : P j -&gt; (b j).<span class="mi">1</span> &lt; (b j).<span class="mi">2</span> -&gt; a1 &lt;= (b j).<span class="mi">2</span>.
  <span class="nb">move</span>=&gt; Pj bj; <span class="nb">suff</span> /itvP-&gt; : A (b j).<span class="mi">2</span> <span class="bp">by</span> [].
  <span class="bp">by</span> <span class="nb">rewrite</span> AE; <span class="kr">exists</span> <span class="nv">j</span> =&gt; //=; <span class="nb">rewrite</span> <span class="nl">?in_itv</span>/= bj//=.
<span class="nb">have</span> a1b j : P j -&gt; (b j).<span class="mi">1</span> &lt; (b j).<span class="mi">2</span> -&gt; a1 &lt;= (b j).<span class="mi">1</span>.
  <span class="nb">move</span>=&gt; Pj bj; <span class="nb">case</span>: ltP=&gt; // bj1a.
  <span class="nb">suff</span> : A a1 <span class="bp">by</span> <span class="nb">rewrite</span> /A/= in_itv/= ltxx.
  <span class="bp">by</span> <span class="nb">rewrite</span> AE; <span class="kr">exists</span> <span class="nv">j</span>; <span class="nb">rewrite</span> //= in_itv/= bj1a//= a1b2.
<span class="nb">have</span> bbi2 j : P j -&gt; (b j).<span class="mi">1</span> &lt; (b j).<span class="mi">2</span> -&gt; (b j).<span class="mi">2</span> &lt;= (b i).<span class="mi">2</span>.
  <span class="nb">move</span>=&gt; Pj bj; <span class="nb">suff</span> /itvP-&gt; : A (b j).<span class="mi">2</span> <span class="bp">by</span> [].
  <span class="bp">by</span> <span class="nb">rewrite</span> AE; <span class="kr">exists</span> <span class="nv">j</span> =&gt; //=; <span class="nb">rewrite</span> <span class="nl">?in_itv</span>/= bj//=.
<span class="nb">apply</span>/IHp.
- <span class="bp">by</span> <span class="nb">rewrite</span> lt_neqAle a1bi/= a1b.
- <span class="nb">rewrite</span> (leq_trans _ cP)// -(cardID (pred1 i) P).
  <span class="nb">rewrite</span> [X <span class="kr">in</span> (_ &lt; X + _)%N](@eq_card _ _ (pred1 i)); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; j; <span class="nb">rewrite</span> !inE andbC; <span class="nb">case</span>: eqVneq =&gt; // -&gt;.
  <span class="nb">rewrite</span> <span class="nl">?card1</span> <span class="nl">?ltnS</span>// subset_leq_card//.
  <span class="bp">by</span> <span class="nb">apply</span>/fintype.subsetP =&gt; j; <span class="nb">rewrite</span> -topredE/= !inE andbC.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; /= [x [j/= /andP[Pj Nji]]|x/= xabi].
  <span class="nb">case</span>: (boolP ((b j).<span class="mi">1</span> &lt; (b j).<span class="mi">2</span>)) =&gt; bj; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> itv_ge.
  <span class="nb">apply</span>: subitvP; <span class="nb">rewrite</span> subitvE <span class="nl">?bnd_simp</span> a1b//= leNgt.
  <span class="nb">have</span> /trivIsetP/(_ j i I I Nji) := Itriv.
  <span class="nb">rewrite</span> -subset0 =&gt; /(_ (b j).<span class="mi">2</span>); <span class="nb">apply</span>: contra_notN =&gt; /= bi1j2.
  <span class="bp">by</span> <span class="nb">rewrite</span> !in_itv/= bj !lexx bi1j2 bbi2.
<span class="nb">have</span>: A x.
  <span class="nb">rewrite</span> /A/= in_itv/= (itvP xabi)/= ltW//.
  <span class="bp">by</span> <span class="nb">rewrite</span> (le_lt_trans _ bi) ?(itvP xabi).
<span class="nb">rewrite</span> AE =&gt; -[j /= Pj xbj].
<span class="kr">exists</span> <span class="nv">j</span> =&gt; //=.
<span class="nb">apply</span>/andP; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: contraTneq xbj =&gt; -&gt;.
<span class="bp">by</span> <span class="nb">rewrite</span> in_itv/= le_gtF// (itvP xabi).
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isContent.Build _ R _
  (hlength : <span class="nb">set</span> ocitv_type -&gt; _) (@hlength_ge0&#39;) hlength_semi_additive.

<span class="kn">Hint Extern</span> <span class="mi">0</span> ((_ .-ocitv).-measurable _) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: is_ocitv] : core.

<span class="kn">Lemma</span> <span class="nf">hlength_sigma_sub_additive</span> :
  sigma_sub_additive (hlength : <span class="nb">set</span> ocitv_type -&gt; _).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; I A /(_ _)/cid2-/all_sig[b]/all_and2[_]/(_ _)/esym AE.
<span class="nb">move</span>=&gt; [a _ &lt;-]; <span class="nb">rewrite</span> hlength_itv <span class="nl">?lte_fin</span>/= -EFinB =&gt; lebig.
<span class="nb">case</span>: ifPn =&gt; a12; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> nneseries_esum// esum_ge0.
<span class="nb">apply</span>: lee_adde =&gt; e.
<span class="nb">rewrite</span> [e%:num]splitr [<span class="kr">in</span> leRHS]EFinD addeA -lee_subl_addr//.
<span class="nb">apply</span>: le_trans (epsilon_trick _ _ _) =&gt; //=.
<span class="nb">have</span> eVn_gt0 n : <span class="mi">0</span> &lt; e%:num / <span class="mi">2</span> / (<span class="mi">2</span> ^ n.+<span class="mi">1</span>)%:R.
  <span class="bp">by</span> <span class="nb">rewrite</span> divr_gt0// ltr0n// expn_gt0.
<span class="nb">have</span> eVn_ge0 n := ltW (eVn_gt0 n).
<span class="nb">pose</span> Aoo i : <span class="nb">set</span> ocitv_type :=
  `](b i).<span class="mi">1</span>, (b i).<span class="mi">2</span> + e%:num / <span class="mi">2</span> / (<span class="mi">2</span> ^ i.+<span class="mi">1</span>)%:R[%classic.
<span class="nb">pose</span> Aoc i : <span class="nb">set</span> ocitv_type :=
  `](b i).<span class="mi">1</span>, (b i).<span class="mi">2</span> + e%:num / <span class="mi">2</span> / (<span class="mi">2</span> ^ i.+<span class="mi">1</span>)%:R]%classic.
<span class="nb">have</span>: `[a.<span class="mi">1</span> + e%:num / <span class="mi">2</span>, a.<span class="mi">2</span>] `&lt;=` \bigcup_i Aoo i.
  <span class="nb">apply</span>: (@subset_trans _ `]a.<span class="mi">1</span>, a.<span class="mi">2</span>]).
    <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> /= !in_itv /= =&gt; /andP[+ -&gt; //].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; /lt_le_trans-&gt; //; <span class="nb">rewrite</span> ltr_addl.
  <span class="nb">apply</span>: (subset_trans lebig); <span class="nb">apply</span>: subset_bigcup =&gt; i _; <span class="nb">rewrite</span> AE /Aoo/=.
  <span class="nb">move</span>=&gt; x /=; <span class="nb">rewrite</span> !in_itv /= =&gt; /andP[-&gt; /le_lt_trans-&gt;]//=.
  <span class="bp">by</span> <span class="nb">rewrite</span> ltr_addl.
<span class="nb">have</span> := @segment_compact _ (a.<span class="mi">1</span> + e%:num / <span class="mi">2</span>) a.<span class="mi">2</span>; <span class="nb">rewrite</span> compact_cover.
<span class="nb">move</span>=&gt; /[<span class="nb">apply</span>]-[i _|X _ Xc]; <span class="kp">first</span> <span class="bp">exact</span>: interval_open.
<span class="nb">have</span>: `](a.<span class="mi">1</span> + e%:num / <span class="mi">2</span>), a.<span class="mi">2</span>] `&lt;=` \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` X]) Aoc i.
  <span class="nb">move</span>=&gt; x /subset_itv_oc_cc /Xc [i /= Xi] Aooix.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">apply</span>: subset_itv_oo_oc Aooix.
<span class="nb">have</span> /[<span class="nb">apply</span>] := @content_sub_fsum _ _ _
  [the content _ _ of hlength : <span class="nb">set</span> ocitv_type -&gt; _] _ [<span class="nb">set</span>` X].
<span class="nb">move</span>=&gt; /(_ _ _ _)/Box[]//=; <span class="nb">apply</span>: le_le_trans.
  <span class="nb">rewrite</span> hlength_itv <span class="nl">?lte_fin</span> -<span class="nl">?EFinD</span>/= -addrA -opprD.
  <span class="bp">by</span> <span class="nb">case</span>: ltP =&gt; //; <span class="nb">rewrite</span> lee_fin subr_le0.
<span class="nb">rewrite</span> nneseries_esum//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> adde_ge0//= <span class="nl">?lee_fin</span>.
<span class="nb">rewrite</span> esum_ge//; <span class="kr">exists</span> [<span class="nb">set</span>` X] =&gt; //; <span class="nb">rewrite</span> fsbig_finite// <span class="nl">?set_fsetK</span>//=.
<span class="nb">rewrite</span> fsbig_finite//= set_fsetK//.
<span class="nb">rewrite</span> lee_sum // =&gt; i _; <span class="nb">rewrite</span> <span class="nl">?AE</span>// !hlength_itv/= <span class="nl">?lte_fin</span> -<span class="nl">?EFinD</span>/=.
<span class="kp">do</span> !<span class="nb">case</span>: ifPn =&gt; //= ?; <span class="kp">do</span> <span class="nl">?by</span> <span class="nb">rewrite</span> <span class="nl">?adde_ge0</span> <span class="nl">?lee_fin</span>// <span class="nl">?subr_ge0</span>// <span class="nl">?ltW</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> addrAC.
<span class="bp">by</span> <span class="nb">rewrite</span> addrAC lee_fin ler_add// subr_le0 leNgt.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hlength_sigma_finite</span> : sigma_finite [<span class="nb">set</span>: ocitv_type] hlength.
<span class="kn">Proof</span>.
<span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">k</span> : nat =&gt; `] (- k%:R)%R, k%:R]%classic).
  <span class="nb">apply</span>/esym; <span class="nb">rewrite</span> -subTset =&gt; x _ /=; <span class="kr">exists</span> `|(floor `|x| + <span class="mi">1</span>)%R|%N =&gt; //=.
  <span class="nb">rewrite</span> in_itv/= !natr_absz intr_norm intrD.
  <span class="nb">suff</span>: `|x| &lt; `|(floor `|x|)%:~R + <span class="mi">1</span>| <span class="bp">by</span> <span class="nb">rewrite</span> ltr_norml =&gt; /andP[-&gt; /ltW-&gt;].
  <span class="bp">by</span> <span class="nb">rewrite</span> ger0_norm <span class="nl">?addr_ge0</span> <span class="nl">?ler0z</span> <span class="nl">?floor_ge0</span>// lt_succ_floor.
<span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> hlength_itv/= -EFinB; <span class="nb">case</span>: ifP; <span class="nb">rewrite</span> ltry.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">lebesgue_measure</span> := Hahn_ext
  [the content _ _ of hlength : <span class="nb">set</span> ocitv_type -&gt; _].

<span class="kn">Let</span> <span class="nf">lebesgue_measure0</span> : lebesgue_measure set0 = <span class="mi">0</span>%E.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_ge0</span> : <span class="kr">forall</span> <span class="nv">x</span>, (<span class="mi">0</span> &lt;= lebesgue_measure x)%E.
<span class="kn">Proof</span>. <span class="bp">exact</span>: <span class="kn">measure</span>.Hahn_ext_ge0. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_semi_sigma_additive</span> : semi_sigma_additive lebesgue_measure.
<span class="kn">Proof</span>. <span class="bp">exact</span>/<span class="kn">measure</span>.Hahn_ext_sigma_additive/hlength_sigma_sub_additive. <span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ lebesgue_measure
  lebesgue_measure0 lebesgue_measure_ge0 lebesgue_measure_semi_sigma_additive.

<span class="kn">End</span> <span class="nf">itv_semiRingOfSets</span>.
<span class="kn">Arguments</span> lebesgue_measure {R}.

<span class="kn">Notation</span> <span class="s2">&quot;R .-ocitv&quot;</span> := (ocitv_display R) : measure_display_scope.
<span class="kn">Notation</span> <span class="s2">&quot;R .-ocitv.-measurable&quot;</span> := (measurable : <span class="nb">set</span> (<span class="nb">set</span> (ocitv_type R))) :
  classical_set_scope.

<span class="kn">Section</span> <span class="nf">lebesgue_measure</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Let</span> <span class="nf">gitvs</span> := [the measurableType _ of salgebraType (@ocitv R)].

<span class="kn">Lemma</span> <span class="nf">lebesgue_measure_unique</span> (<span class="nv">mu</span> : {measure <span class="nb">set</span> gitvs -&gt; \bar R}) :
  (<span class="kr">forall</span> <span class="nv">X</span>, ocitv X -&gt; hlength X = mu X) -&gt;
  <span class="kr">forall</span> <span class="nv">X</span>, measurable X -&gt; lebesgue_measure X = mu X.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; muE X mX; <span class="nb">apply</span>: Hahn_ext_unique =&gt; //=.
- <span class="bp">exact</span>: hlength_sigma_sub_additive.
- <span class="bp">exact</span>: hlength_sigma_finite.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">lebesgue_measure</span>.

<span class="kn">Section</span> <span class="nf">ps_infty</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Inductive</span> <span class="nf">ps_infty</span> : <span class="nb">set</span> \bar T -&gt; <span class="kt">Prop</span> :=
| ps_infty0 : ps_infty set0
| ps_ninfty : ps_infty [<span class="nb">set</span> -oo]
| ps_pinfty : ps_infty [<span class="nb">set</span> +oo]
| ps_inftys : ps_infty [<span class="nb">set</span> -oo; +oo].

<span class="kn">Lemma</span> <span class="nf">ps_inftyP</span> (<span class="nv">A</span> : <span class="nb">set</span> \bar T) : ps_infty A &lt;-&gt; A `&lt;=` [<span class="nb">set</span> -oo; +oo].
<span class="kn">Proof</span>.
<span class="nb">split</span> =&gt; [[]//|Aoo].
<span class="bp">by</span> <span class="nb">have</span> [] := subset_set2 Aoo; <span class="nb">move</span>=&gt; -&gt;; <span class="nb">constructor</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">setCU_Efin</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">B</span> : <span class="nb">set</span> \bar T) : ps_infty B -&gt;
  ~` (EFin @` A) `&amp;` ~` B = (EFin @` ~` A) `|` ([<span class="nb">set</span> -oo%E; +oo%E] `&amp;` ~` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ps_inftyB.
<span class="nb">have</span> -&gt; : ~` (EFin @` A) = EFin @` (~` A) `|` [<span class="nb">set</span> -oo; +oo]%E.
  <span class="bp">by</span> <span class="nb">rewrite</span> EFin_setC setDKU // =&gt; x [|] -&gt; -[].
<span class="nb">rewrite</span> setIUl; <span class="nb">congr</span> (_ `|` _); <span class="nb">rewrite</span> predeqE =&gt; -[x| |]; <span class="nb">split</span>; <span class="kp">try</span> <span class="bp">by</span> <span class="nb">case</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [] x&#39; Ax&#39; [] &lt;-{x}; <span class="nb">split</span>; [<span class="kr">exists</span> <span class="nv">x&#39;</span>|<span class="nb">case</span>: ps_inftyB =&gt; // -[]].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ps_infty</span>.

<span class="kn">Section</span> <span class="nf">salgebra_ereal</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : realType) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> R)).
<span class="kn">Let</span> <span class="nf">measurableR</span> : <span class="nb">set</span> (<span class="nb">set</span> R) := G.-sigma.-measurable.

<span class="kn">Definition</span> <span class="nf">emeasurable</span> : <span class="nb">set</span> (<span class="nb">set</span> \bar R) :=
  [<span class="nb">set</span> EFin @` A `|` B | A <span class="kr">in</span> measurableR &amp; B <span class="kr">in</span> ps_infty].

<span class="kn">Lemma</span> <span class="nf">emeasurable0</span> : emeasurable set0.
<span class="kn">Proof</span>.
<span class="kr">exists</span> <span class="nv">set0</span>; <span class="kp">first</span> <span class="bp">exact</span>: measurable0.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">set0</span>; <span class="nb">rewrite</span> <span class="nl">?setU0</span>// <span class="nl">?image_set0</span>//; <span class="nb">constructor</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurableC</span> (<span class="nv">X</span> : <span class="nb">set</span> \bar R) : emeasurable X -&gt; emeasurable (~` X).
<span class="kn">Proof</span>.
<span class="nb">move</span> =&gt; -[A mA] [B PooB &lt;-]; <span class="nb">rewrite</span> setCU setCU_Efin //.
<span class="kr">exists</span> (~` A); [<span class="bp">exact</span>: measurableC | <span class="kr">exists</span> ([<span class="nb">set</span> -oo%E; +oo%E] `&amp;` ~` B) =&gt; //].
<span class="nb">case</span>: PooB.
- <span class="bp">by</span> <span class="nb">rewrite</span> setC0 setIT; <span class="nb">constructor</span>.
- <span class="nb">rewrite</span> setIUl setICr set0U -setDE.
  <span class="nb">have</span> [_ -&gt;] := @setDidPl (\bar R) [<span class="nb">set</span> +oo%E] [<span class="nb">set</span> -oo%E]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">constructor</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; // -[-&gt;].
- <span class="nb">rewrite</span> setIUl setICr setU0 -setDE.
  <span class="nb">have</span> [_ -&gt;] := @setDidPl (\bar R) [<span class="nb">set</span> -oo%E] [<span class="nb">set</span> +oo%E]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">constructor</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; // -[-&gt;].
- <span class="bp">by</span> <span class="nb">rewrite</span> setICr; <span class="nb">constructor</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigcupT_emeasurable</span> (<span class="nv">F</span> : (<span class="nb">set</span> \bar R)^nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, emeasurable (F i)) -&gt; emeasurable (\bigcup_i (F i)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mF; <span class="nb">pose</span> P := <span class="kr">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; measurableR j.<span class="mi">1</span> /\ ps_infty j.<span class="mi">2</span> /\
                            F i = [<span class="nb">set</span> x%:E | x <span class="kr">in</span> j.<span class="mi">1</span>] `|` j.<span class="mi">2</span>.
<span class="nb">have</span> [f fi] : {f : nat -&gt; (<span class="nb">set</span> R) * (<span class="nb">set</span> \bar R) &amp; <span class="kr">forall</span> <span class="nv">i</span>, P i (f i) }.
  <span class="bp">by</span> <span class="nb">apply</span>: choice =&gt; i; <span class="nb">have</span> [x mx [y PSoo&#39;y] xy] := mF i; <span class="kr">exists</span> (<span class="nv">x</span>, y).
<span class="kr">exists</span> (\bigcup_i (f i).<span class="mi">1</span>).
  <span class="bp">by</span> <span class="nb">apply</span>: bigcupT_measurable =&gt; i; <span class="bp">exact</span>: (fi i).<span class="mi">1</span>.
<span class="kr">exists</span> (\bigcup_i (f i).<span class="mi">2</span>).
  <span class="nb">apply</span>/ps_inftyP =&gt; x [n _] fn2x.
  <span class="nb">have</span> /ps_inftyP : ps_infty(f n).<span class="mi">2</span> <span class="bp">by</span> <span class="nb">have</span> [_ []] := fi n.
  <span class="bp">exact</span>.
<span class="nb">rewrite</span> [RHS](@eq_bigcupr _ _ _ _
    (<span class="kr">fun</span> <span class="nv">i</span> =&gt; [<span class="nb">set</span> x%:E | x <span class="kr">in</span> (f i).<span class="mi">1</span>] `|` (f i).<span class="mi">2</span>)); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">have</span> [_ []] := fi i.
<span class="nb">rewrite</span> bigcupU; <span class="nb">congr</span> (_ `|` _).
<span class="nb">rewrite</span> predeqE =&gt; i /=; <span class="nb">split</span>=&gt; [[r [n _ fn1r &lt;-{i}]]|[n _ [r fn1r &lt;-{i}]]];
 <span class="bp">by</span> [<span class="kr">exists</span> <span class="nv">n</span> =&gt; //; <span class="kr">exists</span> <span class="nv">r</span> | <span class="kr">exists</span> <span class="nv">r</span> =&gt; //; <span class="kr">exists</span> <span class="nv">n</span>].
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">ereal_isMeasurable</span> :
  isMeasurable default_measure_display (\bar R) :=
  isMeasurable.Build _ _ (Pointed.class _)
    emeasurable0 emeasurableC bigcupT_emeasurable.

<span class="kn">End</span> <span class="nf">salgebra_ereal</span>.

<span class="kn">Section</span> <span class="nf">puncture_ereal_itv</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realDomainType.
<span class="kn">Implicit Types</span> (<span class="nv">y</span> : R) (<span class="nv">b</span> : bool).
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">punct_eitv_bnd_pinfty</span> <span class="nv">b</span> <span class="nv">y</span> : [<span class="nb">set</span>` Interval (BSide b y%:E) +oo%O] =
  EFin @` [<span class="nb">set</span>` Interval (BSide b y) +oo%O] `|` [<span class="nb">set</span> +oo].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>; <span class="nb">rewrite</span> /= in_itv andbT.
- <span class="nb">move</span>: x =&gt; [x| |] yxb; [|<span class="bp">by</span> <span class="nb">right</span>|<span class="bp">by</span> <span class="nb">case</span>: b yxb].
  <span class="bp">by</span> <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; <span class="nb">rewrite</span> in_itv /= andbT; <span class="nb">case</span>: b yxb.
- <span class="nb">move</span>=&gt; [[r]|-&gt;].
  + <span class="bp">by</span> <span class="nb">rewrite</span> in_itv /= andbT =&gt; yxb &lt;-; <span class="nb">case</span>: b yxb.
  + <span class="bp">by</span> <span class="nb">case</span>: b =&gt; /=; <span class="nb">rewrite</span> ?(ltry, leey).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">punct_eitv_ninfty_bnd</span> <span class="nv">b</span> <span class="nv">y</span> : [<span class="nb">set</span>` Interval -oo%O (BSide b y%:E)] =
  [<span class="nb">set</span> -oo%E] `|` EFin @` [<span class="nb">set</span> x | x \<span class="kr">in</span> Interval -oo%O (BSide b y)].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>; <span class="nb">rewrite</span> /= in_itv.
- <span class="nb">move</span>: x =&gt; [x| |] yxb; [|<span class="bp">by</span> <span class="nb">case</span>: b yxb|<span class="bp">by</span> <span class="nb">left</span>].
  <span class="bp">by</span> <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; <span class="nb">rewrite</span> in_itv /= andbT; <span class="nb">case</span>: b yxb.
- <span class="nb">move</span>=&gt; [-&gt;|[r]].
  + <span class="bp">by</span> <span class="nb">case</span>: b =&gt; /=; <span class="nb">rewrite</span> ?(ltNyr, leNye).
  + <span class="bp">by</span> <span class="nb">rewrite</span> in_itv /= =&gt; yxb &lt;-; <span class="nb">case</span>: b yxb.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">punct_eitv_setTR</span> : range (@EFin R) `|` [<span class="nb">set</span> +oo] = [<span class="nb">set</span>~ -oo].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [a [[a&#39; _ &lt;-]|-&gt;]|] //.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [x| |] //= _; [<span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">x</span>|<span class="nb">right</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">punct_eitv_setTL</span> : range (@EFin R) `|` [<span class="nb">set</span> -oo] = [<span class="nb">set</span>~ +oo].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [a [[a&#39; _ &lt;-]|-&gt;]|] //.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [x| |] //= _; [<span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">x</span>|<span class="nb">right</span>].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">puncture_ereal_itv</span>.

<span class="kn">Lemma</span> <span class="nf">set1_bigcap_oc</span> (<span class="nv">R</span> : realType) (<span class="nv">r</span> : R) :
   [<span class="nb">set</span> r] = \bigcap_i `]r - i.+<span class="mi">1</span>%:R^-<span class="mi">1</span>, r]%classic.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [x -&gt;|].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i _/=; <span class="nb">rewrite</span> in_itv/= lexx ltr_subl_addr ltr_addl invr_gt0 ltr0n.
<span class="nb">move</span>=&gt; x rx; <span class="nb">apply</span>/esym/eqP; <span class="nb">rewrite</span> eq_le (itvP (rx <span class="mi">0</span>%N _))// andbT.
<span class="nb">apply</span>/ler_addgt0Pl =&gt; e e_gt0; <span class="nb">rewrite</span> -ler_subl_addl ltW//.
<span class="nb">have</span> := rx `|floor e^-<span class="mi">1</span>%R|%N I; <span class="nb">rewrite</span> /= in_itv =&gt; /andP[/le_lt_trans-&gt;]//.
<span class="nb">rewrite</span> ler_add2l ler_opp2 -lef_pinv <span class="nl">?invrK</span>//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> qualifE.
<span class="bp">by</span> <span class="nb">rewrite</span> -natr1 natr_absz ger0_norm <span class="nl">?floor_ge0</span> <span class="nl">?invr_ge0</span> <span class="mi">1</span><span class="nl">?ltW</span>// lt_succ_floor.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">itv_bnd_open_bigcup</span> (<span class="nv">R</span> : realType) <span class="nv">b</span> (<span class="nv">r</span> <span class="nv">s</span> : R) :
  [<span class="nb">set</span>` Interval (BSide b r) (BLeft s)] =
  \bigcup_n [<span class="nb">set</span>` Interval (BSide b r) (BRight (s - n.+<span class="mi">1</span>%:R^-<span class="mi">1</span>))].
<span class="kn">Proof</span>.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; [x/=|]; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; x [n _ /=] /[!in_itv] /andP[-&gt; /le_lt_trans]; <span class="nb">apply</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> ltr_subl_addr ltr_addl invr_gt0 ltr0n.
<span class="nb">rewrite</span> in_itv/= =&gt; /andP[sx xs]; <span class="kr">exists</span> `|ceil ((s - x)^-<span class="mi">1</span>)|%N =&gt; //=.
<span class="nb">rewrite</span> in_itv/= sx/= ler_subr_addl addrC -ler_subr_addl.
<span class="nb">rewrite</span> -[<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X](invrK (s - x)) ler_pinv.
- <span class="nb">rewrite</span> -natr1 natr_absz ger0_norm; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ceil_ge0// invr_ge0 subr_ge0 ltW.
  <span class="bp">by</span> <span class="nb">rewrite</span> (@le_trans _ _ (ceil (s - x)^-<span class="mi">1</span>)%:~R)// <span class="nl">?ler_addl</span>// ceil_ge.
- <span class="bp">by</span> <span class="nb">rewrite</span> inE unitfE ltr0n andbT pnatr_eq0.
- <span class="bp">by</span> <span class="nb">rewrite</span> inE invr_gt0 subr_gt0 xs andbT unitfE invr_eq0 subr_eq0 gt_eqF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">itv_open_bnd_bigcup</span> (<span class="nv">R</span> : realType) <span class="nv">b</span> (<span class="nv">r</span> <span class="nv">s</span> : R) :
  [<span class="nb">set</span>` Interval (BRight s) (BSide b r)] =
  \bigcup_n [<span class="nb">set</span>` Interval (BLeft (s + n.+<span class="mi">1</span>%:R^-<span class="mi">1</span>)) (BSide b r)].
<span class="kn">Proof</span>.
<span class="nb">have</span> /(congr1 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; -%R @` x)) := itv_bnd_open_bigcup (~~ b) (- r) (- s).
<span class="nb">rewrite</span> opp_itv_bnd_bnd/= !opprK negbK =&gt; -&gt;; <span class="nb">rewrite</span> image_bigcup.
<span class="nb">apply</span> eq_bigcupr =&gt; k _; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [_/= [y ysr] &lt;-|x/= xsr].
  <span class="bp">by</span> <span class="nb">rewrite</span> oppr_itv/= opprD.
<span class="bp">by</span> <span class="kr">exists</span> (- x); <span class="nb">rewrite</span> <span class="nl">?oppr_itv</span>//= opprK// negbK opprB opprK addrC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">itv_bnd_infty_bigcup</span> (<span class="nv">R</span> : realType) <span class="nv">b</span> (<span class="nv">x</span> : R) :
  [<span class="nb">set</span>` Interval (BSide b x) +oo%O] =
  \bigcup_i [<span class="nb">set</span>` Interval (BSide b x) (BRight (x + i%:R))].
<span class="kn">Proof</span>.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; y; <span class="nb">rewrite</span> /= !in_itv/= andbT; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [k _ /=]; <span class="nb">move</span>: b =&gt; [|] /=; <span class="nb">rewrite</span> in_itv/= =&gt; /andP[//] /ltW.
<span class="nb">move</span>=&gt; xy; <span class="kr">exists</span> `|ceil (y - x)|%N =&gt; //=; <span class="nb">rewrite</span> in_itv/= xy/= -ler_subl_addl.
<span class="nb">rewrite</span> !natr_absz/= ger0_norm <span class="nl">?ceil_ge0</span> <span class="nl">?subr_ge0</span> <span class="nl">?ceil_ge</span>//.
<span class="bp">by</span> <span class="nb">case</span>: b xy =&gt; //= /ltW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">itv_infty_bnd_bigcup</span> (<span class="nv">R</span> : realType) <span class="nv">b</span> (<span class="nv">x</span> : R) :
  [<span class="nb">set</span>` Interval -oo%O (BSide b x)] =
  \bigcup_i [<span class="nb">set</span>` Interval (BLeft (x - i%:R)) (BSide b x)].
<span class="kn">Proof</span>.
<span class="nb">have</span> /(congr1 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; -%R @` x)) := itv_bnd_infty_bigcup (~~ b) (- x).
<span class="nb">rewrite</span> opp_itv_bnd_infty negbK opprK =&gt; -&gt;; <span class="nb">rewrite</span> image_bigcup.
<span class="nb">apply</span> eq_bigcupr =&gt; k _; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [_ /= -[r rbxk &lt;-]|y/= yxkb].
   <span class="bp">by</span> <span class="nb">rewrite</span> oppr_itv/= opprB addrC.
<span class="bp">by</span> <span class="kr">exists</span> (- y); [<span class="nb">rewrite</span> oppr_itv/= negbK opprD opprK|<span class="nb">rewrite</span> opprK].
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">salgebra_R_ssets</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.

<span class="kn">Definition</span> <span class="nf">measurableTypeR</span> := salgebraType (R.-ocitv.-measurable).
<span class="kn">Definition</span> <span class="nf">measurableR</span> : <span class="nb">set</span> (<span class="nb">set</span> R) :=
  (R.-ocitv.-measurable).-sigma.-measurable.

HB.instance <span class="kn">Definition</span> <span class="nf">R_isMeasurable</span> :
  isMeasurable default_measure_display R :=
  @isMeasurable.Build _ measurableTypeR (Pointed.class R) measurableR
    measurable0 (@measurableC _ _) (@bigcupT_measurable _ _).
<span class="c">(*HB.instance (Real.sort R) R_isMeasurable.*)</span>

<span class="kn">Lemma</span> <span class="nf">measurable_set1</span> (<span class="nv">r</span> : R) : measurable [<span class="nb">set</span> r].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> set1_bigcap_oc; <span class="nb">apply</span>: bigcap_measurable =&gt; k // _.
<span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="bp">exact</span>/is_ocitv.
<span class="kn">Qed</span>.
#[local] <span class="kn">Hint Resolve</span> measurable_set1 : core.

<span class="kn">Lemma</span> <span class="nf">measurable_itv</span> (<span class="nv">i</span> : interval R) : measurable [<span class="nb">set</span>` i].
<span class="kn">Proof</span>.
<span class="nb">have</span> moc (a b : R) : measurable `]a, b]%classic.
  <span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="nb">apply</span>: is_ocitv.
<span class="nb">have</span> mopoo (x : R) : measurable `]x, +oo[%classic.
  <span class="bp">by</span> <span class="nb">rewrite</span> itv_bnd_infty_bigcup; <span class="bp">exact</span>: bigcup_measurable.
<span class="nb">have</span> mnooc (x : R) : measurable `]-oo, x]%classic.
  <span class="bp">by</span> <span class="nb">rewrite</span> -setCitvr; <span class="bp">exact</span>/measurableC.
<span class="nb">have</span> ooE (a b : R) : `]a, b[%classic = `]a, b]%classic `\ b.
  <span class="nb">case</span>: (boolP (a &lt; b)) =&gt; ab; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> !set_itv_ge <span class="nl">?set0D</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -setUitv1// setUDK// =&gt; x [-&gt;]; <span class="nb">rewrite</span> /= in_itv/= ltxx andbF.
<span class="nb">have</span> moo (a b : R) : measurable `]a, b[%classic.
  <span class="bp">by</span> <span class="nb">rewrite</span> ooE; <span class="bp">exact</span>: measurableD.
<span class="nb">have</span> mcc (a b : R) : measurable `[a, b]%classic.
  <span class="nb">case</span>: (boolP (a &lt;= b)) =&gt; ab; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> set_itv_ge.
  <span class="bp">by</span> <span class="nb">rewrite</span> -setU1itv//; <span class="nb">apply</span>/measurableU.
<span class="nb">have</span> mco (a b : R) : measurable `[a, b[%classic.
  <span class="nb">case</span>: (boolP (a &lt; b)) =&gt; ab; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> set_itv_ge.
  <span class="bp">by</span> <span class="nb">rewrite</span> -setU1itv//; <span class="nb">apply</span>/measurableU.
<span class="nb">have</span> oooE (b : R) : `]-oo, b[%classic = `]-oo, b]%classic `\ b.
  <span class="bp">by</span> <span class="nb">rewrite</span> -setUitv1// setUDK// =&gt; x [-&gt;]; <span class="nb">rewrite</span> /= in_itv/= ltxx.
<span class="nb">case</span>: i =&gt; [[[] a|[]] [[] b|[]]] =&gt; //; <span class="kp">do</span> <span class="nl">?by</span> <span class="nb">rewrite</span> set_itv_ge.
- <span class="bp">by</span> <span class="nb">rewrite</span> -setU1itv//; <span class="bp">exact</span>/measurableU.
- <span class="bp">by</span> <span class="nb">rewrite</span> oooE; <span class="bp">exact</span>/measurableD.
- <span class="bp">by</span> <span class="nb">rewrite</span> set_itv_infty_infty.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> :=
  (ereal_isMeasurable (R.-ocitv.-measurable)).
<span class="c">(* NB: Until we dropped support for Coq 8.12, we were using</span>
<span class="c">HB.instance (\bar (Real.sort R))</span>
<span class="c">  (ereal_isMeasurable (@measurable (@itvs_semiRingOfSets R))).</span>
<span class="c">This was producing a warning but the alternative was failing with Coq 8.12 with</span>
<span class="c">  the following message (according to the CI):</span>
<span class="c">  # [redundant-canonical-projection,typechecker]</span>
<span class="c">  # forall (T : measurableType) (f : T -&gt; R), measurable_fun setT f</span>
<span class="c">  #      : Prop</span>
<span class="c">  # File &quot;./theories/lebesgue_measure.v&quot;, line 4508, characters 0-88:</span>
<span class="c">  # Error: Anomaly &quot;Uncaught exception Failure(&quot;sep_last&quot;).&quot;</span>
<span class="c">  # Please report at http://coq.inria.fr/bugs/.</span>
<span class="c">*)</span>

<span class="kn">Lemma</span> <span class="nf">measurable_EFin</span> (<span class="nv">A</span> : <span class="nb">set</span> R) : measurableR A -&gt; measurable (EFin @` A).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mA; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="kr">exists</span> <span class="nv">set0</span>; [<span class="nb">constructor</span>|<span class="nb">rewrite</span> setU0].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_set1</span> (<span class="nv">x</span> : \bar R) : measurable [<span class="nb">set</span> x].
<span class="kn">Proof</span>.
<span class="nb">case</span>: x =&gt; [r| |].
- <span class="bp">by</span> <span class="nb">rewrite</span> -image_set1; <span class="nb">apply</span>: measurable_EFin; <span class="nb">apply</span>: measurable_set1.
- <span class="kr">exists</span> <span class="nv">set0</span> =&gt; //; [<span class="kr">exists</span> [<span class="nb">set</span> +oo%E]; [<span class="bp">by</span> <span class="nb">constructor</span>|]].
  <span class="bp">by</span> <span class="nb">rewrite</span> image_set0 set0U.
- <span class="kr">exists</span> <span class="nv">set0</span> =&gt; //; [<span class="kr">exists</span> [<span class="nb">set</span> -oo%E]; [<span class="bp">by</span> <span class="nb">constructor</span>|]].
  <span class="bp">by</span> <span class="nb">rewrite</span> image_set0 set0U.
<span class="kn">Qed</span>.
#[local] <span class="kn">Hint Resolve</span> emeasurable_set1 : core.

<span class="kn">Lemma</span> <span class="nf">__deprecated__itv_cpinfty_pinfty</span> : `[+oo%E, +oo[%classic = [<span class="nb">set</span> +oo%E] :&gt; <span class="nb">set</span> (\bar R).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> itv_cyy. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed `itv_cyy`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">itv_cpinfty_pinfty</span> := __deprecated__itv_cpinfty_pinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__itv_opinfty_pinfty</span> : `]+oo%E, +oo[%classic = set0 :&gt; <span class="nb">set</span> (\bar R).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> itv_oyy. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed `itv_oyy`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">itv_opinfty_pinfty</span> := __deprecated__itv_opinfty_pinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__itv_cninfty_pinfty</span> : `[-oo%E, +oo[%classic = setT :&gt; <span class="nb">set</span> (\bar R).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> itv_cNyy. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed `itv_cNyy`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">itv_cninfty_pinfty</span> := __deprecated__itv_cninfty_pinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__itv_oninfty_pinfty</span> :
  `]-oo%E, +oo[%classic = ~` [<span class="nb">set</span> -oo]%E :&gt; <span class="nb">set</span> (\bar R).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> itv_oNyy. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed `itv_oNyy`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">itv_oninfty_pinfty</span> := __deprecated__itv_oninfty_pinfty.

<span class="kn">Lemma</span> <span class="nf">emeasurable_itv_bnd_pinfty</span> <span class="nv">b</span> (<span class="nv">y</span> : \bar R) :
  measurable [<span class="nb">set</span>` Interval (BSide b y) +oo%O].
<span class="kn">Proof</span>.
<span class="nb">move</span>: y =&gt; [y| |].
- <span class="kr">exists</span> [<span class="nb">set</span>` Interval (BSide b y) +oo%O]; <span class="kp">first</span> <span class="bp">exact</span>: measurable_itv.
  <span class="bp">by</span> <span class="kr">exists</span> [<span class="nb">set</span> +oo%E]; [<span class="nb">constructor</span>|<span class="nb">rewrite</span> -punct_eitv_bnd_pinfty].
- <span class="bp">by</span> <span class="nb">case</span>: b; <span class="nb">rewrite</span> <span class="nl">?itv_oyy</span> <span class="nl">?itv_cyy</span>.
- <span class="nb">case</span>: b; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> itv_cNyy.
  <span class="bp">by</span> <span class="nb">rewrite</span> itv_oNyy; <span class="bp">exact</span>/measurableC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_itv_ninfty_bnd</span> <span class="nv">b</span> (<span class="nv">y</span> : \bar R) :
  measurable [<span class="nb">set</span>` Interval -oo%O (BSide b y)].
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -setCitvr; <span class="bp">exact</span>/measurableC/emeasurable_itv_bnd_pinfty.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">elebesgue_measure</span> : <span class="nb">set</span> \bar R -&gt; \bar R :=
  <span class="kr">fun</span> <span class="nv">S</span> =&gt; lebesgue_measure (fine @` (S `\` [<span class="nb">set</span> -oo; +oo]%E)).

<span class="kn">Lemma</span> <span class="nf">elebesgue_measure0</span> : elebesgue_measure set0 = <span class="mi">0</span>%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /elebesgue_measure set0D image_set0 measure0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fine</span> (<span class="nv">X</span> : <span class="nb">set</span> \bar R) : measurable X -&gt;
  measurable [<span class="nb">set</span> fine x | x <span class="kr">in</span> X `\` [<span class="nb">set</span> -oo; +oo]%E].
<span class="kn">Proof</span>.
<span class="nb">case</span> =&gt; Y mY [X&#39; [ | &lt;-{X} | &lt;-{X} | &lt;-{X} ]].
- <span class="nb">rewrite</span> setU0 =&gt; &lt;-{X}.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = Y) // predeqE =&gt; r; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; [x [[x&#39; Yx&#39; &lt;-{x}/= _ &lt;-//]]].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Yr; <span class="kr">exists</span> <span class="nv">r</span>%:E; <span class="nb">split</span> =&gt; [|[]//]; <span class="kr">exists</span> <span class="nv">r</span>.
- <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = Y) // predeqE =&gt; r; <span class="nb">split</span>.
    <span class="nb">move</span>=&gt; [x [[[x&#39; Yx&#39; &lt;- _ &lt;-//]|]]].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; &lt;-; <span class="nb">rewrite</span> not_orP =&gt; -[]/(_ erefl).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Yr; <span class="kr">exists</span> <span class="nv">r</span>%:E =&gt; //; <span class="nb">split</span> =&gt; [|[]//]; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">r</span>.
- <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = Y) // predeqE =&gt; r; <span class="nb">split</span>.
    <span class="nb">move</span>=&gt; [x [[[x&#39; Yx&#39; &lt;-{x} _ &lt;-//]|]]].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">rewrite</span> not_orP =&gt; -[_]/(_ erefl).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Yr; <span class="kr">exists</span> <span class="nv">r</span>%:E =&gt; //; <span class="nb">split</span> =&gt; [|[]//]; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">r</span>.
- <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = Y) // predeqE =&gt; r; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> setDUl setDv setU0 =&gt; -[_ [[x&#39; Yx&#39; &lt;-]] _ &lt;-].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Yr; <span class="kr">exists</span> <span class="nv">r</span>%:E =&gt; //; <span class="nb">split</span> =&gt; [|[]//]; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">r</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">elebesgue_measure_ge0</span> <span class="nv">X</span> : (<span class="mi">0</span> &lt;= elebesgue_measure X)%E.
<span class="kn">Proof</span>. <span class="bp">exact</span>/measure_ge0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">semi_sigma_additive_elebesgue_measure</span> :
  semi_sigma_additive elebesgue_measure.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /= F mF tF mUF; <span class="nb">rewrite</span> /elebesgue_measure.
<span class="nb">rewrite</span> [X <span class="kr">in</span> lebesgue_measure X](_ : _ =
    \bigcup_n (fine @` (F n `\` [<span class="nb">set</span> -oo; +oo]%E))); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> predeqE =&gt; r; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; [x [[n _ Fnx xoo &lt;-]]]; <span class="kr">exists</span> <span class="nv">n</span> =&gt; //; <span class="kr">exists</span> <span class="nv">x</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [n _ [x [Fnx xoo &lt;-{r}]]]; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="nb">apply</span>: (@measure_semi_sigma_additive _ _ _ [the <span class="kn">measure</span> _ _ of (@lebesgue_measure R)]
  (<span class="kr">fun</span> <span class="nv">n</span> =&gt; fine @` (F n `\` [<span class="nb">set</span> -oo; +oo]%E))).
- <span class="nb">move</span>=&gt; n; <span class="nb">have</span> := mF n.
  <span class="nb">move</span>=&gt; [X mX [X&#39; mX&#39;]] XX&#39;Fn.
  <span class="nb">apply</span>: measurable_fine.
  <span class="nb">rewrite</span> -XX&#39;Fn.
  <span class="nb">apply</span>: measurableU; <span class="kp">first</span> <span class="bp">exact</span>: measurable_EFin.
  <span class="bp">by</span> <span class="nb">case</span>: mX&#39; =&gt; //; <span class="bp">exact</span>: measurableU.
- <span class="nb">move</span>=&gt; i j _ _ [x [[a [Fia aoo ax] [b [Fjb boo] bx]]]].
  <span class="nb">move</span>: tF =&gt; /(_ i j Logic.I Logic.I); <span class="nb">apply</span>.
  <span class="nb">suff</span> ab : a = b <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">a</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> ab.
  <span class="nb">move</span>: a b {Fia Fjb} aoo boo ax bx.
  <span class="nb">move</span>=&gt; [a| |] [b| |] /=.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; _ _ -&gt; -&gt;.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> not_orP =&gt; -[_]/(_ erefl).
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> not_orP =&gt; -[]/(_ erefl).
  + <span class="bp">by</span> <span class="nb">rewrite</span> not_orP =&gt; -[_]/(_ erefl).
  + <span class="bp">by</span> <span class="nb">rewrite</span> not_orP =&gt; -[_]/(_ erefl).
  + <span class="bp">by</span> <span class="nb">rewrite</span> not_orP =&gt; -[_]/(_ erefl).
  + <span class="bp">by</span> <span class="nb">rewrite</span> not_orP =&gt; -[]/(_ erefl).
  + <span class="bp">by</span> <span class="nb">rewrite</span> not_orP =&gt; -[]/(_ erefl).
  + <span class="bp">by</span> <span class="nb">rewrite</span> not_orP =&gt; -[]/(_ erefl).
- <span class="nb">move</span>: mUF.
  <span class="nb">rewrite</span> {<span class="mi">1</span>}/measurable /emeasurable /= =&gt; -[X mX [Y []]] {Y}.
  - <span class="nb">rewrite</span> setU0 =&gt; h.
    <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = X) // predeqE =&gt; r; <span class="nb">split</span> =&gt; [|Xr].
      <span class="nb">move</span>=&gt; -[n _ [x [Fnx xoo &lt;-{r}]]].
      <span class="nb">have</span> : (\bigcup_n F n) x <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -h =&gt; -[x&#39; Xx&#39; &lt;-].
    <span class="nb">have</span> [n _ Fnr] : (\bigcup_n F n) r%:E <span class="bp">by</span> <span class="nb">rewrite</span> -h; <span class="kr">exists</span> <span class="nv">r</span>.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; //; <span class="kr">exists</span> <span class="nv">r</span>%:E =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">case</span>.
  - <span class="nb">move</span>=&gt; h.
    <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = X) // predeqE =&gt; r; <span class="nb">split</span> =&gt; [|Xr].
      <span class="nb">move</span>=&gt; -[n _ [x [Fnx xoo &lt;-]]].
      <span class="nb">have</span> : (\bigcup_n F n) x <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -h =&gt; -[[x&#39; Xx&#39; &lt;-//]|xoo&#39;]; <span class="nb">move</span>/not_orP : xoo =&gt; -[].
    <span class="nb">have</span> [n _ Fnr] : (\bigcup_n F n) r%:E <span class="bp">by</span> <span class="nb">rewrite</span> -h; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">r</span>.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; //; <span class="kr">exists</span> <span class="nv">r</span>%:E =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">case</span>.
  - <span class="c">(* NB: almost the same as the previous one, factorize?*)</span>
    <span class="nb">move</span>=&gt; h.
    <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = X) // predeqE =&gt; r; <span class="nb">split</span> =&gt; [|Xr].
      <span class="nb">move</span>=&gt; -[n _ [x [Fnx xoo &lt;-]]].
      <span class="nb">have</span> : (\bigcup_n F n) x <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -h =&gt; -[[x&#39; Xx&#39; &lt;-//]|xoo&#39;]; <span class="nb">move</span>/not_orP : xoo =&gt; -[].
    <span class="nb">have</span> [n _ Fnr] : (\bigcup_n F n) r%:E <span class="bp">by</span> <span class="nb">rewrite</span> -h; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">r</span>.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; //; <span class="kr">exists</span> <span class="nv">r</span>%:E =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">case</span>.
  - <span class="nb">move</span>=&gt; h.
    <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = X) // predeqE =&gt; r; <span class="nb">split</span> =&gt; [|Xr].
      <span class="nb">move</span>=&gt; -[n _ [x [Fnx xoo &lt;-]]].
      <span class="nb">have</span> : (\bigcup_n F n) x <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -h =&gt; -[[x&#39; Xx&#39; &lt;-//]|].
    <span class="nb">have</span> [n _ Fnr] : (\bigcup_n F n) r%:E <span class="bp">by</span> <span class="nb">rewrite</span> -h; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">r</span>.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; //; <span class="kr">exists</span> <span class="nv">r</span>%:E =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">case</span>.
<span class="kn">Qed</span>.

HB.instance <span class="kn">Definition</span> <span class="nf">_</span> := isMeasure.Build _ _ _ elebesgue_measure
  elebesgue_measure0 elebesgue_measure_ge0
  semi_sigma_additive_elebesgue_measure.

<span class="kn">End</span> <span class="nf">salgebra_R_ssets</span>.
#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (measurable [<span class="nb">set</span> _]) =&gt; <span class="kp">solve</span> [<span class="nb">apply</span>: measurable_set1|
                                            <span class="nb">apply</span>: emeasurable_set1] : core.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_fine</span> (<span class="nv">R</span> : realType) (<span class="nv">D</span> : <span class="nb">set</span> (\bar R)) : measurable D -&gt;
  measurable_fun D fine.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD _ /= B mB; <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ `&amp;` _ = <span class="kr">if</span> <span class="mi">0</span>%R \<span class="kr">in</span> B <span class="kr">then</span>
    D `&amp;` ((EFin @` B) `|` [<span class="nb">set</span> -oo; +oo]%E) <span class="kr">else</span> D `&amp;` EFin @` B); <span class="nb">last first</span>.
  <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [[r [Dr Br]|[Doo B0]|[Doo B0]]|[r| |]].
  - <span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; _; <span class="nb">split</span> =&gt; //; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">r</span>.
  - <span class="bp">by</span> <span class="nb">rewrite</span> mem_set//; <span class="nb">split</span> =&gt; //; <span class="nb">right</span>; <span class="nb">right</span>.
  - <span class="bp">by</span> <span class="nb">rewrite</span> mem_set//; <span class="nb">split</span> =&gt; //; <span class="nb">right</span>; <span class="nb">left</span>.
  - <span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; [_ [Dr [[s + [sr]]|[]//]]|_ [Dr [s + [sr]]]]; <span class="nb">rewrite</span> sr.
  - <span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; [/[!inE] B0 [Doo [[]//|]] [//|_]|B0 [Doo//] []].
  - <span class="bp">by</span> <span class="nb">case</span>: ifPn =&gt; [/[!inE] B0 [Doo [[]//|]] [//|_]|B0 [Doo//] []].
<span class="nb">case</span>: ifPn =&gt; B0; <span class="nb">apply</span>/measurableI =&gt; //; <span class="nb">last</span> <span class="bp">exact</span>: measurable_EFin.
<span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>: measurable_EFin|<span class="bp">exact</span>: measurableU].
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">lebesgue_measure_itv</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_itvoc</span> (<span class="nv">a</span> <span class="nv">b</span> : R) :
  (lebesgue_measure (`]a, b] : <span class="nb">set</span> R) = hlength `]a, b])%classic.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /lebesgue_measure/= /Hahn_ext measurable_mu_extE//; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">a</span>, b).
<span class="bp">exact</span>: hlength_sigma_sub_additive.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_itvoo_subr1</span> (<span class="nv">a</span> : R) :
  lebesgue_measure (`]a - <span class="mi">1</span>, a[%classic : <span class="nb">set</span> R) = <span class="mi">1</span>%E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> itv_bnd_open_bigcup//; <span class="nb">transitivity</span> (lim (lebesgue_measure \o
    (<span class="kr">fun</span> <span class="nv">k</span> =&gt; `]a - <span class="mi">1</span>, a - k.+<span class="mi">1</span>%:R^-<span class="mi">1</span>]%classic : <span class="nb">set</span> R))).
  <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="nb">apply</span>: nondecreasing_cvg_mu.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: measurable_itv.
  - <span class="bp">by</span> <span class="nb">apply</span>: bigcup_measurable =&gt; k _; <span class="bp">exact</span>: measurable_itv.
  - <span class="nb">move</span>=&gt; n m nm; <span class="nb">apply</span>/subsetPset =&gt; x /=; <span class="nb">rewrite</span> !in_itv/= =&gt; /andP[-&gt;/=].
    <span class="bp">by</span> <span class="nb">move</span>/le_trans; <span class="nb">apply</span>; <span class="nb">rewrite</span> ler_sub// ler_pinv <span class="nl">?ler_nat</span>//;
      <span class="nb">rewrite</span> inE ltr0n andbT unitfE.
<span class="nb">rewrite</span> (_ : _ \o _ = (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (<span class="mi">1</span> - n.+<span class="mi">1</span>%:R^-<span class="mi">1</span>)%:E)); <span class="nb">last first</span>.
  <span class="nb">apply</span>/funext =&gt; n /=; <span class="nb">rewrite</span> lebesgue_measure_itvoc.
  <span class="nb">have</span> [-&gt;|n0] := eqVneq n <span class="mi">0</span>%N; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> invr1 subrr set_itvoc0.
  <span class="nb">rewrite</span> hlength_itv/= lte_fin ifT; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ler_lt_sub// invr_lt1 <span class="nl">?unitfE</span>// ltr1n ltnS lt0n.
  <span class="bp">by</span> <span class="nb">rewrite</span> !(EFinB,EFinN) fin_num_oppeB// addeAC addeA subee// add0e.
<span class="nb">apply</span>/cvg_lim =&gt; //=; <span class="nb">apply</span>/fine_cvgP; <span class="nb">split</span> =&gt; /=; <span class="kp">first</span> <span class="bp">exact</span>: nearW.
<span class="nb">apply</span>/(@cvgrPdist_lt _ [pseudoMetricNormedZmodType R of R^o]) =&gt; _/posnumP[e].
near=&gt; n; <span class="nb">rewrite</span> opprB addrCA subrr addr0 ger0_norm//.
<span class="bp">by</span> near: n; <span class="bp">exact</span>: near_infty_natSinv_lt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lebesgue_measure_set1</span> (<span class="nv">a</span> : R) : lebesgue_measure [<span class="nb">set</span> a] = <span class="mi">0</span>%E.
<span class="kn">Proof</span>.
<span class="nb">suff</span> : (lebesgue_measure (`]a - <span class="mi">1</span>, a]%classic%R : <span class="nb">set</span> R) =
        lebesgue_measure (`]a - <span class="mi">1</span>, a[%classic%R : <span class="nb">set</span> R) +
        lebesgue_measure [<span class="nb">set</span> a])%E.
  <span class="nb">rewrite</span> lebesgue_measure_itvoo_subr1 lebesgue_measure_itvoc =&gt; /eqP.
  <span class="nb">rewrite</span> hlength_itv lte_fin ltr_subl_addr ltr_addl ltr01.
  <span class="nb">rewrite</span> [<span class="kr">in</span> X <span class="kr">in</span> X == _]/= EFinN EFinB fin_num_oppeB// addeA subee// add0e.
  <span class="bp">by</span> <span class="nb">rewrite</span> addeC -sube_eq <span class="nl">?fin_num_adde_defl</span>// subee// =&gt; /eqP.
<span class="nb">rewrite</span> -setUitv1// <span class="nl">?bnd_simp</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltr_subl_addr ltr_addl.
<span class="nb">rewrite</span> measureU//; <span class="kp">first</span> <span class="bp">exact</span>: measurable_itv.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; // x []/=; <span class="nb">rewrite</span> in_itv/= =&gt; + xa.
<span class="bp">by</span> <span class="nb">rewrite</span> xa ltxx andbF.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_itvoo</span> (<span class="nv">a</span> <span class="nv">b</span> : R) :
  (lebesgue_measure (`]a, b[ : <span class="nb">set</span> R) = hlength `]a, b[)%classic.
<span class="kn">Proof</span>.
<span class="nb">have</span> [ab|ba] := ltP a b; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> set_itv_ge <span class="nl">?measure0</span>// -leNgt.
<span class="nb">have</span> := lebesgue_measure_itvoc a b.
<span class="nb">rewrite</span> <span class="mi">2</span>!hlength_itv =&gt; &lt;-; <span class="nb">rewrite</span> -setUitv1// measureU//.
- <span class="bp">by</span> <span class="nb">have</span> /= -&gt; := lebesgue_measure_set1 b; <span class="nb">rewrite</span> adde0.
- <span class="bp">exact</span>: measurable_itv.
- <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; // x [/= + xb]; <span class="nb">rewrite</span> in_itv/= xb ltxx andbF.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_itvcc</span> (<span class="nv">a</span> <span class="nv">b</span> : R) :
  (lebesgue_measure (`[a, b] : <span class="nb">set</span> R) = hlength `[a, b])%classic.
<span class="kn">Proof</span>.
<span class="nb">have</span> [ab|ba] := leP a b; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> set_itv_ge <span class="nl">?measure0</span>// -leNgt.
<span class="nb">have</span> := lebesgue_measure_itvoc a b.
<span class="nb">rewrite</span> <span class="mi">2</span>!hlength_itv =&gt; &lt;-; <span class="nb">rewrite</span> -setU1itv// measureU//.
- <span class="bp">by</span> <span class="nb">have</span> /= -&gt; := lebesgue_measure_set1 a; <span class="nb">rewrite</span> add0e.
- <span class="bp">exact</span>: measurable_itv.
- <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; // x [/= -&gt;]; <span class="nb">rewrite</span> in_itv/= ltxx.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_itvco</span> (<span class="nv">a</span> <span class="nv">b</span> : R) :
  (lebesgue_measure (`[a, b[ : <span class="nb">set</span> R) = hlength `[a, b[)%classic.
<span class="kn">Proof</span>.
<span class="nb">have</span> [ab|ba] := ltP a b; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> set_itv_ge <span class="nl">?measure0</span>// -leNgt.
<span class="nb">have</span> := lebesgue_measure_itvoo a b.
<span class="nb">rewrite</span> <span class="mi">2</span>!hlength_itv =&gt; &lt;-; <span class="nb">rewrite</span> -setU1itv// measureU//.
- <span class="bp">by</span> <span class="nb">have</span> /= -&gt; := lebesgue_measure_set1 a; <span class="nb">rewrite</span> add0e.
- <span class="bp">exact</span>: measurable_itv.
- <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; // x [/= -&gt;]; <span class="nb">rewrite</span> in_itv/= ltxx.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_itv_bnd</span> (<span class="nv">x</span> <span class="nv">y</span> : bool) (<span class="nv">a</span> <span class="nv">b</span> : R) :
  lebesgue_measure ([<span class="nb">set</span>` Interval (BSide x a) (BSide y b)] : <span class="nb">set</span> R) =
  hlength [<span class="nb">set</span>` Interval (BSide x a) (BSide y b)].
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>: x y =&gt; [|] [|]; [<span class="bp">exact</span>: lebesgue_measure_itvco |
  <span class="bp">exact</span>: lebesgue_measure_itvcc | <span class="bp">exact</span>: lebesgue_measure_itvoo |
  <span class="bp">exact</span>: lebesgue_measure_itvoc].
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">limnatR</span> : lim (<span class="kr">fun</span> <span class="nv">k</span> =&gt; (k%:R)%:E : \bar R) = +oo%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>/cvgenyP. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_itv_bnd_infty</span> <span class="nv">x</span> (<span class="nv">a</span> : R) :
  lebesgue_measure ([<span class="nb">set</span>` Interval (BSide x a) +oo%O] : <span class="nb">set</span> R) = +oo%E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> itv_bnd_infty_bigcup; <span class="nb">transitivity</span> (lim (lebesgue_measure \o
    (<span class="kr">fun</span> <span class="nv">k</span> =&gt; [<span class="nb">set</span>` Interval (BSide x a) (BRight (a + k%:R))] : <span class="nb">set</span> R))).
  <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="nb">apply</span>: nondecreasing_cvg_mu.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="bp">exact</span>: measurable_itv.
  + <span class="bp">by</span> <span class="nb">apply</span>: bigcup_measurable =&gt; k _; <span class="bp">exact</span>: measurable_itv.
  + <span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>/subsetPset =&gt; r/=; <span class="nb">rewrite</span> !in_itv/= =&gt; /andP[-&gt;/=].
    <span class="bp">by</span> <span class="nb">move</span>=&gt; /le_trans; <span class="nb">apply</span>; <span class="nb">rewrite</span> ler_add// ler_nat.
<span class="nb">rewrite</span> (_ : _ \o _ = (<span class="kr">fun</span> <span class="nv">k</span> =&gt; k%:R%:E))//.
<span class="nb">apply</span>/funext =&gt; n /=; <span class="nb">rewrite</span> lebesgue_measure_itv_bnd hlength_itv/=.
<span class="nb">rewrite</span> lte_fin;  <span class="nb">have</span> [-&gt;|n0] := eqVneq n <span class="mi">0</span>%N; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> addr0 ltxx.
<span class="bp">by</span> <span class="nb">rewrite</span> ltr_addl ltr0n lt0n n0 EFinD addeAC EFinN subee <span class="nl">?add0e</span>.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">lebesgue_measure_itv_infty_bnd</span> <span class="nv">y</span> (<span class="nv">b</span> : R) :
  lebesgue_measure ([<span class="nb">set</span>` Interval -oo%O (BSide y b)] : <span class="nb">set</span> R) = +oo%E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> itv_infty_bnd_bigcup; <span class="nb">transitivity</span> (lim (lebesgue_measure \o
    (<span class="kr">fun</span> <span class="nv">k</span> =&gt; [<span class="nb">set</span>` Interval (BLeft (b - k%:R)) (BSide y b)] : <span class="nb">set</span> R))).
  <span class="nb">apply</span>/esym/cvg_lim =&gt; //; <span class="nb">apply</span>: nondecreasing_cvg_mu.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="bp">exact</span>: measurable_itv.
  + <span class="bp">by</span> <span class="nb">apply</span>: bigcup_measurable =&gt; k _; <span class="bp">exact</span>: measurable_itv.
  + <span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>/subsetPset =&gt; r/=; <span class="nb">rewrite</span> !in_itv/= =&gt; /andP[+ -&gt;].
    <span class="bp">by</span> <span class="nb">rewrite</span> andbT; <span class="nb">apply</span>: le_trans; <span class="nb">rewrite</span> ler_sub// ler_nat.
<span class="nb">rewrite</span> (_ : _ \o _ = (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; k%:R%:E))//.
<span class="nb">apply</span>/funext =&gt; n /=; <span class="nb">rewrite</span> lebesgue_measure_itv_bnd hlength_itv/= lte_fin.
<span class="nb">have</span> [-&gt;|n0] := eqVneq n <span class="mi">0</span>%N; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> subr0 ltxx.
<span class="nb">rewrite</span> ltr_subl_addr ltr_addl ltr0n lt0n n0 EFinN EFinB fin_num_oppeB// addeA.
<span class="bp">by</span> <span class="nb">rewrite</span> subee// add0e.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lebesgue_measure_itv</span> (<span class="nv">i</span> : interval R) :
  lebesgue_measure ([<span class="nb">set</span>` i] : <span class="nb">set</span> R) = hlength [<span class="nb">set</span>` i].
<span class="kn">Proof</span>.
<span class="nb">move</span>: i =&gt; [[x a|[|]]] [y b|[|]]; <span class="kp">first</span> <span class="bp">exact</span>: lebesgue_measure_itv_bnd.
- <span class="bp">by</span> <span class="nb">rewrite</span> set_itvE <span class="nl">?measure0</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> lebesgue_measure_itv_bnd_infty hlength_bnd_infty.
- <span class="bp">by</span> <span class="nb">rewrite</span> lebesgue_measure_itv_infty_bnd hlength_infty_bnd.
- <span class="bp">by</span> <span class="nb">rewrite</span> set_itvE <span class="nl">?measure0</span>.
- <span class="nb">rewrite</span> set_itvE hlength_setT.
  <span class="nb">rewrite</span> (_ : setT = [<span class="nb">set</span>` `]-oo, <span class="mi">0</span>[] `|` [<span class="nb">set</span>` `[<span class="mi">0</span>, +oo[]); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; // =&gt; x _; <span class="nb">have</span> [x0|x0] := leP <span class="mi">0</span> x; [<span class="nb">right</span>|<span class="nb">left</span>];
      <span class="nb">rewrite</span> /= in_itv//= x0.
  <span class="nb">rewrite</span> measureU//=; <span class="kp">try</span> <span class="bp">exact</span>: measurable_itv.
  + <span class="bp">by</span> <span class="nb">rewrite</span> lebesgue_measure_itv_infty_bnd lebesgue_measure_itv_bnd_infty.
  + <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; // x []/=; <span class="nb">rewrite</span> !in_itv/= andbT leNgt =&gt; -&gt;.
- <span class="bp">by</span> <span class="nb">rewrite</span> set_itvE <span class="nl">?measure0</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> set_itvE <span class="nl">?measure0</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> set_itvE <span class="nl">?measure0</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">lebesgue_measure_itv</span>.

<span class="kn">Lemma</span> <span class="nf">lebesgue_measure_rat</span> (<span class="nv">R</span> : realType) :
  lebesgue_measure (range ratr : <span class="nb">set</span> R) = <span class="mi">0</span>%E.
<span class="kn">Proof</span>.
<span class="nb">have</span> /pcard_eqP/bijPex[f bijf] := card_rat; <span class="nb">set</span> f1 := &#39;pinv_(<span class="kr">fun</span>=&gt; <span class="mi">0</span>) setT f.
<span class="nb">rewrite</span> (_ : range _ = \bigcup_n [<span class="nb">set</span> ratr (f1 n)]); <span class="nb">last first</span>.
  <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; [_ [q _ &lt;-]|_ [n _ /= -&gt;]]; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f1</span> <span class="nv">n</span>).
  <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">q</span>) =&gt; //=; <span class="nb">rewrite</span> /f1 pinvKV// <span class="nl">?in_setE</span>// =&gt; x y _ _.
  <span class="bp">by</span> <span class="nb">apply</span>: bij_inj; <span class="nb">rewrite</span> -setTT_bijective.
<span class="nb">rewrite</span> measure_bigcup//; <span class="nb">last first</span>.
  <span class="nb">apply</span>/trivIsetP =&gt; i j _ _ ij; <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; //= _ [/= -&gt;].
  <span class="nb">move</span>=&gt; /fmorph_inj.
  <span class="nb">have</span> /set_bij_inj /[<span class="nb">apply</span>] := bijpinv_bij (<span class="kr">fun</span>=&gt; <span class="mi">0</span>) bijf.
  <span class="bp">by</span> <span class="nb">rewrite</span> in_setE =&gt; /(_ Logic.I Logic.I); <span class="bp">exact</span>/eqP.
<span class="bp">by</span> <span class="nb">rewrite</span> eseries0// =&gt; n _; <span class="bp">exact</span>: lebesgue_measure_set1.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">measurable_fun_measurable</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Variables</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; \bar R).
<span class="kn">Hypotheses</span> (<span class="nv">mD</span> : measurable D) (<span class="nv">mf</span> : measurable_fun D f).
<span class="kn">Implicit Types</span> <span class="nv">y</span> : \bar R.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_c_infty</span> <span class="nv">y</span> : measurable (D `&amp;` [<span class="nb">set</span> x | y &lt;= f x]).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -preimage_itv_c_infty; <span class="bp">exact</span>/mf/emeasurable_itv_bnd_pinfty.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_o_infty</span> <span class="nv">y</span> :  measurable (D `&amp;` [<span class="nb">set</span> x | y &lt; f x]).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -preimage_itv_o_infty; <span class="bp">exact</span>/mf/emeasurable_itv_bnd_pinfty.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_infty_o</span> <span class="nv">y</span> : measurable (D `&amp;` [<span class="nb">set</span> x | f x &lt; y]).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -preimage_itv_infty_o; <span class="bp">exact</span>/mf/emeasurable_itv_ninfty_bnd.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_infty_c</span> <span class="nv">y</span> : measurable (D `&amp;` [<span class="nb">set</span> x | f x &lt;= y]).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -preimage_itv_infty_c; <span class="bp">exact</span>/mf/emeasurable_itv_ninfty_bnd.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fin_num</span> : measurable (D `&amp;` [<span class="nb">set</span> x | f x \<span class="kr">is</span> a fin_num]).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ =
  \bigcup_k (D `&amp;` ([<span class="nb">set</span>  x | - k%:R%:E &lt;= f x] `&amp;` [<span class="nb">set</span> x | f x &lt;= k%:R%:E]))).
  <span class="nb">apply</span>: bigcupT_measurable =&gt; k; <span class="nb">rewrite</span> -(setIid D) setIACA.
  <span class="bp">by</span> <span class="nb">apply</span>: measurableI; [<span class="bp">exact</span>: emeasurable_fun_c_infty|
                          <span class="bp">exact</span>: emeasurable_fun_infty_c].
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [/= [Dt ft]|].
  <span class="nb">have</span> [ft0|ft0] := leP <span class="mi">0</span>%R (fine (f t)).
    <span class="kr">exists</span> `|ceil (fine (f t))|%N =&gt; //=; <span class="nb">split</span> =&gt; //; <span class="nb">split</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}(fineK ft)// lee_fin (le_trans _ ft0)// ler_oppl oppr0.
    <span class="bp">by</span> <span class="nb">rewrite</span> natr_absz ger0_norm <span class="nl">?ceil_ge0</span>// -(fineK ft) lee_fin ceil_ge.
  <span class="kr">exists</span> `|floor (fine (f t))|%N =&gt; //=; <span class="nb">split</span> =&gt; //; <span class="nb">split</span>.
    <span class="nb">rewrite</span> natr_absz ltr0_norm <span class="nl">?floor_lt0</span>// EFinN.
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}(fineK ft) lee_fin mulrNz opprK floor_le.
  <span class="bp">by</span> <span class="nb">rewrite</span> -(fineK ft)// lee_fin (le_trans (ltW ft0)).
<span class="nb">move</span>=&gt; [n _] [/= Dt [nft fnt]]; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> fin_numElt.
<span class="bp">by</span> <span class="nb">rewrite</span> (lt_le_trans _ nft) <span class="nl">?ltNyr</span>//= (le_lt_trans fnt)// ltry.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_neq</span> <span class="nv">y</span> : measurable (D `&amp;` [<span class="nb">set</span> x | f x != y]).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (_ : [<span class="nb">set</span> x | f x != y] = f @^-<span class="mi">1</span>` (setT `\ y)).
  <span class="bp">exact</span>/mf/measurableD.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> /preimage /= =&gt; -[_ /eqP].
<span class="bp">by</span> <span class="nb">rewrite</span> /= =&gt; ft0; <span class="nb">rewrite</span> /preimage /=; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>/eqP.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measurable_fun_measurable</span>.

<span class="kn">Module</span> <span class="nf">RGenOInfty</span>.
<span class="kn">Section</span> <span class="nf">rgenoinfty</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : R.

<span class="kn">Definition</span> <span class="nf">G</span> := [<span class="nb">set</span> A | <span class="kr">exists</span> <span class="nv">x</span>, A = `]x, +oo[%classic].

<span class="kn">Lemma</span> <span class="nf">measurable_itv_bnd_infty</span> <span class="nv">b</span> <span class="nv">x</span> :
  G.-sigma.-measurable [<span class="nb">set</span>` Interval (BSide b x) +oo%O].
<span class="kn">Proof</span>.
<span class="nb">case</span>: b; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="nb">eexists</span>; <span class="bp">reflexivity</span>.
<span class="nb">rewrite</span> itv_c_inftyEbigcap; <span class="nb">apply</span>: bigcapT_measurable =&gt; k.
<span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="nb">eexists</span>; <span class="bp">reflexivity</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_itv_bounded</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> : a != +oo%O -&gt;
  G.-sigma.-measurable [<span class="nb">set</span>` Interval a (BSide b x)].
<span class="kn">Proof</span>.
<span class="nb">case</span>: a =&gt; [a r _|[_|//]].
  <span class="bp">by</span> <span class="nb">rewrite</span> set_itv_splitD; <span class="nb">apply</span>: measurableD =&gt; //;
    <span class="bp">exact</span>: measurable_itv_bnd_infty.
<span class="bp">by</span> <span class="nb">rewrite</span> -setCitvr; <span class="nb">apply</span>: measurableC; <span class="nb">apply</span>: measurable_itv_bnd_infty.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurableE</span> :
  (R.-ocitv.-measurable).-sigma.-measurable = G.-sigma.-measurable.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; A.
  <span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; I [x _ &lt;-]; <span class="bp">exact</span>: measurable_itv_bounded.
<span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
<span class="bp">by</span> <span class="nb">move</span>=&gt; A&#39; /= [x -&gt;]; <span class="bp">exact</span>: measurable_itv.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">rgenoinfty</span>.
<span class="kn">End</span> <span class="nf">RGenOInfty</span>.

<span class="kn">Module</span> <span class="nf">RGenInftyO</span>.
<span class="kn">Section</span> <span class="nf">rgeninftyo</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : R.

<span class="kn">Definition</span> <span class="nf">G</span> := [<span class="nb">set</span> A | <span class="kr">exists</span> <span class="nv">x</span>, A = `]-oo, x[%classic].

<span class="kn">Lemma</span> <span class="nf">measurable_itv_bnd_infty</span> <span class="nv">b</span> <span class="nv">x</span> :
  G.-sigma.-measurable [<span class="nb">set</span>` Interval -oo%O (BSide b x)].
<span class="kn">Proof</span>.
<span class="nb">case</span>: b; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span> sub_sigma_algebra; <span class="nb">eexists</span>; <span class="bp">reflexivity</span>.
<span class="nb">rewrite</span> -setCitvr itv_o_inftyEbigcup; <span class="nb">apply</span>/measurableC/bigcupT_measurable =&gt; n.
<span class="nb">rewrite</span> -setCitvl; <span class="nb">apply</span>: measurableC.
<span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="nb">eexists</span>; <span class="bp">reflexivity</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_itv_bounded</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> : a != -oo%O -&gt;
  G.-sigma.-measurable [<span class="nb">set</span>` Interval (BSide b x) a].
<span class="kn">Proof</span>.
<span class="nb">case</span>: a =&gt; [a r _|[//|_]].
  <span class="bp">by</span> <span class="nb">rewrite</span> set_itv_splitD; <span class="nb">apply</span>/measurableD =&gt; //;
     <span class="nb">rewrite</span> -setCitvl; <span class="nb">apply</span>: measurableC; <span class="bp">exact</span>: measurable_itv_bnd_infty.
<span class="bp">by</span> <span class="nb">rewrite</span> -setCitvl; <span class="nb">apply</span>: measurableC; <span class="nb">apply</span>: measurable_itv_bnd_infty.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurableE</span> :
  (R.-ocitv.-measurable).-sigma.-measurable = G.-sigma.-measurable.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; A.
  <span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; I [x _ &lt;-]; <span class="nb">apply</span>: measurable_itv_bounded.
<span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
<span class="bp">by</span> <span class="nb">move</span>=&gt; A&#39; /= [x -&gt;]; <span class="nb">apply</span>: measurable_itv.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">rgeninftyo</span>.
<span class="kn">End</span> <span class="nf">RGenInftyO</span>.

<span class="kn">Module</span> <span class="nf">RGenCInfty</span>.
<span class="kn">Section</span> <span class="nf">rgencinfty</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : R.

<span class="kn">Definition</span> <span class="nf">G</span> : <span class="nb">set</span> (<span class="nb">set</span> R) := [<span class="nb">set</span> A | <span class="kr">exists</span> <span class="nv">x</span>, A = `[x, +oo[%classic].

<span class="kn">Lemma</span> <span class="nf">measurable_itv_bnd_infty</span> <span class="nv">b</span> <span class="nv">x</span> :
  G.-sigma.-measurable [<span class="nb">set</span>` Interval (BSide b x) +oo%O].
<span class="kn">Proof</span>.
<span class="nb">case</span>: b; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">rewrite</span> set_itv_c_infty.
<span class="nb">rewrite</span> itv_o_inftyEbigcup; <span class="nb">apply</span>: bigcupT_measurable =&gt; k.
<span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="nb">eexists</span>; <span class="bp">reflexivity</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_itv_bounded</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">y</span> : a != +oo%O -&gt;
  G.-sigma.-measurable [<span class="nb">set</span>` Interval a (BSide b y)].
<span class="kn">Proof</span>.
<span class="nb">case</span>: a =&gt; [a r _|[_|//]].
  <span class="nb">rewrite</span> set_itv_splitD.
  <span class="bp">by</span> <span class="nb">apply</span>: measurableD; <span class="nb">apply</span>: measurable_itv_bnd_infty.
<span class="bp">by</span> <span class="nb">rewrite</span> -setCitvr; <span class="nb">apply</span>: measurableC; <span class="nb">apply</span>: measurable_itv_bnd_infty.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurableE</span> :
  (R.-ocitv.-measurable).-sigma.-measurable = G.-sigma.-measurable.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; A.
  <span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; I [x _ &lt;-]; <span class="nb">apply</span>: measurable_itv_bounded.
<span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
<span class="bp">by</span> <span class="nb">move</span>=&gt; A&#39; /= [x -&gt;]; <span class="nb">apply</span>: measurable_itv.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">rgencinfty</span>.
<span class="kn">End</span> <span class="nf">RGenCInfty</span>.

<span class="kn">Module</span> <span class="nf">RGenOpens</span>.
<span class="kn">Section</span> <span class="nf">rgenopens</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : R.

<span class="kn">Definition</span> <span class="nf">G</span> := [<span class="nb">set</span> A | <span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span>, A = `]x, y[%classic].

<span class="kn">Local Lemma</span> <span class="nf">measurable_itvoo</span> <span class="nv">x</span> <span class="nv">y</span> : G.-sigma.-measurable `]x, y[%classic.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span> sub_sigma_algebra; <span class="nb">eexists</span>; <span class="nb">eexists</span>; <span class="bp">reflexivity</span>. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">measurable_itv_o_infty</span> <span class="nv">x</span> : G.-sigma.-measurable `]x, +oo[%classic.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> itv_bnd_inftyEbigcup; <span class="nb">apply</span>: bigcupT_measurable =&gt; i.
<span class="bp">exact</span>: measurable_itvoo.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_itv_bnd_infty</span> <span class="nv">b</span> <span class="nv">x</span> :
  G.-sigma.-measurable [<span class="nb">set</span>` Interval (BSide b x) +oo%O].
<span class="kn">Proof</span>.
<span class="nb">case</span>: b; <span class="nb">last</span> <span class="bp">exact</span>: measurable_itv_o_infty.
<span class="nb">rewrite</span> itv_c_inftyEbigcap; <span class="nb">apply</span>: bigcapT_measurable =&gt; k.
<span class="bp">exact</span>: measurable_itv_o_infty.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_itv_infty_bnd</span> <span class="nv">b</span> <span class="nv">x</span> :
  G.-sigma.-measurable [<span class="nb">set</span>` Interval -oo%O (BSide b x)].
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -setCitvr; <span class="nb">apply</span>: measurableC; <span class="bp">exact</span>: measurable_itv_bnd_infty.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_itv_bounded</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span> <span class="nv">y</span> :
  G.-sigma.-measurable [<span class="nb">set</span>` Interval (BSide a x) (BSide b y)].
<span class="kn">Proof</span>.
<span class="nb">move</span>: a b =&gt; [] []; <span class="nb">rewrite</span> -[X <span class="kr">in</span> measurable X]setCK setCitv;
  <span class="nb">apply</span>: measurableC; <span class="nb">apply</span>: measurableU; <span class="kp">try</span> <span class="kp">solve</span>[
    <span class="bp">exact</span>: measurable_itv_infty_bnd|<span class="bp">exact</span>: measurable_itv_bnd_infty].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurableE</span> :
  (R.-ocitv.-measurable).-sigma.-measurable = G.-sigma.-measurable.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; A.
  <span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; I [x _ &lt;-]; <span class="nb">apply</span>: measurable_itv_bounded.
<span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
<span class="bp">by</span> <span class="nb">move</span>=&gt; A&#39; /= [x [y -&gt;]]; <span class="nb">apply</span>: measurable_itv.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">rgenopens</span>.
<span class="kn">End</span> <span class="nf">RGenOpens</span>.

<span class="kn">Section</span> <span class="nf">erealwithrays</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : \bar R) (<span class="nv">r</span> <span class="nv">s</span> : R).
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">EFin_itv_bnd_infty</span> <span class="nv">b</span> <span class="nv">r</span> : EFin @` [<span class="nb">set</span>` Interval (BSide b r) +oo%O] =
  [<span class="nb">set</span>` Interval (BSide b r%:E) +oo%O] `\ +oo.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [x [s /itvP rs &lt;-]|x []].
  <span class="nb">split</span> =&gt; //=; <span class="nb">rewrite</span> in_itv /=.
  <span class="bp">by</span> <span class="nb">case</span>: b <span class="kr">in</span> rs *; <span class="nb">rewrite</span> /= ?(lee_fin, lte_fin) rs.
<span class="nb">move</span>: x =&gt; [s|_ /(_ erefl)|] //=; <span class="nb">rewrite</span> in_itv /= andbT; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">case</span>: b =&gt; /=; <span class="nb">rewrite</span> <span class="mi">1</span>?(leNgt,ltNge) <span class="mi">1</span>?(ltNyr, leNye).
<span class="bp">by</span> <span class="nb">case</span>: b =&gt; /=; <span class="nb">rewrite</span> <span class="mi">1</span>?(lte_fin,lee_fin) =&gt; rs _;
  <span class="kr">exists</span> <span class="nv">s</span> =&gt; //; <span class="nb">rewrite</span> in_itv /= rs.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">EFin_itv</span> <span class="nv">r</span> : [<span class="nb">set</span> s | r%:E &lt; s%:E] = `]r, +oo[%classic.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; s; <span class="nb">split</span> =&gt; [|]; <span class="nb">rewrite</span> /= lte_fin in_itv/= andbT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">preimage_EFin_setT</span> : @EFin R @^-<span class="mi">1</span>` [<span class="nb">set</span> x | x \<span class="kr">in</span> `]-oo%E, +oo[] = setT.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> set_itvE predeqE =&gt; r; <span class="nb">split</span>=&gt; // _; <span class="nb">rewrite</span> /preimage /= ltNyr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eitv_bnd_infty</span> <span class="nv">b</span> <span class="nv">r</span> : `[r%:E, +oo[%classic =
  \bigcap_k [<span class="nb">set</span>` Interval (BSide b (r - k.+<span class="mi">1</span>%:R^-<span class="mi">1</span>)%:E) +oo%O] :&gt; <span class="nb">set</span> _.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [|].
- <span class="nb">move</span>: x =&gt; [s /=| _ n _|//].
  + <span class="nb">rewrite</span> in_itv /= andbT lee_fin =&gt; rs n _ /=; <span class="nb">rewrite</span> in_itv/= andbT.
    <span class="nb">case</span>: b =&gt; /=.
    * <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin ler_subl_addl (le_trans rs)// ler_addr.
    * <span class="bp">by</span> <span class="nb">rewrite</span> lte_fin ltr_subl_addl (le_lt_trans rs)// ltr_addr.
  + <span class="bp">by</span> <span class="nb">rewrite</span> /= in_itv /= andbT; <span class="nb">case</span>: b =&gt; /=; <span class="nb">rewrite</span> lteey.
- <span class="nb">move</span>: x =&gt; [s| |/(_ <span class="mi">0</span>%N Logic.I)] /=; <span class="nb">rewrite</span> <span class="nl">?in_itv</span>/= <span class="nl">?leey</span>//; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">case</span>: b.
  <span class="nb">move</span>=&gt; h; <span class="nb">rewrite</span> lee_fin leNgt andbT; <span class="nb">apply</span>/negP =&gt; /ltr_add_invr[k skr].
  <span class="nb">have</span> {h} := h k Logic.I; <span class="nb">rewrite</span> /= in_itv /= andbT; <span class="nb">case</span>: b =&gt; /=.
  + <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin ler_subl_addr leNgt skr.
  + <span class="bp">by</span> <span class="nb">rewrite</span> lte_fin ltr_subl_addr ltNge (ltW skr).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eitv_infty_bnd</span> <span class="nv">b</span> <span class="nv">r</span> : `]-oo, r%:E]%classic =
  \bigcap_k [<span class="nb">set</span>` Interval -oo%O (BSide b (r%:E + k.+<span class="mi">1</span>%:R^-<span class="mi">1</span>%:E))] :&gt; <span class="nb">set</span> _.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [|].
- <span class="nb">move</span>: x =&gt; [s /=|//|_ n _].
  + <span class="nb">rewrite</span> in_itv /= lee_fin =&gt; sr n _; <span class="nb">rewrite</span> /= in_itv /= -EFinD.
    <span class="nb">case</span>: b =&gt; /=.
    * <span class="bp">by</span> <span class="nb">rewrite</span> lte_fin (le_lt_trans sr)// ltr_addl.
    * <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin (le_trans sr)// ler_addl.
  + <span class="bp">by</span> <span class="nb">rewrite</span> /= in_itv /= -EFinD; <span class="nb">case</span>: b =&gt; //=; <span class="nb">rewrite</span> lteNye.
- <span class="nb">move</span>: x =&gt; [s|/(_ <span class="mi">0</span>%N Logic.I)|]/=; <span class="nb">rewrite</span> !in_itv/= <span class="nl">?leNye</span>//; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">case</span>: b.
  <span class="nb">move</span>=&gt; h; <span class="nb">rewrite</span> lee_fin leNgt; <span class="nb">apply</span>/negP =&gt; /ltr_add_invr[k rks].
  <span class="nb">have</span> {h} := h k Logic.I; <span class="nb">rewrite</span> /= in_itv /= -EFinD; <span class="nb">case</span>: b =&gt; /=.
  + <span class="bp">by</span> <span class="nb">rewrite</span> lte_fin ltNge (ltW rks).
  + <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin leNgt rks.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eset1_ninfty</span> :
  [<span class="nb">set</span> -oo] = \bigcap_k `]-oo, (-k%:R%:E)[%classic :&gt; <span class="nb">set</span> (\bar R).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; [_ -&gt; i _ |]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /= in_itv /= ltNyr.
<span class="nb">move</span>=&gt; [r|/(_ O Logic.I)|]//.
<span class="nb">move</span>=&gt; /(_ `|floor r|%N Logic.I); <span class="nb">rewrite</span> /= in_itv/= ltNge.
<span class="nb">rewrite</span> lee_fin; <span class="nb">have</span> [r0|r0] := leP <span class="mi">0</span>%R r.
  <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans _ r0) // ler_oppl oppr0 ler0n.
<span class="nb">rewrite</span> ler_oppl -abszN natr_absz gtr0_norm; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> ltr_oppr oppr0 floor_lt0.
<span class="bp">by</span> <span class="nb">rewrite</span> mulrNz ler_oppl opprK floor_le.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eset1_pinfty</span> :
  [<span class="nb">set</span> +oo] = \bigcap_k `]k%:R%:E, +oo[%classic :&gt; <span class="nb">set</span> (\bar R).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; [_ -&gt; i _/=|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> in_itv /= ltry.
<span class="nb">move</span>=&gt; [r| |/(_ O Logic.I)] // /(_ `|ceil r|%N Logic.I); <span class="nb">rewrite</span> /= in_itv /=.
<span class="nb">rewrite</span> andbT lte_fin ltNge.
<span class="nb">have</span> [r0|r0] := ltP <span class="mi">0</span>%R r; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans r0).
<span class="bp">by</span> <span class="nb">rewrite</span> natr_absz gtr0_norm // <span class="nl">?ceil_ge</span>// ceil_gt0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">erealwithrays</span>.

<span class="kn">Module</span> <span class="nf">ErealGenOInfty</span>.
<span class="kn">Section</span> <span class="nf">erealgenoinfty</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : \bar R) (<span class="nv">r</span> <span class="nv">s</span> : R).

<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Definition</span> <span class="nf">G</span> := [<span class="nb">set</span> A : <span class="nb">set</span> \bar R | <span class="kr">exists</span> <span class="nv">r</span>, A = `]r%:E, +oo[%classic].

<span class="kn">Lemma</span> <span class="nf">measurable_set1_ninfty</span> : G.-sigma.-measurable [<span class="nb">set</span> -oo].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eset1_ninfty; <span class="nb">apply</span>: bigcap_measurable =&gt; i _.
<span class="nb">rewrite</span> -setCitvr; <span class="nb">apply</span>: measurableC; <span class="nb">rewrite</span> (eitv_bnd_infty false).
<span class="nb">apply</span>: bigcap_measurable =&gt; j _; <span class="nb">apply</span>: sub_sigma_algebra.
<span class="bp">by</span> <span class="kr">exists</span> (- (i%:R + j.+<span class="mi">1</span>%:R^-<span class="mi">1</span>))%R; <span class="nb">rewrite</span> opprD.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_set1_pinfty</span> : G.-sigma.-measurable [<span class="nb">set</span> +oo].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eset1_pinfty; <span class="nb">apply</span>: bigcapT_measurable =&gt; i.
<span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="kr">exists</span> <span class="nv">i</span>%:R.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurableE</span> : emeasurable (R.-ocitv.-measurable) = G.-sigma.-measurable.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">apply</span>: smallest_sub.
    <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: emeasurable0.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> setTD; <span class="bp">exact</span>: emeasurableC.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: bigcupT_emeasurable.
  <span class="nb">move</span>=&gt; _ [r -&gt;]; <span class="nb">rewrite</span> /emeasurable /=.
  <span class="kr">exists</span> `]r, +oo[%classic.
    <span class="nb">rewrite</span> RGenOInfty.measurableE.
    <span class="bp">exact</span>: RGenOInfty.measurable_itv_bnd_infty.
  <span class="bp">by</span> <span class="kr">exists</span> [<span class="nb">set</span> +oo]; [<span class="nb">constructor</span>|<span class="nb">rewrite</span> -punct_eitv_bnd_pinfty].
<span class="nb">move</span>=&gt; A [B mB [C mC]] &lt;-; <span class="nb">apply</span>: measurableU; <span class="nb">last first</span>.
  <span class="nb">case</span>: mC; [<span class="bp">by</span> []|<span class="bp">exact</span>: measurable_set1_ninfty
                  |<span class="bp">exact</span>: measurable_set1_pinfty|].
  - <span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>: measurable_set1_ninfty|
                            <span class="bp">exact</span>: measurable_set1_pinfty].
<span class="nb">rewrite</span> RGenOInfty.measurableE <span class="kr">in</span> mB.
<span class="nb">have</span> smB := smallest_sub _ _ mB.
<span class="c">(* BUG: elim/smB : _. fails !! *)</span>
<span class="nb">apply</span>: (smB (G.-sigma.-measurable \o (image^~ EFin))); <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; _ [r -&gt;]/=; <span class="nb">rewrite</span> EFin_itv_bnd_infty; <span class="nb">apply</span>: measurableD.
    <span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra =&gt; /=; <span class="kr">exists</span> <span class="nv">r</span>.
  <span class="bp">exact</span>: measurable_set1_pinfty.
<span class="nb">split</span>=&gt; /= [|D mD|F mF]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> image_set0.
- <span class="nb">rewrite</span> setTD EFin_setC; <span class="nb">apply</span>: measurableD; <span class="kp">first</span> <span class="bp">exact</span>: measurableC.
  <span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>: measurable_set1_ninfty|
                          <span class="bp">exact</span>: measurable_set1_pinfty].
- <span class="bp">by</span> <span class="nb">rewrite</span> EFin_bigcup; <span class="nb">apply</span>: bigcup_measurable =&gt; i _ ; <span class="bp">exact</span>: mF.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">erealgenoinfty</span>.
<span class="kn">End</span> <span class="nf">ErealGenOInfty</span>.

<span class="kn">Module</span> <span class="nf">ErealGenCInfty</span>.
<span class="kn">Section</span> <span class="nf">erealgencinfty</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : \bar R) (<span class="nv">r</span> <span class="nv">s</span> : R).
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Definition</span> <span class="nf">G</span> := [<span class="nb">set</span> A : <span class="nb">set</span> \bar R | <span class="kr">exists</span> <span class="nv">r</span>, A = `[r%:E, +oo[%classic].

<span class="kn">Lemma</span> <span class="nf">measurable_set1_ninfty</span> : G.-sigma.-measurable [<span class="nb">set</span> -oo].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eset1_ninfty; <span class="nb">apply</span>: bigcapT_measurable=&gt; i; <span class="nb">rewrite</span> -setCitvr.
<span class="bp">by</span> <span class="nb">apply</span>: measurableC; <span class="nb">apply</span>: sub_sigma_algebra; <span class="kr">exists</span> (- i%:R)%R.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_set1_pinfty</span> : G.-sigma.-measurable [<span class="nb">set</span> +oo].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eset1_pinfty; <span class="nb">apply</span>: bigcap_measurable =&gt; i _.
<span class="nb">rewrite</span> -setCitvl; <span class="nb">apply</span>: measurableC; <span class="nb">rewrite</span> (eitv_infty_bnd true).
<span class="nb">apply</span>: bigcap_measurable =&gt; j _; <span class="nb">rewrite</span> -setCitvr; <span class="nb">apply</span>: measurableC.
<span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="kr">exists</span> (<span class="nv">i</span>%:R + j.+<span class="mi">1</span>%:R^-<span class="mi">1</span>)%R.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurableE</span> : emeasurable (R.-ocitv.-measurable) = G.-sigma.-measurable.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">apply</span>: smallest_sub.
    <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: emeasurable0.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> setTD; <span class="bp">exact</span>: emeasurableC.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: bigcupT_emeasurable.
  <span class="nb">move</span>=&gt; _ [r -&gt;]/=; <span class="kr">exists</span> `[r, +oo[%classic.
    <span class="nb">rewrite</span> RGenOInfty.measurableE.
    <span class="bp">exact</span>: RGenOInfty.measurable_itv_bnd_infty.
  <span class="bp">by</span> <span class="kr">exists</span> [<span class="nb">set</span> +oo]; [<span class="nb">constructor</span> | <span class="nb">rewrite</span> -punct_eitv_bnd_pinfty].
<span class="nb">move</span>=&gt; _ [A&#39; mA&#39; [C mC]] &lt;-; <span class="nb">apply</span>: measurableU; <span class="nb">last first</span>.
  <span class="nb">case</span>: mC; [<span class="bp">by</span> []|<span class="bp">exact</span>: measurable_set1_ninfty|
                   <span class="bp">exact</span>: measurable_set1_pinfty|].
  <span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>: measurable_set1_ninfty|
                          <span class="bp">exact</span>: measurable_set1_pinfty].
<span class="nb">rewrite</span> RGenCInfty.measurableE <span class="kr">in</span> mA&#39;.
<span class="nb">have</span> smA&#39; := smallest_sub _ _ mA&#39;.
<span class="c">(* BUG: elim/smA&#39; : _. fails !! *)</span>
<span class="nb">apply</span>: (smA&#39; (G.-sigma.-measurable \o (image^~ EFin))); <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; _ [r -&gt;]/=; <span class="nb">rewrite</span> EFin_itv_bnd_infty; <span class="nb">apply</span>: measurableD.
    <span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra =&gt; /=; <span class="kr">exists</span> <span class="nv">r</span>.
  <span class="bp">exact</span>: measurable_set1_pinfty.
<span class="nb">split</span>=&gt; /= [|D mD|F mF]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> image_set0.
- <span class="nb">rewrite</span> setTD EFin_setC; <span class="nb">apply</span>: measurableD; <span class="kp">first</span> <span class="bp">exact</span>: measurableC.
  <span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>: measurable_set1_ninfty|
                          <span class="bp">exact</span>: measurable_set1_pinfty].
- <span class="bp">by</span> <span class="nb">rewrite</span> EFin_bigcup; <span class="nb">apply</span>: bigcup_measurable =&gt; i _; <span class="bp">exact</span>: mF.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">erealgencinfty</span>.
<span class="kn">End</span> <span class="nf">ErealGenCInfty</span>.

<span class="kn">Module</span> <span class="nf">ErealGenInftyO</span>.
<span class="kn">Section</span> <span class="nf">erealgeninftyo</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.

<span class="kn">Definition</span> <span class="nf">G</span> := [<span class="nb">set</span> A : <span class="nb">set</span> \bar R | <span class="kr">exists</span> <span class="nv">r</span>, A = `]-oo, r%:E[%classic].

<span class="kn">Lemma</span> <span class="nf">measurableE</span> : emeasurable (R.-ocitv.-measurable) = G.-sigma.-measurable.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> ErealGenCInfty.measurableE eqEsubset; <span class="nb">split</span> =&gt; A.
  <span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
  <span class="nb">move</span>=&gt; _ [x -&gt;]; <span class="nb">rewrite</span> -[X <span class="kr">in</span> _.-measurable X]setCK; <span class="nb">apply</span>: measurableC.
  <span class="bp">by</span> <span class="nb">apply</span>: sub_sigma_algebra; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">rewrite</span> setCitvr.
<span class="nb">apply</span>: smallest_sub; <span class="kp">first</span> <span class="bp">exact</span>: smallest_sigma_algebra.
<span class="nb">move</span>=&gt; x Gx; <span class="nb">rewrite</span> -(setCK x); <span class="nb">apply</span>: measurableC; <span class="nb">apply</span>: sub_sigma_algebra.
<span class="bp">by</span> <span class="nb">case</span>: Gx =&gt; y -&gt;; <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">rewrite</span> setCitvl.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">erealgeninftyo</span>.
<span class="kn">End</span> <span class="nf">ErealGenInftyO</span>.

<span class="kn">Section</span> <span class="nf">trace</span>.
<span class="kn">Variable</span> (<span class="nv">T</span> : <span class="kt">Type</span>).
<span class="kn">Implicit Types</span> (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">A</span> <span class="nv">D</span> : <span class="nb">set</span> T).

<span class="c">(* intended as a trace sigma-algebra *)</span>
<span class="kn">Definition</span> <span class="nf">strace</span> <span class="nv">G</span> <span class="nv">D</span> := [<span class="nb">set</span> x `&amp;` D | x <span class="kr">in</span> G].

<span class="kn">Lemma</span> <span class="nf">stracexx</span> <span class="nv">G</span> <span class="nv">D</span> : G D -&gt; strace G D D.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /strace /=; <span class="kr">exists</span> <span class="nv">D</span> =&gt; //; <span class="nb">rewrite</span> setIid. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sigma_algebra_strace</span> <span class="nv">G</span> <span class="nv">D</span> :
  sigma_algebra setT G -&gt; sigma_algebra D (strace G D).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [G0 GC GU]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">set0</span> =&gt; //; <span class="nb">rewrite</span> set0I.
- <span class="nb">move</span>=&gt; S [A mA ADS]; <span class="nb">have</span> mCA := GC _ mA.
  <span class="nb">have</span> : strace G D (D `&amp;` ~` A).
    <span class="bp">by</span> <span class="nb">rewrite</span> setIC; <span class="kr">exists</span> (<span class="nv">setT</span> `\` A) =&gt; //; <span class="nb">rewrite</span> setTD.
  <span class="nb">rewrite</span> -setDE =&gt; trDA.
  <span class="nb">have</span> DADS : D `\` A = D `\` S <span class="bp">by</span> <span class="nb">rewrite</span> -ADS !setDE setCI setIUr setICr setU0.
  <span class="bp">by</span> <span class="nb">rewrite</span> DADS <span class="kr">in</span> trDA.
- <span class="nb">move</span>=&gt; S mS; <span class="nb">have</span> /choice[M GM] : <span class="kr">forall</span> <span class="nv">n</span>, <span class="kr">exists</span> <span class="nv">A</span>, G A /\ S n = A `&amp;` D.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">have</span> [A mA ADSn] := mS n; <span class="kr">exists</span> <span class="nv">A</span>.
  <span class="kr">exists</span> (\bigcup_i (M i)); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span> GU =&gt; i;  <span class="bp">exact</span>: (GM i).<span class="mi">1</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> setI_bigcupl; <span class="nb">apply</span> eq_bigcupr =&gt; i _; <span class="nb">rewrite</span> (GM i).<span class="mi">2</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">trace</span>.

<span class="kn">Lemma</span> <span class="nf">strace_measurable</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">A</span> : <span class="nb">set</span> T) : measurable A -&gt;
  strace measurable A `&lt;=` measurable.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; mA=&gt; _ [C mC &lt;-]; <span class="nb">apply</span>: measurableI. <span class="kn">Qed</span>.

<span class="c">(* more properties of measurable functions *)</span>

<span class="kn">Lemma</span> <span class="nf">is_interval_measurable</span> (<span class="nv">R</span> : realType) (<span class="nv">I</span> : <span class="nb">set</span> R) :
  is_interval I -&gt; measurable I.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/is_intervalP =&gt; -&gt;; <span class="bp">exact</span>: measurable_itv. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">coutinuous_measurable</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.

<span class="kn">Lemma</span> <span class="nf">open_measurable</span> (<span class="nv">U</span> : <span class="nb">set</span> R) : open U -&gt; measurable U.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /open_bigcup_rat -&gt;; <span class="nb">rewrite</span> bigcup_mkcond; <span class="nb">apply</span>: bigcupT_measurable_rat.
<span class="nb">move</span>=&gt; q; <span class="nb">case</span>: ifPn =&gt; // qfab; <span class="nb">apply</span>: is_interval_measurable =&gt; //.
<span class="bp">exact</span>: is_interval_bigcup_ointsub.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_measurable_subspace</span> (<span class="nv">D</span> : <span class="nb">set</span> R) (<span class="nv">U</span> : <span class="nb">set</span> (subspace D)) :
  measurable D -&gt; open U -&gt; measurable (D `&amp;` U).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD /open_subspaceP [V [oV] VD]; <span class="nb">rewrite</span> setIC -VD.
<span class="bp">by</span> <span class="nb">apply</span>: measurableI =&gt; //; <span class="bp">exact</span>: open_measurable.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subspace_continuous_measurable_fun</span> (<span class="nv">D</span> : <span class="nb">set</span> R) (<span class="nv">f</span> : subspace D -&gt; R) :
  measurable D -&gt; continuous f -&gt; measurable_fun D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD /continuousP cf; <span class="nb">apply</span>: (measurability (RGenOpens.measurableE R)).
<span class="nb">move</span>=&gt; _ [_ [a [b -&gt;] &lt;-]]; <span class="nb">apply</span>: open_measurable_subspace =&gt; //.
<span class="bp">by</span> <span class="bp">exact</span>/cf/interval_open.
<span class="kn">Qed</span>.

<span class="kn">Corollary</span> <span class="nf">open_continuous_measurable_fun</span> (<span class="nv">D</span> : <span class="nb">set</span> R) (<span class="nv">f</span> : R -&gt; R) :
  open D -&gt; {<span class="kr">in</span> D, continuous f} -&gt; measurable_fun D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; oD; <span class="nb">rewrite</span> -(continuous_open_subspace f oD).
<span class="bp">by</span> <span class="nb">apply</span>: subspace_continuous_measurable_fun; <span class="bp">exact</span>: open_measurable.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_measurable_fun</span> (<span class="nv">f</span> : R -&gt; R) :
  continuous f -&gt; measurable_fun setT f.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; cf; <span class="nb">apply</span>: open_continuous_measurable_fun =&gt; //; <span class="bp">exact</span>: openT.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">coutinuous_measurable</span>.

<span class="kn">Section</span> <span class="nf">standard_measurable_fun</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_opp</span> (<span class="nv">R</span> : realType) : measurable_fun [<span class="nb">set</span>: R] -%R.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: continuous_measurable_fun.
<span class="bp">by</span> <span class="nb">have</span> := @opp_continuous R [the normedModType R of R^o].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_normr</span> (<span class="nv">R</span> : realType) (<span class="nv">D</span> : <span class="nb">set</span> R) :
  measurable_fun D (@normr _ R).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD; <span class="nb">apply</span>: (measurability (RGenOInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; /= _ [_ [x -&gt;] &lt;-]; <span class="nb">apply</span>: measurableI =&gt; //.
<span class="nb">have</span> [x0|x0] := leP <span class="mi">0</span> x.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = `]-oo, (- x)[ `|` `]x, +oo[)%classic.
    <span class="bp">by</span> <span class="nb">apply</span>: measurableU; <span class="nb">apply</span>: measurable_itv.
  <span class="nb">rewrite</span> predeqE =&gt; r; <span class="nb">split</span> =&gt; [|[|]]; <span class="nb">rewrite</span> preimage_itv <span class="nl">?in_itv</span> <span class="nl">?andbT</span>/=.
  - <span class="nb">have</span> [r0|r0] := leP <span class="mi">0</span> r; [<span class="nb">rewrite</span> ger0_norm|<span class="nb">rewrite</span> ltr0_norm] =&gt; // xr;
      <span class="nb">rewrite</span> <span class="mi">2</span>!in_itv/=.
    + <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">rewrite</span> xr.
    + <span class="bp">by</span> <span class="nb">left</span>; <span class="nb">rewrite</span> ltr_oppr.
  - <span class="nb">move</span>=&gt; rx /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> ler0_norm <span class="mi">1</span><span class="nl">?ltr_oppr</span>// (le_trans (ltW rx))// ler_oppl oppr0.
  - <span class="bp">by</span> <span class="nb">rewrite</span> in_itv /= andbT =&gt; xr; <span class="nb">rewrite</span> (lt_le_trans _ (ler_norm _)).
<span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = setT)// predeqE =&gt; r.
<span class="bp">by</span> <span class="nb">split</span> =&gt; // _; <span class="nb">rewrite</span> /= in_itv /= andbT (lt_le_trans x0).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">standard_measurable_fun</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (measurable_fun _ normr) =&gt;
  <span class="kp">solve</span> [<span class="bp">exact</span>: measurable_fun_normr] : core.

<span class="kn">Section</span> <span class="nf">measurable_fun_realType</span>.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Implicit Types</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; R).

<span class="kn">Lemma</span> <span class="nf">measurable_funD</span> <span class="nv">D</span> <span class="nv">f</span> <span class="nv">g</span> :
  measurable_fun D f -&gt; measurable_fun D g -&gt; measurable_fun D (f \+ g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf mg mD; <span class="nb">apply</span>: (measurability (RGenOInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; /= _ [_ [a -&gt;] &lt;-]; <span class="nb">rewrite</span> preimage_itv_o_infty.
<span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = \bigcup_(q : rat)
  ((D `&amp;` [<span class="nb">set</span> x | ratr q &lt; f x]) `&amp;` (D `&amp;` [<span class="nb">set</span> x | a - ratr q &lt; g x]))).
  <span class="nb">apply</span>: bigcupT_measurable_rat =&gt; q; <span class="nb">apply</span>: measurableI.
  - <span class="bp">by</span> <span class="nb">rewrite</span> -preimage_itv_o_infty; <span class="nb">apply</span>: mf =&gt; //; <span class="nb">apply</span>: measurable_itv.
  - <span class="bp">by</span> <span class="nb">rewrite</span> -preimage_itv_o_infty; <span class="nb">apply</span>: mg =&gt; //; <span class="nb">apply</span>: measurable_itv.
<span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; [|[r _] []/= [Dx rfx]] /= =&gt; [[Dx]|[_]].
  <span class="nb">rewrite</span> -ltr_subl_addr =&gt; /rat_in_itvoo[r]; <span class="nb">rewrite</span> inE /= =&gt; /itvP h.
  <span class="kr">exists</span> <span class="nv">r</span> =&gt; //; <span class="nb">rewrite</span> setIACA setIid; <span class="nb">split</span> =&gt; //; <span class="nb">split</span> =&gt; /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> h.
  <span class="bp">by</span> <span class="nb">rewrite</span> ltr_subl_addr addrC -ltr_subl_addr h.
<span class="bp">by</span> <span class="nb">rewrite</span> ltr_subl_addr=&gt; afg; <span class="nb">rewrite</span> (lt_le_trans afg)// addrC ler_add2r ltW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_funrM</span> <span class="nv">D</span> <span class="nv">f</span> (<span class="nv">k</span> : R) : measurable_fun D f -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; k * f x).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (@measurable_funT_comp _ _ _ _ _ _ ( *%R k)).
<span class="bp">by</span> <span class="nb">apply</span>: continuous_measurable_fun; <span class="nb">apply</span>: mulrl_continuous.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_funN</span> <span class="nv">D</span> <span class="nv">f</span> : measurable_fun D f -&gt; measurable_fun D (-%R \o f).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf mD; <span class="nb">rewrite</span> (_ : _ \o _ = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; - <span class="mi">1</span> * f x)).
  <span class="bp">exact</span>: measurable_funrM.
<span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> mulN1r.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_funB</span> <span class="nv">D</span> <span class="nv">f</span> <span class="nv">g</span> : measurable_fun D f -&gt;
  measurable_fun D g -&gt; measurable_fun D (f \- g).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; <span class="nb">apply</span>: measurable_funD =&gt; //; <span class="bp">exact</span>: measurable_funN.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_exprn</span> <span class="nv">D</span> <span class="nv">n</span> <span class="nv">f</span> :
  measurable_fun D f -&gt; measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x ^+ n).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: measurable_funT_comp ((@GRing.exp R)^~ n) _ _ _.
<span class="bp">by</span> <span class="nb">apply</span>: continuous_measurable_fun; <span class="nb">apply</span>: exprn_continuous.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_sqr</span> <span class="nv">D</span> <span class="nv">f</span> :
  measurable_fun D f -&gt; measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x ^+ <span class="mi">2</span>).
<span class="kn">Proof</span>. <span class="bp">exact</span>: measurable_fun_exprn. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_funM</span> <span class="nv">D</span> <span class="nv">f</span> <span class="nv">g</span> :
  measurable_fun D f -&gt; measurable_fun D g -&gt; measurable_fun D (f \* g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf mg mD; <span class="nb">rewrite</span> (_ : (_ \* _) = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">2</span>%:R^-<span class="mi">1</span> * (f x + g x) ^+ <span class="mi">2</span>)
  \- (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">2</span>%:R^-<span class="mi">1</span> * (f x ^+ <span class="mi">2</span>)) \- (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">2</span>%:R^-<span class="mi">1</span> * ( g x ^+ <span class="mi">2</span>))).
  <span class="nb">apply</span>: measurable_funB =&gt; //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: measurable_funrM =&gt; //; <span class="bp">exact</span>: measurable_fun_sqr.
  <span class="nb">apply</span>: measurable_funB =&gt; //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: measurable_funrM =&gt; //; <span class="bp">exact</span>: measurable_fun_sqr.
  <span class="nb">apply</span>: measurable_funrM =&gt; //.
  <span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_sqr =&gt; //; <span class="bp">exact</span>: measurable_funD.
<span class="nb">rewrite</span> funeqE =&gt; x /=; <span class="nb">rewrite</span> -<span class="mi">2</span>!mulrBr sqrrD (addrC (f x ^+ <span class="mi">2</span>)) -addrA.
<span class="nb">rewrite</span> -(addrA (f x * g x *+ <span class="mi">2</span>)) -opprB opprK (addrC (g x ^+ <span class="mi">2</span>)) addrK.
<span class="bp">by</span> <span class="nb">rewrite</span> -(mulr_natr (f x * g x)) -(mulrC <span class="mi">2</span>) mulrA mulVr <span class="nl">?mul1r</span>// unitfE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_max</span>  <span class="nv">D</span> <span class="nv">f</span> <span class="nv">g</span> :
  measurable_fun D f -&gt; measurable_fun D g -&gt; measurable_fun D (f \max g).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf mg mD; <span class="nb">apply</span> (measurability (RGenCInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; _ [_ [x -&gt;] &lt;-]; <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ =
    (D `&amp;` f @^-<span class="mi">1</span>` `[x, +oo[) `|` (D `&amp;` g @^-<span class="mi">1</span>` `[x, +oo[)); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> predeqE =&gt; t /=; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> /= !in_itv /= !andbT le_maxr =&gt; -[Dx /orP[|]]; <span class="bp">tauto</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [|]; <span class="nb">rewrite</span> !in_itv/= !andbT le_maxr =&gt; -[Dx -&gt;]//; <span class="nb">rewrite</span> orbT.
<span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="nb">apply</span>: mf|<span class="nb">apply</span>: mg] =&gt;//; <span class="nb">apply</span>: measurable_itv.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_sups</span> <span class="nv">D</span> (<span class="nv">h</span> : (T -&gt; R)^nat) <span class="nv">n</span> :
  (<span class="kr">forall</span> <span class="nv">t</span>, D t -&gt; has_ubound (range (h ^~ t))) -&gt;
  (<span class="kr">forall</span> <span class="nv">m</span>, measurable_fun D (h m)) -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; sups (h ^~ x) n).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_ub mf mD; <span class="nb">apply</span>: (measurability (RGenOInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; _ [_ [x -&gt;] &lt;-]; <span class="nb">rewrite</span> sups_preimage // setI_bigcupr.
<span class="bp">by</span> <span class="nb">apply</span>: bigcup_measurable =&gt; k /= nk; <span class="nb">apply</span>: mf =&gt; //; <span class="bp">exact</span>: measurable_itv.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_infs</span> <span class="nv">D</span> (<span class="nv">h</span> : (T -&gt; R)^nat) <span class="nv">n</span> :
  (<span class="kr">forall</span> <span class="nv">t</span>, D t -&gt; has_lbound (range (h ^~ t))) -&gt;
  (<span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (h n)) -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; infs (h ^~ x) n).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; lb_f mf mD; <span class="nb">apply</span>: (measurability (RGenInftyO.measurableE R)) =&gt;//.
<span class="nb">move</span>=&gt; _ [_ [x -&gt;] &lt;-]; <span class="nb">rewrite</span> infs_preimage // setI_bigcupr.
<span class="bp">by</span> <span class="nb">apply</span>: bigcup_measurable =&gt; k /= nk; <span class="nb">apply</span>: mf =&gt; //; <span class="bp">exact</span>: measurable_itv.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_lim_sup</span> <span class="nv">D</span> (<span class="nv">h</span> : (T -&gt; R)^nat) :
  (<span class="kr">forall</span> <span class="nv">t</span>, D t -&gt; has_ubound (range (h ^~ t))) -&gt;
  (<span class="kr">forall</span> <span class="nv">t</span>, D t -&gt; has_lbound (range (h ^~ t))) -&gt;
  (<span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (h n)) -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lim_sup (h ^~ x)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_ub f_lb mf.
<span class="nb">have</span> : {<span class="kr">in</span> D, (<span class="kr">fun</span> <span class="nv">x</span> =&gt; inf [<span class="nb">set</span> sups (h ^~ x) n | n <span class="kr">in</span> [<span class="nb">set</span> n | <span class="mi">0</span> &lt;= n]%N])
              =<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lim_sup (h^~ x))}.
  <span class="nb">move</span>=&gt; t; <span class="nb">rewrite</span> inE =&gt; Dt; <span class="nb">apply</span>/esym/cvg_lim; <span class="kp">first</span> <span class="bp">exact</span>: Rhausdorff.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ = inf (range (sups (h^~t)))).
    <span class="bp">by</span> <span class="nb">apply</span>: cvg_sups_inf; [<span class="bp">exact</span>: f_ub|<span class="bp">exact</span>: f_lb].
  <span class="bp">by</span> <span class="nb">congr</span> (inf [<span class="nb">set</span> _ | _ <span class="kr">in</span> _]); <span class="nb">rewrite</span> predeqE.
<span class="nb">move</span>/eq_measurable_fun; <span class="nb">apply</span>; <span class="nb">apply</span>: measurable_fun_infs =&gt; //.
  <span class="nb">move</span>=&gt; t Dt; <span class="nb">have</span> [M hM] := f_lb _ Dt; <span class="kr">exists</span> <span class="nv">M</span> =&gt; _ [m /= nm &lt;-].
  <span class="nb">rewrite</span> (@le_trans _ _ (h m t)) //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span> hM =&gt; /=; <span class="kr">exists</span> <span class="nv">m</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: sup_ub; [<span class="bp">exact</span>/has_ubound_sdrop/f_ub|<span class="kr">exists</span> <span class="nv">m</span> =&gt; /=].
<span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="bp">exact</span>: measurable_fun_sups.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_cvg</span> <span class="nv">D</span> (<span class="nv">h</span> : (T -&gt; R)^nat) <span class="nv">f</span> :
  (<span class="kr">forall</span> <span class="nv">m</span>, measurable_fun D (h m)) -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; h ^~ x --&gt; f x) -&gt;
  measurable_fun D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf_ f_f; <span class="nb">have</span> fE x : D x -&gt; f x = lim_sup (h ^~ x).
  <span class="nb">move</span>=&gt; Dx; <span class="nb">have</span> /cvg_lim  &lt;-// := @cvg_sups _ (h ^~ x) (f x) (f_f _ Dx).
  <span class="bp">exact</span>: Rhausdorff.
<span class="nb">apply</span>: (@eq_measurable_fun _ _ _ _ D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lim_sup (h ^~ x))).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> inE =&gt; Dx; <span class="nb">rewrite</span> -fE.
<span class="nb">apply</span>: (@measurable_fun_lim_sup _ h) =&gt; // t Dt.
- <span class="nb">apply</span>/bounded_fun_has_ubound/(@cvg_seq_bounded _ [normedModType R of R^o]).
  <span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: f_f.
- <span class="nb">apply</span>/bounded_fun_has_lbound/(@cvg_seq_bounded _ [normedModType R of R^o]).
  <span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: f_f.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">measurable_fun_realType</span>.

<span class="kn">Section</span> <span class="nf">standard_emeasurable_fun</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_EFin</span> (<span class="nv">D</span> : <span class="nb">set</span> R) : measurable_fun D EFin.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD; <span class="nb">apply</span>: (measurability (ErealGenOInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; /= _ [_ [x -&gt;]] &lt;-; <span class="nb">apply</span>: measurableI =&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> preimage_itv_o_infty EFin_itv; <span class="bp">exact</span>: measurable_itv.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_abse</span> (<span class="nv">D</span> : <span class="nb">set</span> (\bar R)) : measurable_fun D abse.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD; <span class="nb">apply</span>: (measurability (ErealGenOInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; /= _ [_ [x -&gt;] &lt;-].
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ @^-<span class="mi">1</span>` X](punct_eitv_bnd_pinfty _ x) preimage_setU setIUr.
<span class="nb">apply</span>: measurableU; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> preimage_abse_pinfty; <span class="nb">apply</span>: measurableI =&gt; //; <span class="bp">exact</span>: measurableU.
<span class="nb">apply</span>: measurableI =&gt; //; <span class="kr">exists</span> (<span class="nv">normr</span> @^-<span class="mi">1</span>` `]x, +oo[%classic).
  <span class="nb">rewrite</span> -[X <span class="kr">in</span> measurable X]setTI.
  <span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_normr =&gt; //; <span class="bp">exact</span>: measurable_itv.
<span class="kr">exists</span> <span class="nv">set0</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">constructor</span>.
<span class="nb">rewrite</span> setU0 predeqE =&gt; -[y| |]; <span class="nb">split</span> =&gt; /= =&gt; -[r];
  <span class="nb">rewrite</span> ?/= /= <span class="nl">?in_itv</span> /= <span class="nl">?andbT</span> =&gt; xr//.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; [ry]; <span class="kr">exists</span> `|y| =&gt; //=; <span class="nb">rewrite</span> in_itv/= andbT -ry.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; [ry]; <span class="kr">exists</span> <span class="nv">y</span> =&gt; //=; <span class="nb">rewrite</span> /= in_itv/= andbT -ry.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_minus</span> (<span class="nv">D</span> : <span class="nb">set</span> (\bar R)) :
  measurable_fun D (-%E : \bar R -&gt; \bar R).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mD; <span class="nb">apply</span>: (measurability (ErealGenCInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; _ [_ [x -&gt;] &lt;-]; <span class="nb">rewrite</span> (_ : _ @^-<span class="mi">1</span>` _ = `]-oo, (- x)%:E]%classic).
  <span class="bp">by</span> <span class="nb">apply</span>: measurableI =&gt; //; <span class="bp">exact</span>: emeasurable_itv_ninfty_bnd.
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; y; <span class="nb">rewrite</span> preimage_itv !in_itv/= andbT in_itv lee_oppr.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">standard_emeasurable_fun</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (measurable_fun _ abse) =&gt;
  <span class="kp">solve</span> [<span class="bp">exact</span>: measurable_fun_abse] : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (measurable_fun _ EFin) =&gt;
  <span class="kp">solve</span> [<span class="bp">exact</span>: measurable_fun_EFin] : core.

<span class="c">(* NB: real-valued function *)</span>
<span class="kn">Lemma</span> <span class="nf">EFin_measurable_fun</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType) (<span class="nv">D</span> : <span class="nb">set</span> T)
    (<span class="nv">g</span> : T -&gt; R) :
  measurable_fun D (EFin \o g) &lt;-&gt; measurable_fun D g.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [mf mD A mA|]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; mg; <span class="bp">exact</span>: measurable_funT_comp.
<span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ = D `&amp;` (EFin \o g) @^-<span class="mi">1</span>` (EFin @` A)).
  <span class="bp">by</span> <span class="nb">apply</span>: mf =&gt; //; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="kr">exists</span> <span class="nv">set0</span>; [<span class="nb">constructor</span>|<span class="nb">rewrite</span> setU0].
<span class="nb">congr</span> (_ `&amp;` _);<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; [|? []/= _ /[<span class="nb">swap</span>] -[-&gt;//]].
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="bp">exact</span>: preimage_image.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">emeasurable_fun</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> <span class="nv">d</span> (<span class="nv">T</span> : measurableType d) (<span class="nv">R</span> : realType).
<span class="kn">Implicit Types</span> (<span class="nv">D</span> : <span class="nb">set</span> T).

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_bool</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; bool) <span class="nv">b</span> :
  measurable (f @^-<span class="mi">1</span>` [<span class="nb">set</span> b]) -&gt; measurable_fun D f.
<span class="kn">Proof</span>.
<span class="nb">have</span> FNT : [<span class="nb">set</span> false] = [<span class="nb">set</span>~ true] <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; -[]//=.
<span class="nb">wlog</span> {b}-&gt; : b / b = true.
  <span class="nb">case</span>: b =&gt; [|h]; <span class="kp">first</span> <span class="bp">exact</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> FNT -preimage_setC =&gt; /measurableC; <span class="nb">rewrite</span> setCK; <span class="bp">exact</span>: h.
<span class="nb">move</span>=&gt; mfT mD /= Y; <span class="nb">have</span> := @subsetT _ Y; <span class="nb">rewrite</span> setT_bool =&gt; YT.
<span class="nb">have</span> [-&gt; _|-&gt; _|-&gt; _ |-&gt; _] := subset_set2 YT.
- <span class="bp">by</span> <span class="nb">rewrite</span> preimage0 <span class="nl">?setI0</span>.
- <span class="bp">by</span> <span class="nb">apply</span>: measurableI =&gt; //; <span class="bp">exact</span>: mfT.
- <span class="nb">rewrite</span> -[X <span class="kr">in</span> measurable X]setCK; <span class="nb">apply</span>: measurableC; <span class="nb">rewrite</span> setCI.
  <span class="nb">apply</span>: measurableU; <span class="kp">first</span> <span class="bp">exact</span>: measurableC.
  <span class="bp">by</span> <span class="nb">rewrite</span> FNT preimage_setC setCK; <span class="bp">exact</span>: mfT.
- <span class="bp">by</span> <span class="nb">rewrite</span> -setT_bool preimage_setT setIT.
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> emeasurable_fun_bool {D f} b.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_einfs</span> <span class="nv">D</span> (<span class="nv">f</span> : (T -&gt; \bar R)^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (f n)) -&gt;
  <span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; einfs (f ^~ x) n).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf n mD.
<span class="nb">apply</span>: (measurability (ErealGenCInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; _ [_ [x -&gt;] &lt;-]; <span class="nb">rewrite</span> einfs_preimage -bigcapIr; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; /=.
<span class="bp">by</span> <span class="nb">apply</span>: bigcap_measurable =&gt; ? ?; <span class="bp">exact</span>/mf/emeasurable_itv_bnd_pinfty.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_esups</span> <span class="nv">D</span> (<span class="nv">f</span> : (T -&gt; \bar R)^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (f n)) -&gt;
  <span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; esups (f ^~ x) n).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf n mD; <span class="nb">apply</span>: (measurability (ErealGenOInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; _ [_ [x -&gt;] &lt;-];<span class="nb">rewrite</span> esups_preimage setI_bigcupr.
<span class="bp">by</span> <span class="nb">apply</span>: bigcup_measurable =&gt; ? ?; <span class="bp">exact</span>/mf/emeasurable_itv_bnd_pinfty.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_max</span> <span class="nv">D</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; \bar R) :
  measurable_fun D f -&gt; measurable_fun D g -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; maxe (f x) (g x)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf mg mD; <span class="nb">apply</span>: (measurability (ErealGenCInfty.measurableE R)) =&gt; //.
<span class="nb">move</span>=&gt; _ [_ [x -&gt;] &lt;-]; <span class="nb">rewrite</span> [X <span class="kr">in</span> measurable X](_ : _ =
    (D `&amp;` f @^-<span class="mi">1</span>` `[x%:E, +oo[) `|` (D `&amp;` g @^-<span class="mi">1</span>` `[x%:E, +oo[)); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> predeqE =&gt; t /=; <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> !/= /= !in_itv /= !andbT le_maxr =&gt; -[Dx /orP[|]];
      <span class="bp">tauto</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [|]; <span class="nb">rewrite</span> !/= /= !in_itv/= !andbT le_maxr;
    <span class="nb">move</span>=&gt; [Dx -&gt;]//; <span class="nb">rewrite</span> orbT.
<span class="bp">by</span> <span class="nb">apply</span>: measurableU; [<span class="bp">exact</span>/mf/emeasurable_itv_bnd_pinfty|
                        <span class="bp">exact</span>/mg/emeasurable_itv_bnd_pinfty].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_funN</span> <span class="nv">D</span> (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable_fun D f -&gt; measurable_fun D (\- f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: measurable_funT_comp =&gt; //; <span class="bp">exact</span>: emeasurable_fun_minus. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_funepos</span> <span class="nv">D</span> (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable_fun D f -&gt; measurable_fun D f^\+.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mf; <span class="nb">apply</span>: emeasurable_fun_max =&gt; //; <span class="bp">exact</span>: measurable_fun_cst.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_funeneg</span> <span class="nv">D</span> (<span class="nv">f</span> : T -&gt; \bar R) :
  measurable_fun D f -&gt; measurable_fun D f^\-.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; mf; <span class="nb">apply</span>: emeasurable_fun_max =&gt; //;
  [<span class="bp">exact</span>: emeasurable_funN|<span class="bp">exact</span>: measurable_fun_cst].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_min</span> <span class="nv">D</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; \bar R) :
  measurable_fun D f -&gt; measurable_fun D g -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; mine (f x) (g x)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /emeasurable_funN mf /emeasurable_funN mg.
<span class="nb">have</span> /emeasurable_funN := emeasurable_fun_max mf mg.
<span class="bp">by</span> <span class="nb">apply</span> eq_measurable_fun =&gt; i Di; <span class="nb">rewrite</span> -oppe_min oppeK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">measurable_fun_lim_esup</span> <span class="nv">D</span> (<span class="nv">f</span> : (T -&gt; \bar R)^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, measurable_fun D (f n)) -&gt;
  measurable_fun D (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lim_esup (f ^~ x)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf mD; <span class="nb">rewrite</span> (_ :  (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) =
    (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ereal_inf [<span class="nb">set</span> esups (f^~ x) n | n <span class="kr">in</span> [<span class="nb">set</span> n | n &gt;= <span class="mi">0</span>]%N])).
  <span class="bp">by</span> <span class="nb">apply</span>: measurable_fun_einfs =&gt; // k; <span class="bp">exact</span>: measurable_fun_esups.
<span class="nb">rewrite</span> funeqE =&gt; t; <span class="nb">apply</span>/cvg_lim =&gt; //.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ = ereal_inf (range (esups (f^~t)))).
  <span class="bp">exact</span>: cvg_esups_inf.
<span class="bp">by</span> <span class="nb">congr</span> (ereal_inf [<span class="nb">set</span> _ | _ <span class="kr">in</span> _]); <span class="nb">rewrite</span> predeqE.
<span class="kn">Qed</span>.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed `measurable_fun_lim_esup`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">measurable_fun_elim_sup</span> := measurable_fun_lim_esup.

<span class="kn">Lemma</span> <span class="nf">emeasurable_fun_cvg</span> <span class="nv">D</span> (<span class="nv">f_</span> : (T -&gt; \bar R)^nat) (<span class="nv">f</span> : T -&gt; \bar R) :
  (<span class="kr">forall</span> <span class="nv">m</span>, measurable_fun D (f_ m)) -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, D x -&gt; f_ ^~ x --&gt; f x) -&gt; measurable_fun D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; mf_ f_f; <span class="nb">have</span> fE x : D x -&gt; f x = lim_esup (f_^~ x).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Dx; <span class="nb">have</span> /cvg_lim  &lt;-// := @cvg_esups _ (f_^~x) (f x) (f_f x Dx).
<span class="nb">apply</span>: (measurable_fun_ext (<span class="kr">fun</span> <span class="nv">x</span> =&gt; lim_esup (f_ ^~ x))) =&gt; //.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> inE =&gt; Dx; <span class="nb">rewrite</span> fE.
<span class="bp">exact</span>: measurable_fun_lim_esup.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">emeasurable_fun</span>.
<span class="kn">Arguments</span> emeasurable_fun_cvg {d T R D} f_.</span></pre></article></body></html>