<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>topology.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect all_algebra finmap generic_quotient.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predI _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predU _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predD _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predC _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ preim _ of _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closedM;
                   GRing.smulr_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedM; GRing.smulr_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed.
New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.sdivr_closed_div;
                   GRing.divr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.sdivr_closedM; GRing.smulr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subalg_closedBM;
                   GRing.subring_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subalg_closedZ; GRing.submod_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divring_closed_div;
                   GRing.sdivr_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divring_closedBM; GRing.subring_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divalg_closedBdiv;
                   GRing.divring_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divalg_closedZ; GRing.subalg_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.Pred.subring_smul;
                   GRing.Pred.smul_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.Pred.subring_semi; GRing.Pred.semiring_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> boolp classical_sets functions.
<span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> cardinality mathcomp_extra fsbigop.
<span class="kn">Require Import</span> reals signed.

<span class="sd">(******************************************************************************)</span>
<span class="c">(*                  Filters and basic topological notions                     *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* This file develops tools for the manipulation of filters and basic         *)</span>
<span class="c">(* topological notions. The development of topological notions builds on      *)</span>
<span class="c">(* &quot;filtered types&quot;. They are types equipped with an interface that           *)</span>
<span class="c">(* associates to each element a set of sets, intended to represent a filter.  *)</span>
<span class="c">(* The notions of limit and convergence are defined for filtered types and in *)</span>
<span class="c">(* the documentation below we call &quot;canonical filter&quot; of an element the set   *)</span>
<span class="c">(* of sets associated to it by the interface of filtered types.               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*                 monotonous A f := {in A &amp;, {mono f : x y / x &lt;= y}} \/     *)</span>
<span class="c">(*                                   {in A &amp;, {mono f : x y /~ x &lt;= y}}.      *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Filters :                                                                *)</span>
<span class="c">(*                   filteredType U == interface type for types whose         *)</span>
<span class="c">(*                                     elements represent sets of sets on U.  *)</span>
<span class="c">(*                                     These sets are intended to be filters  *)</span>
<span class="c">(*                                     on U but this is not enforced yet.     *)</span>
<span class="c">(*               FilteredType U T m == packs the function m: T -&gt; set (set U) *)</span>
<span class="c">(*                                     to build a filtered type of type       *)</span>
<span class="c">(*                                     filteredType U; T must have a          *)</span>
<span class="c">(*                                     pointedType structure.                 *)</span>
<span class="c">(*     [filteredType U of T for cT] == T-clone of the filteredType U          *)</span>
<span class="c">(*                                     structure cT.                          *)</span>
<span class="c">(*            [filteredType U of T] == clone of a canonical structure of      *)</span>
<span class="c">(*                                     filteredType U on T.                   *)</span>
<span class="c">(*              Filtered.source Y Z == structure that records types X such    *)</span>
<span class="c">(*                                     that there is a function mapping       *)</span>
<span class="c">(*                                     functions of type X -&gt; Y to filters on *)</span>
<span class="c">(*                                     Z. Allows to infer the canonical       *)</span>
<span class="c">(*                                     filter associated to a function by     *)</span>
<span class="c">(*                                     looking at its source type.            *)</span>
<span class="c">(*                Filtered.Source F == if F : (X -&gt; Y) -&gt; set (set Z), packs  *)</span>
<span class="c">(*                                     X with F in a Filtered.source Y Z      *)</span>
<span class="c">(*                                     structure.                             *)</span>
<span class="c">(*                           nbhs p == set of sets associated to p (in a      *)</span>
<span class="c">(*                                     filtered type).                        *)</span>
<span class="c">(*                  filter_from D B == set of the supersets of the elements   *)</span>
<span class="c">(*                                     of the family of sets B whose indices  *)</span>
<span class="c">(*                                     are in the domain D.                   *)</span>
<span class="c">(*                                     This is a filter if (B_i)_(i in D)     *)</span>
<span class="c">(*                                     forms a filter base.                   *)</span>
<span class="c">(*                  filter_prod F G == product of the filters F and G.        *)</span>
<span class="c">(*                    [filter of x] == canonical filter associated to x.      *)</span>
<span class="c">(*                        F `=&gt;` G &lt;-&gt; G is included in F; F and G are sets   *)</span>
<span class="c">(*                                     of sets.                               *)</span>
<span class="c">(*                         F --&gt; G &lt;-&gt; the canonical filter associated to G   *)</span>
<span class="c">(*                                     is included in the canonical filter    *)</span>
<span class="c">(*                                     associated to F.                       *)</span>
<span class="c">(*                            lim F == limit of the canonical filter          *)</span>
<span class="c">(*                                     associated with F if there is such a   *)</span>
<span class="c">(*                                     limit, i.e., an element l such that    *)</span>
<span class="c">(*                                     the canonical filter associated to l   *)</span>
<span class="c">(*                                     is a subset of F.                      *)</span>
<span class="c">(*                     [lim F in T] == limit of the canonical filter          *)</span>
<span class="c">(*                                     associated to F in T where T has type  *)</span>
<span class="c">(*                                     filteredType U.                        *)</span>
<span class="c">(*                    [cvg F in T] &lt;-&gt; the canonical filter associated to F   *)</span>
<span class="c">(*                                     converges in T.                        *)</span>
<span class="c">(*                           cvg F &lt;-&gt; same as [cvg F in T] where T is        *)</span>
<span class="c">(*                                     inferred from the type of the          *)</span>
<span class="c">(*                                     canonical filter associated to F.      *)</span>
<span class="c">(*                         Filter F == type class proving that the set of     *)</span>
<span class="c">(*                                     sets F is a filter.                    *)</span>
<span class="c">(*                   ProperFilter F == type class proving that the set of     *)</span>
<span class="c">(*                                     sets F is a proper filter.             *)</span>
<span class="c">(*                    UltraFilter F == type class proving that the set of     *)</span>
<span class="c">(*                                     sets F is an ultrafilter               *)</span>
<span class="c">(*                      filter_on T == interface type for sets of sets on T   *)</span>
<span class="c">(*                                     that are filters.                      *)</span>
<span class="c">(*                  FilterType F FF == packs the set of sets F with the proof *)</span>
<span class="c">(*                                     FF of Filter F to build a filter_on T  *)</span>
<span class="c">(*                                     structure.                             *)</span>
<span class="c">(*                     pfilter_on T == interface type for sets of sets on T   *)</span>
<span class="c">(*                                     that are proper filters.               *)</span>
<span class="c">(*                 PFilterPack F FF == packs the set of sets F with the proof *)</span>
<span class="c">(*                                     FF of ProperFilter F to build a        *)</span>
<span class="c">(*                                     pfilter_on T structure.                *)</span>
<span class="c">(*                         fmap f F == image of the filter F by the function  *)</span>
<span class="c">(*                                     f                                      *)</span>
<span class="c">(*                       E @[x --&gt; F] == image of the canonical filter        *)</span>
<span class="c">(*                                     associated to F by the function        *)</span>
<span class="c">(*                                     (fun x =&gt; E).                          *)</span>
<span class="c">(*                            f @ F == image of the canonical filter          *)</span>
<span class="c">(*                                     associated to F by the function f.     *)</span>
<span class="c">(*                        fmapi f F == image of the filter F by the relation  *)</span>
<span class="c">(*                                     f                                      *)</span>
<span class="c">(*                      E `@[x --&gt; F] == image of the canonical filter        *)</span>
<span class="c">(*                                     associated to F by the relation        *)</span>
<span class="c">(*                                     (fun x =&gt; E).                          *)</span>
<span class="c">(*                           f `@ F == image of the canonical filter          *)</span>
<span class="c">(*                                     associated to F by the relation f.     *)</span>
<span class="c">(*                       globally A == filter of the sets containing A.       *)</span>
<span class="c">(*                @frechet_filter T := [set S : set T | finite_set (~` S)]    *)</span>
<span class="c">(*                                     a.k.a. cofinite filter                 *)</span>
<span class="c">(*                       at_point a == filter of the sets containing a.       *)</span>
<span class="c">(*                       within D F == restriction of the filter F to the     *)</span>
<span class="c">(*                                     domain D.                              *)</span>
<span class="c">(*               principal_filter x == filter containing every superset of x. *)</span>
<span class="c">(*                subset_filter F D == similar to within D F, but with        *)</span>
<span class="c">(*                                     dependent types.                       *)</span>
<span class="c">(*           powerset_filter_from F == The filter of downward closed subsets  *)</span>
<span class="c">(*                                     of F. Enables use of near notation to  *)</span>
<span class="c">(*                                     pick suitably small members of F       *)</span>
<span class="c">(*                      in_filter F == interface type for the sets that       *)</span>
<span class="c">(*                                     belong to the set of sets F.           *)</span>
<span class="c">(*                      InFilter FP == packs a set P with a proof of F P to   *)</span>
<span class="c">(*                                     build a in_filter F structure.         *)</span>
<span class="c">(*                              \oo == &quot;eventually&quot; filter on nat: set of     *)</span>
<span class="c">(*                                     predicates on natural numbers that are *)</span>
<span class="c">(*                                     eventually true.                       *)</span>
<span class="c">(*    separate_points_from_closed f == For a closed set U and point x outside *)</span>
<span class="c">(*                                     some member of the family f sends      *)</span>
<span class="c">(*                                     f_i(x) outside (closure (f_i @` U)).   *)</span>
<span class="c">(*                                     Used together with join_product.       *)</span>
<span class="c">(*                   join_product f == The function (x =&gt; f ^~ x). When the   *)</span>
<span class="c">(*                                     family f separates points from closed  *)</span>
<span class="c">(*                                     sets, join_product is an embedding.    *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Near notations and tactics:                                              *)</span>
<span class="c">(*   --&gt; The purpose of the near notations and tactics is to make the         *)</span>
<span class="c">(*       manipulation of filters easier. Instead of proving F G, one can      *)</span>
<span class="c">(*       prove G x for x &quot;near F&quot;, i.e. for x such that H x for H arbitrarily *)</span>
<span class="c">(*       precise as long as F H. The near tactics allow for a delayed         *)</span>
<span class="c">(*       introduction of H: H is introduced as an existential variable and    *)</span>
<span class="c">(*       progressively instantiated during the proof process.                 *)</span>
<span class="c">(*   --&gt; Notations:                                                           *)</span>
<span class="c">(*                      {near F, P} == the property P holds near the          *)</span>
<span class="c">(*                                     canonical filter associated to F; P    *)</span>
<span class="c">(*                                     must have the form forall x, Q x.      *)</span>
<span class="c">(*                                     Equivalent to F Q.                     *)</span>
<span class="c">(*          \forall x \near F, P x &lt;-&gt; F (fun x =&gt; P x).                      *)</span>
<span class="c">(*                     \near x, P x := \forall y \near x, P y.                *)</span>
<span class="c">(*                  {near F &amp; G, P} == same as {near H, P}, where H is the    *)</span>
<span class="c">(*                                     product of the filters F and G.        *)</span>
<span class="c">(*   \forall x \near F &amp; y \near G, P x y := {near F &amp; G, forall x y, P x y}. *)</span>
<span class="c">(*     \forall x &amp; y \near F, P x y == same as before, with G = F.            *)</span>
<span class="c">(*               \near x &amp; y, P x y := \forall z \near x &amp; t \near y, P x y.  *)</span>
<span class="c">(*                     x \is_near F == x belongs to a set P : in_filter F.    *)</span>
<span class="c">(*   --&gt; Tactics:                                                             *)</span>
<span class="c">(*     - near=&gt; x    introduces x:                                            *)</span>
<span class="c">(*       On the goal \forall x \near F, G x, introduces the variable x and an *)</span>
<span class="c">(*       &quot;existential&quot;, and unaccessible hypothesis ?H x and asks the user to *)</span>
<span class="c">(*       prove (G x) in this context.                                         *)</span>
<span class="c">(*       Under the hood delays the proof of F ?H and waits for near: x        *)</span>
<span class="c">(*       Also exists under the form near=&gt; x y.                               *)</span>
<span class="c">(*     - near: x     discharges x:                                            *)</span>
<span class="c">(*       On the goal H_i x, and where x \is_near F, it asks the user to prove *)</span>
<span class="c">(*       that (\forall x \near F, H_i x), provided that H_i x does not depend *)</span>
<span class="c">(*       on variables introduced after x.                                     *)</span>
<span class="c">(*       Under the hood, it refines by intersection the existential variable  *)</span>
<span class="c">(*       ?H attached to x, computes the intersection with F, and asks the     *)</span>
<span class="c">(*       user to prove F H_i, right now                                       *)</span>
<span class="c">(*     - end_near should be used to close remaining existentials trivially    *)</span>
<span class="c">(*     - near F =&gt; x     poses a variable near F, where F is a proper filter  *)</span>
<span class="c">(*       adds to the context a variable x that \is_near F, i.e. one may       *)</span>
<span class="c">(*       assume H x for any H in F. This new variable x can be dealt with     *)</span>
<span class="c">(*       using  near: x, as for variables introduced by near=&gt;.               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Topology :                                                               *)</span>
<span class="c">(*                  topologicalType == interface type for topological space   *)</span>
<span class="c">(*                                     structure.                             *)</span>
<span class="c">(* TopologicalMixin nbhs_filt nbhsE == builds the mixin for a topological     *)</span>
<span class="c">(*                                     space from the proofs that nbhs        *)</span>
<span class="c">(*                                     outputs proper filters and defines the *)</span>
<span class="c">(*                                     same notion of neighbourhood as the    *)</span>
<span class="c">(*                                     open sets.                             *)</span>
<span class="c">(* topologyOfFilterMixin nbhs_filt nbhs_sing nbhs_nbhs == builds the mixin    *)</span>
<span class="c">(*                                     for a topological space from the       *)</span>
<span class="c">(*                                     properties of nbhs and hence assumes   *)</span>
<span class="c">(*                                     that the carrier is a filterType       *)</span>
<span class="c">(*   topologyOfOpenMixin opT opI op_bigU == builds the mixin for a            *)</span>
<span class="c">(*                                     topological space from the properties  *)</span>
<span class="c">(*                                     of open sets, assuming the carrier is  *)</span>
<span class="c">(*                                     a pointed type. nbhs_of_open must be   *)</span>
<span class="c">(*                                     used to declare a filterType.          *)</span>
<span class="c">(*   topologyOfBaseMixin b_cover b_join == builds the mixin for a topological *)</span>
<span class="c">(*                                     space from the properties of a base of *)</span>
<span class="c">(*                                     open sets; the type of indices must be *)</span>
<span class="c">(*                                     a pointedType, as well as the carrier. *)</span>
<span class="c">(*                                     nbhs_of_open \o open_from must be      *)</span>
<span class="c">(*                                     used to declare a filterType           *)</span>
<span class="c">(*       topologyOfSubbaseMixin D b == builds the mixin for a topological     *)</span>
<span class="c">(*                                     space from a subbase of open sets b    *)</span>
<span class="c">(*                                     indexed on domain D; the type of       *)</span>
<span class="c">(*                                     indices must be a pointedType.         *)</span>
<span class="c">(*              TopologicalType T m == packs the mixin m to build a           *)</span>
<span class="c">(*                                     topologicalType; T must have a         *)</span>
<span class="c">(*                                     canonical structure of filteredType T. *)</span>
<span class="c">(*           weak_topologicalType f == weak topology by f : S -&gt; T on S; S    *)</span>
<span class="c">(*                                     must be a pointedType and T a          *)</span>
<span class="c">(*                                     topologicalType.                       *)</span>
<span class="c">(*           sup_topologicalType Tc == supremum topology of the family of     *)</span>
<span class="c">(*                                     topologicalType structures Tc on T; T  *)</span>
<span class="c">(*                                     must be a pointedType.                 *)</span>
<span class="c">(*        product_topologicalType T == product topology of the family of      *)</span>
<span class="c">(*                                     topologicalTypes T.                    *)</span>
<span class="c">(*    [topologicalType of T for cT] == T-clone of the topologicalType         *)</span>
<span class="c">(*                                     structure cT.                          *)</span>
<span class="c">(*           [topologicalType of T] == clone of a canonical structure of      *)</span>
<span class="c">(*                                     topologicalType on T.                  *)</span>
<span class="c">(*                             open == set of open sets.                      *)</span>
<span class="c">(*                      open_nbhs p == set of open neighbourhoods of p.       *)</span>
<span class="c">(*                    continuous f &lt;-&gt; f is continuous w.r.t the topology.    *)</span>
<span class="c">(*                              x^&#39; == set of neighbourhoods of x where x is  *)</span>
<span class="c">(*                                     excluded (a &quot;deleted neighborhood&quot;).   *)</span>
<span class="c">(*                        closure A == closure of the set A.                  *)</span>
<span class="c">(*                    limit_point E == the set of limit points of E           *)</span>
<span class="c">(*                           closed == set of closed sets.                    *)</span>
<span class="c">(*                        cluster F == set of cluster points of F.            *)</span>
<span class="c">(*                          compact == set of compact sets w.r.t. the filter- *)</span>
<span class="c">(*                                     based definition of compactness.       *)</span>
<span class="c">(*                   compact_near F == the filter F contains a closed comapct *)</span>
<span class="c">(*                                     set                                    *)</span>
<span class="c">(*                     precompact A == The set A is contained in a closed and *)</span>
<span class="c">(*                                     compact set                            *)</span>
<span class="c">(*                locally_compact A == every point in A has a compact         *)</span>
<span class="c">(*                                     (and closed) neighborhood              *)</span>
<span class="c">(*               hausdorff_space T &lt;-&gt; T is a Hausdorff space (T_2).          *)</span>
<span class="c">(*                discrete_space T &lt;-&gt; every nbhs is a principal filter       *)</span>
<span class="c">(*        finite_subset_cover D F A == the family of sets F is a cover of A   *)</span>
<span class="c">(*                                     for a finite number of indices in D    *)</span>
<span class="c">(*                    cover_compact == set of compact sets w.r.t. the open    *)</span>
<span class="c">(*                                     cover-based definition of compactness. *)</span>
<span class="c">(*                    near_covering == a reformulation of covering compact    *)</span>
<span class="c">(*                                     better suited for use with `near`      *)</span>
<span class="c">(*                     connected A &lt;-&gt; the only non empty subset of A which   *)</span>
<span class="c">(*                                     is both open and closed in A is A.     *)</span>
<span class="c">(*              kolmogorov_space T &lt;-&gt; T is a Kolmogorov space (T_0).         *)</span>
<span class="c">(*              accessible_space T &lt;-&gt; T is an accessible space (T_1).        *)</span>
<span class="c">(*                    separated A B == the two sets A and B are separated     *)</span>
<span class="c">(*                      component x == the connected component of point x     *)</span>
<span class="c">(*                    perfect_set A == A is closed, and is every point in A   *)</span>
<span class="c">(*                                     is a limit point of A.                 *)</span>
<span class="c">(*                      [locally P] := forall a, A a -&gt; G (within A (nbhs x)) *)</span>
<span class="c">(*                                     if P is convertible to G (globally A)  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Function space topologies :                                              *)</span>
<span class="c">(*     {uniform` A -&gt; V} == The space U -&gt; V, equipped with the topology of   *)</span>
<span class="c">(*                          uniform convergence from a set A to V, where      *)</span>
<span class="c">(*                          V is a uniformType.                               *)</span>
<span class="c">(*      {uniform U -&gt; V} := {uniform` [set: U] -&gt; V}                          *)</span>
<span class="c">(*  {uniform A, F --&gt; f} == F converges to f in {uniform A -&gt; V}.             *)</span>
<span class="c">(*    {uniform, F --&gt; f} := {uniform setT, F --&gt; f}                           *)</span>
<span class="c">(*         {ptws U -&gt; V} == The space U -&gt; V, equipped with the topology of   *)</span>
<span class="c">(*                          pointwise convergence from U to V, where V is a   *)</span>
<span class="c">(*                          topologicalType.                                  *)</span>
<span class="c">(*       {ptws, F --&gt; f} == F converges to f in {ptws U -&gt; V}.                *)</span>
<span class="c">(*  {family fam, U -&gt; V} == The space U -&gt; V, equipped with the supremum      *)</span>
<span class="c">(*                          topology of {uniform A -&gt; f} for each A in &#39;fam&#39;  *)</span>
<span class="c">(*                          In particular {family compact, U -&gt; V} is the     *)</span>
<span class="c">(*                          topology of compact convergence.                  *)</span>
<span class="c">(* {family fam, F --&gt; f} == F converges to f in {family fam, U -&gt; V}.         *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* --&gt; We used these topological notions to prove Tychonoff&#39;s Theorem, which  *)</span>
<span class="c">(*     states that any product of compact sets is compact according to the    *)</span>
<span class="c">(*     product topology.                                                      *)</span>
<span class="c">(* * Uniform spaces :                                                         *)</span>
<span class="c">(*                      nbhs_ ent == neighbourhoods defined using entourages  *)</span>
<span class="c">(*                    uniformType == interface type for uniform spaces: a     *)</span>
<span class="c">(*                                   type equipped with entourages            *)</span>
<span class="c">(*   UniformMixin efilter erefl einv esplit nbhse == builds the mixin for a   *)</span>
<span class="c">(*                                   uniform space from the properties of     *)</span>
<span class="c">(*                                   entourages and the compatibility between *)</span>
<span class="c">(*                                   entourages and nbhs                      *)</span>
<span class="c">(*                UniformType T m == packs the uniform space mixin into a     *)</span>
<span class="c">(*                                   uniformType. T must have a canonical     *)</span>
<span class="c">(*                                   structure of topologicalType             *)</span>
<span class="c">(*      [uniformType of T for cT] == T-clone of the uniformType structure cT  *)</span>
<span class="c">(*             [uniformType of T] == clone of a canonical structure of        *)</span>
<span class="c">(*                                   uniformType on T                         *)</span>
<span class="c">(*   topologyOfEntourageMixin umixin == builds the mixin for a topological    *)</span>
<span class="c">(*                                   space from a mixin for a uniform space   *)</span>
<span class="c">(*                      entourage == set of entourages in a uniform space     *)</span>
<span class="c">(*                    split_ent E == when E is an entourage, split_ent E is   *)</span>
<span class="c">(*                                   an entourage E&#39; such that E&#39; \o E&#39; is    *)</span>
<span class="c">(*                                   included in E when seen as a relation    *)</span>
<span class="c">(*                   unif_continuous f &lt;-&gt; f is uniformly continuous.         *)</span>
<span class="c">(*               weak_uniformType == the uniform space for weak topologies    *)</span>
<span class="c">(*                sup_uniformType == the uniform space for sup topologies     *)</span>
<span class="c">(*         countable_uniformity T == T&#39;s entourage has a countable base. This *)</span>
<span class="c">(*                                   is equivalent to `T` being metrizable    *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * PseudoMetric spaces :                                                    *)</span>
<span class="c">(*                entourage_ ball == entourages defined using balls           *)</span>
<span class="c">(*               pseudoMetricType == interface type for pseudo metric space   *)</span>
<span class="c">(*                                   structure: a type equipped with balls.   *)</span>
<span class="c">(*  PseudoMetricMixin brefl bsym btriangle nbhsb == builds the mixin for a    *)</span>
<span class="c">(*                                   pseudo metric space from the properties  *)</span>
<span class="c">(*                                   of balls and the compatibility between   *)</span>
<span class="c">(*                                   balls and entourages.                    *)</span>
<span class="c">(*           PseudoMetricType T m == packs the pseudo metric space mixin into *)</span>
<span class="c">(*                                   a pseudoMetricType. T must have a        *)</span>
<span class="c">(*                                   canonical structure of uniformType.      *)</span>
<span class="c">(* [pseudoMetricType R of T for cT] == T-clone of the pseudoMetricType        *)</span>
<span class="c">(*                                   structure cT, with R the ball radius.    *)</span>
<span class="c">(*      [pseudoMetricType R of T] == clone of a canonical structure of        *)</span>
<span class="c">(*                                   pseudoMetricType on T, with R the ball   *)</span>
<span class="c">(*                                   radius.                                  *)</span>
<span class="c">(*   uniformityOfBallMixin umixin == builds the mixin for a topological space *)</span>
<span class="c">(*                                   from a mixin for a pseudoMetric space.   *)</span>
<span class="c">(*                       ball x e == ball of center x and radius e.           *)</span>
<span class="c">(*                nbhs_ball_ ball == nbhs defined using the given balls       *)</span>
<span class="c">(*                      nbhs_ball == nbhs defined using balls in a            *)</span>
<span class="c">(*                                   pseudometric space                       *)</span>
<span class="c">(*                     close x y &lt;-&gt; x and y are arbitrarily close w.r.t. to  *)</span>
<span class="c">(*                                   balls.                                   *)</span>
<span class="c">(*          weak_pseudoMetricType == the metric space for weak topologies     *)</span>
<span class="c">(*            quotient_topology Q == the quotient topology corresponding to   *)</span>
<span class="c">(*                                   quotient Q : quotType T. where T has     *)</span>
<span class="c">(*                                   type topologicalType                     *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Complete uniform spaces :                                                *)</span>
<span class="c">(*                      cauchy F &lt;-&gt; the set of sets F is a cauchy filter     *)</span>
<span class="c">(*                                   (entourage definition)                   *)</span>
<span class="c">(*                   completeType == interface type for a complete uniform    *)</span>
<span class="c">(*                                   space structure.                         *)</span>
<span class="c">(*       CompleteType T cvgCauchy == packs the proof that every proper cauchy *)</span>
<span class="c">(*                                   filter on T converges into a             *)</span>
<span class="c">(*                                   completeType structure; T must have a    *)</span>
<span class="c">(*                                   canonical structure of uniformType.      *)</span>
<span class="c">(*     [completeType of T for cT] == T-clone of the completeType structure    *)</span>
<span class="c">(*                                   cT.                                      *)</span>
<span class="c">(*            [completeType of T] == clone of a canonical structure of        *)</span>
<span class="c">(*                                   completeType on T.                       *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Complete pseudometric spaces :                                           *)</span>
<span class="c">(*                   cauchy_ex F &lt;-&gt; the set of sets F is a cauchy filter     *)</span>
<span class="c">(*                                   (epsilon-delta definition).              *)</span>
<span class="c">(*                      cauchy F &lt;-&gt; the set of sets F is a cauchy filter     *)</span>
<span class="c">(*                                   (using the near notations).              *)</span>
<span class="c">(*       completePseudoMetricType == interface type for a complete            *)</span>
<span class="c">(*                                   pseudometric space structure.            *)</span>
<span class="c">(* CompletePseudoMetricType T cvgCauchy == packs the proof that every proper  *)</span>
<span class="c">(*                                   cauchy filter on T converges into a      *)</span>
<span class="c">(*                                   completePseudoMetricType structure; T    *)</span>
<span class="c">(*                                   must have a canonical structure of       *)</span>
<span class="c">(*                                   pseudoMetricType.                        *)</span>
<span class="c">(* [completePseudoMetricType of T for cT] == T-clone of the                   *)</span>
<span class="c">(*                                   completePseudoMetricType structure cT.   *)</span>
<span class="c">(* [completePseudoMetricType of T] == clone of a canonical structure of       *)</span>
<span class="c">(*                                   completePseudoMetricType on T.           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*                        ball_ N == balls defined by the norm/absolute       *)</span>
<span class="c">(*                                   value N                                  *)</span>
<span class="c">(*                        dense S == the set (S : set T) is dense in T, with  *)</span>
<span class="c">(*                                   T of type topologicalType                *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Subspaces of topological spaces :                                        *)</span>
<span class="c">(*                 subspace A == for (A : set T), this is a copy of T with    *)</span>
<span class="c">(*                               a topology that ignores points outside A     *)</span>
<span class="c">(*            incl_subspace x == with x of type subspace A with (A : set T),  *)</span>
<span class="c">(*                               inclusion of subspace A into T               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Arzela Ascoli&#39; theorem :                                                 *)</span>
<span class="c">(*            singletons T := [set [set x] | x in [set: T]].                  *)</span>
<span class="c">(*      equicontinuous W x == the set (W : X -&gt; Y) is equicontinuous at x     *)</span>
<span class="c">(*  pointwise_precompact W == For each (x : X), set of images [f x | f in W]  *)</span>
<span class="c">(*                            is precompact                                   *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* We endow several standard types with the types of topological notions:     *)</span>
<span class="c">(* - products: prod_topologicalType, prod_uniformType, prod_pseudoMetricType  *)</span>
<span class="c">(*     sup_pseudoMetricType, weak_pseudoMetricType, product_pseudoMetricType  *)</span>
<span class="c">(* - matrices: matrix_filtered, matrix_topologicalType, matrix_uniformType,   *)</span>
<span class="c">(*     matrix_pseudoMetricType, matrix_completeType,                          *)</span>
<span class="c">(*     matrix_completePseudoMetricType                                        *)</span>
<span class="c">(* - nat: nat_filteredType, nat_topologicalType                               *)</span>
<span class="c">(* - numFieldType: numField_filteredType, numField_topologicalType,           *)</span>
<span class="c">(*     numField_uniformType, numField_pseudoMetricType (accessible with       *)</span>
<span class="c">(*     &quot;Import numFieldTopology.Exports.&quot;)                                    *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;near&#39; x , P }&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;near&#39;  x ,  P }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;\forall&#39; x &#39;\near&#39; x_0 , P&quot;</span>
  (<span class="kn">at level</span> <span class="mi">200</span>, x name, P <span class="kn">at level</span> <span class="mi">200</span>,
   <span class="kn">format</span> <span class="s2">&quot;&#39;\forall&#39;  x  &#39;\near&#39;  x_0 ,  P&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;\near&#39; x , P&quot;</span>
  (<span class="kn">at level</span> <span class="mi">200</span>, x <span class="kn">at level</span> <span class="mi">99</span>, P <span class="kn">at level</span> <span class="mi">200</span>,
   <span class="kn">format</span> <span class="s2">&quot;&#39;\near&#39;  x ,  P&quot;</span>, <span class="kn">only parsing</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;near&#39; x &amp; y , P }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;near&#39;  x  &amp;  y ,  P }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;\forall&#39; x &#39;\near&#39; x_0 &amp; y &#39;\near&#39; y_0 , P&quot;</span>
  (<span class="kn">at level</span> <span class="mi">200</span>, x name, y name, P <span class="kn">at level</span> <span class="mi">200</span>,
   <span class="kn">format</span> <span class="s2">&quot;&#39;\forall&#39;  x  &#39;\near&#39;  x_0  &amp;  y  &#39;\near&#39;  y_0 ,  P&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;\forall&#39; x &amp; y &#39;\near&#39; z , P&quot;</span>
  (<span class="kn">at level</span> <span class="mi">200</span>, x name, y name, P <span class="kn">at level</span> <span class="mi">200</span>,
   <span class="kn">format</span> <span class="s2">&quot;&#39;\forall&#39;  x  &amp;  y  &#39;\near&#39;  z ,  P&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;\near&#39; x &amp; y , P&quot;</span>
  (<span class="kn">at level</span> <span class="mi">200</span>, x, y <span class="kn">at level</span> <span class="mi">99</span>, P <span class="kn">at level</span> <span class="mi">200</span>,
   <span class="kn">format</span> <span class="s2">&quot;&#39;\near&#39;  x  &amp;  y ,  P&quot;</span>, <span class="kn">only parsing</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;filter&#39; &#39;of&#39; x ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;filter&#39;  &#39;of&#39;  x ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;F `=&gt;` G&quot;</span> (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">format</span> <span class="s2">&quot;F  `=&gt;`  G&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;F --&gt; G&quot;</span> (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">format</span> <span class="s2">&quot;F  --&gt;  G&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;lim&#39; F &#39;in&#39; T ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;lim&#39;  F  &#39;in&#39;  T ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;cvg&#39; F &#39;in&#39; T ]&quot;</span> (<span class="kn">format</span> <span class="s2">&quot;[ &#39;cvg&#39;  F  &#39;in&#39;  T ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;x \is_near F&quot;</span> (<span class="kn">at level</span> <span class="mi">10</span>, <span class="kn">format</span> <span class="s2">&quot;x  \is_near  F&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;E @[ x --&gt; F ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">60</span>, x name, <span class="kn">format</span> <span class="s2">&quot;E  @[ x  --&gt;  F ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;f @ F&quot;</span> (<span class="kn">at level</span> <span class="mi">60</span>, <span class="kn">format</span> <span class="s2">&quot;f  @  F&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;E `@[ x --&gt; F ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">60</span>, x name, <span class="kn">format</span> <span class="s2">&quot;E  `@[ x  --&gt;  F ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;f `@ F&quot;</span> (<span class="kn">at level</span> <span class="mi">60</span>, <span class="kn">format</span> <span class="s2">&quot;f  `@  F&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;A ^¬∞&quot;</span> (<span class="kn">at level</span> <span class="mi">1</span>, <span class="kn">format</span> <span class="s2">&quot;A ^¬∞&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;locally&#39; P ]&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;locally&#39;  P ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;x ^&#39;&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;x ^&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;within&#39; A , &#39;continuous&#39; f }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">70</span>, A <span class="kn">at level</span> <span class="mi">69</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;within&#39;  A ,  &#39;continuous&#39;  f }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;uniform`&#39; A -&gt; V }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, A <span class="kn">at level</span> <span class="mi">69</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;uniform`&#39;  A  -&gt;  V }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;uniform&#39; U -&gt; V }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, U <span class="kn">at level</span> <span class="mi">69</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;uniform&#39;  U  -&gt;  V }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;uniform&#39; A , F --&gt; f }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, A <span class="kn">at level</span> <span class="mi">69</span>, F <span class="kn">at level</span> <span class="mi">69</span>,
   <span class="kn">format</span> <span class="s2">&quot;{ &#39;uniform&#39;  A ,  F  --&gt;  f }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;uniform&#39; , F --&gt; f }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, F <span class="kn">at level</span> <span class="mi">69</span>,
   <span class="kn">format</span> <span class="s2">&quot;{ &#39;uniform&#39; ,  F  --&gt;  f }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;ptws&#39; U -&gt; V }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, U <span class="kn">at level</span> <span class="mi">69</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;ptws&#39;  U  -&gt;  V }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;ptws&#39; , F --&gt; f }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, F <span class="kn">at level</span> <span class="mi">69</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;ptws&#39; ,  F  --&gt;  f }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;family&#39; fam , U -&gt; V }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, U <span class="kn">at level</span> <span class="mi">69</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;family&#39;  fam ,  U  -&gt;  V }&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;{ &#39;family&#39; fam , F --&gt; f }&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, F <span class="kn">at level</span> <span class="mi">69</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;family&#39;  fam ,  F  --&gt;  f }&quot;</span>).

<span class="kn">Set Implicit Arguments</span>.
<span class="kn">Unset Strict Implicit</span>.
<span class="kn">Unset Printing Implicit Defensive</span>.

<span class="c">(* Making sure that [Program] does not automatically introduce *)</span>
<span class="kn">Obligation Tactic</span> := <span class="kp">idtac</span>.

<span class="kn">Import</span> Order.TTheory GRing.Theory Num.Theory.
<span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.

<span class="kn">Section</span> <span class="nf">bigmaxmin</span>.
<span class="kn">Local Notation</span> <span class="nf">max</span> := Order.max.
<span class="kn">Local Notation</span> <span class="nf">min</span> := Order.min.
<span class="kn">Local</span> <span class="kn">Open Scope</span> order_scope.
<span class="kn">Variables</span> (<span class="nv">d</span> : unit) (<span class="nv">T</span> : orderType d) (<span class="nv">x</span> : T) (<span class="nv">I</span> : finType) (<span class="nv">P</span> : pred I)
          (<span class="nv">m</span> : T) (<span class="nv">F</span> : I -&gt; T).

<span class="kn">Lemma</span> <span class="nf">bigmax_geP</span> : reflect (m &lt;= x \/ <span class="kr">exists2</span> i, P i &amp; m &lt;= F i)
                           (m &lt;= \big[max/x]_(i | P i) F i).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (iffP idP) =&gt; [|[mx|[i Pi mFi]]].
- <span class="nb">rewrite</span> leNgt =&gt; /bigmax_ltP /not_andP[/negP|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -leNgt; <span class="nb">left</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /existsNP[i /not_implyP[Pi /negP]]; <span class="nb">rewrite</span> -leNgt; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">i</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> bigmax_idl le_maxr mx.
- <span class="bp">by</span> <span class="nb">rewrite</span> (bigmaxD1 i)// le_maxr mFi.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigmax_gtP</span> : reflect (m &lt; x \/ <span class="kr">exists2</span> i, P i &amp; m &lt; F i)
                           (m &lt; \big[max/x]_(i | P i) F i).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (iffP idP) =&gt; [|[mx|[i Pi mFi]]].
- <span class="nb">rewrite</span> ltNge =&gt; /bigmax_leP /not_andP[/negP|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -ltNge; <span class="nb">left</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /existsNP[i /not_implyP[Pi /negP]]; <span class="nb">rewrite</span> -ltNge; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">i</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> bigmax_idl lt_maxr mx.
- <span class="bp">by</span> <span class="nb">rewrite</span> (bigmaxD1 i)// lt_maxr mFi.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigmin_leP</span> : reflect (x &lt;= m \/ <span class="kr">exists2</span> i, P i &amp; F i &lt;= m)
                           (\big[min/x]_(i | P i) F i &lt;= m).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (iffP idP) =&gt; [|[xm|[i Pi Fim]]].
- <span class="nb">rewrite</span> leNgt =&gt; /bigmin_gtP /not_andP[/negP|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -leNgt; <span class="nb">left</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /existsNP[i /not_implyP[Pi /negP]]; <span class="nb">rewrite</span> -leNgt; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">i</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> bigmin_idl le_minl xm.
- <span class="bp">by</span> <span class="nb">rewrite</span> (bigminD1 i)// le_minl Fim.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigmin_ltP</span> : reflect (x &lt; m \/ <span class="kr">exists2</span> i, P i &amp; F i &lt; m)
                           (\big[min/x]_(i | P i) F i &lt; m).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (iffP idP) =&gt; [|[xm|[i Pi Fim]]].
- <span class="nb">rewrite</span> ltNge =&gt; /bigmin_geP /not_andP[/negP|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -ltNge; <span class="nb">left</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /existsNP[i /not_implyP[Pi /negP]]; <span class="nb">rewrite</span> -ltNge; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">i</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> bigmin_idl lt_minl xm.
- <span class="bp">by</span> <span class="nb">rewrite</span> (bigminD1 _ _ _ Pi) lt_minl Fim.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">bigmaxmin</span>.

<span class="kn">Definition</span> <span class="nf">monotonous</span> <span class="nv">d</span> (<span class="nv">T</span> : porderType d) (<span class="nv">pT</span> : predType T) (<span class="nv">A</span> : pT) (<span class="nv">f</span> : T -&gt; T) :=
  {<span class="kr">in</span> A &amp;, {mono f : x y / (x &lt;= y)%O}} \/ {<span class="kr">in</span> A &amp;, {mono f : x y /~ (x &lt;= y)%O}}.

<span class="kn">Lemma</span> <span class="nf">and_prop_in</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">p</span> : mem_pred T) (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; <span class="kt">Prop</span>) :
  {<span class="kr">in</span> p, <span class="kr">forall</span> <span class="nv">x</span>, P x /\ Q x} &lt;-&gt;
  {<span class="kr">in</span> p, <span class="kr">forall</span> <span class="nv">x</span>, P x} /\ {<span class="kr">in</span> p, <span class="kr">forall</span> <span class="nv">x</span>, Q x}.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [cnd|[cnd1 cnd2] x xin]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">split</span>=&gt; x xin; <span class="nb">case</span>: (cnd x xin).
<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span>: cnd1 | <span class="nb">apply</span>: cnd2].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mem_inc_segment</span> <span class="nv">d</span> (<span class="nv">T</span> : porderType d) (<span class="nv">a</span> <span class="nv">b</span> : T) (<span class="nv">f</span> : T -&gt; T) :
    {<span class="kr">in</span> `[a, b] &amp;, {mono f : x y / (x &lt;= y)%O}} -&gt;
  {homo f : x / x \<span class="kr">in</span> `[a, b] &gt;-&gt; x \<span class="kr">in</span> `[f a, f b]}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fle x xab; <span class="nb">have</span> leab : (a &lt;= b)%O <span class="bp">by</span> <span class="nb">rewrite</span> (itvP xab).
<span class="bp">by</span> <span class="nb">rewrite</span> in_itv/= !fle ?(itvP xab).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mem_dec_segment</span> <span class="nv">d</span> (<span class="nv">T</span> : porderType d) (<span class="nv">a</span> <span class="nv">b</span> : T) (<span class="nv">f</span> : T -&gt; T) :
    {<span class="kr">in</span> `[a, b] &amp;, {mono f : x y /~ (x &lt;= y)%O}} -&gt;
  {homo f : x / x \<span class="kr">in</span> `[a, b] &gt;-&gt; x \<span class="kr">in</span> `[f b, f a]}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fge x xab; <span class="nb">have</span> leab : (a &lt;= b)%O <span class="bp">by</span> <span class="nb">rewrite</span> (itvP xab).
<span class="bp">by</span> <span class="nb">rewrite</span> in_itv/= !fge ?(itvP xab).
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">Linear1</span>.
<span class="kn">Context</span> (<span class="nv">R</span> : ringType) (<span class="nv">U</span> : lmodType R) (<span class="nv">V</span> : zmodType) (<span class="nv">s</span> : R -&gt; V -&gt; V).
<span class="kn">Canonical</span> <span class="nf">linear_eqType</span> := EqType {linear U -&gt; V | s} gen_eqMixin.
<span class="kn">Canonical</span> <span class="nf">linear_choiceType</span> := ChoiceType {linear U -&gt; V | s} gen_choiceMixin.
<span class="kn">End</span> <span class="nf">Linear1</span>.
<span class="kn">Section</span> <span class="nf">Linear2</span>.
<span class="kn">Context</span> (<span class="nv">R</span> : ringType) (<span class="nv">U</span> : lmodType R) (<span class="nv">V</span> : zmodType) (<span class="nv">s</span> : R -&gt; V -&gt; V)
        (<span class="nv">s_law</span> : GRing.Scale.law s).
<span class="kn">Canonical</span> <span class="nf">linear_pointedType</span> := PointedType {linear U -&gt; V | GRing.Scale.op s_law}
                                            (@GRing.null_fun_linear R U V s s_law).
<span class="kn">End</span> <span class="nf">Linear2</span>.

<span class="kn">Module</span> <span class="nf">Filtered</span>.

<span class="c">(* Index a family of filters on a type, one for each element of the type *)</span>
<span class="kn">Definition</span> <span class="nf">nbhs_of</span> <span class="nv">U</span> <span class="nv">T</span> := T -&gt; <span class="nb">set</span> (<span class="nb">set</span> U).
<span class="kn">Record</span> <span class="nf">class_of</span> <span class="nv">U</span> <span class="nv">T</span> := <span class="kn">Class</span> {
  base : Pointed.class_of T;
  nbhs_op : nbhs_of U T
}.

<span class="kn">Section</span> <span class="nf">ClassDef</span>.
<span class="kn">Variable</span> <span class="nv">U</span> : <span class="kt">Type</span>.

<span class="kn">Structure</span> <span class="nf">type</span> := Pack { sort; _ : class_of U sort }.
<span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type).
<span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of U cT <span class="kr">in</span> c.

<span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack T c.
<span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.
<span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of U xT).
<span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Pointed.class_of.

<span class="kn">Definition</span> <span class="nf">pack</span> <span class="nv">m</span> :=
  <span class="kr">fun</span> <span class="nv">bT</span> <span class="nv">b</span> <span class="nv">of</span> <span class="nv">phant_id</span> (<span class="nv">Pointed</span>.class bT) <span class="nv">b</span> =&gt; @Pack T (<span class="kn">Class</span> <span class="nf">b</span> <span class="nv">m</span>).

<span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">fpointedType</span> := @Pointed.Pack cT xclass.

<span class="kn">End</span> <span class="nf">ClassDef</span>.

<span class="c">(* filter on arrow sources *)</span>
<span class="kn">Structure</span> <span class="nf">source</span> <span class="nv">Z</span> <span class="nv">Y</span> := Source {
  source_type :&gt; <span class="kt">Type</span>;
  _ : (source_type -&gt; Z) -&gt; <span class="nb">set</span> (<span class="nb">set</span> Y)
}.
<span class="kn">Definition</span> <span class="nf">source_filter</span> <span class="nv">Z</span> <span class="nv">Y</span> (<span class="nv">F</span> : source Z Y) : (F -&gt; Z) -&gt; <span class="nb">set</span> (<span class="nb">set</span> Y) :=
  <span class="kr">let</span>: Source X f := F <span class="kr">in</span> f.

<span class="kn">Module</span> <span class="nf">Exports</span>.
<span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Pointed.class_of.
<span class="kn">Coercion</span> <span class="nf">nbhs_op</span> : class_of &gt;-&gt; nbhs_of.
<span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.
<span class="kn">Canonical</span> <span class="nf">eqType</span>.
<span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.
<span class="kn">Canonical</span> <span class="nf">choiceType</span>.
<span class="kn">Coercion</span> <span class="nf">fpointedType</span> : type &gt;-&gt; Pointed.type.
<span class="kn">Canonical</span> <span class="nf">fpointedType</span>.
<span class="kn">Notation</span> <span class="nf">filteredType</span> := type.
<span class="kn">Notation</span> <span class="nf">FilteredType</span> U T m := (@pack U T m _ _ idfun).
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;filteredType&#39; U &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> :=  (@clone U T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;filteredType&#39;  U  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;filteredType&#39; U &#39;of&#39; T ]&quot;</span> := (@clone U T _ _ id)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;filteredType&#39;  U  &#39;of&#39;  T ]&quot;</span>) : form_scope.

<span class="c">(* The default filter for an arbitrary element is the one obtained *)</span>
<span class="c">(* from its type *)</span>
<span class="kn">Canonical</span> <span class="nf">default_arrow_filter</span> Y (Z : pointedType) (X : source Z Y) :=
  FilteredType Y (X -&gt; Z) (@source_filter _ _ X).
<span class="kn">Canonical</span> <span class="nf">source_filter_filter</span> Y :=
  @Source <span class="kt">Prop</span> _ (_ -&gt; <span class="kt">Prop</span>) (<span class="kr">fun</span> <span class="nv">x</span> : (<span class="nb">set</span> (<span class="nb">set</span> Y)) =&gt; x).
<span class="kn">Canonical</span> <span class="nf">source_filter_filter&#39;</span> Y :=
  @Source <span class="kt">Prop</span> _ (<span class="nb">set</span> _) (<span class="kr">fun</span> <span class="nv">x</span> : (<span class="nb">set</span> (<span class="nb">set</span> Y)) =&gt; x).

<span class="kn">End</span> <span class="nf">Exports</span>.
<span class="kn">End</span> <span class="nf">Filtered</span>.
<span class="kn">Export</span> Filtered.Exports.

<span class="kn">Definition</span> <span class="nf">nbhs</span> {<span class="nv">U</span>} {<span class="nv">T</span> : filteredType U} : T -&gt; <span class="nb">set</span> (<span class="nb">set</span> U) :=
  Filtered.nbhs_op (Filtered.class T).
<span class="kn">Arguments</span> nbhs {U T} _ _ : <span class="nb">simpl</span> never.

<span class="kn">Definition</span> <span class="nf">filter_from</span> {<span class="nv">I</span> <span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">B</span> : I -&gt; <span class="nb">set</span> T) : <span class="nb">set</span> (<span class="nb">set</span> T) :=
  [<span class="nb">set</span> P | <span class="kr">exists2</span> i, D i &amp; B i `&lt;=` P].

<span class="c">(* the canonical filter on matrices on X is the product of the canonical filter</span>
<span class="c">   on X *)</span>
<span class="kn">Canonical</span> <span class="nf">matrix_filtered</span> m n X (Z : filteredType X) : filteredType &#39;M[X]_(m, n) :=
  FilteredType &#39;M[X]_(m, n) &#39;M[Z]_(m, n) (<span class="kr">fun</span> <span class="nv">mx</span> =&gt; filter_from
    [<span class="nb">set</span> P | <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, nbhs (mx i j) (P i j)]
    (<span class="kr">fun</span> <span class="nv">P</span> =&gt; [<span class="nb">set</span> my : &#39;M[X]_(m, n) | <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, P i j (my i j)])).

<span class="kn">Definition</span> <span class="nf">filter_prod</span> {<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>}
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) : <span class="nb">set</span> (<span class="nb">set</span> (T * U)) :=
  filter_from (<span class="kr">fun</span> <span class="nv">P</span> =&gt; F P.<span class="mi">1</span> /\ G P.<span class="mi">2</span>) (<span class="kr">fun</span> <span class="nv">P</span> =&gt; P.<span class="mi">1</span> `*` P.<span class="mi">2</span>).

<span class="kn">Section</span> <span class="nf">Near</span>.

<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;{ &#39;all1&#39; P }&quot;</span> := (<span class="kr">forall</span> <span class="nv">x</span>, P x : <span class="kt">Prop</span>) (<span class="kn">at level</span> <span class="mi">0</span>).
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;{ &#39;all2&#39; P }&quot;</span> := (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x y : <span class="kt">Prop</span>) (<span class="kn">at level</span> <span class="mi">0</span>).
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;{ &#39;all3&#39; P }&quot;</span> := (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, P x y z: <span class="kt">Prop</span>) (<span class="kn">at level</span> <span class="mi">0</span>).
<span class="kn">Local Notation</span> <span class="nf">ph</span> := (phantom _).

<span class="kn">Definition</span> <span class="nf">prop_near1</span> {<span class="nv">X</span>} {<span class="nv">fX</span> : filteredType X} (<span class="nv">x</span> : fX)
   <span class="nv">P</span> (<span class="nv">phP</span> : ph {all1 P}) := nbhs x P.

<span class="kn">Definition</span> <span class="nf">prop_near2</span> {<span class="nv">X</span> <span class="nv">X&#39;</span>} {<span class="nv">fX</span> : filteredType X} {<span class="nv">fX&#39;</span> : filteredType X&#39;}
  (<span class="nv">x</span> : fX) (<span class="nv">x&#39;</span> : fX&#39;) := <span class="kr">fun</span> <span class="nv">P</span> <span class="nv">of</span> <span class="nv">ph</span> {<span class="nv">all2</span> <span class="nv">P</span>} =&gt;
  filter_prod (nbhs x) (nbhs x&#39;) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P x.<span class="mi">1</span> x.<span class="mi">2</span>).

<span class="kn">End</span> <span class="nf">Near</span>.

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;near&#39; x , P }&quot;</span> := (@prop_near1 _ _ x _ (inPhantom P)) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;\forall&#39; x &#39;\near&#39; x_0 , P&quot;</span> := {near x_0, <span class="kr">forall</span> <span class="nv">x</span>, P} : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;\near&#39; x , P&quot;</span> := (\<span class="kr">forall</span> <span class="nv">x</span> \near x, P) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;near&#39; x &amp; y , P }&quot;</span> :=
  (@prop_near2 _ _ _ _ x y _ (inPhantom P)) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;\forall&#39; x &#39;\near&#39; x_0 &amp; y &#39;\near&#39; y_0 , P&quot;</span> :=
  {near x_0 &amp; y_0, <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P} : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;\forall&#39; x &amp; y &#39;\near&#39; z , P&quot;</span> :=
  {near z &amp; z, <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P} : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;&#39;\near&#39; x &amp; y , P&quot;</span> := (\<span class="kr">forall</span> <span class="nv">x</span> \near x &amp; y \near y, P) : type_scope.
<span class="kn">Arguments</span> prop_near1 : <span class="nb">simpl</span> never.
<span class="kn">Arguments</span> prop_near2 : <span class="nb">simpl</span> never.

<span class="kn">Lemma</span> <span class="nf">nearE</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} (<span class="nv">P</span> : <span class="nb">set</span> T) : (\<span class="kr">forall</span> <span class="nv">x</span> \near F, P x) = F P.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_near</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} (<span class="nv">P</span> <span class="nv">Q</span> : <span class="nb">set</span> T) :
   (<span class="kr">forall</span> <span class="nv">x</span>, P x &lt;-&gt; Q x) -&gt;
   (\<span class="kr">forall</span> <span class="nv">x</span> \near F, P x) = (\<span class="kr">forall</span> <span class="nv">x</span> \near F, Q x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /predeqP -&gt;. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">filter_of</span> <span class="nv">X</span> (<span class="nv">fX</span> : filteredType X) (<span class="nv">x</span> : fX) <span class="nv">of</span> <span class="nv">phantom</span> <span class="nv">fX</span> <span class="nv">x</span> :=
   nbhs x.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;filter&#39; &#39;of&#39; x ]&quot;</span> :=
  (@filter_of _ _ _ (Phantom _ x)) : classical_set_scope.
<span class="kn">Arguments</span> filter_of _ _ _ _ _ /.

<span class="kn">Lemma</span> <span class="nf">filter_of_filterE</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) : [filter of F] = F.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_filterE</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) : nbhs F = F.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Module</span> <span class="nf">Export</span> NbhsFilter.
<span class="kn">Definition</span> <span class="nf">nbhs_simpl</span> := (@filter_of_filterE, @nbhs_filterE).
<span class="kn">End</span> <span class="nf">NbhsFilter</span>.

<span class="kn">Definition</span> <span class="nf">cvg_to</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) := G `&lt;=` F.
<span class="kn">Notation</span> <span class="s2">&quot;F `=&gt;` G&quot;</span> := (cvg_to F G) : classical_set_scope.
<span class="kn">Lemma</span> <span class="nf">cvg_refl</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) : F `=&gt;` F.
<span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> cvg_refl {T F}.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> cvg_refl : core.

<span class="kn">Lemma</span> <span class="nf">cvg_trans</span> <span class="nv">T</span> (<span class="nv">G</span> <span class="nv">F</span> <span class="nv">H</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  (F `=&gt;` G) -&gt; (G `=&gt;` H) -&gt; (F `=&gt;` H).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FG GH P /GH /FG. <span class="kn">Qed</span>.

<span class="kn">Notation</span> <span class="s2">&quot;F --&gt; G&quot;</span> := (cvg_to [filter of F] [filter of G]) : classical_set_scope.
<span class="kn">Definition</span> <span class="nf">type_of_filter</span> {<span class="nv">T</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) := T.

<span class="kn">Definition</span> <span class="nf">lim_in</span> {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">T</span> : filteredType U) :=
  <span class="kr">fun</span> <span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U) =&gt; get (<span class="kr">fun</span> <span class="nv">l</span> : T =&gt; F --&gt; l).
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;lim&#39; F &#39;in&#39; T ]&quot;</span> := (@lim_in _ T [filter of F]) : classical_set_scope.
<span class="kn">Notation</span> <span class="nf">lim</span> F := [lim F <span class="kr">in</span> [filteredType _ of @type_of_filter _ [filter of F]]].
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;cvg&#39; F &#39;in&#39; T ]&quot;</span> := (F --&gt; [lim F <span class="kr">in</span> T]) : classical_set_scope.
<span class="kn">Notation</span> <span class="nf">cvg</span> F := [cvg F <span class="kr">in</span> [filteredType _ of @type_of_filter _ [filter of F]]].

<span class="kn">Section</span> <span class="nf">FilteredTheory</span>.

<span class="kn">Canonical</span> <span class="nf">filtered_prod</span> X1 X2 (Z1 : filteredType X1)
  (Z2 : filteredType X2) : filteredType (X1 * X2) :=
  FilteredType (X1 * X2) (Z1 * Z2)
    (<span class="kr">fun</span> <span class="nv">x</span> =&gt; filter_prod (nbhs x.<span class="mi">1</span>) (nbhs x.<span class="mi">2</span>)).

<span class="kn">Lemma</span> <span class="nf">cvg_prod</span> <span class="nv">T</span> {<span class="nv">U</span> <span class="nv">U&#39;</span> <span class="nv">V</span> <span class="nv">V&#39;</span> : filteredType T} (<span class="nv">x</span> : U) (<span class="nv">l</span> : U&#39;) (<span class="nv">y</span> : V) (<span class="nv">k</span> : V&#39;) :
  x --&gt; l -&gt; y --&gt; k -&gt; (x, y) --&gt; (l, k).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; xl yk X [[X1 X2] /= [HX1 HX2] H]; <span class="kr">exists</span> (<span class="nv">X1</span>, X2) =&gt; //=.
<span class="nb">split</span>; [<span class="bp">exact</span>: xl | <span class="bp">exact</span>: yk].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_ex</span> {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">T</span> : filteredType U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) :
  [cvg F <span class="kr">in</span> T] &lt;-&gt; (<span class="kr">exists</span> <span class="nv">l</span> : T, F --&gt; l).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; [cvg|/getPex//]; <span class="kr">exists</span> [lim F <span class="kr">in</span> T]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgP</span> {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">T</span> : filteredType U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">l</span> : T) :
   F --&gt; l -&gt; [cvg F <span class="kr">in</span> T].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Fl; <span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> <span class="nv">l</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_toP</span> {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">T</span> : filteredType U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">l</span> : T) :
   [cvg F <span class="kr">in</span> T] -&gt; [lim F <span class="kr">in</span> T] = l -&gt; F --&gt; l.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /[<span class="nb">swap</span>]-&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dvgP</span> {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">T</span> : filteredType U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) :
  ~ [cvg F <span class="kr">in</span> T] -&gt; [lim F <span class="kr">in</span> T] = point.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /lim_in /=; <span class="nb">case</span> xgetP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgNpoint</span> {<span class="nv">U</span>} (<span class="nv">T</span> : filteredType U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) :
  [lim F <span class="kr">in</span> T] != point -&gt; [cvg F <span class="kr">in</span> T].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: contra_neqP; <span class="nb">apply</span>: dvgP. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">FilteredTheory</span>.
<span class="kn">Arguments</span> cvgP {U T F} l.
<span class="kn">Arguments</span> dvgP {U} T {F}.

<span class="kn">Lemma</span> <span class="nf">nbhs_nearE</span> {<span class="nv">U</span>} {<span class="nv">T</span> : filteredType U} (<span class="nv">x</span> : T) (<span class="nv">P</span> : <span class="nb">set</span> U) :
  nbhs x P = \near x, P x.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_nbhs</span> {<span class="nv">U</span>} {<span class="nv">T</span> : filteredType U} (<span class="nv">x</span> : T) (<span class="nv">P</span> : <span class="nb">set</span> U) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near nbhs x, P x) = \near x, P x.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near2_curry</span> {<span class="nv">U</span> <span class="nv">V</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> V)) (<span class="nv">P</span> : U -&gt; <span class="nb">set</span> V) :
  {near F &amp; G, <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x y} = {near (F, G), <span class="kr">forall</span> <span class="nv">x</span>, P x.<span class="mi">1</span> x.<span class="mi">2</span>}.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near2_pair</span> {<span class="nv">U</span> <span class="nv">V</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> V)) (<span class="nv">P</span> : <span class="nb">set</span> (U * V)) :
  {near F &amp; G, <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P (x, y)} = {near (F, G), <span class="kr">forall</span> <span class="nv">x</span>, P x}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">symmetry</span>; <span class="nb">congr</span> (nbhs _); <span class="nb">rewrite</span> predeqE =&gt; -[]. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">near2E</span> := (@near2_curry, @near2_pair).

<span class="kn">Lemma</span> <span class="nf">filter_of_nearI</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : filteredType X)
  (<span class="nv">x</span> : fX) (<span class="nv">ph</span> : phantom fX x) : <span class="kr">forall</span> <span class="nv">P</span>,
  @filter_of X fX x ph P = @prop_near1 X fX x P (inPhantom (<span class="kr">forall</span> <span class="nv">x</span>, P x)).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Module</span> <span class="nf">Export</span> NearNbhs.
<span class="kn">Definition</span> <span class="nf">near_simpl</span> := (@near_nbhs, @nbhs_nearE, filter_of_nearI).
<span class="kn">Ltac</span> <span class="nf">near_simpl</span> := <span class="nb">rewrite</span> <span class="nl">?near_simpl</span>.
<span class="kn">End</span> <span class="nf">NearNbhs</span>.

<span class="kn">Lemma</span> <span class="nf">near_swap</span> {<span class="nv">U</span> <span class="nv">V</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> V)) (<span class="nv">P</span> : U -&gt; <span class="nb">set</span> V) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near F &amp; y \near G, P x y) = (\<span class="kr">forall</span> <span class="nv">y</span> \near G &amp; x \near F, P x y).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; -[[/=A B] [FA FB] ABP];
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">B</span>, A) =&gt; // -[x y] [/=Bx Ay]; <span class="nb">apply</span>: (ABP (y, x)).
<span class="kn">Qed</span>.</span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Filters</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
<a id="lab2"></a><h2 class="section">Definitions</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Class</span> <span class="nf">Filter</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) := {
  filterT : F setT ;
  filterI : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="nb">set</span> T, F P -&gt; F Q -&gt; F (P `&amp;` Q) ;
  filterS : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="nb">set</span> T, P `&lt;=` Q -&gt; F P -&gt; F Q
}.
<span class="kn">Global</span> <span class="kn">Hint Mode</span> Filter - ! : typeclass_instances.

<span class="kn">Class</span> <span class="nf">ProperFilter&#39;</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) := {
  filter_not_empty : not (F (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kt">False</span>)) ;
  filter_filter&#39; : Filter F
}.
<span class="c">(* TODO: Reuse :&gt; above and remove the following line and the coercion below</span>
<span class="c">   after 8.17 is the minimum required version for Coq *)</span>
<span class="kn">Global Existing Instance</span> <span class="nf">filter_filter&#39;</span>.
<span class="kn">Global</span> <span class="kn">Hint Mode</span> ProperFilter&#39; - ! : typeclass_instances.
<span class="kn">Arguments</span> filter_not_empty {T} F {_}.

<span class="kn">Notation</span> <span class="nf">ProperFilter</span> := ProperFilter&#39;.

<span class="kn">Lemma</span> <span class="nf">filter_setT</span> (<span class="nv">T&#39;</span> : <span class="kt">Type</span>) : Filter [<span class="nb">set</span>: <span class="nb">set</span> T&#39;].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">constructor</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filterP_strong</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : Filter F} (<span class="nv">P</span> : <span class="nb">set</span> T) :
  (<span class="kr">exists</span> <span class="nv">Q</span> : <span class="nb">set</span> T, <span class="kr">exists</span> <span class="nv">FQ</span>  : F Q, <span class="kr">forall</span> <span class="nv">x</span> : T, Q x -&gt; P x) &lt;-&gt; F P.
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">P</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [Q [FQ QP]]; <span class="nb">apply</span>: (filterS QP).
<span class="kn">Qed</span>.

<span class="kn">Structure</span> <span class="nf">filter_on</span> <span class="nv">T</span> := FilterType {
  filter :&gt; (T -&gt; <span class="kt">Prop</span>) -&gt; <span class="kt">Prop</span>;
  _ : Filter filter
}.
<span class="kn">Definition</span> <span class="nf">filter_class</span> <span class="nv">T</span> (<span class="nv">F</span> : filter_on T) : Filter F :=
  <span class="kr">let</span>: FilterType _ class := F <span class="kr">in</span> class.
<span class="kn">Arguments</span> FilterType {T} _ _.
#[<span class="kn">global</span>] <span class="kn">Existing Instance</span> <span class="nf">filter_class</span>.
<span class="c">(* Typeclasses Opaque filter. *)</span>
<span class="kn">Coercion</span> <span class="nf">filter_filter&#39;</span> : ProperFilter &gt;-&gt; Filter.

<span class="kn">Structure</span> <span class="nf">pfilter_on</span> <span class="nv">T</span> := PFilterPack {
  pfilter :&gt; (T -&gt; <span class="kt">Prop</span>) -&gt; <span class="kt">Prop</span>;
  _ : ProperFilter pfilter
}.
<span class="kn">Definition</span> <span class="nf">pfilter_class</span> <span class="nv">T</span> (<span class="nv">F</span> : pfilter_on T) : ProperFilter F :=
  <span class="kr">let</span>: PFilterPack _ class := F <span class="kr">in</span> class.
<span class="kn">Arguments</span> PFilterPack {T} _ _.
#[<span class="kn">global</span>] <span class="kn">Existing Instance</span> <span class="nf">pfilter_class</span>.
<span class="c">(* Typeclasses Opaque pfilter. *)</span>
<span class="kn">Canonical</span> <span class="nf">pfilter_filter_on</span> T (F : pfilter_on T) :=
  FilterType F (pfilter_class F).
<span class="kn">Coercion</span> <span class="nf">pfilter_filter_on</span> : pfilter_on &gt;-&gt; filter_on.
<span class="kn">Definition</span> <span class="nf">PFilterType</span> {<span class="nv">T</span>} (<span class="nv">F</span> : (T -&gt; <span class="kt">Prop</span>) -&gt; <span class="kt">Prop</span>)
  {<span class="nv">fF</span> : Filter F} (<span class="nv">fN0</span> : not (F set0)) :=
  PFilterPack F (Build_ProperFilter&#39; fN0 fF).
<span class="kn">Arguments</span> PFilterType {T} F {fF} fN0.

<span class="kn">Canonical</span> <span class="nf">filter_on_eqType</span> T := EqType (filter_on T) gen_eqMixin.
<span class="kn">Canonical</span> <span class="nf">filter_on_choiceType</span> T :=
  ChoiceType (filter_on T) gen_choiceMixin.
<span class="kn">Canonical</span> <span class="nf">filter_on_PointedType</span> T :=
  PointedType (filter_on T) (FilterType _ (filter_setT T)).
<span class="kn">Canonical</span> <span class="nf">filter_on_FilteredType</span> T :=
  FilteredType T (filter_on T) (@filter T).

<span class="kn">Global Instance</span> <span class="nf">filter_on_Filter</span> <span class="nv">T</span> (<span class="nv">F</span> : filter_on T) : Filter F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: F. <span class="kn">Qed</span>.
<span class="kn">Global Instance</span> <span class="nf">pfilter_on_ProperFilter</span> <span class="nv">T</span> (<span class="nv">F</span> : pfilter_on T) : ProperFilter F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: F. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_filter_onE</span> <span class="nv">T</span> (<span class="nv">F</span> : filter_on T) : nbhs F = nbhs (filter F).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">nbhs_simpl</span> := (@nbhs_simpl, @nbhs_filter_onE).

<span class="kn">Lemma</span> <span class="nf">near_filter_onE</span> <span class="nv">T</span> (<span class="nv">F</span> : filter_on T) (<span class="nv">P</span> : <span class="nb">set</span> T) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near F, P x) = \<span class="kr">forall</span> <span class="nv">x</span> \near filter F, P x.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">near_simpl</span> := (@near_simpl, @near_filter_onE).

<span class="kn">Program Definition</span> <span class="nf">trivial_filter_on</span> <span class="nv">T</span> := FilterType [<span class="nb">set</span> setT : <span class="nb">set</span> T] _.
<span class="kn">Next Obligation</span>.
<span class="nb">split</span>=&gt; // [_ _ -&gt; -&gt;|Q R sQR QT]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> setIT.
<span class="bp">by</span> <span class="nb">move</span>; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; // ? _; <span class="nb">apply</span>/sQR; <span class="nb">rewrite</span> QT.
<span class="kn">Qed</span>.
<span class="kn">Canonical</span> <span class="nf">trivial_filter_on</span>.

<span class="kn">Lemma</span> <span class="nf">filter_nbhsT</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
   Filter F -&gt; nbhs F setT.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FF; <span class="nb">apply</span>: filterT. <span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> filter_nbhsT : core.

<span class="kn">Lemma</span> <span class="nf">nearT</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) : Filter F -&gt; \near F, <span class="kt">True</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FF; <span class="nb">apply</span>: filterT. <span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> nearT : core.

<span class="kn">Lemma</span> <span class="nf">filter_not_empty_ex</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
    (<span class="kr">forall</span> <span class="nv">P</span>, F P -&gt; <span class="kr">exists</span> <span class="nv">x</span>, P x) -&gt; ~ F set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /(_ set0) ex /ex []. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">Build_ProperFilter</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T))
  (<span class="nv">filter_ex</span> : <span class="kr">forall</span> <span class="nv">P</span>, F P -&gt; <span class="kr">exists</span> <span class="nv">x</span>, P x)
  (<span class="nv">filter_filter</span> : Filter F) :=
  Build_ProperFilter&#39; (filter_not_empty_ex filter_ex) (filter_filter).

<span class="kn">Lemma</span> <span class="nf">filter_ex_subproof</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
     ~ F set0 -&gt; (<span class="kr">forall</span> <span class="nv">P</span>, F P -&gt; <span class="kr">exists</span> <span class="nv">x</span>, P x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; NFset0 P FP; <span class="nb">apply</span>: contra_notP NFset0 =&gt; nex; <span class="nb">suff</span> &lt;- : P = set0 <span class="bp">by</span> [].
<span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; // Px; <span class="nb">apply</span>: nex; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">filter_ex</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : ProperFilter F} :=
  filter_ex_subproof (filter_not_empty F).
<span class="kn">Arguments</span> filter_ex {T F FF _}.

<span class="kn">Lemma</span> <span class="nf">filter_getP</span> {<span class="nv">T</span> : pointedType} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : ProperFilter F}
      (<span class="nv">P</span> : <span class="nb">set</span> T) : F P -&gt; P (get P).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /filter_ex /getPex. <span class="kn">Qed</span>.

<span class="c">(* Near Tactic *)</span>

<span class="kn">Record</span> <span class="nf">in_filter</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) := InFilter {
  prop_in_filter_proj : T -&gt; <span class="kt">Prop</span>;
  prop_in_filterP_proj : F prop_in_filter_proj
}.
<span class="c">(* add ball x e as a canonical instance of nbhs x *)</span>

<span class="kn">Module Type</span> <span class="nf">PropInFilterSig</span>.
<span class="kn">Axiom</span> <span class="nv">t</span> : <span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)), in_filter F -&gt; T -&gt; <span class="kt">Prop</span>.
<span class="kn">Axiom</span> <span class="nv">tE</span> : t = prop_in_filter_proj.
<span class="kn">End</span> <span class="nf">PropInFilterSig</span>.
<span class="kn">Module</span> <span class="nf">PropInFilter</span> : PropInFilterSig.
<span class="kn">Definition</span> <span class="nf">t</span> := prop_in_filter_proj.
<span class="kn">Lemma</span> <span class="nf">tE</span> : t = prop_in_filter_proj. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">PropInFilter</span>.
<span class="c">(* Coercion PropInFilter.t : in_filter &gt;-&gt; Funclass. *)</span>
<span class="kn">Notation</span> <span class="nf">prop_of</span> := PropInFilter.t.
<span class="kn">Definition</span> <span class="nf">prop_ofE</span> := PropInFilter.tE.
<span class="kn">Notation</span> <span class="s2">&quot;x \is_near F&quot;</span> := (@PropInFilter.t _ F _ x).
<span class="kn">Definition</span> <span class="nf">is_nearE</span> := prop_ofE.

<span class="kn">Lemma</span> <span class="nf">prop_ofP</span> <span class="nv">T</span> <span class="nv">F</span> (<span class="nv">iF</span> : @in_filter T F) : F (prop_of iF).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> prop_ofE; <span class="nb">apply</span>: prop_in_filterP_proj. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">in_filterT</span> <span class="nv">T</span> <span class="nv">F</span> (<span class="nv">FF</span> : Filter F) : @in_filter T F :=
  InFilter (filterT).
<span class="kn">Canonical</span> <span class="nf">in_filterI</span> T F (FF : Filter F) (P Q : @in_filter T F) :=
  InFilter (filterI (prop_in_filterP_proj P) (prop_in_filterP_proj Q)).

<span class="kn">Lemma</span> <span class="nf">filter_near_of</span> <span class="nv">T</span> <span class="nv">F</span> (<span class="nv">P</span> : @in_filter T F) (<span class="nv">Q</span> : <span class="nb">set</span> T) : Filter F -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, prop_of P x -&gt; Q x) -&gt; F Q.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>: P =&gt; [P FP] FF /=; <span class="nb">rewrite</span> prop_ofE /= =&gt; /filterS; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Fact</span> <span class="nf">near_key</span> : unit. <span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mark_near</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : locked_with near_key P -&gt; P.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> <span class="nb">unlock</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_acc</span> <span class="nv">T</span> <span class="nv">F</span> (<span class="nv">P</span> : @in_filter T F) (<span class="nv">Q</span> : <span class="nb">set</span> T) (<span class="nv">FF</span> : Filter F)
   (<span class="nv">FQ</span> : \<span class="kr">forall</span> <span class="nv">x</span> \near F, Q x) :
   locked_with near_key (<span class="kr">forall</span> <span class="nv">x</span>, prop_of (in_filterI FF P (InFilter FQ)) x -&gt; Q x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> <span class="nb">unlock</span> =&gt; x /=; <span class="nb">rewrite</span> !prop_ofE /= =&gt; -[Px]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_skip_subproof</span> <span class="nv">T</span> <span class="nv">F</span> (<span class="nv">P</span> <span class="nv">Q</span> : @in_filter T F) (<span class="nv">G</span> : <span class="nb">set</span> T) (<span class="nv">FF</span> : Filter F) :
   locked_with near_key (<span class="kr">forall</span> <span class="nv">x</span>, prop_of P x -&gt; G x) -&gt;
   locked_with near_key (<span class="kr">forall</span> <span class="nv">x</span>, prop_of (in_filterI FF P Q) x -&gt; G x).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> !<span class="nb">unlock</span> =&gt; FG x /=; <span class="nb">rewrite</span> !prop_ofE /= =&gt; -[Px Qx].
<span class="bp">by</span> <span class="nb">have</span> /= := FG x; <span class="nb">apply</span>; <span class="nb">rewrite</span> prop_ofE.
<span class="kn">Qed</span>.

<span class="kn">Tactic Notation</span> <span class="s2">&quot;near=&gt;&quot;</span> <span class="kn">ident</span>(x) := <span class="nb">apply</span>: filter_near_of =&gt; x ?.

<span class="kn">Ltac</span> <span class="nf">just_discharge_near</span> x :=
  <span class="kr">tryif</span> <span class="kr">match goal with</span> Hx : x \is_near _ |- _ =&gt; <span class="nb">move</span>: (x) (Hx); <span class="nb">apply</span>: mark_near <span class="kr">end</span>
        <span class="kr">then</span> <span class="kp">idtac</span> <span class="kr">else</span> <span class="kp">fail</span> <span class="s2">&quot;the variable&quot;</span> x <span class="s2">&quot;is not a &quot;&quot;near&quot;&quot; variable&quot;</span>.
<span class="kn">Ltac</span> <span class="nf">near_skip</span> :=
  <span class="kr">match goal with</span> |- locked_with near_key (<span class="kr">forall</span> <span class="nv">_</span>, @PropInFilter.t _ _ <span class="nl">?P</span> _ -&gt; _) =&gt;
    <span class="kr">tryif</span> <span class="nb">is_evar</span> P <span class="kr">then</span> <span class="kp">fail</span> <span class="s2">&quot;nothing to skip&quot;</span> <span class="kr">else</span> <span class="nb">apply</span>: near_skip_subproof <span class="kr">end</span>.

<span class="kn">Tactic Notation</span> <span class="s2">&quot;near:&quot;</span> <span class="kn">ident</span>(x) :=
  just_discharge_near x;
  <span class="kr">tryif</span> <span class="kp">do</span> ![<span class="nb">apply</span>: near_acc; <span class="kp">first</span> <span class="nb">shelve</span>|near_skip]
  <span class="kr">then</span> <span class="kp">idtac</span>
  <span class="kr">else</span> <span class="kp">fail</span> <span class="s2">&quot;the goal depends on variables introduced after&quot;</span> x.

<span class="kn">Ltac</span> <span class="nf">under_near</span> i tac := near=&gt; i; tac; near: i.
<span class="kn">Tactic Notation</span> <span class="s2">&quot;near=&gt;&quot;</span> <span class="kn">ident</span>(i) <span class="s2">&quot;do&quot;</span> tactic1(tac) := under_near i <span class="kp">ltac</span>:(tac).
<span class="kn">Tactic Notation</span> <span class="s2">&quot;near=&gt;&quot;</span> <span class="kn">ident</span>(i) <span class="s2">&quot;do&quot;</span> <span class="s2">&quot;[&quot;</span> tactic4(tac) <span class="s2">&quot;]&quot;</span> := near=&gt; i <span class="kp">do</span> tac.
<span class="kn">Tactic Notation</span> <span class="s2">&quot;near&quot;</span> <span class="s2">&quot;do&quot;</span> tactic1(tac) :=
  <span class="kr">let</span> <span class="nv">i</span> := <span class="kp">fresh</span> <span class="s2">&quot;i&quot;</span> <span class="kr">in</span> under_near i <span class="kp">ltac</span>:(tac).
<span class="kn">Tactic Notation</span> <span class="s2">&quot;near&quot;</span> <span class="s2">&quot;do&quot;</span> <span class="s2">&quot;[&quot;</span> tactic4(tac) <span class="s2">&quot;]&quot;</span> := near <span class="kp">do</span> tac.

<span class="kn">Ltac</span> <span class="nf">end_near</span> := <span class="kp">do</span> <span class="nl">?exact</span>: in_filterT.

<span class="kn">Ltac</span> <span class="nf">done</span> :=
  <span class="nb">trivial</span>; <span class="nb">hnf</span>; <span class="nb">intros</span>; <span class="kp">solve</span>
   [ <span class="kp">do</span> ![<span class="kp">solve</span> [<span class="nb">trivial</span> | <span class="nb">apply</span>: sym_equal; <span class="nb">trivial</span>]
         | <span class="bp">discriminate</span> | <span class="bp">contradiction</span> | <span class="nb">split</span>]
   | <span class="nb">case</span> not_locked_false_eq_true; <span class="bp">assumption</span>
   | <span class="kr">match goal with</span> H : ~ _ |- _ =&gt; <span class="kp">solve</span> [<span class="nb">case</span> H; <span class="nb">trivial</span>] <span class="kr">end</span>
   | <span class="kr">match goal with</span> |- <span class="nl">?x</span> \is_near _ =&gt; near: x; <span class="nb">apply</span>: prop_ofP <span class="kr">end</span> ].

<span class="kn">Lemma</span> <span class="nf">have_near</span> (<span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">fT</span> : filteredType U) (<span class="nv">x</span> : fT) (<span class="nv">P</span> : <span class="kt">Prop</span>) :
  ProperFilter (nbhs x) -&gt; (\<span class="kr">forall</span> <span class="nv">x</span> \near x, P) -&gt; P.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FF nP; <span class="nb">have</span> [] := @filter_ex _ _ FF (<span class="kr">fun</span>=&gt; P). <span class="kn">Qed</span>.
<span class="kn">Arguments</span> have_near {U fT} x.

<span class="kn">Tactic Notation</span> <span class="s2">&quot;near&quot;</span> <span class="kp">constr</span>(F) <span class="s2">&quot;=&gt;&quot;</span> <span class="kn">ident</span>(x) :=
  <span class="nb">apply</span>: (have_near F); near=&gt; x.

<span class="kn">Lemma</span> <span class="nf">near</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) <span class="nv">P</span> (<span class="nv">FP</span> : F P) (<span class="nv">x</span> : T)
  (<span class="nv">Px</span> : prop_of (InFilter FP) x) : P x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>: Px; <span class="nb">rewrite</span> prop_ofE. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> near {T F P} FP x Px.

<span class="kn">Lemma</span> <span class="nf">nearW</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) :
  Filter F -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, P x) -&gt; (\<span class="kr">forall</span> <span class="nv">x</span> \near F, P x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FF FP; <span class="nb">apply</span>: filterS filterT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filterE</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} :
  Filter F -&gt; <span class="kr">forall</span> <span class="nv">P</span> : <span class="nb">set</span> T, (<span class="kr">forall</span> <span class="nv">x</span>, P x) -&gt; F P.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; [FT _ +] P fP =&gt; /(_ setT); <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_app</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="nb">set</span> T, F (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P x -&gt; Q x) -&gt; F P -&gt; F Q.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FF P Q subPQ FP; near=&gt; x <span class="kp">do</span> <span class="nb">suff</span>: P x.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_app2</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="nb">set</span> T,  F (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P x -&gt; Q x -&gt; R x) -&gt;
  F P -&gt; F Q -&gt; F R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ???? PQR FP; <span class="nb">apply</span>: filter_app; <span class="nb">apply</span>: filter_app FP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_app3</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> <span class="nv">S</span> : <span class="nb">set</span> T, F (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P x -&gt; Q x -&gt; R x -&gt; S x) -&gt;
  F P -&gt; F Q -&gt; F R -&gt; F S.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ????? PQR FP; <span class="nb">apply</span>: filter_app2; <span class="nb">apply</span>: filter_app FP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filterS2</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="nb">set</span> T, (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; Q x -&gt; R x) -&gt;
  F P -&gt; F Q -&gt; F R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ? ? ?; <span class="nb">apply</span>: filter_app2; <span class="nb">apply</span>: filterE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filterS3</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> <span class="nv">S</span> : <span class="nb">set</span> T, (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; Q x -&gt; R x -&gt; S x) -&gt;
  F P -&gt; F Q -&gt; F R -&gt; F S.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ? ? ? ?; <span class="nb">apply</span>: filter_app3; <span class="nb">apply</span>: filterE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_const</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">F</span>} {<span class="nv">FF</span>: @ProperFilter T F} (<span class="nv">P</span> : <span class="kt">Prop</span>) :
  F (<span class="kr">fun</span>=&gt; P) -&gt; P.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FP; <span class="nb">case</span>: (filter_ex FP). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">in_filter_from</span> {<span class="nv">I</span> <span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">B</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">i</span> : I) :
  D i -&gt; filter_from D B (B i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_andP</span> {<span class="nv">T</span> : <span class="kt">Type</span>} <span class="nv">F</span> (<span class="nv">b1</span> <span class="nv">b2</span> : T -&gt; <span class="kt">Prop</span>) : Filter F -&gt;
  (\<span class="kr">forall</span> <span class="nv">x</span> \near F, b1 x /\ b2 x) &lt;-&gt;
    (\<span class="kr">forall</span> <span class="nv">x</span> \near F, b1 x) /\ (\<span class="kr">forall</span> <span class="nv">x</span> \near F, b2 x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">split</span>=&gt; [H|[H1 H2]]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">split</span>; <span class="nb">apply</span>: filterS H =&gt; ? [].
<span class="bp">by</span> <span class="nb">apply</span>: filterS2 H1 H2.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nearP_dep</span> {<span class="nv">T</span> <span class="nv">U</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)}
   {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} (<span class="nv">P</span> : T -&gt; U -&gt; <span class="kt">Prop</span>) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near F &amp; y \near G, P x y) -&gt;
  \<span class="kr">forall</span> <span class="nv">x</span> \near F, \<span class="kr">forall</span> <span class="nv">y</span> \near G, P x y.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [[Q R] [/=FQ GR]] QRP.
<span class="bp">by</span> <span class="nb">apply</span>: filterS FQ =&gt; x Q1x; <span class="nb">apply</span>: filterS GR =&gt; y Q2y; <span class="nb">apply</span>: (QRP (_, _)).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter2P</span> <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U))
  {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} (<span class="nv">P</span> : <span class="nb">set</span> (T * U)) :
  (<span class="kr">exists2</span> Q : <span class="nb">set</span> T * <span class="nb">set</span> U, F Q.<span class="mi">1</span> /\ G Q.<span class="mi">2</span>
     &amp; <span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : U), Q.<span class="mi">1</span> x -&gt; Q.<span class="mi">2</span> y -&gt; P (x, y))
   &lt;-&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near (F, G), P x.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [][[A B] /=[FA GB] ABP]; <span class="kr">exists</span> (<span class="nv">A</span>, B) =&gt; //=.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [a b] [/=Aa Bb]; <span class="nb">apply</span>: ABP.
<span class="bp">by</span> <span class="nb">move</span>=&gt; a b Aa Bb; <span class="nb">apply</span>: (ABP (_, _)).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_ex2</span> {<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U))
  {<span class="nv">FF</span> : ProperFilter F} {<span class="nv">FG</span> : ProperFilter G} (<span class="nv">P</span> : <span class="nb">set</span> T) (<span class="nv">Q</span> : <span class="nb">set</span> U) :
    F P -&gt; G Q -&gt; <span class="kr">exists</span> <span class="nv">x</span> : T, <span class="kr">exists2</span> y : U, P x &amp; Q y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /filter_ex [x Px] /filter_ex [y Qy]; <span class="kr">exists</span> <span class="nv">x</span>, y. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> filter_ex2 {T U F G FF FG _ _}.

<span class="kn">Lemma</span> <span class="nf">filter_fromP</span> {<span class="nv">I</span> <span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">B</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; F `=&gt;` filter_from D B &lt;-&gt; <span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; F (B i).
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; FB i ?; <span class="nb">apply</span>/FB/in_filter_from.
<span class="bp">by</span> <span class="nb">move</span>=&gt; FB P [i Di BjP]; <span class="nb">apply</span>: (filterS BjP); <span class="nb">apply</span>: FB.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_fromTP</span> {<span class="nv">I</span> <span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; F `=&gt;` filter_from setT B &lt;-&gt; <span class="kr">forall</span> <span class="nv">i</span>, F (B i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FF; <span class="nb">rewrite</span> filter_fromP; <span class="nb">split</span>=&gt; [P i|P i _]; <span class="nb">apply</span>: P. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_from_filter</span> {<span class="nv">I</span> <span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">B</span> : I -&gt; <span class="nb">set</span> T) :
  (<span class="kr">exists</span> <span class="nv">i</span> : I, D i) -&gt;
  (<span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, D i -&gt; D j -&gt; <span class="kr">exists2</span> k, D k &amp; B k `&lt;=` B i `&amp;` B j) -&gt;
  Filter (filter_from D B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [i0 Di0] Binter; <span class="nb">constructor</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i0</span>.
  <span class="nb">move</span>=&gt; P Q [i Di BiP] [j Dj BjQ]; <span class="nb">have</span> [k Dk BkPQ]:= Binter _ _ Di Dj.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span> =&gt; // x /BkPQ [/BiP ? /BjQ].
<span class="bp">by</span> <span class="nb">move</span>=&gt; P Q subPQ [i Di BiP]; <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">apply</span>: subset_trans subPQ.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_fromT_filter</span> {<span class="nv">I</span> <span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : I -&gt; <span class="nb">set</span> T) :
  (<span class="kr">exists</span> <span class="nv">_</span> : I, <span class="kt">True</span>) -&gt;
  (<span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, <span class="kr">exists</span> <span class="nv">k</span>, B k `&lt;=` B i `&amp;` B j) -&gt;
  Filter (filter_from setT B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [i0 _] BI; <span class="nb">apply</span>: filter_from_filter; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i0</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; i j _ _; <span class="nb">have</span> [k] := BI i j; <span class="kr">exists</span> <span class="nv">k</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_from_proper</span> {<span class="nv">I</span> <span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">B</span> : I -&gt; <span class="nb">set</span> T) :
  Filter (filter_from D B) -&gt;
  (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; B i !=set0) -&gt;
  ProperFilter (filter_from D B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF BN0; <span class="nb">apply</span>: Build_ProperFilter=&gt; P [i Di BiP].
<span class="bp">by</span> <span class="nb">have</span> [x Bix] := BN0 _ Di; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">apply</span>: BiP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_bigI</span> <span class="nv">T</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : {fset I}) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T)
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, i \<span class="kr">in</span> D -&gt; F (f i)) -&gt;
  F (\bigcap_(i <span class="kr">in</span> [<span class="nb">set</span> i | i \<span class="kr">in</span> D]) f i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF FfD.
<span class="nb">suff</span>: F [<span class="nb">set</span> p | <span class="kr">forall</span> <span class="nv">i</span>, i \<span class="kr">in</span> enum_fset D -&gt; f i p] <span class="bp">by</span> [].
<span class="nb">have</span> {FfD} : <span class="kr">forall</span> <span class="nv">i</span>, i \<span class="kr">in</span> enum_fset D -&gt; F (f i) <span class="bp">by</span> <span class="nb">move</span>=&gt; ? /FfD.
<span class="nb">elim</span>: (enum_fset D) =&gt; [|i s ihs] FfD; <span class="kp">first</span> <span class="bp">exact</span>: filterS filterT.
<span class="nb">apply</span>: (@filterS _ _ _ (f i `&amp;` [<span class="nb">set</span> p | <span class="kr">forall</span> <span class="nv">i</span>, i \<span class="kr">in</span> s -&gt; f i p])).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; p [fip fsp] j; <span class="nb">rewrite</span> inE =&gt; /orP [/eqP-&gt;|] //; <span class="nb">apply</span>: fsp.
<span class="nb">apply</span>: filterI; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: FfD; <span class="nb">rewrite</span> inE eq_refl.
<span class="bp">by</span> <span class="nb">apply</span>: ihs =&gt; j sj; <span class="nb">apply</span>: FfD; <span class="nb">rewrite</span> inE sj orbC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_forall</span> <span class="nv">T</span> (<span class="nv">I</span> : finType) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
    Filter F -&gt; (<span class="kr">forall</span> <span class="nv">i</span> : I, \<span class="kr">forall</span> <span class="nv">x</span> \near F, f i x) -&gt;
  \<span class="kr">forall</span> <span class="nv">x</span> \near F, <span class="kr">forall</span> <span class="nv">i</span>, f i x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF fIF; <span class="nb">apply</span>: filterS (@filter_bigI T I [fset x <span class="kr">in</span> I]%fset f F FF _).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x fIx i; <span class="nb">have</span> := fIx i; <span class="nb">rewrite</span> /= inE/=; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">rewrite</span> inE/= =&gt; _; <span class="nb">apply</span>: (fIF i).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_imply</span> [T : <span class="kt">Type</span>] [P : <span class="kt">Prop</span>] [f : <span class="nb">set</span> T] [F : <span class="nb">set</span> (<span class="nb">set</span> T)] :
  Filter F -&gt; (P -&gt; \near F, f F) -&gt; \near F, P -&gt; f F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ? PF; near <span class="kp">do</span> <span class="nb">move</span>=&gt; /asboolP.
<span class="bp">by</span> <span class="nb">case</span>: asboolP=&gt; [/PF|_]; <span class="bp">by</span> [<span class="nb">apply</span>: filterS|<span class="nb">apply</span>: nearW].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.</span></pre><div class="doc">
<a id="lab3"></a><h2 class="section">Limits expressed with filters</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">fmap</span> {<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :=
  [<span class="nb">set</span> P | F (f @^-<span class="mi">1</span>` P)].
<span class="kn">Arguments</span> fmap _ _ _ _ _ /.

<span class="kn">Lemma</span> <span class="nf">fmapE</span> {<span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : U -&gt; V)
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">P</span> : <span class="nb">set</span> V) : fmap f F P = F (f @^-<span class="mi">1</span>` P).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Notation</span> <span class="s2">&quot;E @[ x --&gt; F ]&quot;</span> :=
  (fmap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; E) [filter of F]) : classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;f @ F&quot;</span> := (fmap f [filter of F]) : classical_set_scope.
<span class="kn">Global Instance</span> <span class="nf">fmap_filter</span> <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; Filter (f @ F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">constructor</span> =&gt; [|P Q|P Q PQ]; <span class="nb">rewrite</span> <span class="nl">?fmapE</span> <span class="nl">?filter_ofE</span> //=.
- <span class="bp">exact</span>: filterT.
- <span class="bp">exact</span>: filterI.
- <span class="bp">by</span> <span class="nb">apply</span>: filterS=&gt; ?/PQ.
<span class="kn">Qed</span>.
<span class="c">(*Typeclasses Opaque fmap.*)</span>

<span class="kn">Global Instance</span> <span class="nf">fmap_proper_filter</span> <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  ProperFilter F -&gt; ProperFilter (f @ F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">apply</span>: Build_ProperFilter&#39;;
<span class="bp">by</span> <span class="nb">rewrite</span> fmapE; <span class="nb">apply</span>: filter_not_empty.
<span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">fmap_proper_filter&#39;</span> := fmap_proper_filter.

<span class="kn">Definition</span> <span class="nf">fmapi</span> {<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :=
  [<span class="nb">set</span> P | \<span class="kr">forall</span> <span class="nv">x</span> \near F, <span class="kr">exists</span> <span class="nv">y</span>, f x y /\ P y].

<span class="kn">Notation</span> <span class="s2">&quot;E `@[ x --&gt; F ]&quot;</span> :=
  (fmapi (<span class="kr">fun</span> <span class="nv">x</span> =&gt; E) [filter of F]) : classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;f `@ F&quot;</span> := (fmapi f [filter of F]) : classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">fmapiE</span> {<span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : U -&gt; <span class="nb">set</span> V)
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">P</span> : <span class="nb">set</span> V) :
  fmapi f F P = \<span class="kr">forall</span> <span class="nv">x</span> \near F, <span class="kr">exists</span> <span class="nv">y</span>, f x y /\ P y.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">fmapi_filter</span> <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">f</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  infer {near F, is_totalfun f} -&gt; Filter F -&gt; Filter (f `@ F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_totalfun FF; <span class="nb">rewrite</span> /fmapi; <span class="nb">apply</span>: Build_Filter.
- <span class="bp">by</span> <span class="nb">apply</span>: filterS f_totalfun =&gt; x [[y Hy] H]; <span class="kr">exists</span> <span class="nv">y</span>.
- <span class="nb">move</span>=&gt; /= P Q FP FQ; near=&gt; x.
    <span class="nb">have</span> [//|y [fxy Py]] := near FP x.
    <span class="nb">have</span> [//|z [fxz Qz]] := near FQ x.
    <span class="nb">have</span> [//|_ fx_prop] := near f_totalfun x.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">split</span> =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> [y](fx_prop _ z).
- <span class="nb">move</span>=&gt; /= P Q subPQ FP; near=&gt; x.
  <span class="bp">by</span> <span class="nb">have</span> [//|y [fxy /subPQ Qy]] := near FP x; <span class="kr">exists</span> <span class="nv">y</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

#[<span class="kn">global</span>] <span class="kn">Typeclasses Opaque</span> fmapi.

<span class="kn">Global Instance</span> <span class="nf">fmapi_proper_filter</span>
  <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">f</span> : T -&gt; U -&gt; <span class="kt">Prop</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  infer {near F, is_totalfun f} -&gt;
  ProperFilter F -&gt; ProperFilter (f `@ F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_totalfun FF; <span class="nb">apply</span>: Build_ProperFilter.
<span class="bp">by</span> <span class="nb">move</span>=&gt; P; <span class="nb">rewrite</span> /fmapi/= =&gt; /filter_ex [x [y [??]]]; <span class="kr">exists</span> <span class="nv">y</span>.
<span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">filter_map_proper_filter&#39;</span> := fmapi_proper_filter.

<span class="kn">Lemma</span> <span class="nf">cvg_id</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) : x @[x --&gt; F] --&gt; F.
<span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> cvg_id {T F}.

<span class="kn">Lemma</span> <span class="nf">fmap_comp</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : B -&gt; C) (<span class="nv">g</span> : A -&gt; B) <span class="nv">F</span>:
  Filter F -&gt; (f \o g)%FUN @ F = f @ (g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">appfilter</span> <span class="nv">U</span> <span class="nv">V</span> (<span class="nv">f</span> : U -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) :
  f @ F = [<span class="nb">set</span> P : <span class="nb">set</span> _ | \<span class="kr">forall</span> <span class="nv">x</span> \near F, P (f x)].
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_app</span> <span class="nv">U</span> <span class="nv">V</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">f</span> : U -&gt; V) :
  F --&gt; G -&gt; f @ F --&gt; f @ G.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FG P /=; <span class="bp">exact</span>: FG. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> cvg_app {U V F G} _.

<span class="kn">Lemma</span> <span class="nf">cvgi_app</span> <span class="nv">U</span> <span class="nv">V</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">f</span> : U -&gt; <span class="nb">set</span> V) :
  F --&gt; G -&gt; f `@ F --&gt; f `@ G.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FG P /=; <span class="bp">exact</span>: FG. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_comp</span> <span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> (<span class="nv">f</span> : T -&gt; U) (<span class="nv">g</span> : U -&gt; V)
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">H</span> : <span class="nb">set</span> (<span class="nb">set</span> V)) :
  f @ F `=&gt;` G -&gt; g @ G `=&gt;` H -&gt; g \o f @ F `=&gt;` H.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fFG gGH; <span class="nb">apply</span>: cvg_trans gGH =&gt; P /fFG. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgi_comp</span> <span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> (<span class="nv">f</span> : T -&gt; U) (<span class="nv">g</span> : U -&gt; <span class="nb">set</span> V)
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">H</span> : <span class="nb">set</span> (<span class="nb">set</span> V)) :
  f @ F `=&gt;` G -&gt; g `@ G `=&gt;` H -&gt; g \o f `@ F `=&gt;` H.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fFG gGH; <span class="nb">apply</span>: cvg_trans gGH =&gt; P /fFG. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_eq_cvg</span> {<span class="nv">T</span> <span class="nv">U</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U) :
  {near F, f =<span class="mi">1</span> g} -&gt; g @ F `=&gt;` f @ F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; eq_fg P /=; <span class="nb">apply</span>: filterS2 eq_fg =&gt; x /= &lt;-. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_cvg</span> (<span class="nv">T</span> <span class="nv">T&#39;</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; T&#39;) (<span class="nv">x</span> : <span class="nb">set</span> (<span class="nb">set</span> T&#39;)) :
  f =<span class="mi">1</span> g -&gt; (f @ F --&gt; x) = (g @ F --&gt; x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /funext-&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_is_cvg</span> (<span class="nv">T</span> <span class="nv">T&#39;</span> : <span class="kt">Type</span>) (<span class="nv">fT</span> : filteredType T&#39;) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; T&#39;) :
  f =<span class="mi">1</span> g -&gt; [cvg (f @ F) <span class="kr">in</span> fT] = [cvg (g @ F) <span class="kr">in</span> fT].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /funext-&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">neari_eq_loc</span> {<span class="nv">T</span> <span class="nv">U</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; <span class="nb">set</span> U) :
  {near F, f =<span class="mi">2</span> g} -&gt; g `@ F `=&gt;` f `@ F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; eq_fg P /=; <span class="nb">apply</span>: filterS2 eq_fg =&gt; x eq_fg [y [fxy Py]].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">rewrite</span> -eq_fg.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_near_const</span> (<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) :
  Filter F -&gt; ProperFilter G -&gt;
  (\<span class="kr">forall</span> <span class="nv">y</span> \near G, \<span class="kr">forall</span> <span class="nv">x</span> \near F, f x = y) -&gt; f @ F --&gt; G.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF FG fFG P /= GP; <span class="nb">rewrite</span> !near_simpl; <span class="nb">apply</span>: (have_near G).
<span class="bp">by</span> <span class="nb">apply</span>: filter_app fFG; near <span class="kp">do</span> <span class="nb">apply</span>: filterS =&gt; x /= -&gt;.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="c">(* globally filter *)</span>

<span class="kn">Definition</span> <span class="nf">globally</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">A</span> : <span class="nb">set</span> T) : <span class="nb">set</span> (<span class="nb">set</span> T) :=
   [<span class="nb">set</span> P : <span class="nb">set</span> T | <span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; P x].
<span class="kn">Arguments</span> globally {T} A _ /.

<span class="kn">Global Instance</span> <span class="nf">globally_filter</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">A</span> : <span class="nb">set</span> T) :
  Filter (globally A).
<span class="kn">Proof</span>.
<span class="nb">constructor</span> =&gt; //= P Q; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; PQ AP x /AP /PQ.
<span class="bp">by</span> <span class="nb">move</span>=&gt; AP AQ x Ax; <span class="nb">split</span>; [<span class="nb">apply</span>: AP|<span class="nb">apply</span>: AQ].
<span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">globally_properfilter</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">A</span> : <span class="nb">set</span> T) <span class="nv">a</span> :
  infer (A a) -&gt; ProperFilter (globally A).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Aa; <span class="nb">apply</span>: Build_ProperFilter&#39; =&gt; /(_ a). <span class="kn">Qed</span>.</span></pre><div class="doc">
<a id="lab4"></a><h2 class="section">Specific filters</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">frechet_filter</span>.
<span class="kn">Variable</span> <span class="nv">T</span> : <span class="kt">Type</span>.

<span class="kn">Definition</span> <span class="nf">frechet_filter</span> := [<span class="nb">set</span> S : <span class="nb">set</span> T | finite_set (~` S)].

<span class="kn">Global Instance</span> <span class="nf">frechet_properfilter</span> : infinite_set [<span class="nb">set</span>: T] -&gt;
  ProperFilter frechet_filter.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; infT; <span class="nb">rewrite</span> /frechet_filter.
<span class="nb">constructor</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /= setC0; <span class="bp">exact</span>: infT.
<span class="nb">constructor</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /= setCT.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">rewrite</span> /= setCI finite_setU.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; P Q PQ; <span class="bp">exact</span>/sub_finite_set/subsetC.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">frechet_filter</span>.

<span class="kn">Global Instance</span> <span class="nf">frechet_properfilter_nat</span> : ProperFilter (@frechet_filter nat).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: frechet_properfilter; <span class="bp">exact</span>: infinite_nat. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">at_point</span>.

<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>}.

<span class="kn">Definition</span> <span class="nf">at_point</span> (<span class="nv">a</span> : T) (<span class="nv">P</span> : <span class="nb">set</span> T) : <span class="kt">Prop</span> := P a.

<span class="kn">Global Instance</span> <span class="nf">at_point_filter</span> (<span class="nv">a</span> : T) : ProperFilter (at_point a).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">constructor</span>=&gt; //; <span class="nb">constructor</span>=&gt; // P Q subPQ /subPQ. <span class="kn">Qed</span>.
<span class="kn">Typeclasses Opaque</span> at_point.

<span class="kn">End</span> <span class="nf">at_point</span>.</span></pre><div class="doc">
Filters for pairs 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Global Instance</span> <span class="nf">filter_prod_filter</span> <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) :
  Filter F -&gt; Filter G -&gt; Filter (filter_prod F G).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF FG; <span class="nb">apply</span>: filter_from_filter.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">setT</span>, setT); <span class="nb">split</span>; <span class="nb">apply</span>: filterT.
<span class="nb">move</span>=&gt; [P Q] [P&#39; Q&#39;] /= [FP GQ] [FP&#39; GQ&#39;].
<span class="kr">exists</span> (<span class="nv">P</span> `&amp;` P&#39;, Q `&amp;` Q&#39;) =&gt; /=; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">split</span>; <span class="nb">apply</span>: filterI.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [x y] [/= [??] []].
<span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">prod_filter_on</span> T U (F : filter_on T) (G : filter_on U) :=
  FilterType (filter_prod F G) (filter_prod_filter _ _).

<span class="kn">Global Instance</span> <span class="nf">filter_prod_proper</span> {<span class="nv">T1</span> <span class="nv">T2</span> : <span class="kt">Type</span>}
  {<span class="nv">F</span> : (T1 -&gt; <span class="kt">Prop</span>) -&gt; <span class="kt">Prop</span>} {<span class="nv">G</span> : (T2 -&gt; <span class="kt">Prop</span>) -&gt; <span class="kt">Prop</span>}
  {<span class="nv">FF</span> : ProperFilter F} {<span class="nv">FG</span> : ProperFilter G} :
  ProperFilter (filter_prod F G).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: filter_from_proper =&gt; -[A B] [/=FA GB].
<span class="bp">by</span> <span class="nb">have</span> [[x ?] [y ?]] := (filter_ex FA, filter_ex GB); <span class="kr">exists</span> (<span class="nv">x</span>, y).
<span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">filter_prod_proper&#39;</span> := @filter_prod_proper.

<span class="kn">Lemma</span> <span class="nf">filter_prod1</span> {<span class="nv">T</span> <span class="nv">U</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)}
  {<span class="nv">FG</span> : Filter G} (<span class="nv">P</span> : <span class="nb">set</span> T) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near F, P x) -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F &amp; _ \near G, P x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FP; <span class="kr">exists</span> (<span class="nv">P</span>, setT)=&gt; //= [|[?? []//]].
<span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: filterT.
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">filter_prod2</span> {<span class="nv">T</span> <span class="nv">U</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)}
  {<span class="nv">FF</span> : Filter F} (<span class="nv">P</span> : <span class="nb">set</span> U) :
  (\<span class="kr">forall</span> <span class="nv">y</span> \near G, P y) -&gt; \<span class="kr">forall</span> <span class="nv">_</span> \near F &amp; y \near G, P y.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FP; <span class="kr">exists</span> (<span class="nv">setT</span>, P)=&gt; //= [|[?? []//]].
<span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: filterT.
<span class="kn">Qed</span>.

<span class="kn">Program Definition</span> <span class="nf">in_filter_prod</span> {<span class="nv">T</span> <span class="nv">U</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)}
  (<span class="nv">P</span> : in_filter F) (<span class="nv">Q</span> : in_filter G) : in_filter (filter_prod F G) :=
  @InFilter _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; prop_of P x.<span class="mi">1</span> /\ prop_of Q x.<span class="mi">2</span>) _.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; T U F G P Q.
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">prop_of</span> <span class="nv">P</span>, prop_of Q) =&gt; //=; <span class="nb">split</span>; <span class="nb">apply</span>: prop_ofP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_pair</span> {<span class="nv">T</span> <span class="nv">U</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)}
      {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G}
      (<span class="nv">P</span> : in_filter F) (<span class="nv">Q</span> : in_filter G) <span class="nv">x</span> :
       prop_of P x.<span class="mi">1</span> -&gt; prop_of Q x.<span class="mi">2</span> -&gt; prop_of (in_filter_prod P Q) x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: x=&gt; x y; <span class="kp">do</span> <span class="nl">?rewrite</span> prop_ofE /=; <span class="nb">split</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_fst</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">F</span> <span class="nv">G</span>} {<span class="nv">FG</span> : Filter G} :
  (@fst T U) @ filter_prod F G --&gt; F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; P; <span class="nb">apply</span>: filter_prod1. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_snd</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">F</span> <span class="nv">G</span>} {<span class="nv">FF</span> : Filter F} :
  (@snd T U) @ filter_prod F G --&gt; G.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; P; <span class="nb">apply</span>: filter_prod2. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_map</span> {<span class="nv">T</span> <span class="nv">U</span>} (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">P</span> : <span class="nb">set</span> U) :
  (\<span class="kr">forall</span> <span class="nv">y</span> \near f @ F, P y) = (\<span class="kr">forall</span> <span class="nv">x</span> \near F, P (f x)).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_map2</span> {<span class="nv">T</span> <span class="nv">T&#39;</span> <span class="nv">U</span> <span class="nv">U&#39;</span>} (<span class="nv">f</span> : T -&gt; U) (<span class="nv">g</span> : T&#39; -&gt; U&#39;)
      (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T&#39;)) (<span class="nv">P</span> : U -&gt; <span class="nb">set</span> U&#39;) :
  Filter F -&gt; Filter G -&gt;
  (\<span class="kr">forall</span> <span class="nv">y</span> \near f @ F &amp; y&#39; \near g @ G, P y y&#39;) =
  (\<span class="kr">forall</span> <span class="nv">x</span> \near F     &amp; x&#39; \near G     , P (f x) (g x&#39;)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF FG; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; -[[A B] /= [fFA fGB] ABP].
  <span class="kr">exists</span> (<span class="nv">f</span> @^-<span class="mi">1</span>` A, g @^-<span class="mi">1</span>` B) =&gt; //= -[x y /=] xyAB.
  <span class="bp">by</span> <span class="nb">apply</span>: (ABP (_, _)); <span class="nb">apply</span>: xyAB.
<span class="kr">exists</span> (<span class="nv">f</span> @` A, g @` B) =&gt; //=; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; -_ [/= [x Ax &lt;-] [x&#39; Bx&#39; &lt;-]]; <span class="nb">apply</span>: (ABP (_, _)).
<span class="nb">rewrite</span> !nbhs_simpl /fmap /=; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: filterS fFA=&gt; x Ax; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="bp">by</span> <span class="nb">apply</span>: filterS fGB =&gt; x Bx; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_mapi</span> {<span class="nv">T</span> <span class="nv">U</span>} (<span class="nv">f</span> : T -&gt; <span class="nb">set</span> U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">P</span> : <span class="nb">set</span> U) :
  (\<span class="kr">forall</span> <span class="nv">y</span> \near f `@ F, P y) = (\<span class="kr">forall</span> <span class="nv">x</span> \near F, <span class="kr">exists</span> <span class="nv">y</span>, f x y /\ P y).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_pair_set</span> (<span class="nv">T</span> <span class="nv">T&#39;</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">F&#39;</span> : <span class="nb">set</span> (<span class="nb">set</span> T&#39;)) :
   Filter F -&gt; Filter F&#39; -&gt;
   <span class="kr">forall</span> (<span class="nv">P</span> : <span class="nb">set</span> T) (<span class="nv">P&#39;</span> : <span class="nb">set</span> T&#39;) (<span class="nv">Q</span> : <span class="nb">set</span> (T * T&#39;)),
   (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span>, P x -&gt; P&#39; x&#39; -&gt; Q (x, x&#39;)) -&gt; F P /\ F&#39; P&#39; -&gt;
   filter_prod F F&#39; Q.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; FF FF&#39; P P&#39; Q PQ [FP FP&#39;];
   near=&gt; x <span class="kp">do</span> [<span class="nb">have</span> := PQ x.<span class="mi">1</span> x.<span class="mi">2</span>; <span class="nb">rewrite</span> -surjective_pairing; <span class="nb">apply</span>];
   [<span class="nb">apply</span>: cvg_fst | <span class="nb">apply</span>: cvg_snd].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_pair_near_of</span> (<span class="nv">T</span> <span class="nv">T&#39;</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">F&#39;</span> : <span class="nb">set</span> (<span class="nb">set</span> T&#39;)) :
   Filter F -&gt; Filter F&#39; -&gt;
   <span class="kr">forall</span> (<span class="nv">P</span> : @in_filter T F) (<span class="nv">P&#39;</span> : @in_filter T&#39; F&#39;) (<span class="nv">Q</span> : <span class="nb">set</span> (T * T&#39;)),
   (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span>, prop_of P x -&gt; prop_of P&#39; x&#39; -&gt; Q (x, x&#39;)) -&gt;
   filter_prod F F&#39; Q.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF FF&#39; [P FP] [P&#39; FP&#39;] Q PQ; <span class="nb">rewrite</span> prop_ofE <span class="kr">in</span> FP FP&#39; PQ.
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">P</span>, P&#39;) =&gt; //= -[t t&#39;] [] /=; <span class="bp">exact</span>: PQ.
<span class="kn">Qed</span>.

<span class="kn">Tactic Notation</span> <span class="s2">&quot;near=&gt;&quot;</span> <span class="kn">ident</span>(x) <span class="kn">ident</span>(y) :=
  (<span class="nb">apply</span>: filter_pair_near_of =&gt; x y ? ?).
<span class="kn">Tactic Notation</span> <span class="s2">&quot;near&quot;</span> <span class="kp">constr</span>(F) <span class="s2">&quot;=&gt;&quot;</span> <span class="kn">ident</span>(x) <span class="kn">ident</span>(y) :=
  <span class="nb">apply</span>: (have_near F); near=&gt; x y.

<span class="kn">Module</span> <span class="nf">Export</span> NearMap.
<span class="kn">Definition</span> <span class="nf">near_simpl</span> := (@near_simpl, @near_map, @near_mapi, @near_map2).
<span class="kn">Ltac</span> <span class="nf">near_simpl</span> := <span class="nb">rewrite</span> <span class="nl">?near_simpl</span>.
<span class="kn">End</span> <span class="nf">NearMap</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_pair</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> <span class="nv">F</span>} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)} {<span class="nv">H</span> : <span class="nb">set</span> (<span class="nb">set</span> V)}
  {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} {<span class="nv">FH</span> : Filter H} (<span class="nv">f</span> : T -&gt; U) (<span class="nv">g</span> : T -&gt; V) :
  f @ F --&gt; G -&gt; g @ F --&gt; H -&gt;
  (f x, g x) @[x --&gt; F] --&gt; (G, H).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fFG gFH P; <span class="nb">rewrite</span> !near_simpl =&gt; -[[A B] /=[GA HB] ABP]; near=&gt; x.
<span class="bp">by</span> <span class="nb">apply</span>: (ABP (_, _)); <span class="nb">split</span>=&gt; //=; near: x; [<span class="nb">apply</span>: fFG|<span class="nb">apply</span>: gFH].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_comp2</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> <span class="nv">W</span>}
  {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)} {<span class="nv">H</span> : <span class="nb">set</span> (<span class="nb">set</span> V)} {<span class="nv">I</span> : <span class="nb">set</span> (<span class="nb">set</span> W)}
  {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} {<span class="nv">FH</span> : Filter H}
  (<span class="nv">f</span> : T -&gt; U) (<span class="nv">g</span> : T -&gt; V) (<span class="nv">h</span> : U -&gt; V -&gt; W) :
  f @ F --&gt; G -&gt; g @ F --&gt; H -&gt;
  h (fst x) (snd x) @[x --&gt; (G, H)] --&gt; I -&gt;
  h (f x) (g x) @[x --&gt; F] --&gt; I.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fFG gFH hGHI P /= IP; <span class="nb">apply</span>: cvg_pair (hGHI _ IP). <span class="kn">Qed</span>.
<span class="kn">Arguments</span> cvg_comp2 {T U V W F G H I FF FG FH f g h} _ _ _.
<span class="kn">Definition</span> <span class="nf">cvg_to_comp_2</span> := @cvg_comp2.

<span class="c">(* Lemma cvgi_comp_2 {T U V W} *)</span>
<span class="c">(*   {F : set (set T)} {G : set (set U)} {H : set (set V)} {I : set (set W)} *)</span>
<span class="c">(*   {FF : Filter F} *)</span>
<span class="c">(*   (f : T -&gt; U) (g : T -&gt; V) (h : U -&gt; V -&gt; set W) : *)</span>
<span class="c">(*   f @ F --&gt; G -&gt; g @ F --&gt; H -&gt; *)</span>
<span class="c">(*   h (fst x) (snd x) `@[x --&gt; (G, H)] --&gt; I -&gt; *)</span>
<span class="c">(*   h (f x) (g x) `@[x --&gt; F] --&gt; I. *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* intros Cf Cg Ch. *)</span>
<span class="c">(* change (fun x =&gt; h (f x) (g x)) with (fun x =&gt; h (fst (f x, g x)) (snd (f x, g x))). *)</span>
<span class="c">(* apply: cvgi_comp Ch. *)</span>
<span class="c">(* now apply cvg_pair. *)</span>
<span class="c">(* Qed. *)</span></span></pre><div class="doc">
Restriction of a filter to a domain 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">within</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Implicit Types</span> (<span class="nv">D</span> : <span class="nb">set</span> T) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)).

<span class="kn">Definition</span> <span class="nf">within</span> <span class="nv">D</span> <span class="nv">F</span> (<span class="nv">P</span> : <span class="nb">set</span> T) := {near F, D `&lt;=` P}.
<span class="kn">Arguments</span> within : <span class="nb">simpl</span> never.

<span class="kn">Lemma</span> <span class="nf">near_withinE</span> <span class="nv">D</span> <span class="nv">F</span> (<span class="nv">P</span> : <span class="nb">set</span> T) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near within D F, P x) = {near F, D `&lt;=` P}.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">withinT</span> <span class="nv">F</span> <span class="nv">D</span> : Filter F -&gt; within D F D.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FF; <span class="nb">rewrite</span> /within; <span class="nb">apply</span>: filterE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_withinT</span> <span class="nv">F</span> <span class="nv">D</span> : Filter F -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near within D F, D x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: withinT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_within</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} <span class="nv">D</span> : within D F --&gt; F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; P; <span class="nb">apply</span>: filterS. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">withinET</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} : within setT F = F.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset /within; <span class="nb">split</span> =&gt; ?; <span class="nb">apply</span>: filter_app; <span class="nb">apply</span>: nearW =&gt; //.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">within</span>.

<span class="kn">Global Instance</span> <span class="nf">within_filter</span> <span class="nv">T</span> <span class="nv">D</span> <span class="nv">F</span> : Filter F -&gt; Filter (@within T D F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">rewrite</span> /within; <span class="nb">constructor</span>.
- <span class="bp">by</span> <span class="nb">apply</span>: filterE.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; P Q; <span class="nb">apply</span>: filterS2 =&gt; x DP DQ Dx; <span class="nb">split</span>; [<span class="nb">apply</span>: DP|<span class="nb">apply</span>: DQ].
- <span class="bp">by</span> <span class="nb">move</span>=&gt; P Q subPQ; <span class="nb">apply</span>: filterS =&gt; x DP /DP /subPQ.
<span class="kn">Qed</span>.

#[<span class="kn">global</span>] <span class="kn">Typeclasses Opaque</span> within.

<span class="kn">Canonical</span> <span class="nf">within_filter_on</span> T D (F : filter_on T) :=
  FilterType (within D F) (within_filter _ _).

<span class="kn">Definition</span> <span class="nf">subset_filter</span> {<span class="nv">T</span>} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">D</span> : <span class="nb">set</span> T) :=
  [<span class="nb">set</span> P : <span class="nb">set</span> {x | D x} | F [<span class="nb">set</span> x | <span class="kr">forall</span> <span class="nv">Dx</span> : D x, P (exist _ x Dx)]].
<span class="kn">Arguments</span> subset_filter {T} F D _.

<span class="kn">Global Instance</span> <span class="nf">subset_filter_filter</span> <span class="nv">T</span> <span class="nv">F</span> (<span class="nv">D</span> : <span class="nb">set</span> T) :
  Filter F -&gt; Filter (subset_filter F D).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">constructor</span>; <span class="nb">rewrite</span> /subset_filter/=.
- <span class="bp">exact</span>: filterE.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; P Q; <span class="nb">apply</span>: filterS2=&gt; x PD QD Dx; <span class="nb">split</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; P Q subPQ; <span class="nb">apply</span>: filterS =&gt; R PD Dx; <span class="nb">apply</span>: subPQ.
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Typeclasses Opaque</span> subset_filter.

<span class="kn">Lemma</span> <span class="nf">subset_filter_proper</span> {<span class="nv">T</span> <span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} (<span class="nv">D</span> : <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">P</span>, F P -&gt; ~ ~ <span class="kr">exists</span> <span class="nv">x</span>, D x /\ P x) -&gt;
  ProperFilter (subset_filter F D).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; DAP; <span class="nb">apply</span>: Build_ProperFilter&#39;; <span class="nb">rewrite</span> /subset_filter =&gt; subFD.
<span class="bp">by</span> <span class="nb">have</span> /(_ subFD) := DAP (~` D); <span class="nb">apply</span> =&gt; -[x [dx /(_ dx)]].
<span class="kn">Qed</span>.

<span class="c">(* For using near on sets in a filter *)</span>
<span class="kn">Section</span> <span class="nf">NearSet</span>.

<span class="kn">Context</span> {<span class="nv">T</span> : choiceType} {<span class="nv">Y</span> : filteredType T}.
<span class="kn">Context</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> Y)) (<span class="nv">PF</span> : ProperFilter F).

<span class="kn">Definition</span> <span class="nf">powerset_filter_from</span> : <span class="nb">set</span> (<span class="nb">set</span> (<span class="nb">set</span> Y)) := filter_from
  [<span class="nb">set</span> M | [/\ M `&lt;=` F,
    (<span class="kr">forall</span> <span class="nv">E1</span> <span class="nv">E2</span>, M E1 -&gt; F E2 -&gt; E2 `&lt;=` E1 -&gt; M E2) &amp; M !=set0 ] ]
  id.

<span class="kn">Global Instance</span> <span class="nf">powerset_filter_from_filter</span> : ProperFilter powerset_filter_from.
<span class="kn">Proof</span>.
<span class="nb">split</span>.
  <span class="nb">rewrite</span> (_ : xpredp0 = set0); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [W [_ _ [N +]]]; <span class="nb">rewrite</span> subset0 =&gt; /[<span class="nb">swap</span>] -&gt;; <span class="nb">apply</span>.
<span class="nb">apply</span>: filter_from_filter.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">F</span>; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">setT</span>; <span class="bp">exact</span>: filterT.
<span class="nb">move</span>=&gt; M N /= [entM subM [M0 MM0]] [entN subN [N0 NN0]].
<span class="kr">exists</span> [<span class="nb">set</span> E | <span class="kr">exists</span> <span class="nv">P</span> <span class="nv">Q</span>, [/\ M P, N Q &amp; E = P `&amp;` Q] ]; <span class="kp">first</span> <span class="nb">split</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [? [? [? ? -&gt;]]]; <span class="nb">apply</span> filterI; [<span class="bp">exact</span>: entM | <span class="bp">exact</span>: entN].
- <span class="nb">move</span>=&gt; ? E2 [P [Q [MP MQ -&gt;]]] entE2 E2subPQ; <span class="kr">exists</span> <span class="nv">E2</span>, E2.
  <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> setIid.
  + <span class="bp">by</span> <span class="nb">apply</span>: (subM _ _ MP) =&gt; // ? /E2subPQ [].
  + <span class="bp">by</span> <span class="nb">apply</span>: (subN _ _ MQ) =&gt; // ? /E2subPQ [].
- <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">M0</span> `&amp;` N0), M0, N0.
- <span class="nb">move</span>=&gt; E /= [P [Q [MP MQ -&gt;]]]; <span class="nb">have</span> entPQ : F (P `&amp;` Q).
    <span class="bp">by</span> <span class="nb">apply</span> filterI; [<span class="bp">exact</span>: entM | <span class="bp">exact</span>: entN].
  <span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span>: (subM _ _ MP) | <span class="nb">apply</span>: (subN _ _ MQ)] =&gt; // ? [].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_small_set</span> : \<span class="kr">forall</span> <span class="nv">E</span> \near powerset_filter_from, F E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">F</span> =&gt; //; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">setT</span>; <span class="bp">exact</span>: filterT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">small_set_sub</span> (<span class="nv">E</span> : <span class="nb">set</span> Y) : F E -&gt;
  \<span class="kr">forall</span> <span class="nv">E&#39;</span> \near powerset_filter_from, E&#39; `&lt;=` E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; entE; <span class="kr">exists</span> [<span class="nb">set</span> E&#39; | F E&#39; /\ E&#39; `&lt;=` E]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [].
<span class="nb">split</span>; [<span class="bp">by</span> <span class="nb">move</span>=&gt; E&#39; [] | | <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span>].
<span class="bp">by</span> <span class="nb">move</span>=&gt; E1 E2 [] ? sub ? ?; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: subset_trans sub.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_powerset_filter_fromP</span> (<span class="nv">P</span> : <span class="nb">set</span> Y -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, A `&lt;=` B -&gt; P B -&gt; P A) -&gt;
  (\<span class="kr">forall</span> <span class="nv">U</span> \near powerset_filter_from, P U) &lt;-&gt; <span class="kr">exists2</span> U, F U &amp; P U.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Psub; <span class="nb">split</span>=&gt; [[M [FM ? [U MU]]] MsubP|[U FU PU]].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">U</span>; [<span class="bp">exact</span>: FM | <span class="bp">exact</span>: MsubP].
<span class="kr">exists</span> [<span class="nb">set</span> V | F V /\ V `&lt;=` U]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; V [_] /Psub; <span class="bp">exact</span>.
<span class="nb">split</span>=&gt; [E [] //| |]; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">U</span>; <span class="nb">split</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; E1 E2 [F1 E1U F2 E2subE1]; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: subset_trans E1U.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">NearSet</span>.

<span class="kn">Section</span> <span class="nf">PrincipalFilters</span>.

<span class="kn">Definition</span> <span class="nf">principal_filter</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : X) : <span class="nb">set</span> (<span class="nb">set</span> X) :=
  globally [<span class="nb">set</span> x].

<span class="kn">Lemma</span> <span class="nf">principal_filterP</span> {<span class="nv">X</span>} (<span class="nv">x</span> : X) (<span class="nv">W</span> : <span class="nb">set</span> X) : principal_filter x W &lt;-&gt; W x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; [|? ? -&gt;]; [<span class="bp">exact</span>|]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">principal_filter_proper</span> {<span class="nv">X</span>} (<span class="nv">x</span> : X) : ProperFilter (principal_filter x).
<span class="kn">Proof</span>. <span class="bp">exact</span>: globally_properfilter. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">bool_discrete_filter</span> := FilteredType bool bool principal_filter.

<span class="kn">End</span> <span class="nf">PrincipalFilters</span>.</span></pre><div class="doc">
<a id="lab5"></a><h1 class="section">Topological spaces</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Module</span> <span class="nf">Topological</span>.

<span class="kn">Record</span> <span class="nf">mixin_of</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">nbhs</span> : T -&gt; <span class="nb">set</span> (<span class="nb">set</span> T)) := Mixin {
  open : <span class="nb">set</span> (<span class="nb">set</span> T) ;
  ax1 : <span class="kr">forall</span> <span class="nv">p</span> : T, ProperFilter (nbhs p) ;
  ax2 : <span class="kr">forall</span> <span class="nv">p</span> : T, nbhs p =
    [<span class="nb">set</span> A : <span class="nb">set</span> T | <span class="kr">exists</span> <span class="nv">B</span> : <span class="nb">set</span> T, [/\ open B, B p &amp; B `&lt;=` A] ] ;
  ax3 : open = [<span class="nb">set</span> A : <span class="nb">set</span> T | A `&lt;=` nbhs^~ A ]
}.

<span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">T</span> : <span class="kt">Type</span>) := <span class="kn">Class</span> {
  base : Filtered.class_of T T;
  mixin : mixin_of (Filtered.nbhs_op base)
}.

<span class="kn">Section</span> <span class="nf">ClassDef</span>.

<span class="kn">Structure</span> <span class="nf">type</span> := Pack { sort; _ : class_of sort }.
<span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type).
<span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of cT <span class="kr">in</span> c.

<span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack T c.
<span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.
<span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of xT).
<span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Filtered.class_of.
<span class="kn">Local Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; mixin_of.

<span class="kn">Definition</span> <span class="nf">pack</span> <span class="nv">nbhs&#39;</span> (<span class="nv">m</span> : @mixin_of T nbhs&#39;) :=
  <span class="kr">fun</span> <span class="nv">bT</span> (<span class="nv">b</span> : Filtered.class_of T T) <span class="nv">of</span> <span class="nv">phant_id</span> (@Filtered.class T bT) <span class="nv">b</span> =&gt;
  <span class="kr">fun</span> <span class="nv">m&#39;</span>   <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">m</span> (<span class="nv">m&#39;</span> : @mixin_of T (Filtered.nbhs_op b)) =&gt;
  @Pack T (@<span class="kn">Class</span> <span class="nf">_</span> <span class="nv">b</span> <span class="nv">m&#39;</span>).

<span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">pointedType</span> := @Pointed.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">filteredType</span> := @Filtered.Pack cT cT xclass.

<span class="kn">End</span> <span class="nf">ClassDef</span>.

<span class="kn">Module</span> <span class="nf">Exports</span>.

<span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Filtered.class_of.
<span class="kn">Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; mixin_of.
<span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.
<span class="kn">Canonical</span> <span class="nf">eqType</span>.
<span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.
<span class="kn">Canonical</span> <span class="nf">choiceType</span>.
<span class="kn">Coercion</span> <span class="nf">pointedType</span> : type &gt;-&gt; Pointed.type.
<span class="kn">Canonical</span> <span class="nf">pointedType</span>.
<span class="kn">Coercion</span> <span class="nf">filteredType</span> : type &gt;-&gt; Filtered.type.
<span class="kn">Canonical</span> <span class="nf">filteredType</span>.
<span class="kn">Notation</span> <span class="nf">topologicalType</span> := type.
<span class="kn">Notation</span> <span class="nf">TopologicalType</span> T m := (@pack T _ m _ _ idfun _ idfun).
<span class="kn">Notation</span> <span class="nf">TopologicalMixin</span> := Mixin.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;topologicalType&#39; &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> :=  (@clone T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;topologicalType&#39;  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;topologicalType&#39; &#39;of&#39; T ]&quot;</span> := (@clone T _ _ id)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;topologicalType&#39;  &#39;of&#39;  T ]&quot;</span>) : form_scope.

<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">Topological</span>.

<span class="kn">Export</span> Topological.Exports.

<span class="kn">Section</span> <span class="nf">Topological1</span>.

<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType}.

<span class="kn">Definition</span> <span class="nf">open</span> := Topological.open (Topological.class T).

<span class="kn">Definition</span> <span class="nf">open_nbhs</span> (<span class="nv">p</span> : T) (<span class="nv">A</span> : <span class="nb">set</span> T) := open A /\ A p.

<span class="kn">Global Instance</span> <span class="nf">nbhs_pfilter</span> (<span class="nv">p</span> : T) : ProperFilter (nbhs p).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: Topological.ax1; <span class="nb">case</span>: T p =&gt; ? []. <span class="kn">Qed</span>.
<span class="kn">Typeclasses Opaque</span> nbhs.

<span class="kn">Lemma</span> <span class="nf">nbhs_filter</span> (<span class="nv">p</span> : T) : Filter (nbhs p).
<span class="kn">Proof</span>. <span class="bp">exact</span>: (@nbhs_pfilter). <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">nbhs_filter_on</span> (x : T) := FilterType (nbhs x) (@nbhs_filter x).

<span class="kn">Lemma</span> <span class="nf">nbhsE</span> (<span class="nv">p</span> : T) :
  nbhs p = [<span class="nb">set</span> A : <span class="nb">set</span> T | <span class="kr">exists2</span> B : <span class="nb">set</span> T, open_nbhs p B &amp; B `&lt;=` A].
<span class="kn">Proof</span>.
<span class="nb">have</span> -&gt; : nbhs p = [<span class="nb">set</span> A : <span class="nb">set</span> T | <span class="kr">exists</span> <span class="nv">B</span>, [/\ open B, B p &amp; B `&lt;=` A] ].
  <span class="bp">exact</span>: Topological.ax2.
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>=&gt; [[B [?]]|[B[]]]; <span class="kr">exists</span> <span class="nv">B</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_nbhsE</span> (<span class="nv">p</span> : T) (<span class="nv">A</span> : <span class="nb">set</span> T) : open_nbhs p A = (open A /\ nbhs p A).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> nbhsE propeqE; <span class="nb">split</span>=&gt; [[? ?]|[? [B [? ?] BA]]]; <span class="nb">split</span> =&gt; //;
  [<span class="kr">exists</span> <span class="nv">A</span> | <span class="bp">exact</span>: BA].
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">interior</span> (<span class="nv">A</span> : <span class="nb">set</span> T) := (@nbhs _ T)^~ A.

<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;A ^¬∞&quot;</span> := (interior A).

<span class="kn">Lemma</span> <span class="nf">interior_subset</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : A^¬∞ `&lt;=` A.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; p; <span class="nb">rewrite</span> /interior nbhsE =&gt; -[? [? ?]]; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">openE</span> : open = [<span class="nb">set</span> A : <span class="nb">set</span> T | A `&lt;=` A^¬∞].
<span class="kn">Proof</span>. <span class="bp">exact</span>: Topological.ax3. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_singleton</span> (<span class="nv">p</span> : T) (<span class="nv">A</span> : <span class="nb">set</span> T) : nbhs p A -&gt; A p.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> nbhsE =&gt; - [? [_ ?]]; <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_interior</span> (<span class="nv">p</span> : T) (<span class="nv">A</span> : <span class="nb">set</span> T) : nbhs p A -&gt; nbhs p A^¬∞.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> nbhsE /open_nbhs openE =&gt; - [B [Bop Bp] sBA].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">B</span> =&gt; // q Bq; <span class="nb">apply</span>: filterS sBA _; <span class="nb">apply</span>: Bop.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open0</span> : open set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> openE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">openT</span> : open setT.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> openE =&gt; ??; <span class="nb">apply</span>: filterT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">openI</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : open A -&gt; open B -&gt; open (A `&amp;` B).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> openE =&gt; Aop Bop p [Ap Bp].
<span class="bp">by</span> <span class="nb">apply</span>: filterI; [<span class="nb">apply</span>: Aop|<span class="nb">apply</span>: Bop].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigcup_open</span> (<span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; open (f i)) -&gt; open (\bigcup_(i <span class="kr">in</span> D) f i).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> openE =&gt; fop p [i Di].
<span class="bp">by</span> <span class="nb">have</span> /fop fiop := Di; <span class="nb">move</span>/fiop; <span class="nb">apply</span>: filterS =&gt; ??; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">openU</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : open A -&gt; open B -&gt; open (A `|` B).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> openE =&gt; Aop Bop p [/Aop|/Bop]; <span class="nb">apply</span>: filterS =&gt; ??; [<span class="nb">left</span>|<span class="nb">right</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_subsetE</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : open A -&gt; (A `&lt;=` B) = (A `&lt;=` B^¬∞).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> openE =&gt; Aop; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; sAB p Ap; <span class="nb">apply</span>: filterS sAB _; <span class="nb">apply</span>: Aop.
<span class="bp">by</span> <span class="nb">move</span>=&gt; sAB p /sAB /interior_subset.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_interior</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : open A^¬∞.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> openE =&gt; p; <span class="nb">rewrite</span> /interior nbhsE =&gt; - [B [Bop Bp]].
<span class="bp">by</span> <span class="nb">rewrite</span> open_subsetE //; <span class="kr">exists</span> <span class="nv">B</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">interior_bigcup</span> <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :
  \bigcup_(i <span class="kr">in</span> D) (f i)^¬∞ `&lt;=` (\bigcup_(i <span class="kr">in</span> D) f i)^¬∞.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; p [i Di]; <span class="nb">rewrite</span> /interior nbhsE =&gt; - [B [Bop Bp] sBfi].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">B</span> =&gt; // ? /sBfi; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_nbhsT</span> (<span class="nv">p</span> : T) : open_nbhs p setT.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: openT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_nbhsI</span> (<span class="nv">p</span> : T) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
  open_nbhs p A -&gt; open_nbhs p B -&gt; open_nbhs p (A `&amp;` B).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; [Aop Ap] [Bop Bp]; <span class="nb">split</span>; [<span class="nb">apply</span>: openI|<span class="nb">split</span>]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_nbhs_nbhs</span> (<span class="nv">p</span> : T) (<span class="nv">A</span> : <span class="nb">set</span> T) : open_nbhs p A -&gt; nbhs p A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> nbhsE =&gt; p_A; <span class="kr">exists</span> <span class="nv">A</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">interiorI</span> (<span class="nv">A</span> <span class="nv">B</span>:<span class="nb">set</span> T): (A `&amp;` B)^¬∞ = A^¬∞ `&amp;` B^¬∞.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /interior predeqE =&gt; //= x; <span class="nb">rewrite</span> nbhsE; <span class="nb">split</span> =&gt; [[B0 ?] | []].
- <span class="bp">by</span> <span class="nb">rewrite</span> subsetI =&gt; // -[? ?]; <span class="nb">split</span>; <span class="kr">exists</span> <span class="nv">B0</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; -[B0 ? ?] [B1 ? ?]; <span class="kr">exists</span> (<span class="nv">B0</span> `&amp;` B1);
  [<span class="bp">exact</span>: open_nbhsI | <span class="nb">rewrite</span> subsetI; <span class="nb">split</span>; <span class="nb">apply</span>: subIset; [<span class="nb">left</span>|<span class="nb">right</span>]].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Topological1</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (Filter (nbhs _)) =&gt;
  <span class="kp">solve</span> [<span class="nb">apply</span>: nbhs_filter] : typeclass_instances.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (ProperFilter (nbhs _)) =&gt;
  <span class="kp">solve</span> [<span class="nb">apply</span>: nbhs_pfilter] : typeclass_instances.

<span class="kn">Notation</span> <span class="s2">&quot;A ^¬∞&quot;</span> := (interior A) : classical_set_scope.

<span class="kn">Notation</span> <span class="nf">continuous</span> f := (<span class="kr">forall</span> <span class="nv">x</span>, f%function @ x --&gt; f%function x).

<span class="kn">Lemma</span> <span class="nf">near_fun</span> (<span class="nv">T</span> <span class="nv">T&#39;</span> : topologicalType) (<span class="nv">f</span> : T -&gt; T&#39;) (<span class="nv">x</span> : T) (<span class="nv">P</span> : T&#39; -&gt; <span class="kt">Prop</span>) :
    {<span class="kr">for</span> x, continuous f} -&gt;
  (\<span class="kr">forall</span> <span class="nv">y</span> \near f x, P y) -&gt; (\near x, P (f x)).
<span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> near_fun {T T&#39;} f x.

<span class="kn">Lemma</span> <span class="nf">continuousP</span> (<span class="nv">S</span> <span class="nv">T</span> : topologicalType) (<span class="nv">f</span> : S -&gt; T) :
  continuous f &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, open A -&gt; open (f @^-<span class="mi">1</span>` A).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; fcont; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> !openE =&gt; A Aop ? /Aop /fcont.
<span class="nb">move</span>=&gt; s A; <span class="nb">rewrite</span> nbhs_simpl /= !nbhsE =&gt; - [B [Bop Bfs] sBA].
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f</span> @^-<span class="mi">1</span>` B); [<span class="nb">split</span>=&gt; //; <span class="nb">apply</span>/fcont|<span class="nb">move</span>=&gt; ? /sBA].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_comp</span> (<span class="nv">R</span> <span class="nv">S</span> <span class="nv">T</span> : topologicalType) (<span class="nv">f</span> : R -&gt; S) (<span class="nv">g</span> : S -&gt; T) <span class="nv">x</span> :
  {<span class="kr">for</span> x, continuous f} -&gt; {<span class="kr">for</span> (f x), continuous g} -&gt;
  {<span class="kr">for</span> x, continuous (g \o f)}.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvg_comp. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_comp</span>  {<span class="nv">T</span> <span class="nv">U</span> : topologicalType} (<span class="nv">f</span> : T -&gt; U) (<span class="nv">D</span> : <span class="nb">set</span> U) :
  {<span class="kr">in</span> f @^-<span class="mi">1</span>` D, continuous f} -&gt; open D -&gt; open (f @^-<span class="mi">1</span>` D).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> !openE =&gt; fcont Dop x /= Dfx.
<span class="bp">by</span> <span class="nb">apply</span>: fcont; [<span class="nb">rewrite</span> inE|<span class="nb">apply</span>: Dop].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_fmap</span> {<span class="nv">T</span>: topologicalType} {<span class="nv">U</span> : topologicalType}
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) <span class="nv">x</span> (<span class="nv">f</span> : T -&gt; U) :
   {<span class="kr">for</span> x, continuous f} -&gt; F --&gt; x -&gt; f @ F --&gt; f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf fx P /cf /fx. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_join</span> (<span class="nv">T</span> : topologicalType) (<span class="nv">x</span> : T) (<span class="nv">P</span> : <span class="nb">set</span> T) :
  (\near x, P x) -&gt; \near x, \near x, P x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: nbhs_interior. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_bind</span> (<span class="nv">T</span> : topologicalType) (<span class="nv">P</span> <span class="nv">Q</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T) :
  (\near x, (\near x, P x) -&gt; Q x) -&gt; (\near x, P x) -&gt; \near x, Q x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; PQ xP; near=&gt; y; <span class="nb">apply</span>: (near PQ y) =&gt; //;
<span class="bp">by</span> <span class="nb">apply</span>: (near (near_join xP) y).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="c">(* limit composition *)</span>

<span class="kn">Lemma</span> <span class="nf">continuous_cvg</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">V</span> <span class="nv">U</span> : topologicalType}
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : Filter F)
  (<span class="nv">f</span> : T -&gt; V) (<span class="nv">h</span> : V -&gt; U) (<span class="nv">a</span> : V) :
  {<span class="kr">for</span> a, continuous h} -&gt;
  f @ F --&gt; a -&gt; (h \o f) @ F --&gt; h a.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; h_continuous fa fb; <span class="nb">apply</span>: (cvg_trans _ h_continuous).
<span class="bp">exact</span>: (@cvg_comp _ _ _ _ h _ _ _ fa).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_is_cvg</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">V</span> <span class="nv">U</span> : topologicalType} [F : <span class="nb">set</span> (<span class="nb">set</span> T)]
  (FF : Filter F) (f : T -&gt; V) (h : V -&gt; U) :
  (<span class="kr">forall</span> <span class="nv">l</span>, f x @[x --&gt; F] --&gt; l -&gt; {<span class="kr">for</span> l, continuous h}) -&gt;
  cvg (f x @[x --&gt; F]) -&gt; cvg ((h \o f) x @[x --&gt; F]).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ach /cvg_ex[l fxl]; <span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> (<span class="nv">h</span> <span class="nv">l</span>).
<span class="bp">by</span> <span class="nb">apply</span>: continuous_cvg =&gt; //; <span class="bp">exact</span>: ach.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous2_cvg</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">V</span> <span class="nv">W</span> <span class="nv">U</span> : topologicalType}
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : Filter F)
  (<span class="nv">f</span> : T -&gt; V) (<span class="nv">g</span> : T -&gt; W) (<span class="nv">h</span> : V -&gt; W -&gt; U) (<span class="nv">a</span> : V) (<span class="nv">b</span> : W) :
  h z.<span class="mi">1</span> z.<span class="mi">2</span> @[z --&gt; (a, b)] --&gt; h a b -&gt;
  f @ F --&gt; a -&gt; g @ F --&gt; b -&gt; (<span class="kr">fun</span> <span class="nv">x</span> =&gt; h (f x) (g x)) @ F --&gt; h a b.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; h_continuous fa fb; <span class="nb">apply</span>: (cvg_trans _ h_continuous).
<span class="bp">exact</span>: (@cvg_comp _ _ _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; h x.<span class="mi">1</span> x.<span class="mi">2</span>) _ _ _ (cvg_pair fa fb)).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_near_cst</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">U</span> : topologicalType)
  (<span class="nv">l</span> : U) (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : Filter F} :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near F, f x = l) -&gt; f @ F --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fFl P /=; <span class="nb">rewrite</span> !near_simpl =&gt; Pl.
<span class="bp">by</span> <span class="nb">apply</span>: filterS fFl =&gt; _ -&gt;; <span class="nb">apply</span>: nbhs_singleton.
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> cvg_near_cst {T U} l {f F FF}.

<span class="kn">Lemma</span> <span class="nf">is_cvg_near_cst</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">U</span> : topologicalType)
  (<span class="nv">l</span> : U) (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : Filter F} :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near F, f x = l) -&gt; cvg (f @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvg_near_cst/cvgP. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> is_cvg_near_cst {T U} l {f F FF}.

<span class="kn">Lemma</span> <span class="nf">near_cst_continuous</span> (<span class="nv">T</span> <span class="nv">U</span> : topologicalType)
  (<span class="nv">l</span> : U) (<span class="nv">f</span> : T -&gt; U) (<span class="nv">x</span> : T) :
  (\<span class="kr">forall</span> <span class="nv">y</span> \near x, f y = l) -&gt; {<span class="kr">for</span> x, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; eq_f_l; <span class="nb">apply</span>: cvg_near_cst; <span class="nb">apply</span>: filterS (eq_f_l) =&gt; y -&gt;.
<span class="bp">by</span> <span class="nb">rewrite</span> (nbhs_singleton eq_f_l).
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> near_cst_continuous {T U} l [f x].

<span class="kn">Lemma</span> <span class="nf">cvg_cst</span> (<span class="nv">U</span> : topologicalType) (<span class="nv">x</span> : U) (<span class="nv">T</span> : <span class="kt">Type</span>)
    (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : Filter F} :
  (<span class="kr">fun</span> <span class="nv">_</span> : T =&gt; x) @ F --&gt; x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: cvg_near_cst; near=&gt; x0. <span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> cvg_cst {U} x {T F FF}.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> cvg_cst : core.

<span class="kn">Lemma</span> <span class="nf">is_cvg_cst</span> (<span class="nv">U</span> : topologicalType) (<span class="nv">x</span> : U) (<span class="nv">T</span> : <span class="kt">Type</span>)
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : Filter F} :
  cvg ((<span class="kr">fun</span> <span class="nv">_</span> : T =&gt; x) @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: cvgP; <span class="nb">apply</span>: cvg_cst. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> is_cvg_cst {U} x {T F FF}.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> is_cvg_cst : core.

<span class="kn">Lemma</span> <span class="nf">cst_continuous</span> {<span class="nv">T</span> <span class="nv">U</span> : topologicalType} (<span class="nv">x</span> : U) :
  continuous (<span class="kr">fun</span> <span class="nv">_</span> : T =&gt; x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; t; <span class="nb">apply</span>: cvg_cst. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">within_topologicalType</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType} (<span class="nv">A</span> : <span class="nb">set</span> T).
<span class="kn">Implicit Types</span> <span class="nv">B</span> : <span class="nb">set</span> T.

<span class="c">(* Relation between  globally  and  within A (nbhs x)          *)</span>
<span class="c">(* to be combined with lemmas such as boundedP in normedtype.v *)</span>
<span class="kn">Lemma</span> <span class="nf">within_nbhsW</span> (<span class="nv">x</span> : T) : A x -&gt; within A (nbhs x) `=&gt;` globally A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Ax P AP; <span class="nb">rewrite</span> /within; near=&gt; y; <span class="nb">apply</span>: AP.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="c">(* [locally P] replaces a (globally A) in P by a within A (nbhs x)      *)</span>
<span class="c">(* Can be combined with a notation taking a filter as its last argument *)</span>
<span class="kn">Definition</span> <span class="nf">locally_of</span> (<span class="nv">P</span> : <span class="nb">set</span> (<span class="nb">set</span> T) -&gt; <span class="kt">Prop</span>) <span class="nv">of</span> <span class="nv">phantom</span> <span class="nv">Prop</span> (<span class="nv">P</span> (globally A))
  := <span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; P (within A (nbhs x)).
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;[ &#39;locally&#39; P ]&quot;</span> := (@locally_of _ _ _ (Phantom _ P)).
<span class="c">(* e.g. [locally [bounded f x | x in A]]                  *)</span>
<span class="c">(* see lemmas bounded_locally in normedtype.v for example *)</span>

<span class="kn">Lemma</span> <span class="nf">within_interior</span> (<span class="nv">x</span> : T) : A^¬∞ x -&gt; within A (nbhs x) = nbhs x.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Aox; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: cvg_within.
<span class="nb">rewrite</span> <span class="nl">?nbhsE</span> =&gt; W /= =&gt; [[B + BsubW]].
<span class="nb">rewrite</span> open_nbhsE =&gt; [[oB nbhsB]].
<span class="kr">exists</span> (<span class="nv">B</span> `&amp;` A^¬∞); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; t /= [] /BsubW + /interior_subset; <span class="nb">apply</span>.
<span class="nb">rewrite</span> open_nbhsE; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: openI =&gt; //; <span class="bp">exact</span>: open_interior.
<span class="bp">by</span> <span class="nb">apply</span>: filterI =&gt; //; <span class="nb">move</span>:(open_interior A); <span class="nb">rewrite</span> openE; <span class="bp">exact</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">within_subset</span> <span class="nv">B</span> <span class="nv">F</span> : Filter F -&gt; A `&lt;=` B -&gt; within A F `=&gt;` within B F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF AsubB W; <span class="nb">rewrite</span> /within; <span class="nb">apply</span>: filter_app; <span class="nb">rewrite</span> nbhs_simpl.
<span class="bp">by</span> <span class="nb">apply</span>: filterE =&gt; ? + ?; <span class="nb">apply</span>; <span class="bp">exact</span>: AsubB.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">withinE</span> <span class="nv">F</span> : Filter F -&gt;
  within A F = [<span class="nb">set</span> U | <span class="kr">exists2</span> V, F V &amp; U `&amp;` A = V `&amp;` A].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; U.
  <span class="nb">move</span>=&gt; Wu; <span class="kr">exists</span> [<span class="nb">set</span> x | A x -&gt; U x] =&gt; //.
  <span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; t [L R]; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: L.
<span class="nb">move</span>=&gt; [V FV AU]; <span class="nb">rewrite</span> /within /prop_near1 nbhs_simpl; near=&gt; w =&gt; Aw.
<span class="bp">by</span> <span class="nb">have</span> []// : (U `&amp;` A) w; <span class="nb">rewrite</span> AU; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: (near FV).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fmap_within_eq</span> {<span class="nv">S</span> : topologicalType} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; S) :
  Filter F -&gt; {<span class="kr">in</span> A, f =<span class="mi">1</span> g} -&gt; f @ within A F --&gt; g @ within A F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF feq U /=; near_simpl; <span class="nb">apply</span>: filter_app.
<span class="nb">rewrite</span> <span class="nl">?nbhs_simpl</span>; near_simpl; near=&gt; w; <span class="nb">rewrite</span> (feq w) // inE.
<span class="bp">exact</span>: (near (withinT A FF) w).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">within_topologicalType</span>.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;locally&#39; P ]&quot;</span> := (@locally_of _ _ _ (Phantom _ P)).</span></pre><div class="doc">
<a id="lab6"></a><h2 class="section">Topology defined by a filter</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">TopologyOfFilter</span>.

<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">nbhs&#39;</span> : T -&gt; <span class="nb">set</span> (<span class="nb">set</span> T)}.
<span class="kn">Hypothesis</span> (<span class="nv">nbhs&#39;_filter</span> : <span class="kr">forall</span> <span class="nv">p</span> : T, ProperFilter (nbhs&#39; p)).
<span class="kn">Hypothesis</span> (<span class="nv">nbhs&#39;_singleton</span> : <span class="kr">forall</span> (<span class="nv">p</span> : T) (<span class="nv">A</span> : <span class="nb">set</span> T), nbhs&#39; p A -&gt; A p).
<span class="kn">Hypothesis</span> (<span class="nv">nbhs&#39;_nbhs&#39;</span> : <span class="kr">forall</span> (<span class="nv">p</span> : T) (<span class="nv">A</span> : <span class="nb">set</span> T), nbhs&#39; p A -&gt; nbhs&#39; p (nbhs&#39;^~ A)).

<span class="kn">Definition</span> <span class="nf">open_of_nbhs</span> := [<span class="nb">set</span> A : <span class="nb">set</span> T | A `&lt;=` nbhs&#39;^~ A].

<span class="kn">Program Definition</span> <span class="nf">topologyOfFilterMixin</span> : Topological.mixin_of nbhs&#39; :=
  @Topological.Mixin T nbhs&#39; open_of_nbhs _ _ _.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; p; <span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>=&gt; [p_A|]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [B [Bop Bp sBA]]; <span class="nb">apply</span>: filterS sBA _; <span class="nb">apply</span>: Bop.
<span class="kr">exists</span> (<span class="nv">nbhs&#39;</span>^~ A) ; <span class="nb">split</span> =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: nbhs&#39;_nbhs&#39;.
<span class="bp">by</span> <span class="nb">move</span>=&gt; q /nbhs&#39;_singleton.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">done</span>. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">TopologyOfFilter</span>.</span></pre><div class="doc">
<a id="lab7"></a><h2 class="section">Topology defined by open sets</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">TopologyOfOpen</span>.

<span class="kn">Variable</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">op</span> : <span class="nb">set</span> T -&gt; <span class="kt">Prop</span>).
<span class="kn">Hypothesis</span> (<span class="nv">opT</span> : op setT).
<span class="kn">Hypothesis</span> (<span class="nv">opI</span> : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T), op A -&gt; op B -&gt; op (A `&amp;` B)).
<span class="kn">Hypothesis</span> (<span class="nv">op_bigU</span> : <span class="kr">forall</span> (<span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T),
  (<span class="kr">forall</span> <span class="nv">i</span>, op (f i)) -&gt; op (\bigcup_i f i)).

<span class="kn">Definition</span> <span class="nf">nbhs_of_open</span> (<span class="nv">p</span> : T) (<span class="nv">A</span> : <span class="nb">set</span> T) :=
  <span class="kr">exists</span> <span class="nv">B</span>, [/\ op B, B p &amp; B `&lt;=` A].

<span class="kn">Program Definition</span> <span class="nf">topologyOfOpenMixin</span> : Topological.mixin_of nbhs_of_open :=
  @Topological.Mixin T nbhs_of_open op _ _ _.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; p; <span class="nb">apply</span>: Build_ProperFilter.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; A [B [_ Bp sBA]]; <span class="kr">exists</span> <span class="nv">p</span>; <span class="nb">apply</span>: sBA.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span>.
  <span class="nb">move</span>=&gt; A B [C [Cop Cp sCA]] [D [Dop Dp sDB]].
  <span class="kr">exists</span> (<span class="nv">C</span> `&amp;` D); <span class="nb">split</span> =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: opI.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; q [/sCA Aq /sDB Bq].
<span class="nb">move</span>=&gt; A B sAB [C [Cop p_C sCA]].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">C</span>; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: subset_trans sAB.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">done</span>. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>=&gt; [Aop p Ap|Aop].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span>; <span class="nb">split</span>=&gt; //; <span class="nb">split</span>.
<span class="nb">suff</span> -&gt; : A = \bigcup_(B : {B : <span class="nb">set</span> T &amp; op B /\ B `&lt;=` A}) projT1 B.
  <span class="bp">by</span> <span class="nb">apply</span>: op_bigU =&gt; B; <span class="nb">have</span> [] := projT2 B.
<span class="nb">rewrite</span> predeqE =&gt; p; <span class="nb">split</span>=&gt; [|[B _ Bp]]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">have</span> [_] := projT2 B; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /Aop [B [Bop Bp sBA]]; <span class="kr">exists</span> (<span class="nv">existT</span> <span class="nv">_</span> <span class="nv">B</span> (conj Bop sBA)).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">TopologyOfOpen</span>.</span></pre><div class="doc">
<a id="lab8"></a><h2 class="section">Topology defined by a base of open sets</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">TopologyOfBase</span>.

<span class="kn">Definition</span> <span class="nf">open_from</span> <span class="nv">I</span> <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">b</span> : I -&gt; <span class="nb">set</span> T) :=
  [<span class="nb">set</span> \bigcup_(i <span class="kr">in</span> D&#39;) b i | D&#39; <span class="kr">in</span> subset^~ D].

<span class="kn">Lemma</span> <span class="nf">open_fromT</span> <span class="nv">I</span> <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">b</span> : I -&gt; <span class="nb">set</span> T) :
  \bigcup_(i <span class="kr">in</span> D) b i = setT -&gt; open_from D b setT.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="kr">exists</span> <span class="nv">D</span>. <span class="kn">Qed</span>.

<span class="kn">Variable</span> (<span class="nv">I</span> : pointedType) (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">b</span> : I -&gt; (<span class="nb">set</span> T)).
<span class="kn">Hypothesis</span> (<span class="nv">b_cover</span> : \bigcup_(i <span class="kr">in</span> D) b i = setT).
<span class="kn">Hypothesis</span> (<span class="nv">b_join</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">t</span>, D i -&gt; D j -&gt; b i t -&gt; b j t -&gt;
  <span class="kr">exists</span> <span class="nv">k</span>, [/\ D k, b k t &amp; b k `&lt;=` b i `&amp;` b j]).

<span class="kn">Program Definition</span> <span class="nf">topologyOfBaseMixin</span> :=
  @topologyOfOpenMixin _ (open_from D b) (open_fromT b_cover) _ _.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; A B [DA sDAD AeUbA] [DB sDBD BeUbB].
<span class="nb">have</span> ABU : <span class="kr">forall</span> <span class="nv">t</span>, (A `&amp;` B) t -&gt;
  <span class="kr">exists</span> <span class="nv">it</span>, D it /\ b it t /\ b it `&lt;=` A `&amp;` B.
  <span class="nb">move</span>=&gt; t [At Bt].
  <span class="nb">have</span> [iA [DiA [biAt sbiA]]] : <span class="kr">exists</span> <span class="nv">i</span>, D i /\ b i t /\ b i `&lt;=` A.
    <span class="nb">move</span>: At; <span class="nb">rewrite</span> -AeUbA =&gt; - [i DAi bit]; <span class="kr">exists</span> <span class="nv">i</span>.
    <span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span>: sDAD|<span class="nb">split</span>=&gt; // ?; <span class="kr">exists</span> <span class="nv">i</span>].
  <span class="nb">have</span> [iB [DiB [biBt sbiB]]] : <span class="kr">exists</span> <span class="nv">i</span>, D i /\ b i t /\ b i `&lt;=` B.
    <span class="nb">move</span>: Bt; <span class="nb">rewrite</span> -BeUbB =&gt; - [i DBi bit]; <span class="kr">exists</span> <span class="nv">i</span>.
    <span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span>: sDBD|<span class="nb">split</span>=&gt; // ?; <span class="kr">exists</span> <span class="nv">i</span>].
  <span class="nb">have</span> [i [Di bit sbiAB]] := b_join DiA DiB biAt biBt.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>; <span class="nb">split</span>=&gt; //; <span class="nb">split</span>=&gt; // s /sbiAB [/sbiA ? /sbiB].
<span class="nb">set</span> Dt := <span class="kr">fun</span> <span class="nv">t</span> =&gt; [<span class="nb">set</span> it | D it /\ b it t /\ b it `&lt;=` A `&amp;` B].
<span class="kr">exists</span> [<span class="nb">set</span> get (Dt t) | t <span class="kr">in</span> A `&amp;` B].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [t ABt &lt;-]; <span class="nb">have</span> /ABU/getPex [] := ABt.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [[_ [s ABs &lt;-] bDtst]|ABt].
  <span class="bp">by</span> <span class="nb">have</span> /ABU/getPex [_ [_]] := ABs; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">get</span> (Dt t)); [<span class="kr">exists</span> <span class="nv">t</span>| <span class="nb">have</span> /ABU/getPex [? []]:= ABt].
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; I0 f.
<span class="nb">set</span> fop := <span class="kr">fun</span> <span class="nv">j</span> =&gt; [<span class="nb">set</span> Dj | Dj `&lt;=` D /\ f j = \bigcup_(i <span class="kr">in</span> Dj) b i].
<span class="kr">exists</span> (\bigcup_j get (fop j)).
  <span class="nb">move</span>=&gt; i [j _ fopji].
  <span class="nb">suff</span> /getPex [/(_ _ fopji)] : <span class="kr">exists</span> <span class="nv">Dj</span>, fop j Dj <span class="bp">by</span> [].
  <span class="bp">by</span> <span class="nb">have</span> [Dj] := H j; <span class="kr">exists</span> <span class="nv">Dj</span>.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [[i [j _ fopji bit]]|[j _]].
  <span class="kr">exists</span> <span class="nv">j</span> =&gt; //; <span class="nb">suff</span> /getPex [_ -&gt;] : <span class="kr">exists</span> <span class="nv">Dj</span>, fop j Dj <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>.
  <span class="bp">by</span> <span class="nb">have</span> [Dj] := H j; <span class="kr">exists</span> <span class="nv">Dj</span>.
<span class="nb">have</span> /getPex [_ -&gt;] : <span class="kr">exists</span> <span class="nv">Dj</span>, fop j Dj <span class="bp">by</span> <span class="nb">have</span> [Dj] := H j; <span class="kr">exists</span> <span class="nv">Dj</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [i]; <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="kr">exists</span> <span class="nv">j</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">TopologyOfBase</span>.</span></pre><div class="doc">
<a id="lab9"></a><h2 class="section">Topology defined by a subbase of open sets</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">finI_from</span> (<span class="nv">I</span> : choiceType) <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :=
  [<span class="nb">set</span> \bigcap_(i <span class="kr">in</span> [<span class="nb">set</span>` D&#39;]) f i |
    D&#39; <span class="kr">in</span> [<span class="nb">set</span> A : {fset I} | {subset A &lt;= D}]].

<span class="kn">Lemma</span> <span class="nf">finI_from_cover</span> (<span class="nv">I</span> : choiceType) <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :
  \bigcup_(A <span class="kr">in</span> finI_from D f) A = setT.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; // _; <span class="kr">exists</span> <span class="nv">setT</span> =&gt; //.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">fset0</span> =&gt; //; <span class="nb">rewrite</span> predeqE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">finI_from1</span> (<span class="nv">I</span> : choiceType) <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) <span class="nv">i</span> :
  D i -&gt; finI_from D f (f i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Di; <span class="kr">exists</span> [fset i]%fset.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> !inE =&gt; /eqP-&gt;.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; [|fit]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>; <span class="nb">rewrite</span> /= inE.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> /= inE =&gt; /eqP-&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">finI_from_countable</span> (<span class="nv">I</span> : pointedType) <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :
  countable D -&gt; countable (finI_from D f).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: (card_le_trans (card_image_le _ _)).
<span class="bp">exact</span>: fset_subset_countable.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">TopologyOfSubbase</span>.

<span class="kn">Variable</span> (<span class="nv">I</span> : pointedType) (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">b</span> : I -&gt; <span class="nb">set</span> T).

<span class="kn">Program Definition</span> <span class="nf">topologyOfSubbaseMixin</span> :=
  @topologyOfBaseMixin _ _ (finI_from D b) id (finI_from_cover D b) _.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; A B t [DA sDAD AeIbA] [DB sDBD BeIbB] At Bt.
<span class="kr">exists</span> (<span class="nv">A</span> `&amp;` B); <span class="nb">split</span> =&gt; //.
<span class="kr">exists</span> (<span class="nv">DA</span> `|` DB)%fset; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; i /fsetUP [/sDAD|/sDBD].
<span class="nb">rewrite</span> predeqE =&gt; s; <span class="nb">split</span>=&gt; [Ifs|[<span class="kn">As</span> Bs] i /fsetUP].
  <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -AeIbA =&gt; i DAi; <span class="nb">apply</span>: Ifs; <span class="nb">rewrite</span> /= inE DAi.
  <span class="bp">by</span> <span class="nb">rewrite</span> -BeIbB =&gt; i DBi; <span class="nb">apply</span>: Ifs; <span class="nb">rewrite</span> /= inE DBi orbC.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [DAi|DBi];
  [<span class="nb">have</span> := <span class="kn">As</span>; <span class="nb">rewrite</span> -AeIbA; <span class="nb">apply</span>|<span class="nb">have</span> := Bs; <span class="nb">rewrite</span> -BeIbB; <span class="nb">apply</span>].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">TopologyOfSubbase</span>.

<span class="c">(* Topology on nat *)</span>

<span class="kn">Section</span> <span class="nf">nat_topologicalType</span>.

<span class="kn">Let</span> <span class="nf">D</span> : <span class="nb">set</span> nat := setT.
<span class="kn">Let</span> <span class="nf">b</span> : nat -&gt; <span class="nb">set</span> nat := <span class="kr">fun</span> <span class="nv">i</span> =&gt; [<span class="nb">set</span> i].
<span class="kn">Let</span> <span class="nf">bT</span> : \bigcup_(i <span class="kr">in</span> D) b i = setT.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; i; <span class="nb">split</span> =&gt; // _; <span class="kr">exists</span> <span class="nv">i</span>. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">bD</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">t</span>, D i -&gt; D j -&gt; b i t -&gt; b j t -&gt;
  <span class="kr">exists</span> <span class="nv">k</span>, [/\ D k, b k t &amp; b k `&lt;=` b i `&amp;` b j].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; i j t _ _ -&gt; -&gt;; <span class="kr">exists</span> <span class="nv">j</span>. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">nat_topologicalTypeMixin</span> := topologyOfBaseMixin bT bD.
<span class="kn">Canonical</span> <span class="nf">nat_filteredType</span> := FilteredType nat nat (nbhs_of_open (open_from D b)).
<span class="kn">Canonical</span> <span class="nf">nat_topologicalType</span> := TopologicalType nat nat_topologicalTypeMixin.

<span class="kn">End</span> <span class="nf">nat_topologicalType</span>.

<span class="c">(* :TODO: ultimately nat could be replaced by any lattice *)</span>
<span class="kn">Definition</span> <span class="nf">eventually</span> := filter_from setT (<span class="kr">fun</span> <span class="nv">N</span> =&gt; [<span class="nb">set</span> n | (N &lt;= n)%N]).
<span class="kn">Notation</span> <span class="s2">&quot;&#39;\oo&#39;&quot;</span> := eventually : classical_set_scope.

<span class="kn">Canonical</span> <span class="nf">eventually_filter_source</span> X :=
   @Filtered.Source X _ nat (<span class="kr">fun</span> <span class="nv">f</span> =&gt; f @ \oo).

<span class="kn">Global Instance</span> <span class="nf">eventually_filter</span> : ProperFilter eventually.
<span class="kn">Proof</span>.
<span class="nb">eapply</span> @filter_from_proper; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; i _; <span class="kr">exists</span> <span class="nv">i</span> =&gt; /=.
<span class="nb">apply</span>: filter_fromT_filter; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>%N.
<span class="nb">move</span>=&gt; i j; <span class="kr">exists</span> (<span class="nv">maxn</span> <span class="nv">i</span> <span class="nv">j</span>) =&gt; n //=.
<span class="bp">by</span> <span class="nb">rewrite</span> geq_max =&gt; /andP[ltin ltjn].
<span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">eventually_filterType</span> := FilterType eventually _.
<span class="kn">Canonical</span> <span class="nf">eventually_pfilterType</span> := PFilterType eventually (filter_not_empty _).

<span class="kn">Lemma</span> <span class="nf">nbhs_infty_gt</span> <span class="nv">N</span> : \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, (N &lt; n)%N.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">N</span>.+<span class="mi">1</span>. <span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> nbhs_infty_gt : core.

<span class="kn">Lemma</span> <span class="nf">nbhs_infty_ge</span> <span class="nv">N</span> : \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, (N &lt;= n)%N.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">N</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_addnl</span> <span class="nv">N</span> : addn N @ \oo --&gt; \oo.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; P [n _ Pn]; <span class="kr">exists</span> (<span class="nv">n</span> - N)%N =&gt; // m; <span class="nb">rewrite</span> /= leq_subLR =&gt; /Pn.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_addnr</span> <span class="nv">N</span> : addn^~ N --&gt; \oo.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">under</span> [addn^~ N]funext =&gt; n <span class="kp">do</span> <span class="nb">rewrite</span> addnC; <span class="nb">apply</span>: cvg_addnl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_subnr</span> <span class="nv">N</span> : subn^~ N --&gt; \oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; P [n _ Pn]; <span class="kr">exists</span> (<span class="nv">N</span> + n)%N =&gt; //= m le_m.
<span class="bp">by</span> <span class="nb">apply</span>: Pn; <span class="nb">rewrite</span> /= leq_subRL// (leq_trans _ le_m)// leq_addr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_mulnl</span> <span class="nv">N</span> : (N &gt; <span class="mi">0</span>)%N -&gt; muln N --&gt; \oo.
<span class="kn">Proof</span>.
<span class="nb">case</span>: N =&gt; N // _ P [n _ Pn]; <span class="kr">exists</span> (<span class="nv">n</span> %/ N.+<span class="mi">1</span>).+<span class="mi">1</span> =&gt; // m.
<span class="bp">by</span> <span class="nb">rewrite</span> /= ltn_divLR// =&gt; n_lt; <span class="nb">apply</span>: Pn; <span class="nb">rewrite</span> mulnC /= ltnW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_mulnr</span> <span class="nv">N</span> :(N &gt; <span class="mi">0</span>)%N -&gt; muln^~ N --&gt; \oo.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; N_gt0; <span class="nb">under</span> [muln^~ N]funext =&gt; n <span class="kp">do</span> <span class="nb">rewrite</span> mulnC; <span class="nb">apply</span>: cvg_mulnl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_divnr</span> <span class="nv">N</span> : (N &gt; <span class="mi">0</span>)%N -&gt; divn^~ N --&gt; \oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; N_gt0 P [n _ Pn]; <span class="kr">exists</span> (<span class="nv">n</span> * N)%N =&gt; //= m.
<span class="bp">by</span> <span class="nb">rewrite</span> /= -leq_divRL//; <span class="nb">apply</span>: Pn.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_inftyS</span> (<span class="nv">P</span> : <span class="nb">set</span> nat) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near \oo, P (S x)) -&gt; (\<span class="kr">forall</span> <span class="nv">x</span> \near \oo, P x).
<span class="kn">Proof</span>. <span class="nb">case</span>=&gt; N _ NPS; <span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">N</span>) =&gt; // [[]]; <span class="nb">rewrite</span> /= <span class="nl">?ltn0</span> //. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">infty_nat</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.

<span class="kn">Let</span> <span class="nf">cvgnyP</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> nat)} {<span class="nv">FF</span> : Filter F} : [&lt;-&gt;
<span class="c">(* 0 *)</span> F --&gt; \oo;
<span class="c">(* 1 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= x;
<span class="c">(* 2 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; x;
<span class="c">(* 3 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near \oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; x;
<span class="c">(* 4 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near \oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= x ].
<span class="kn">Proof</span>.
tfae; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo A; <span class="nb">apply</span>: Foo; <span class="nb">apply</span>: nbhs_infty_ge.
- <span class="nb">move</span>=&gt; AF A; near \oo =&gt; B; near=&gt; x.
  <span class="nb">suff</span> : (B &lt;= x)%N <span class="bp">by</span> <span class="nb">apply</span>: leq_trans; near: B; <span class="nb">apply</span>: nbhs_infty_gt.
  <span class="bp">by</span> near: x; <span class="nb">apply</span>: AF; near: B.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo; near <span class="kp">do</span> <span class="nb">apply</span>: Foo.
- <span class="bp">by</span> <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: ltnW.
<span class="nb">case</span>=&gt; [A _ AF] P [n _ Pn]; near \oo =&gt; B; near=&gt; m; <span class="nb">apply</span>: Pn =&gt; /=.
<span class="nb">suff</span>: (B &lt;= m)%N <span class="bp">by</span> <span class="nb">apply</span>: leq_trans; near: B; <span class="nb">apply</span>: nbhs_infty_ge.
<span class="bp">by</span> near: m; <span class="nb">apply</span>: AF; near: B; <span class="nb">apply</span>: nbhs_infty_ge.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">map</span>.

<span class="kn">Context</span> {<span class="nv">I</span> : <span class="kt">Type</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : I -&gt; nat).

<span class="kn">Lemma</span> <span class="nf">cvgnyPge</span> :
  f @ F --&gt; \oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgnyP <span class="mi">0</span>%N <span class="mi">1</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgnyPgt</span> :
  f @ F --&gt; \oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgnyP <span class="mi">0</span>%N <span class="mi">2</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgnyPgty</span> :
  f @ F --&gt; \oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near \oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgnyP <span class="mi">0</span>%N <span class="mi">3</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgnyPgey</span> :
  f @ F --&gt; \oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near \oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgnyP <span class="mi">0</span>%N <span class="mi">4</span>%N). <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">map</span>.

<span class="kn">End</span> <span class="nf">infty_nat</span>.</span></pre><div class="doc">
<a id="lab10"></a><h2 class="section">Topology on the product of two spaces</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">Prod_Topology</span>.

<span class="kn">Context</span> {<span class="nv">T</span> <span class="nv">U</span> : topologicalType}.

<span class="kn">Let</span> <span class="nf">prod_nbhs</span> (<span class="nv">p</span> : T * U) := filter_prod (nbhs p.<span class="mi">1</span>) (nbhs p.<span class="mi">2</span>).

<span class="kn">Lemma</span> <span class="nf">prod_nbhs_filter</span> (<span class="nv">p</span> : T * U) : ProperFilter (prod_nbhs p).
<span class="kn">Proof</span>. <span class="bp">exact</span>: filter_prod_proper. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_nbhs_singleton</span> (<span class="nv">p</span> : T * U) (<span class="nv">A</span> : <span class="nb">set</span> (T * U)) : prod_nbhs p A -&gt; A p.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [QR [/nbhs_singleton Qp1 /nbhs_singleton Rp2]]; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_nbhs_nbhs</span> (<span class="nv">p</span> : T * U) (<span class="nv">A</span> : <span class="nb">set</span> (T * U)) :
  prod_nbhs p A -&gt; prod_nbhs p (prod_nbhs^~ A).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [QR [/nbhs_interior p1_Q /nbhs_interior p2_R] sQRA].
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">QR</span>.<span class="mi">1</span>^¬∞, QR.<span class="mi">2</span>^¬∞) =&gt; // ??; <span class="kr">exists</span> <span class="nv">QR</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">prod_topologicalTypeMixin</span> :=
  topologyOfFilterMixin prod_nbhs_filter prod_nbhs_singleton prod_nbhs_nbhs.

<span class="kn">Canonical</span> <span class="nf">prod_topologicalType</span> :=
  TopologicalType (T * U) prod_topologicalTypeMixin.

<span class="kn">End</span> <span class="nf">Prod_Topology</span>.</span></pre><div class="doc">
<a id="lab11"></a><h2 class="section">Topology on matrices</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">matrix_Topology</span>.

<span class="kn">Variables</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">T</span> : topologicalType).

<span class="kn">Implicit Types</span> <span class="nv">M</span> : &#39;M[T]_(m, n).

<span class="kn">Lemma</span> <span class="nf">mx_nbhs_filter</span> <span class="nv">M</span> : ProperFilter (nbhs M).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: (filter_from_proper (filter_from_filter _ _)) =&gt; [|P Q M_P M_Q|P M_P].
- <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; setT) =&gt; ??; <span class="nb">apply</span>: filterT.
- <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; P i j `&amp;` Q i j) =&gt; [??|mx PQmx]; <span class="kp">first</span> <span class="bp">exact</span>: filterI.
  <span class="bp">by</span> <span class="nb">split</span>=&gt; i j; <span class="nb">have</span> [] := PQmx i j.
- <span class="kr">exists</span> (\matrix_(i, j) get (P i j)) =&gt; i j; <span class="nb">rewrite</span> mxE; <span class="nb">apply</span>: getPex.
  <span class="bp">exact</span>: filter_ex (M_P i j).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_nbhs_singleton</span> <span class="nv">M</span> (<span class="nv">A</span> : <span class="nb">set</span> &#39;M[T]_(m, n)) : nbhs M A -&gt; A M.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; [P M_P]; <span class="nb">apply</span>=&gt; ??; <span class="nb">apply</span>: nbhs_singleton. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_nbhs_nbhs</span> <span class="nv">M</span> (<span class="nv">A</span> : <span class="nb">set</span> &#39;M[T]_(m, n)) : nbhs M A -&gt; nbhs M (nbhs^~ A).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [P M_P sPA]; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; (P i j)^¬∞).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: nbhs_interior.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="kr">exists</span> <span class="nv">P</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">matrix_topologicalTypeMixin</span> :=
  topologyOfFilterMixin mx_nbhs_filter mx_nbhs_singleton mx_nbhs_nbhs.

<span class="kn">Canonical</span> <span class="nf">matrix_topologicalType</span> :=
  TopologicalType &#39;M[T]_(m, n) matrix_topologicalTypeMixin.

<span class="kn">End</span> <span class="nf">matrix_Topology</span>.</span></pre><div class="doc">
<a id="lab12"></a><h2 class="section">Weak topology by a function</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">Weak_Topology</span>.

<span class="kn">Variable</span> (<span class="nv">S</span> : pointedType) (<span class="nv">T</span> : topologicalType) (<span class="nv">f</span> : S -&gt; T).

<span class="kn">Definition</span> <span class="nf">wopen</span> := [<span class="nb">set</span> f @^-<span class="mi">1</span>` A | A <span class="kr">in</span> open].

<span class="kn">Lemma</span> <span class="nf">wopT</span> : wopen setT.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span> =&gt; //; <span class="nb">apply</span>: openT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">wopI</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> S) : wopen A -&gt; wopen B -&gt; wopen (A `&amp;` B).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [C Cop &lt;-] [D Dop &lt;-]; <span class="kr">exists</span> (<span class="nv">C</span> `&amp;` D) =&gt; //; <span class="nb">apply</span>: openI.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">wop_bigU</span> (<span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : I -&gt; <span class="nb">set</span> S) :
  (<span class="kr">forall</span> <span class="nv">i</span>, wopen (g i)) -&gt; wopen (\bigcup_i g i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; gop.
<span class="nb">set</span> opi := <span class="kr">fun</span> <span class="nv">i</span> =&gt; [<span class="nb">set</span> Ui | open Ui /\ g i = f @^-<span class="mi">1</span>` Ui].
<span class="kr">exists</span> (\bigcup_i get (opi i)).
  <span class="nb">apply</span>: bigcup_open =&gt; i.
  <span class="bp">by</span> <span class="nb">have</span> /getPex [] : <span class="kr">exists</span> <span class="nv">U</span>, opi i U <span class="bp">by</span> <span class="nb">have</span> [U] := gop i; <span class="kr">exists</span> <span class="nv">U</span>.
<span class="nb">have</span> g_preim i : g i = f @^-<span class="mi">1</span>` (get (opi i)).
  <span class="bp">by</span> <span class="nb">have</span> /getPex [] : <span class="kr">exists</span> <span class="nv">U</span>, opi i U <span class="bp">by</span> <span class="nb">have</span> [U] := gop i; <span class="kr">exists</span> <span class="nv">U</span>.
<span class="nb">rewrite</span> predeqE =&gt; s; <span class="nb">split</span>=&gt; [[i _]|[i _]]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> g_preim; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -[_ _]/((f @^-<span class="mi">1</span>` _) _) -g_preim; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">weak_topologicalTypeMixin</span> := topologyOfOpenMixin wopT wopI wop_bigU.

<span class="kn">Let</span> <span class="nf">S_filteredClass</span> := Filtered.<span class="kn">Class</span> (Pointed.class S) (nbhs_of_open wopen).
<span class="kn">Definition</span> <span class="nf">weak_topologicalType</span> :=
  Topological.Pack (@Topological.<span class="kn">Class</span> <span class="nf">_</span> <span class="nv">S_filteredClass</span>
    <span class="nv">weak_topologicalTypeMixin</span>).

<span class="kn">Lemma</span> <span class="nf">weak_continuous</span> : continuous (f : weak_topologicalType -&gt; T).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/continuousP =&gt; A ?; <span class="kr">exists</span> <span class="nv">A</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_image</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> S)) (<span class="nv">s</span> : S) :
  Filter F -&gt; f @` setT = setT -&gt;
  F --&gt; (s : weak_topologicalType) &lt;-&gt; [<span class="nb">set</span> f @` A | A <span class="kr">in</span> F] --&gt; f s.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF fsurj; <span class="nb">split</span>=&gt; [cvFs|cvfFfs].
  <span class="nb">move</span>=&gt; A /weak_continuous [B [Bop Bs sBAf]].
  <span class="nb">have</span> /cvFs FB : nbhs (s : weak_topologicalType) B <span class="bp">by</span> <span class="nb">apply</span>: open_nbhs_nbhs.
  <span class="nb">rewrite</span> nbhs_simpl; <span class="kr">exists</span> (<span class="nv">f</span> @^-<span class="mi">1</span>` A); <span class="kp">first</span> <span class="bp">exact</span>: filterS FB.
  <span class="bp">exact</span>: image_preimage.
<span class="nb">move</span>=&gt; A /= [_ [[B Bop &lt;-] Bfs sBfA]].
<span class="nb">have</span> /cvfFfs [C FC fCeB] : nbhs (f s) B <span class="bp">by</span> <span class="nb">rewrite</span> nbhsE; <span class="kr">exists</span> <span class="nv">B</span>.
<span class="nb">rewrite</span> nbhs_filterE; <span class="nb">apply</span>: filterS FC.
<span class="bp">by</span> <span class="nb">apply</span>: subset_trans sBfA; <span class="nb">rewrite</span> -fCeB; <span class="nb">apply</span>: preimage_image.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Weak_Topology</span>.</span></pre><div class="doc">
<a id="lab13"></a><h2 class="section">Supremum of a family of topologies</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">Sup_Topology</span>.

<span class="kn">Variable</span> (<span class="nv">T</span> : pointedType) (<span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">Tc</span> : I -&gt; Topological.class_of T).

<span class="kn">Let</span> <span class="nf">TS</span> := <span class="kr">fun</span> <span class="nv">i</span> =&gt; Topological.Pack (Tc i).

<span class="kn">Definition</span> <span class="nf">sup_subbase</span> := \bigcup_i (@open (TS i) : <span class="nb">set</span> (<span class="nb">set</span> T)).

<span class="kn">Definition</span> <span class="nf">sup_topologicalTypeMixin</span> := topologyOfSubbaseMixin sup_subbase id.

<span class="kn">Definition</span> <span class="nf">sup_topologicalType</span> :=
  Topological.Pack (@Topological.<span class="kn">Class</span> <span class="nf">_</span> (<span class="nv">Filtered</span>.Class (Pointed.class T) _)
  <span class="nv">sup_topologicalTypeMixin</span>).

<span class="kn">Lemma</span> <span class="nf">cvg_sup</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">t</span> : T) :
  Filter F -&gt; F --&gt; (t : sup_topologicalType) &lt;-&gt; <span class="kr">forall</span> <span class="nv">i</span>, F --&gt; (t : TS i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Ffilt; <span class="nb">split</span>=&gt; cvFt.
  <span class="nb">move</span>=&gt; i A /=; <span class="nb">rewrite</span> (@nbhsE (TS i)) =&gt; - [B [Bop Bt] sBA].
  <span class="nb">apply</span>: cvFt; <span class="kr">exists</span> <span class="nv">B</span>; <span class="nb">split</span>=&gt; //; <span class="kr">exists</span> [<span class="nb">set</span> B]; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span>=&gt; [[_ -&gt;]|] //; <span class="kr">exists</span> <span class="nv">B</span>.
  <span class="nb">move</span>=&gt; _ -&gt;; <span class="kr">exists</span> [fset B]%fset.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> inE inE =&gt; /eqP-&gt;; <span class="kr">exists</span> <span class="nv">i</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE=&gt; ?; <span class="nb">split</span>=&gt; [|??]; [<span class="nb">apply</span>|]; <span class="nb">rewrite</span> /= inE // =&gt;/eqP-&gt;.
<span class="nb">move</span>=&gt; A /=; <span class="nb">rewrite</span> (@nbhsE sup_topologicalType).
<span class="nb">move</span>=&gt; [_ [[B sB &lt;-] [C BC Ct] sUBA]].
<span class="nb">rewrite</span> nbhs_filterE; <span class="nb">apply</span>: filterS sUBA _; <span class="nb">apply</span>: (@filterS _ _ _ C).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="kr">exists</span> <span class="nv">C</span>.
<span class="nb">have</span> /sB [D sD IDeC] := BC; <span class="nb">rewrite</span> -IDeC; <span class="nb">apply</span>: filter_bigI =&gt; E DE.
<span class="nb">have</span> /sD := DE; <span class="nb">rewrite</span> inE =&gt; - [i _]; <span class="nb">rewrite</span> openE =&gt; Eop.
<span class="bp">by</span> <span class="nb">apply</span>: (cvFt i); <span class="nb">apply</span>: Eop; <span class="nb">move</span>: Ct; <span class="nb">rewrite</span> -IDeC =&gt; /(_ _ DE).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Sup_Topology</span>.</span></pre><div class="doc">
<a id="lab14"></a><h2 class="section">Product topology</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">Product_Topology</span>.

<span class="kn">Variable</span> (<span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">T</span> : I -&gt; topologicalType).

<span class="kn">Definition</span> <span class="nf">product_topologicalType</span> :=
  sup_topologicalType (<span class="kr">fun</span> <span class="nv">i</span> =&gt; Topological.class
    (weak_topologicalType (<span class="kr">fun</span> <span class="nv">f</span> : dep_arrow_pointedType T =&gt; f i))).

<span class="kn">End</span> <span class="nf">Product_Topology</span>.</span></pre><div class="doc">
dnbhs 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">dnbhs</span> {<span class="nv">T</span> : topologicalType} (<span class="nv">x</span> : T) :=
  within (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y != x) (nbhs x).
<span class="kn">Notation</span> <span class="s2">&quot;x ^&#39;&quot;</span> := (dnbhs x) : classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">dnbhsE</span> (<span class="nv">T</span> : topologicalType) (<span class="nv">x</span> : T) : nbhs x = x^&#39; `&amp;` at_point x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>=&gt; [x_A|[x_A Ax]].
  <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: nbhs_singleton.
  <span class="nb">move</span>: x_A; <span class="nb">rewrite</span> nbhsE =&gt; -[B [oB x_B sBA]]; <span class="nb">rewrite</span> /dnbhs nbhsE.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">B</span> =&gt; // ? /sBA.
<span class="nb">move</span>: x_A; <span class="nb">rewrite</span> /dnbhs !nbhsE =&gt; -[B [oB x_B sBA]]; <span class="kr">exists</span> <span class="nv">B</span> =&gt; //.
<span class="bp">by</span> <span class="nb">move</span>=&gt; y /sBA Ay; <span class="nb">case</span>: (eqVneq y x) =&gt; [-&gt;|].
<span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">dnbhs_filter</span> {<span class="nv">T</span> : topologicalType} (<span class="nv">x</span> : T) : Filter x^&#39;.
<span class="kn">Proof</span>. <span class="bp">exact</span>: within_filter. <span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Typeclasses Opaque</span> dnbhs.

<span class="kn">Canonical</span> <span class="nf">dnbhs_filter_on</span> (T : topologicalType)  (x : T) :=
  FilterType x^&#39; (dnbhs_filter _).

<span class="kn">Lemma</span> <span class="nf">cvg_fmap2</span> (<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : T -&gt; U):
  <span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)), G `=&gt;` F -&gt; f @ G `=&gt;` f @ F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; F G H A fFA ; <span class="bp">exact</span>: H (preimage f A) fFA. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_within_filter</span> {<span class="nv">T</span> <span class="nv">U</span>} {<span class="nv">f</span> : T -&gt; U} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : (Filter F) }
  (<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) : <span class="kr">forall</span> (<span class="nv">D</span> : <span class="nb">set</span> T), (f @ F) --&gt; G -&gt; (f @ within D F) --&gt; G.
<span class="kn">Proof</span>. <span class="nb">move</span>=&gt; ?;  <span class="bp">exact</span>: cvg_trans (cvg_fmap2 (cvg_within _)). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_app_within</span> {<span class="nv">T</span>} {<span class="nv">U</span> : topologicalType} (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T))
  (<span class="nv">D</span> : <span class="nb">set</span> T): Filter F -&gt; cvg (f @ F) -&gt; cvg (f @ within D F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span> =&gt; FF /cvg_ex [l H]; <span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> <span class="nv">l</span>; <span class="bp">exact</span>: cvg_within_filter. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_dnbhs</span> {<span class="nv">T</span> : topologicalType} (<span class="nv">x</span> : T) : x^&#39; `=&gt;` nbhs x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvg_within. <span class="kn">Qed</span>.</span></pre><div class="doc">
meets 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Lemma</span> <span class="nf">meets_openr</span> {<span class="nv">T</span> : topologicalType} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">x</span> : T) :
  F `#` nbhs x = F `#` open_nbhs x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>; [<span class="bp">exact</span>/meetsSr/open_nbhs_nbhs|].
<span class="bp">by</span> <span class="nb">move</span>=&gt; P A B {}/P P; <span class="nb">rewrite</span> nbhsE =&gt; -[B&#39; /P + sB]; <span class="nb">apply</span>: subsetI_neq0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">meets_openl</span> {<span class="nv">T</span> : topologicalType} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">x</span> : T) :
  nbhs x `#` F = open_nbhs x `#` F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> meetsC meets_openr meetsC. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">meets_globallyl</span> <span class="nv">T</span> (<span class="nv">A</span> : <span class="nb">set</span> T) <span class="nv">G</span> :
  globally A `#` G = <span class="kr">forall</span> <span class="nv">B</span>, G B -&gt; A `&amp;` B !=set0.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [/(_ _ _ (<span class="kr">fun</span>=&gt; id))//|clA A&#39; B sA].
<span class="bp">by</span> <span class="nb">move</span>=&gt; /clA; <span class="nb">apply</span>: subsetI_neq0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">meets_globallyr</span> <span class="nv">T</span> <span class="nv">F</span> (<span class="nv">B</span> : <span class="nb">set</span> T) :
  F `#` globally B = <span class="kr">forall</span> <span class="nv">A</span>, F A -&gt; A `&amp;` B !=set0.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> meetsC meets_globallyl; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> setIC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">meetsxx</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : Filter F) : F `#` F = ~ (F set0).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [FmF F0|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">have</span> [x []] := FmF _ _ F0 F0.
<span class="nb">move</span>=&gt; FN0 A B /filterI FAI {}/FAI FAB; <span class="nb">apply</span>/set0P/eqP =&gt; AB0.
<span class="bp">by</span> <span class="nb">rewrite</span> AB0 <span class="kr">in</span> FAB.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">proper_meetsxx</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : ProperFilter F) : F `#` F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> meetsxx; <span class="nb">apply</span>: filter_not_empty. <span class="kn">Qed</span>.</span></pre><div class="doc">
<a id="lab15"></a><h2 class="section">Closed sets in topological spaces</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">Closed</span>.

<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType}.

<span class="kn">Definition</span> <span class="nf">closure</span> (<span class="nv">A</span> : <span class="nb">set</span> T) :=
  [<span class="nb">set</span> p : T | <span class="kr">forall</span> <span class="nv">B</span>, nbhs p B -&gt; A `&amp;` B !=set0].

<span class="kn">Lemma</span> <span class="nf">closure0</span> : closure set0 = set0 :&gt; <span class="nb">set</span> T.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; // /(_ _ (filter_nbhsT _))/set0P.
<span class="bp">by</span> <span class="nb">rewrite</span> set0I eqxx.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closureEnbhs</span> <span class="nv">A</span> : closure A = [<span class="nb">set</span> p | globally A `#` nbhs p].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> meets_globallyl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closureEonbhs</span> <span class="nv">A</span> : closure A = [<span class="nb">set</span> p | globally A `#` open_nbhs p].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -meets_openr meets_globallyl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subset_closure</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : A `&lt;=` closure A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; p ??; <span class="kr">exists</span> <span class="nv">p</span>; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: nbhs_singleton. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closureI</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) : closure (A `&amp;` B) `&lt;=` closure A `&amp;` closure B.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; p clABp; <span class="nb">split</span>=&gt; ? /clABp [q [[]]]; <span class="kr">exists</span> <span class="nv">q</span>. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">limit_point</span> <span class="nv">E</span> := [<span class="nb">set</span> t : T |
  <span class="kr">forall</span> <span class="nv">U</span>, nbhs t U -&gt; <span class="kr">exists</span> <span class="nv">y</span>, [/\ y != t, E y &amp; U y]].

<span class="kn">Lemma</span> <span class="nf">limit_pointEnbhs</span> <span class="nv">E</span> :
  limit_point E = [<span class="nb">set</span> p | globally (E `\ p) `#` nbhs p].
<span class="kn">Proof</span>.
<span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> meets_globallyl; <span class="nb">rewrite</span> funeqE =&gt; p /=.
<span class="nb">apply</span>/eq_forall2 =&gt; x px; <span class="nb">apply</span>/eq_exists =&gt; y.
<span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [[/eqP ? ?]|[[? /eqP ?]]]; <span class="kp">do</span> <span class="mi">2</span><span class="nl">?split</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limit_pointEonbhs</span> <span class="nv">E</span> :
  limit_point E = [<span class="nb">set</span> p | globally (E `\ p) `#` open_nbhs p].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> limit_pointEnbhs; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> meets_openr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subset_limit_point</span> <span class="nv">E</span> : limit_point E `&lt;=` closure E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; t Et U tU; <span class="nb">have</span> [p [? ? ?]] := Et _ tU; <span class="kr">exists</span> <span class="nv">p</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closure_limit_point</span> <span class="nv">E</span> : closure E = E `|` limit_point E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; [cEt|]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">case</span>; [<span class="bp">exact</span>: subset_closure|<span class="bp">exact</span>: subset_limit_point].
<span class="nb">have</span> [?|Et] := pselect (E t); [<span class="bp">by</span> <span class="nb">left</span>|<span class="nb">right</span>=&gt; U tU; <span class="nb">have</span> [p []] := cEt _ tU].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">p</span>; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>/eqP =&gt; pt; <span class="nb">apply</span>: Et; <span class="nb">rewrite</span> -pt.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">closed</span> (<span class="nv">D</span> : <span class="nb">set</span> T) := closure D `&lt;=` D.

<span class="kn">Lemma</span> <span class="nf">open_closedC</span> (<span class="nv">D</span> : <span class="nb">set</span> T) : open D -&gt; closed (~` D).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> openE =&gt; Dop p clNDp /Dop /clNDp [? []]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_bigI</span> {<span class="nv">I</span>} (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; closed (f i)) -&gt; closed (\bigcap_(i <span class="kr">in</span> D) f i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fcl t clft i Di; <span class="nb">have</span> /fcl := Di; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; A /clft [s [/(_ i Di)]]; <span class="kr">exists</span> <span class="nv">s</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closedI</span> (<span class="nv">D</span> <span class="nv">E</span> : <span class="nb">set</span> T) : closed D -&gt; closed E -&gt; closed (D `&amp;` E).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Dcl Ecl p clDEp; <span class="nb">split</span>; [<span class="nb">apply</span>: Dcl|<span class="nb">apply</span>: Ecl];
  <span class="nb">move</span>=&gt; A /clDEp [q [[]]]; <span class="kr">exists</span> <span class="nv">q</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closedT</span> : closed setT. <span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed0</span> : closed set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? /(_ setT) [|? []] //; <span class="nb">apply</span>: filterT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closedE</span> : closed = [<span class="nb">set</span> A : <span class="nb">set</span> T | <span class="kr">forall</span> <span class="nv">p</span>, ~ (\near p, ~ A p) -&gt; A p].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>=&gt; Acl p; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; clAp; <span class="nb">apply</span>: Acl; <span class="nb">rewrite</span> -nbhs_nearE =&gt; /clAp [? []].
<span class="nb">rewrite</span> -nbhs_nearE nbhsE =&gt; /asboolP.
<span class="nb">rewrite</span> asbool_neg =&gt; /forallp_asboolPn2 clAp.
<span class="nb">apply</span>: Acl =&gt; B; <span class="nb">rewrite</span> nbhsE =&gt; - [C [oC pC]].
<span class="nb">have</span> /asboolP := clAp C.
<span class="nb">rewrite</span> asbool_or <span class="mi">2</span>!asbool_neg =&gt; /orP[/asboolP/not_andP[]//|/existsp_asboolPn [q]].
<span class="nb">move</span>/asboolP; <span class="nb">rewrite</span> asbool_neg =&gt; /imply_asboolPn[+ /contrapT Aq sCB] =&gt; /sCB.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">q</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_openC</span> (<span class="nv">D</span> : <span class="nb">set</span> T) : closed D -&gt; open (~` D).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> closedE openE =&gt; Dcl t nDt; <span class="nb">apply</span>: contrapT.
<span class="bp">by</span> <span class="nb">rewrite</span> /interior nbhs_nearE =&gt; /Dcl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closedC</span> (<span class="nv">D</span> : <span class="nb">set</span> T) : closed (~` D) = open D.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>/propext; <span class="nb">split</span>=&gt; [/closed_openC|]; [<span class="nb">rewrite</span> setCK|<span class="bp">exact</span>: open_closedC].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">openC</span> (<span class="nv">D</span> : <span class="nb">set</span> T) : open (~`D) = closed (D).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -closedC setCK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_closure</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : closed (closure A).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; p clclAp B /nbhs_interior /clclAp [q [clAq /clAq]]. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Closed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_comp</span> {<span class="nv">T</span> <span class="nv">U</span> : topologicalType} (<span class="nv">f</span> : T -&gt; U) (<span class="nv">D</span> : <span class="nb">set</span> U) :
  {<span class="kr">in</span> ~` f @^-<span class="mi">1</span>` D, continuous f} -&gt; closed D -&gt; closed (f @^-<span class="mi">1</span>` D).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> !closedE=&gt; f_continuous D_cl x /= xDf.
<span class="nb">apply</span>: D_cl; <span class="nb">apply</span>: contra_not xDf =&gt; fxD.
<span class="nb">have</span> NDfx : ~ D (f x).
  <span class="bp">by</span> <span class="nb">move</span>: fxD; <span class="nb">rewrite</span> -nbhs_nearE nbhsE =&gt; - [A [? ?]]; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">apply</span>: f_continuous fxD; <span class="nb">rewrite</span> inE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_cvg</span> {<span class="nv">T</span>} {<span class="nv">V</span> : topologicalType} {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F}
    (<span class="nv">u_</span> : T -&gt; V) (<span class="nv">A</span> : V -&gt; <span class="kt">Prop</span>) :
    <span class="c">(* BUG: elim does not see this as an elimination principle if A : set V *)</span>
    closed A -&gt; (\<span class="kr">forall</span> <span class="nv">n</span> \near F, A (u_ n)) -&gt;
  <span class="kr">forall</span> <span class="nv">l</span>, u_ @ F --&gt; l -&gt; A l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; + FAu_ l u_Fl; <span class="nb">apply</span> =&gt; B /u_Fl /=; <span class="nb">rewrite</span> nbhs_filterE.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /(filterI FAu_) =&gt; /filter_ex[t [Au_t u_Bt]]; <span class="kr">exists</span> (<span class="nv">u_</span> <span class="nv">t</span>).
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> closed_cvg {T V F FF u_} _ _ _ _ _.

<span class="kn">Lemma</span> <span class="nf">continuous_closedP</span> (<span class="nv">S</span> <span class="nv">T</span> : topologicalType) (<span class="nv">f</span> : S -&gt; T) :
  continuous f &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, closed A -&gt; closed (f @^-<span class="mi">1</span>` A).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> continuousP; <span class="nb">split</span>=&gt; ctsf ? ?.
  <span class="bp">by</span> <span class="nb">rewrite</span> -openC preimage_setC; <span class="nb">apply</span> ctsf; <span class="nb">rewrite</span> openC.
<span class="bp">by</span> <span class="nb">rewrite</span> -closedC preimage_setC; <span class="nb">apply</span> ctsf; <span class="nb">rewrite</span> closedC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closedU</span> (<span class="nv">T</span> : topologicalType) (<span class="nv">D</span> <span class="nv">E</span> : <span class="nb">set</span> T) :
  closed D -&gt; closed E -&gt; closed (D `|` E).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -<span class="nl">?openC</span> setCU; <span class="bp">exact</span>: openI. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_bigsetU</span> (<span class="nv">T</span> : topologicalType) (<span class="nv">I</span> : eqType) (<span class="nv">s</span> : seq I)
    (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> T) : (<span class="kr">forall</span> <span class="nv">x</span>, x \<span class="kr">in</span> s -&gt; closed (F x)) -&gt;
  closed (\big[setU/set0]_(x &lt;- s) F x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; scF; <span class="nb">rewrite</span> big_seq.
<span class="bp">by</span> <span class="nb">elim</span>/big_ind : _ =&gt; //; [<span class="bp">exact</span>: closed0|<span class="bp">exact</span>: closedU].
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">closure_lemmas</span>.
<span class="kn">Variable</span> <span class="nv">T</span> : topologicalType.
<span class="kn">Implicit Types</span> <span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">U</span> : <span class="nb">set</span> T.

<span class="kn">Lemma</span> <span class="nf">closure_subset</span> <span class="nv">A</span> <span class="nv">B</span> : A `&lt;=` B -&gt; closure A `&lt;=` closure B.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? CAx ?; <span class="nb">move</span>/CAx; <span class="bp">exact</span>/subsetI_neq0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closureE</span> <span class="nv">A</span> : closure A = smallest closed A.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; [x ? B [cB AB]|]; <span class="kp">first</span> <span class="bp">exact</span>/cB/(closure_subset AB).
<span class="bp">exact</span>: (smallest_sub (@closed_closure _ _) (@subset_closure _ _)).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closureC</span> <span class="nv">E</span> :
  ~` closure E = \bigcup_(x <span class="kr">in</span> [<span class="nb">set</span> U | open U /\ U `&lt;=` ~` E]) x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> closureE setC_bigcap eqEsubset; <span class="nb">split</span> =&gt; t [U [? EU Ut]].
  <span class="bp">by</span> <span class="kr">exists</span> (~` U) =&gt; //; <span class="nb">split</span>; [<span class="bp">exact</span>: closed_openC|<span class="bp">exact</span>: subsetC].
<span class="bp">by</span> <span class="nb">rewrite</span> -(setCK E); <span class="kr">exists</span> (~` U)=&gt; //; <span class="nb">split</span>; [<span class="bp">exact</span>:open_closedC|<span class="bp">exact</span>:subsetC].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closure_id</span> <span class="nv">E</span> : closed E &lt;-&gt; E = closure E.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [?|-&gt;]; <span class="nb">last</span> <span class="bp">exact</span>: closed_closure.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: subset_closure.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">closure_lemmas</span>.</span></pre><div class="doc">
<a id="lab16"></a><h2 class="section">Compact sets</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">Compact</span>.

<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType}.

<span class="kn">Definition</span> <span class="nf">cluster</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) := [<span class="nb">set</span> p : T | F `#` nbhs p].

<span class="kn">Lemma</span> <span class="nf">cluster_nbhs</span> <span class="nv">t</span> : cluster (nbhs t) t.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; A B /nbhs_singleton At /nbhs_singleton Bt; <span class="kr">exists</span> <span class="nv">t</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">clusterEonbhs</span> <span class="nv">F</span> : cluster F = [<span class="nb">set</span> p | F `#` open_nbhs p].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -meets_openr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">clusterE</span> <span class="nv">F</span> : cluster F = \bigcap_(A <span class="kr">in</span> F) (closure A).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; p; <span class="nb">split</span>=&gt; cF ????; <span class="nb">apply</span>: cF. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closureEcluster</span> <span class="nv">E</span> : closure E = cluster (globally E).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> closureEnbhs. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_cluster</span> <span class="nv">F</span> <span class="nv">G</span> : F --&gt; G -&gt; cluster F `&lt;=` cluster G.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; sGF p Fp P Q GP Qp; <span class="nb">apply</span>: Fp Qp; <span class="nb">apply</span>: sGF. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cluster_cvgE</span> <span class="nv">F</span> :
  Filter F -&gt;
  cluster F = [<span class="nb">set</span> p | <span class="kr">exists2</span> G, ProperFilter G &amp; G --&gt; p /\ F `&lt;=` G].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">have</span> [F0|nF0] := pselect (F set0).
  <span class="nb">have</span> -&gt; : cluster F = set0.
    <span class="bp">by</span> <span class="nb">rewrite</span> -subset0 clusterE =&gt; x /(_ set0 F0); <span class="nb">rewrite</span> closure0.
  <span class="bp">by</span> <span class="nb">apply</span>/esym; <span class="nb">rewrite</span> -subset0 =&gt; p [? PG [_ /(_ set0 F0)]]; <span class="nb">apply</span> PG.
<span class="nb">rewrite</span> predeqE =&gt; p; <span class="nb">have</span> PF : ProperFilter F <span class="bp">by</span> [].
<span class="nb">split</span>=&gt; [clFp|[G Gproper [cvGp sFG]] A B]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /sFG GA /cvGp GB; <span class="nb">apply</span>: (@filter_ex _ G); <span class="nb">apply</span>: filterI.
<span class="kr">exists</span> (<span class="nv">filter_from</span> (\bigcup_(A <span class="kr">in</span> F) [<span class="nb">set</span> A `&amp;` B | B <span class="kr">in</span> nbhs p]) id).
  <span class="nb">apply</span> filter_from_proper; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [A FA [B p_B &lt;-]]; <span class="nb">have</span> := clFp _ _ FA p_B.
  <span class="nb">apply</span>: filter_from_filter.
    <span class="kr">exists</span> <span class="nv">setT</span>; <span class="kr">exists</span> <span class="nv">setT</span>; <span class="kp">first</span> <span class="bp">exact</span>: filterT.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span>; [<span class="nb">apply</span>: filterT|<span class="nb">rewrite</span> setIT].
  <span class="nb">move</span>=&gt; _ _ [A1 FA1 [B1 p_B1 &lt;-]] [A2 FA2 [B2 p_B2 &lt;-]].
  <span class="kr">exists</span> (<span class="nv">A1</span> `&amp;` B1 `&amp;` (A2 `&amp;` B2)) =&gt; //; <span class="kr">exists</span> (<span class="nv">A1</span> `&amp;` A2).
    <span class="bp">exact</span>: filterI.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">B1</span> `&amp;` B2); [<span class="nb">apply</span>: filterI|<span class="nb">rewrite</span> setIACA].
<span class="nb">split</span>.
  <span class="nb">move</span>=&gt; A p_A; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="kr">exists</span> <span class="nv">setT</span>; <span class="kp">first</span> <span class="bp">exact</span>: filterT.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="nb">rewrite</span> setIC setIT.
<span class="nb">move</span>=&gt; A FA; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="kr">exists</span> <span class="nv">setT</span>; <span class="kp">first</span> <span class="bp">exact</span>: filterT.
<span class="bp">by</span> <span class="nb">rewrite</span> setIT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closureEcvg</span> (<span class="nv">E</span> : <span class="nb">set</span> T):
  closure E =
  [<span class="nb">set</span> p | <span class="kr">exists2</span> G, ProperFilter G &amp; G --&gt; p /\ globally E `&lt;=` G].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> closureEcluster cluster_cvgE. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">compact</span> <span class="nv">A</span> := <span class="kr">forall</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)),
  ProperFilter F -&gt; F A -&gt; A `&amp;` cluster F !=set0.

<span class="kn">Lemma</span> <span class="nf">compact0</span> : compact set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; F FF /filter_ex []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subclosed_compact</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T) :
  closed A -&gt; compact B -&gt; A `&lt;=` B -&gt; compact A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Acl Bco sAB F Fproper FA.
<span class="nb">have</span> [|p [Bp Fp]] := Bco F; <span class="kp">first</span> <span class="bp">exact</span>: filterS FA.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">p</span>; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: Acl=&gt; C Cp; <span class="nb">apply</span>: Fp.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">hausdorff_space</span> := <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : T, cluster (nbhs p) q -&gt; p = q.

<span class="kn">Typeclasses Opaque</span> within.
<span class="kn">Global Instance</span> <span class="nf">within_nbhs_proper</span> (<span class="nv">A</span> : <span class="nb">set</span> T) <span class="nv">p</span> :
  infer (closure A p) -&gt; ProperFilter (within A (nbhs p)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; clAp; <span class="nb">apply</span>: Build_ProperFilter =&gt; B.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /clAp [q [Aq AqsoBq]]; <span class="kr">exists</span> <span class="nv">q</span>; <span class="nb">apply</span>: AqsoBq.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">compact_closed</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : hausdorff_space -&gt; compact A -&gt; closed A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; hT Aco p clAp; <span class="nb">have</span> pA := !! @withinT _ (nbhs p) A _.
<span class="nb">have</span> [q [Aq clsAp_q]] := !! Aco _ _ pA; <span class="nb">rewrite</span> (hT p q) //.
<span class="bp">by</span> <span class="nb">apply</span>: cvg_cluster clsAp_q; <span class="nb">apply</span>: cvg_within.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">compact_set1</span> (<span class="nv">x</span> : T) : compact [<span class="nb">set</span> x].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F PF Fx; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> [].
<span class="nb">move</span>=&gt; P B nbhsB; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: nbhs_singleton.
<span class="nb">suff</span> [y [Py &lt;-//]] : P `&amp;` [<span class="nb">set</span> x] !=set0.
<span class="bp">by</span> <span class="nb">apply</span>: filter_ex; [<span class="bp">exact</span>: PF| <span class="bp">exact</span>: filterI].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Compact</span>.
<span class="kn">Arguments</span> hausdorff_space : <span class="kn">clear implicits</span>.

<span class="kn">Section</span> <span class="nf">near_covering</span>.
<span class="kn">Context</span> {<span class="nv">X</span> : topologicalType}.

<span class="kn">Definition</span> <span class="nf">near_covering</span> (<span class="nv">K</span> : <span class="nb">set</span> X) :=
  <span class="kr">forall</span> (<span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)) (<span class="nv">P</span> : I -&gt; X -&gt; <span class="kt">Prop</span>),
  Filter F -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, K x -&gt; \<span class="kr">forall</span> <span class="nv">x&#39;</span> \near x &amp; i \near F, P i x&#39;) -&gt;
  \near F, K `&lt;=` P F.

<span class="kn">Let</span> <span class="nf">near_covering_compact</span> : near_covering `&lt;=` compact.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; K locK F PF FK; <span class="nb">apply</span>/set0P/eqP=&gt; KclstF0; <span class="nb">case</span>: (PF) =&gt; + FF; <span class="nb">apply</span>.
<span class="nb">rewrite</span> (_ : xpredp0 = set0)// -(setICr K); <span class="nb">apply</span>: filterI =&gt; //.
<span class="nb">have</span> /locK : <span class="kr">forall</span> <span class="nv">x</span>, K x -&gt;
    \<span class="kr">forall</span> <span class="nv">x&#39;</span> \near x &amp; i \near powerset_filter_from F, (~` i) x&#39;.
  <span class="nb">move</span>=&gt; x Kx; <span class="nb">have</span> : ~ cluster F x.
    <span class="bp">by</span> <span class="nb">apply</span>: contraPnot KclstF0 =&gt; clstFx; <span class="nb">apply</span>/eqP/set0P; <span class="kr">exists</span> <span class="nv">x</span>.
  <span class="nb">move</span>=&gt; /existsNP [U /existsNP [V /not_implyP [FU /not_implyP [nbhsV]]]] UV0.
  near=&gt; x&#39; W =&gt; //= =&gt; Wx&#39;; <span class="nb">apply</span> UV0; <span class="kr">exists</span> <span class="nv">x&#39;</span>.
  <span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">exact</span>: (near (small_set_sub FU) W) | <span class="bp">exact</span>: (near nbhsV x&#39;)].
<span class="nb">case</span>=&gt; G [GF Gdown [U GU]] GP; <span class="nb">apply</span>: (@filterS _ _ _ U); <span class="nb">last</span> <span class="bp">exact</span>: GF.
<span class="bp">by</span> <span class="nb">move</span>=&gt; y Uy Ky; <span class="bp">exact</span>: (GP _ GU y Ky).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">compact_near_covering</span> : compact `&lt;=` near_covering.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; K cptK I F P FF cover.
<span class="nb">pose</span> badPoints := <span class="kr">fun</span> <span class="nv">U</span> =&gt; K `\` [<span class="nb">set</span> x | K x /\ U `&lt;=` P ^~ x].
<span class="nb">pose</span> G := filter_from F badPoints.
<span class="nb">have</span> FG : Filter G.
  <span class="nb">apply</span>: filter_from_filter; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span>; <span class="bp">exact</span>: filterT.
  <span class="nb">move</span>=&gt; L R FL FR; <span class="kr">exists</span> (<span class="nv">L</span> `&amp;` R); <span class="kp">first</span> <span class="bp">exact</span>: filterI.
  <span class="nb">rewrite</span> /badPoints /= !setDIr !setDv !set0U -setDUr; <span class="nb">apply</span>: setDS.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [|] =&gt; + ? [? ?]; <span class="bp">exact</span>.
<span class="nb">have</span> [[V FV]|G0] := pselect (G set0).
  <span class="nb">rewrite</span> subset0 setD_eq0 =&gt; subK.
  <span class="bp">by</span> <span class="nb">apply</span>: (@filterS _ _ _ V) =&gt; // ? ? ? /subK [?]; <span class="bp">exact</span>.
<span class="nb">have</span> PG : ProperFilter G <span class="bp">by</span> [].
<span class="nb">have</span> GK : G K <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span>; [<span class="bp">exact</span>: filterT | <span class="nb">move</span>=&gt; ? []].
<span class="nb">case</span>: (cptK _ PG GK) =&gt; x [Kx].
<span class="nb">have</span> [[/= U1 U2] [U1x FU2 subP]] := cover x Kx.
<span class="nb">have</span> GP : G (badPoints (P ^~ x `&amp;` U2)).
  <span class="nb">apply</span>: filterI =&gt; //; <span class="kr">exists</span> (<span class="nv">P</span> ^~ x `&amp;` U2); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [].
  near=&gt; i; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: (near FU2 i).
  <span class="bp">by</span> <span class="nb">apply</span>: (subP (x, i)); <span class="nb">split</span>; [<span class="bp">exact</span>: nbhs_singleton|<span class="bp">exact</span>: (near FU2 i)].
<span class="nb">move</span>=&gt; /(_ _ _ GP U1x) =&gt; [[x&#39;[]]][] Kx&#39; /[<span class="nb">swap</span>] U1x&#39;.
<span class="bp">by</span> <span class="nb">case</span>; <span class="nb">split</span> =&gt; // i [? ?]; <span class="bp">exact</span>: (subP (x&#39;, i)).
<span class="kn">Unshelve</span>. end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">compact_near_coveringP</span> : compact `&lt;=&gt;` near_covering.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">exact</span>: compact_near_covering| <span class="bp">exact</span>: near_covering_compact].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">near_covering</span>.

<span class="kn">Section</span> <span class="nf">Tychonoff</span>.

<span class="kn">Class</span> <span class="nf">UltraFilter</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) := {
  ultra_proper :&gt; ProperFilter F ;
  max_filter : <span class="kr">forall</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T), ProperFilter G -&gt; F `&lt;=` G -&gt; G = F
}.

<span class="kn">Lemma</span> <span class="nf">ultra_cvg_clusterE</span> (<span class="nv">T</span> : topologicalType) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  UltraFilter F -&gt; cluster F = [<span class="nb">set</span> p | F --&gt; p].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FU; <span class="nb">rewrite</span> predeqE =&gt; p; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> cluster_cvgE =&gt; - [G GF [cvGp /max_filter &lt;-]].
<span class="bp">by</span> <span class="nb">move</span>=&gt; cvFp; <span class="nb">rewrite</span> cluster_cvgE; <span class="kr">exists</span> <span class="nv">F</span>; [<span class="nb">apply</span>: ultra_proper|<span class="nb">split</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ultraFilterLemma</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  ProperFilter F -&gt; <span class="kr">exists</span> <span class="nv">G</span>, UltraFilter G /\ F `&lt;=` G.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF.
<span class="nb">set</span> filter_preordset := ({G : <span class="nb">set</span> (<span class="nb">set</span> T) &amp; ProperFilter G /\ F `&lt;=` G}).
<span class="nb">set</span> preorder := <span class="kr">fun</span> <span class="nv">G1</span> <span class="nv">G2</span> : filter_preordset =&gt; projT1 G1 `&lt;=` projT1 G2.
<span class="nb">suff</span> [G Gmax] : <span class="kr">exists</span> <span class="nv">G</span> : filter_preordset, premaximal preorder G.
  <span class="nb">have</span> [GF sFG] := projT2 G; <span class="kr">exists</span> (<span class="nv">projT1</span> <span class="nv">G</span>); <span class="nb">split</span>=&gt; //; <span class="nb">split</span>=&gt; // H HF sGH.
  <span class="nb">have</span> sFH : F `&lt;=` H <span class="bp">by</span> <span class="nb">apply</span>: subset_trans sGH.
  <span class="nb">have</span> sHG : preorder (existT _ H (conj HF sFH)) G <span class="bp">by</span> <span class="nb">apply</span>: Gmax.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">split</span>=&gt; [/sHG|/sGH].
<span class="nb">have</span> sFF : F `&lt;=` F <span class="bp">by</span> [].
<span class="nb">apply</span>: (ZL_preorder ((existT _ F (conj FF sFF)) : filter_preordset)) =&gt;
  [?|G H I sGH sHI ? /sGH /sHI|A Atot] //.
<span class="nb">case</span>: (pselect (A !=set0)) =&gt; [[G AG] | A0]; <span class="nb">last first</span>.
  <span class="kr">exists</span> (<span class="nv">existT</span> <span class="nv">_</span> <span class="nv">F</span> (conj FF sFF)) =&gt; G AG.
  <span class="bp">by</span> <span class="nb">have</span> /asboolP := A0; <span class="nb">rewrite</span> asbool_neg =&gt; /forallp_asboolPn /(_ G).
<span class="nb">have</span> [GF sFG] := projT2 G.
<span class="nb">suff</span> UAF : ProperFilter (\bigcup_(H <span class="kr">in</span> A) projT1 H).
  <span class="nb">have</span> sFUA : F `&lt;=` \bigcup_(H <span class="kr">in</span> A) projT1 H.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; B FB; <span class="kr">exists</span> <span class="nv">G</span> =&gt; //; <span class="nb">apply</span>: sFG.
  <span class="kr">exists</span> (<span class="nv">existT</span> <span class="nv">_</span> (\bigcup_(H <span class="kr">in</span> A) projT1 H) (conj UAF sFUA)) =&gt; H AH B HB /=.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">H</span>.
<span class="nb">apply</span> Build_ProperFilter.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; B [H AH HB]; <span class="nb">have</span> [HF _] := projT2 H; <span class="nb">apply</span>: (@filter_ex _ _ HF).
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">G</span> =&gt; //; <span class="nb">apply</span>: filterT.
  <span class="nb">move</span>=&gt; B C [HB AHB HBB] [HC AHC HCC]; <span class="nb">have</span> [sHBC|sHCB] := Atot _ _ AHB AHC.
    <span class="kr">exists</span> <span class="nv">HC</span> =&gt; //; <span class="nb">have</span> [HCF _] := projT2 HC; <span class="nb">apply</span>: filterI HCC.
    <span class="bp">exact</span>: sHBC.
  <span class="kr">exists</span> <span class="nv">HB</span> =&gt; //; <span class="nb">have</span> [HBF _] := projT2 HB; <span class="nb">apply</span>: filterI HBB _.
  <span class="bp">exact</span>: sHCB.
<span class="nb">move</span>=&gt; B C SBC [H AH HB]; <span class="kr">exists</span> <span class="nv">H</span> =&gt; //; <span class="nb">have</span> [HF _] := projT2 H.
<span class="bp">exact</span>: filterS HB.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">compact_ultra</span> (<span class="nv">T</span> : topologicalType) :
  compact = [<span class="nb">set</span> A | <span class="kr">forall</span> <span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T),
  UltraFilter F -&gt; F A -&gt; A `&amp;` [<span class="nb">set</span> p | F --&gt; p] !=set0].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>=&gt; Aco F FF FA.
  <span class="bp">by</span> <span class="nb">have</span> /Aco [p [?]] := FA; <span class="nb">rewrite</span> ultra_cvg_clusterE; <span class="kr">exists</span> <span class="nv">p</span>.
<span class="nb">have</span> [G [GU sFG]] := ultraFilterLemma FF.
<span class="nb">have</span> /Aco [p [Ap]] : G A <span class="bp">by</span> <span class="nb">apply</span>: sFG.
<span class="nb">rewrite</span> /= -[_ --&gt; p]/([<span class="nb">set</span> _ | _] p) -ultra_cvg_clusterE.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /(cvg_cluster sFG); <span class="kr">exists</span> <span class="nv">p</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_image</span> (<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  Filter F -&gt; f @` setT = setT -&gt; Filter [<span class="nb">set</span> f @` A | A <span class="kr">in</span> F].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF fsurj; <span class="nb">split</span>.
- <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span> =&gt; //; <span class="nb">apply</span>: filterT.
- <span class="nb">move</span>=&gt; _ _ [A FA &lt;-] [B FB &lt;-].
  <span class="kr">exists</span> (<span class="nv">f</span> @^-<span class="mi">1</span>` (f @` A `&amp;` f @` B)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> image_preimage.
  <span class="nb">have</span> sAB : A `&amp;` B `&lt;=` f @^-<span class="mi">1</span>` (f @` A `&amp;` f @` B).
    <span class="bp">by</span> <span class="nb">move</span>=&gt; x [Ax Bx]; <span class="nb">split</span>; <span class="kr">exists</span> <span class="nv">x</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: filterS sAB _; <span class="nb">apply</span>: filterI.
- <span class="nb">move</span>=&gt; A B sAB [C FC fC_eqA].
  <span class="kr">exists</span> (<span class="nv">f</span> @^-<span class="mi">1</span>` B); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> image_preimage.
  <span class="bp">by</span> <span class="nb">apply</span>: filterS FC =&gt; p Cp; <span class="nb">apply</span>: sAB; <span class="nb">rewrite</span> -fC_eqA; <span class="kr">exists</span> <span class="nv">p</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">proper_image</span> (<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  ProperFilter F -&gt; f @` setT = setT -&gt; ProperFilter [<span class="nb">set</span> f @` A | A <span class="kr">in</span> F].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF fsurj; <span class="nb">apply</span> Build_ProperFilter; <span class="nb">last</span> <span class="bp">exact</span>: filter_image.
<span class="bp">by</span> <span class="nb">move</span>=&gt; _ [A FA &lt;-]; <span class="nb">have</span> /filter_ex [p Ap] := FA; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">p</span>); <span class="kr">exists</span> <span class="nv">p</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">principal_filter_ultra</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : T) :
  UltraFilter (principal_filter x).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [|G [G0 xG] FG]; <span class="kp">first</span> <span class="bp">exact</span>: principal_filter_proper.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; // U GU; <span class="nb">apply</span>/principal_filterP.
<span class="nb">have</span> /(filterI GU): G [<span class="nb">set</span> x] <span class="bp">by</span> <span class="bp">exact</span>/FG/principal_filterP.
<span class="bp">by</span> <span class="nb">rewrite</span> setIC set1I; <span class="nb">case</span>: ifPn =&gt; // /[!inE].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">in_ultra_setVsetC</span> <span class="nv">T</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">A</span> : <span class="nb">set</span> T) :
  UltraFilter F -&gt; F A \/ F (~` A).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FU; <span class="nb">case</span>: (pselect (F (~` A))) =&gt; [|nFnA]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">right</span>.
<span class="nb">left</span>; <span class="nb">suff</span> : ProperFilter (filter_from (F `|` [<span class="nb">set</span> A `&amp;` B | B <span class="kr">in</span> F]) id).
  <span class="nb">move</span>=&gt; /max_filter &lt;-; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; B FB; <span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="nb">left</span>.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">setT</span>; [<span class="nb">apply</span>: filterT|<span class="nb">rewrite</span> setIT].
<span class="nb">apply</span> filter_from_proper; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; B [|[C FC &lt;-]]; <span class="kp">first</span> <span class="bp">exact</span>: filter_ex.
  <span class="nb">apply</span>: contrapT =&gt; /asboolP; <span class="nb">rewrite</span> asbool_neg =&gt; /forallp_asboolPn AC0.
  <span class="bp">by</span> <span class="nb">apply</span>: nFnA; <span class="nb">apply</span>: filterS FC =&gt; p Cp Ap; <span class="nb">apply</span>: (AC0 p).
<span class="nb">apply</span>: filter_from_filter.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span>; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">setT</span>; [<span class="nb">apply</span>: filterT|<span class="nb">rewrite</span> setIT].
<span class="nb">move</span>=&gt; B C [FB|[DB FDB &lt;-]].
  <span class="nb">move</span>=&gt; [FC|[DC FDC &lt;-]]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">B</span> `&amp;` C)=&gt; //; <span class="nb">left</span>; <span class="nb">apply</span>: filterI.
  <span class="kr">exists</span> (<span class="nv">A</span> `&amp;` (B `&amp;` DC)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> setICA.
  <span class="bp">by</span> <span class="nb">right</span>; <span class="kr">exists</span> (<span class="nv">B</span> `&amp;` DC) =&gt; //; <span class="nb">apply</span>: filterI.
<span class="nb">move</span>=&gt; [FC|[DC FDC &lt;-]].
  <span class="kr">exists</span> (<span class="nv">A</span> `&amp;` (DB `&amp;` C)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> setIA.
  <span class="bp">by</span> <span class="nb">right</span>; <span class="kr">exists</span> (<span class="nv">DB</span> `&amp;` C) =&gt; //; <span class="nb">apply</span>: filterI.
<span class="kr">exists</span> (<span class="nv">A</span> `&amp;` (DB `&amp;` DC)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="nb">rewrite</span> setIACA setIid.
<span class="bp">by</span> <span class="nb">right</span>; <span class="kr">exists</span> (<span class="nv">DB</span> `&amp;` DC) =&gt; //; <span class="nb">apply</span>: filterI.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ultra_image</span> (<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : T -&gt; U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :
  UltraFilter F -&gt; f @` setT = setT -&gt; UltraFilter [<span class="nb">set</span> f @` A | A <span class="kr">in</span> F].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FU fsurj; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: proper_image.
<span class="nb">move</span>=&gt; G GF sfFG; <span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: sfFG.
<span class="nb">move</span>=&gt; GA; <span class="kr">exists</span> (<span class="nv">f</span> @^-<span class="mi">1</span>` A); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> image_preimage.
<span class="nb">have</span> [//|FnAf] := in_ultra_setVsetC (f @^-<span class="mi">1</span>` A) FU.
<span class="nb">have</span> : G (f @` (~` (f @^-<span class="mi">1</span>` A))) <span class="bp">by</span> <span class="nb">apply</span>: sfFG; <span class="kr">exists</span> (~` (f @^-<span class="mi">1</span>` A)).
<span class="nb">suff</span> : ~ G (f @` (~` (f @^-<span class="mi">1</span>` A))) <span class="bp">by</span> [].
<span class="nb">rewrite</span> preimage_setC image_preimage // =&gt; GnA.
<span class="bp">by</span> <span class="nb">have</span> /filter_ex [? []] : G (A `&amp;` (~` A)) <span class="bp">by</span> <span class="nb">apply</span>: filterI.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">tychonoff</span> (<span class="nv">I</span> : eqType) (<span class="nv">T</span> : I -&gt; topologicalType)
  (<span class="nv">A</span> : <span class="kr">forall</span> <span class="nv">i</span>, <span class="nb">set</span> (T i)) :
  (<span class="kr">forall</span> <span class="nv">i</span>, compact (A i)) -&gt;
  @compact (product_topologicalType T)
    [<span class="nb">set</span> f : <span class="kr">forall</span> <span class="nv">i</span>, T i | <span class="kr">forall</span> <span class="nv">i</span>, A i (f i)].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Aco; <span class="nb">rewrite</span> compact_ultra =&gt; F FU FA.
<span class="nb">set</span> subst_coord := <span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">pi</span> : T i) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : I, T x) (<span class="nv">j</span> : I) =&gt;
  <span class="kr">if</span> eqP <span class="kr">is</span> ReflectT e <span class="kr">then</span> ecast i (T i) (esym e) pi <span class="kr">else</span> f j.
<span class="nb">have</span> subst_coordT i pi f : subst_coord i pi f i = pi.
  <span class="nb">rewrite</span> /subst_coord; <span class="nb">case</span> eqP =&gt; // e.
  <span class="bp">by</span> <span class="nb">rewrite</span> (eq_irrelevance e (erefl _)).
<span class="nb">have</span> subst_coordN i pi f j : i != j -&gt; subst_coord i pi f j = f j.
  <span class="nb">move</span>=&gt; inej; <span class="nb">rewrite</span> /subst_coord; <span class="nb">case</span>: eqP =&gt; // e.
  <span class="bp">by</span> <span class="nb">move</span>: inej; <span class="nb">rewrite</span> {<span class="mi">1</span>}e =&gt; /negP.
<span class="nb">have</span> pr_surj i : @^~ i @` [<span class="nb">set</span>: <span class="kr">forall</span> <span class="nv">i</span>, T i] = setT.
  <span class="nb">rewrite</span> predeqE =&gt; pi; <span class="nb">split</span>=&gt; // _.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">subst_coord</span> <span class="nv">i</span> <span class="nv">pi</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; point))=&gt; //; <span class="nb">rewrite</span> subst_coordT.
<span class="nb">set</span> pF := <span class="kr">fun</span> <span class="nv">i</span> =&gt; [<span class="nb">set</span> @^~ i @` B | B <span class="kr">in</span> F].
<span class="nb">have</span> pFultra : <span class="kr">forall</span> <span class="nv">i</span>, UltraFilter (pF i).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">apply</span>: ultra_image (pr_surj i).
<span class="nb">have</span> pFA : <span class="kr">forall</span> <span class="nv">i</span>, pF i (A i).
  <span class="nb">move</span>=&gt; i; <span class="kr">exists</span> [<span class="nb">set</span> g | <span class="kr">forall</span> <span class="nv">i</span>, A i (g i)] =&gt; //.
  <span class="nb">rewrite</span> predeqE =&gt; pi; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; [g Ag &lt;-]; <span class="nb">apply</span>: Ag.
  <span class="nb">move</span>=&gt; Aipi; <span class="nb">have</span> [f Af] := filter_ex FA.
  <span class="kr">exists</span> (<span class="nv">subst_coord</span> <span class="nv">i</span> <span class="nv">pi</span> <span class="nv">f</span>); <span class="nb">last</span> <span class="bp">exact</span>: subst_coordT.
  <span class="nb">move</span>=&gt; j; <span class="nb">case</span>: (eqVneq i j); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: _ /; <span class="nb">rewrite</span> subst_coordT.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /subst_coordN -&gt;; <span class="nb">apply</span>: Af.
<span class="nb">have</span> cvpFA i : A i `&amp;` [<span class="nb">set</span> p | pF i --&gt; p] !=set0.
  <span class="bp">by</span> <span class="nb">rewrite</span> -ultra_cvg_clusterE; <span class="nb">apply</span>: Aco.
<span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> =&gt; get (A i `&amp;` [<span class="nb">set</span> p | pF i --&gt; p])).
<span class="nb">split</span>=&gt; [i|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">have</span> /getPex [] := cvpFA i.
<span class="bp">by</span> <span class="nb">apply</span>/cvg_sup =&gt; i; <span class="nb">apply</span>/cvg_image=&gt; //; <span class="nb">have</span> /getPex [] := cvpFA i.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Tychonoff</span>.

<span class="kn">Section</span> <span class="nf">Precompact</span>.

<span class="kn">Context</span> {<span class="nv">X</span> : topologicalType}.

<span class="kn">Lemma</span> <span class="nf">compactU</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> X) : compact A -&gt; compact B -&gt; compact (A `|` B).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> compact_ultra =&gt; cptA cptB F UF FAB; <span class="nb">rewrite</span> setIUl.
<span class="nb">have</span> [/cptA[x AFx]|] := in_ultra_setVsetC A UF; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">left</span>.
<span class="nb">move</span>=&gt; /(filterI FAB); <span class="nb">rewrite</span> setIUl setICr set0U =&gt; FBA.
<span class="nb">have</span> /cptB[x BFx] : F B <span class="bp">by</span> <span class="nb">apply</span>: filterS FBA; <span class="bp">exact</span>: subIsetr.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">right</span>.
<span class="kn">Qed</span>.

<span class="c">(* The closed condition here is neccessary to make this definition work in a  *)</span>
<span class="c">(* non-hausdorff setting.                                                     *)</span>
<span class="kn">Definition</span> <span class="nf">compact_near</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> X)) :=
  <span class="kr">exists2</span> U, F U &amp; compact U /\ closed U.

<span class="kn">Definition</span> <span class="nf">precompact</span> (<span class="nv">C</span> : <span class="nb">set</span> X) := compact_near (globally C).

<span class="kn">Lemma</span> <span class="nf">precompactE</span> (<span class="nv">C</span> : <span class="nb">set</span> X) : precompact C = compact (closure C).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [[B CsubB [cptB cB]]|]; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; clC; <span class="kr">exists</span> (<span class="nv">closure</span> <span class="nv">C</span>) =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: subset_closure.
  <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: closed_closure.
<span class="nb">apply</span>: (subclosed_compact _ cptB); <span class="kp">first</span> <span class="bp">exact</span>: closed_closure.
<span class="bp">by</span> <span class="nb">move</span>/closure_id: cB =&gt; -&gt;; <span class="bp">exact</span>: closure_subset.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">precompact_subset</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> X) :
  A `&lt;=` B -&gt; precompact B -&gt; precompact A.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; AsubB [B&#39; B&#39;subB cptB&#39;]; <span class="kr">exists</span> <span class="nv">B&#39;</span> =&gt; // ? ?; <span class="bp">exact</span>/B&#39;subB/AsubB.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">compact_precompact</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> X) :
  hausdorff_space X -&gt; compact A -&gt; precompact A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; h c; <span class="nb">rewrite</span> precompactE ( _ : closure A = A)//.
<span class="nb">apply</span>/esym/closure_id; <span class="bp">exact</span>: compact_closed.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">precompact_closed</span> (<span class="nv">A</span> : <span class="nb">set</span> X) : closed A -&gt; precompact A = compact A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; clA; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [[B AsubB [ + _ ]]|].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /subclosed_compact; <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> {<span class="mi">1</span>}(_ : A = closure A) <span class="nl">?precompactE</span>// -closure_id.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">locally_compact</span> (<span class="nv">A</span> : <span class="nb">set</span> X) := [locally precompact A].

<span class="kn">End</span> <span class="nf">Precompact</span>.

<span class="kn">Section</span> <span class="nf">product_spaces</span>.
<span class="kn">Context</span> {<span class="nv">I</span> : eqType} {<span class="nv">K</span> : I -&gt; topologicalType}.

<span class="kn">Let</span> <span class="nf">PK</span> := product_topologicalType K.

<span class="c">(* Note we have to give the signature explicitly because there&#39;s no canonical *)</span>
<span class="c">(* topology associated with `K`. This should be cleaned up after HB port.     *)</span>

<span class="kn">Lemma</span> <span class="nf">proj_continuous</span> <span class="nv">i</span> : continuous (proj i : PK -&gt; K i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f; <span class="nb">have</span> /cvg_sup/(_ i)/cvg_image : f --&gt; f <span class="bp">by</span> <span class="nb">apply</span>: cvg_id.
<span class="nb">move</span>=&gt; h; <span class="nb">apply</span>: cvg_trans (h _) =&gt; {h}.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Q /= [W nbdW &lt;-]; <span class="nb">apply</span>: filterS nbdW; <span class="bp">exact</span>: preimage_image.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; y //; <span class="kr">exists</span> (<span class="nv">dfwith</span> (<span class="kr">fun</span>=&gt; point) i y) =&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> dfwithin.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dfwith_continuous</span> <span class="nv">g</span> (<span class="nv">i</span> : I) : continuous (dfwith g _ : K i -&gt; PK).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; z U [] P [] [] Q QfinP &lt;- [] V JV Vpz.
<span class="nb">move</span>/(@preimage_subset _ _ (dfwith g i))/filterS; <span class="nb">apply</span>.
<span class="nb">apply</span>: (@filterS _ _ _ ((dfwith g i) @^-<span class="mi">1</span>` V)); <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">V</span>.
<span class="nb">have</span> [L Lsub /[dup] VL &lt;-] := QfinP _ JV; <span class="nb">rewrite</span> preimage_bigcap.
<span class="nb">apply</span>: filter_bigI =&gt; /= M /[dup] LM /Lsub /set_mem [] w _ [+] + /[dup] + &lt;-.
<span class="nb">have</span> [-&gt;|wnx] := eqVneq w i =&gt; N oN NM.
  <span class="nb">apply</span> (@filterS _ _ _ N); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">rewrite</span> /= dfwithin.
  <span class="nb">apply</span>: open_nbhs_nbhs; <span class="nb">split</span> =&gt; //; <span class="nb">move</span>: Vpz.
  <span class="bp">by</span> <span class="nb">rewrite</span> -VL =&gt; /(_ _ LM); <span class="nb">rewrite</span> -NM /= dfwithin.
<span class="nb">apply</span>: nearW =&gt; y /=; <span class="nb">move</span>: Vpz.
<span class="bp">by</span> <span class="nb">rewrite</span> -VL =&gt; /(_ _ LM); <span class="nb">rewrite</span> -NM /= ? dfwithout // eq_sym.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">proj_open</span> <span class="nv">i</span> (<span class="nv">A</span> : <span class="nb">set</span> PK) : open A -&gt; open (proj i @` A).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; oA; <span class="nb">rewrite</span> openE =&gt; z [f Af &lt;-]; <span class="nb">rewrite</span> openE <span class="kr">in</span> oA.
<span class="nb">have</span> {oA} := oA _ Af; <span class="nb">rewrite</span> /interior =&gt; nAf.
<span class="nb">apply</span>: (@filterS _ _ _ ((dfwith f i) @^-<span class="mi">1</span>` A)).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; w Apw; <span class="kr">exists</span> (<span class="nv">dfwith</span> <span class="nv">f</span> <span class="nv">i</span> <span class="nv">w</span>) =&gt; //; <span class="nb">rewrite</span> projK.
<span class="nb">apply</span>: dfwith_continuous =&gt; /=; <span class="nb">move</span>: nAf; <span class="nb">congr</span> (nbhs _ A).
<span class="bp">by</span> <span class="nb">apply</span>: functional_extensionality_dep =&gt; ?; <span class="nb">case</span>: dfwithP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hausdorff_product</span> :
  (<span class="kr">forall</span> <span class="nv">x</span>, hausdorff_space (K x)) -&gt; hausdorff_space PK.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; hsdfK p q /= clstr; <span class="nb">apply</span>: functional_extensionality_dep =&gt; x.
<span class="nb">apply</span>: hsdfK; <span class="nb">move</span>: clstr; <span class="nb">rewrite</span> <span class="nl">?cluster_cvgE</span> /= =&gt; -[G PG [GtoQ psubG]].
<span class="kr">exists</span> (<span class="nv">proj</span> <span class="nv">x</span> @ G); [<span class="bp">exact</span>: fmap_proper_filter|<span class="nb">split</span>].
  <span class="nb">apply</span>: cvg_trans; <span class="nb">last</span> <span class="bp">exact</span>: (@proj_continuous x q).
  <span class="bp">by</span> <span class="nb">apply</span>: cvg_app; <span class="bp">exact</span>: GtoQ.
<span class="nb">move</span>/(cvg_app (proj x)): psubG =&gt; /cvg_trans; <span class="nb">apply</span>.
<span class="bp">exact</span>: proj_continuous.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">product_spaces</span>.

<span class="kn">Definition</span> <span class="nf">finI</span> (<span class="nv">I</span> : choiceType) <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :=
  <span class="kr">forall</span> <span class="nv">D&#39;</span> : {fset I}, {subset D&#39; &lt;= D} -&gt;
  \bigcap_(i <span class="kr">in</span> [<span class="nb">set</span> i | i \<span class="kr">in</span> D&#39;]) f i !=set0.

<span class="kn">Lemma</span> <span class="nf">finI_filter</span> (<span class="nv">I</span> : choiceType) <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :
  finI D f -&gt; ProperFilter (filter_from (finI_from D f) id).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; finIf; <span class="nb">apply</span>: (filter_from_proper (filter_from_filter _ _)).
- <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span>; <span class="kr">exists</span> <span class="nv">fset0</span> =&gt; //; <span class="nb">rewrite</span> predeqE.
- <span class="nb">move</span>=&gt; A B [DA sDA IfA] [DB sDB IfB]; <span class="kr">exists</span> (<span class="nv">A</span> `&amp;` B) =&gt; //.
  <span class="kr">exists</span> (<span class="nv">DA</span> `|` DB)%fset.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> inE =&gt; /orP [/sDA|/sDB].
  <span class="nb">rewrite</span> -IfA -IfB predeqE =&gt; p; <span class="nb">split</span>=&gt; [Ifp|[IfAp IfBp] i].
    <span class="bp">by</span> <span class="nb">split</span>=&gt; i Di; <span class="nb">apply</span>: Ifp; <span class="nb">rewrite</span> /= inE Di // orbC.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= inE =&gt; /orP []; [<span class="nb">apply</span>: IfAp|<span class="nb">apply</span>: IfBp].
- <span class="bp">by</span> <span class="nb">move</span>=&gt; _ [?? &lt;-]; <span class="nb">apply</span>: finIf.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_finI</span> (<span class="nv">T</span> : pointedType) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">D</span> : <span class="nb">set</span> (<span class="nb">set</span> T))
  (<span class="nv">f</span> : <span class="nb">set</span> T -&gt; <span class="nb">set</span> T) :
  ProperFilter F -&gt; (<span class="kr">forall</span> <span class="nv">A</span>, D A -&gt; F (f A)) -&gt; finI D f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF sDFf D&#39; sD; <span class="nb">apply</span>: (@filter_ex _ F); <span class="nb">apply</span>: filter_bigI.
<span class="bp">by</span> <span class="nb">move</span>=&gt; A /sD; <span class="nb">rewrite</span> inE =&gt; /sDFf.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">finite_subset_cover</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> I)
    <span class="nv">U</span> (<span class="nv">F</span> : I -&gt; <span class="nb">set</span> U) (<span class="nv">A</span> : <span class="nb">set</span> U) :=
  <span class="kr">exists2</span> D&#39; : {fset I}, {subset D&#39; &lt;= D} &amp; A `&lt;=` cover [<span class="nb">set</span>` D&#39;] F.

<span class="kn">Section</span> <span class="nf">Covers</span>.

<span class="kn">Variable</span> <span class="nv">T</span> : topologicalType.

<span class="kn">Definition</span> <span class="nf">cover_compact</span> (<span class="nv">A</span> : <span class="nb">set</span> T) :=
  <span class="kr">forall</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T),
  (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; open (f i)) -&gt; A `&lt;=` cover D f -&gt;
  finite_subset_cover D f A.

<span class="kn">Definition</span> <span class="nf">open_fam_of</span> (<span class="nv">A</span> : <span class="nb">set</span> T) <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :=
  <span class="kr">exists2</span> g : I -&gt; <span class="nb">set</span> T, (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; open (g i)) &amp;
    <span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; f i = A `&amp;` g i.

<span class="kn">Lemma</span> <span class="nf">cover_compactE</span> : cover_compact =
  [<span class="nb">set</span> A | <span class="kr">forall</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T),
    open_fam_of A D f -&gt;
      A `&lt;=` cover D f -&gt; finite_subset_cover D f A].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>=&gt; [Aco I D f [g gop feAg] fcov|Aco I D f fop fcov].
  <span class="nb">have</span> gcov : A `&lt;=` \bigcup_(i <span class="kr">in</span> D) g i.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; p /fcov [i Di]; <span class="nb">rewrite</span> feAg // =&gt; - []; <span class="kr">exists</span> <span class="nv">i</span>.
  <span class="nb">have</span> [D&#39; sD sgcov] := Aco _ _ _ gop gcov.
  <span class="kr">exists</span> <span class="nv">D&#39;</span> =&gt; // p Ap; <span class="nb">have</span> /sgcov [i D&#39;i gip] := Ap.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">rewrite</span> feAg //; <span class="nb">have</span> /sD := D&#39;i; <span class="nb">rewrite</span> inE.
<span class="nb">have</span> Afcov : A `&lt;=` \bigcup_(i <span class="kr">in</span> D) (A `&amp;` f i).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; p Ap; <span class="nb">have</span> /fcov [i ??] := Ap; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="nb">have</span> Afop : open_fam_of A D (<span class="kr">fun</span> <span class="nv">i</span> =&gt; A `&amp;` f i) <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">f</span>.
<span class="nb">have</span> [D&#39; sD sAfcov] := Aco _ _ _ Afop Afcov.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">D&#39;</span> =&gt; // p /sAfcov [i ? []]; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">closed_fam_of</span> (<span class="nv">A</span> : <span class="nb">set</span> T) <span class="nv">I</span> (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T) :=
  <span class="kr">exists2</span> g : I -&gt; <span class="nb">set</span> T, (<span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; closed (g i)) &amp;
    <span class="kr">forall</span> <span class="nv">i</span>, D i -&gt; f i = A `&amp;` g i.

<span class="kn">Lemma</span> <span class="nf">compact_In0</span> :
  compact = [<span class="nb">set</span> A | <span class="kr">forall</span> (<span class="nv">I</span> : choiceType) (<span class="nv">D</span> : <span class="nb">set</span> I) (<span class="nv">f</span> : I -&gt; <span class="nb">set</span> T),
    closed_fam_of A D f -&gt; finI D f -&gt; \bigcap_(i <span class="kr">in</span> D) f i !=set0].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>=&gt; [Aco I D f [g gcl feAg] finIf|Aco F FF FA].
  <span class="nb">case</span>: (pselect (<span class="kr">exists</span> <span class="nv">i</span>, D i)) =&gt; [[i Di] | /asboolP]; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> asbool_neg =&gt; /forallp_asboolPn D0; <span class="kr">exists</span> <span class="nv">point</span> =&gt; ? /D0.
  <span class="nb">have</span> [|p [Ap clfinIfp]] := Aco _ (finI_filter finIf).
    <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">i</span>); [<span class="nb">apply</span>: finI_from1|<span class="nb">rewrite</span> feAg // =&gt; ? []].
  <span class="kr">exists</span> <span class="nv">p</span> =&gt; j Dj; <span class="nb">rewrite</span> feAg //; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: gcl =&gt; // B.
  <span class="bp">by</span> <span class="nb">apply</span>: clfinIfp; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">j</span>); [<span class="nb">apply</span>: finI_from1|<span class="nb">rewrite</span> feAg // =&gt; ? []].
<span class="nb">have</span> finIAclF : finI F (<span class="kr">fun</span> <span class="nv">B</span> =&gt; A `&amp;` closure B).
  <span class="nb">apply</span>: (@filter_finI _ F) =&gt; B FB.
  <span class="bp">by</span> <span class="nb">apply</span>: filterI =&gt; //; <span class="nb">apply</span>: filterS FB; <span class="nb">apply</span>: subset_closure.
<span class="nb">have</span> [|p AclFIp] := Aco _ _ _ _ finIAclF.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">closure</span>=&gt; //; <span class="nb">move</span>=&gt; ??; <span class="nb">apply</span>: closed_closure.
<span class="kr">exists</span> <span class="nv">p</span>; <span class="nb">split</span>=&gt; [|B C FB p_C]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">have</span> /AclFIp [] := FA.
<span class="bp">by</span> <span class="nb">have</span> /AclFIp [_] := FB; <span class="nb">move</span>=&gt; /(_ _ p_C).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">compact_cover</span> : compact = cover_compact.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> compact_In0 cover_compactE predeqE =&gt; A.
<span class="nb">split</span>=&gt; [Aco I D f [g gop feAg] fcov|Aco I D f [g gcl feAg]].
  <span class="nb">case</span>: (pselect (<span class="kr">exists</span> <span class="nv">i</span>, D i)) =&gt; [[j Dj] | /asboolP]; <span class="nb">last first</span>.
    <span class="nb">rewrite</span> asbool_neg =&gt; /forallp_asboolPn D0.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">fset0</span> =&gt; // ? /fcov [? /D0].
  <span class="nb">apply</span>/exists2P; <span class="nb">apply</span>: contrapT.
  <span class="nb">move</span>=&gt; /asboolP; <span class="nb">rewrite</span> asbool_neg =&gt; /forallp_asboolPn sfncov.
  <span class="nb">suff</span> [p IAnfp] : \bigcap_(i <span class="kr">in</span> D) (A `\` f i) !=set0.
    <span class="bp">by</span> <span class="nb">have</span> /IAnfp [Ap _] := Dj; <span class="nb">have</span> /fcov [k /IAnfp [_]] := Ap.
  <span class="nb">apply</span>: Aco.
    <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> =&gt; ~` g i) =&gt; i Di; <span class="kp">first</span> <span class="bp">exact</span>/open_closedC/gop.
    <span class="nb">rewrite</span> predeqE =&gt; p; <span class="nb">split</span>=&gt; [[Ap nfip] | [Ap ngip]]; <span class="nb">split</span>=&gt; //.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; gip; <span class="nb">apply</span>: nfip; <span class="nb">rewrite</span> feAg.
    <span class="bp">by</span> <span class="nb">rewrite</span> feAg // =&gt; - [].
  <span class="nb">move</span>=&gt; D&#39; sD.
  <span class="nb">have</span> /asboolP : ~ A `&lt;=` cover [<span class="nb">set</span>` D&#39;] f <span class="bp">by</span> <span class="nb">move</span>=&gt; sAIf; <span class="bp">exact</span>: (sfncov D&#39;).
  <span class="nb">rewrite</span> asbool_neg =&gt; /existsp_asboolPn [p /asboolP].
  <span class="nb">rewrite</span> asbool_neg =&gt; /imply_asboolPn [Ap nUfp].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">p</span> =&gt; i D&#39;i; <span class="nb">split</span>=&gt; // fip; <span class="nb">apply</span>: nUfp; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="nb">case</span>: (pselect (<span class="kr">exists</span> <span class="nv">i</span>, D i)) =&gt; [[j Dj] | /asboolP]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> asbool_neg =&gt; /forallp_asboolPn D0 =&gt; _; <span class="kr">exists</span> <span class="nv">point</span> =&gt; ? /D0.
<span class="nb">apply</span>: contraPP =&gt; /asboolP; <span class="nb">rewrite</span> asbool_neg =&gt; /forallp_asboolPn If0.
<span class="nb">apply</span>/asboolP; <span class="nb">rewrite</span> asbool_neg; <span class="nb">apply</span>/existsp_asboolPn.
<span class="nb">have</span> Anfcov : A `&lt;=` \bigcup_(i <span class="kr">in</span> D) (A `\` f i).
  <span class="nb">move</span>=&gt; p Ap; <span class="nb">have</span> /asboolP := If0 p; <span class="nb">rewrite</span> asbool_neg =&gt; /existsp_asboolPn.
  <span class="nb">move</span>=&gt; [i /asboolP]; <span class="nb">rewrite</span> asbool_neg =&gt; /imply_asboolPn [Di nfip].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>.
<span class="nb">have</span> Anfop : open_fam_of A D (<span class="kr">fun</span> <span class="nv">i</span> =&gt; A `\` f i).
  <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> =&gt; ~` g i) =&gt; i Di; <span class="kp">first</span> <span class="bp">exact</span>/closed_openC/gcl.
  <span class="nb">rewrite</span> predeqE =&gt; p; <span class="nb">split</span>=&gt; [[Ap nfip] | [Ap ngip]]; <span class="nb">split</span>=&gt; //.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; gip; <span class="nb">apply</span>: nfip; <span class="nb">rewrite</span> feAg.
  <span class="bp">by</span> <span class="nb">rewrite</span> feAg // =&gt; - [].
<span class="nb">have</span> [D&#39; sD sAnfcov] := Aco _ _ _ Anfop Anfcov.
<span class="nb">wlog</span> [k D&#39;k] : D&#39; sD sAnfcov / <span class="kr">exists</span> <span class="nv">i</span>, i \<span class="kr">in</span> D&#39;.
  <span class="nb">move</span>=&gt; /(_ (D&#39; `|` [fset j])%fset); <span class="nb">apply</span>.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">rewrite</span> !inE =&gt; /orP [/sD|/eqP-&gt;] //; <span class="nb">rewrite</span> inE.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; p /sAnfcov [i D&#39;i Anfip]; <span class="kr">exists</span> <span class="nv">i</span> =&gt; //=; <span class="nb">rewrite</span> !inE D&#39;i.
  - <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">j</span>; <span class="nb">rewrite</span> !inE orbC eq_refl.
<span class="kr">exists</span> <span class="nv">D&#39;</span> =&gt; /(_ sD) [p Ifp].
<span class="nb">have</span> /Ifp := D&#39;k; <span class="nb">rewrite</span> feAg; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">have</span> /sD := D&#39;k; <span class="nb">rewrite</span> inE.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [/sAnfcov [i D&#39;i [_ nfip]] _]; <span class="nb">have</span> /Ifp := D&#39;i.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Covers</span>.

<span class="kn">Section</span> <span class="nf">separated_topologicalType</span>.
<span class="kn">Variable</span> (<span class="nv">T</span> : topologicalType).
<span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> : T.

<span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.

<span class="kn">Definition</span> <span class="nf">kolmogorov_space</span> := <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x != y -&gt;
  <span class="kr">exists</span> <span class="nv">A</span> : <span class="nb">set</span> T, (A \<span class="kr">in</span> nbhs x /\ y \<span class="kr">in</span> ~` A) \/ (A \<span class="kr">in</span> nbhs y /\ x \<span class="kr">in</span> ~` A).

<span class="kn">Definition</span> <span class="nf">accessible_space</span> := <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x != y -&gt;
  <span class="kr">exists</span> <span class="nv">A</span> : <span class="nb">set</span> T, open A /\ x \<span class="kr">in</span> A /\ y \<span class="kr">in</span> ~` A.

<span class="kn">Lemma</span> <span class="nf">accessible_closed_set1</span> : accessible_space -&gt; <span class="kr">forall</span> <span class="nv">x</span>, closed [<span class="nb">set</span> x].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; T1 x; <span class="nb">rewrite</span> -[X <span class="kr">in</span> closed X]setCK; <span class="nb">apply</span>: open_closedC.
<span class="nb">rewrite</span> openE =&gt; y /eqP /T1 [U [oU [yU xU]]].
<span class="nb">rewrite</span> /interior nbhsE /=; <span class="kr">exists</span> <span class="nv">U</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> subsetC1.
<span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="bp">exact</span>: set_mem.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">accessible_kolmogorov</span> : accessible_space -&gt; kolmogorov_space.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; T1 x y /T1 [A [oA [xA yA]]]; <span class="kr">exists</span> <span class="nv">A</span>; <span class="nb">left</span>; <span class="nb">split</span>=&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> nbhsE inE; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="nb">rewrite</span> inE <span class="kr">in</span> xA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">accessible_finite_set_closed</span> :
  accessible_space &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> T, finite_set A -&gt; closed A.
<span class="kn">Proof</span>.
<span class="nb">split</span> =&gt; [TT1 A fA|h x y xy].
  <span class="nb">rewrite</span> -(fsbig_setU_set1 fA) fsbig_finite//=.
  <span class="bp">by</span> <span class="nb">apply</span>: closed_bigsetU =&gt; x xA; <span class="bp">exact</span>: accessible_closed_set1.
<span class="kr">exists</span> (~` [<span class="nb">set</span> y]); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> openC; <span class="bp">exact</span>: h.
<span class="bp">by</span> <span class="nb">rewrite</span> !inE/=; <span class="nb">split</span>=&gt; [|/eqP]; [<span class="bp">exact</span>/eqP|<span class="nb">rewrite</span> eqxx].
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">close</span> <span class="nv">x</span> <span class="nv">y</span> : <span class="kt">Prop</span> := <span class="kr">forall</span> <span class="nv">M</span>, open_nbhs y M -&gt; closure M x.

<span class="kn">Lemma</span> <span class="nf">closeEnbhs</span> <span class="nv">x</span> : close x = cluster (nbhs x).
<span class="kn">Proof</span>.
<span class="nb">transitivity</span> (cluster (open_nbhs x)); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> /cluster; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -meets_openl.
<span class="nb">rewrite</span> clusterEonbhs /close funeqE =&gt; y /=; <span class="nb">rewrite</span> meetsC /meets.
<span class="nb">apply</span>/eq_forall =&gt; A; <span class="nb">rewrite</span> forall_swap.
<span class="bp">by</span> <span class="nb">rewrite</span> closureEonbhs/= meets_globallyl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closeEonbhs</span> <span class="nv">x</span> : close x = [<span class="nb">set</span> y | open_nbhs x `#` open_nbhs y].
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> closeEnbhs; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -meets_openl -meets_openr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">close_sym</span> <span class="nv">x</span> <span class="nv">y</span> : close x y -&gt; close y x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> !closeEnbhs /cluster/= meetsC. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_close</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} <span class="nv">x</span> <span class="nv">y</span> : F --&gt; x -&gt; F --&gt; y -&gt; close x y.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /sub_meets sx /sx; <span class="nb">rewrite</span> closeEnbhs; <span class="nb">apply</span>; <span class="nb">apply</span>/proper_meetsxx.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">close_refl</span> <span class="nv">x</span> : close x x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (@cvg_close (nbhs x)). <span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> close_refl : core.

<span class="kn">Lemma</span> <span class="nf">close_cvg</span> (<span class="nv">F1</span> <span class="nv">F2</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF2</span> : ProperFilter F2} :
  F1 --&gt; F2 -&gt; F2 --&gt; F1 -&gt; close (lim F1) (lim F2).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; F12 F21.
<span class="nb">have</span> [/(cvg_trans F21) F2l|dvgF1] := pselect (cvg F1).
  <span class="bp">by</span> <span class="nb">apply</span>: (@cvg_close F2) =&gt; //; <span class="nb">apply</span>: cvgP F2l.
<span class="nb">have</span> [/(cvg_trans F12)/cvgP//|dvgF2] := pselect (cvg F2).
<span class="nb">rewrite</span> dvgP // dvgP //; <span class="bp">exact</span>/close_refl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgx_close</span> <span class="nv">x</span> <span class="nv">y</span> : x --&gt; y -&gt; close x y.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvg_close. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgi_close</span> <span class="nv">T&#39;</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">f</span> : T&#39; -&gt; <span class="nb">set</span> T) (<span class="nv">l</span> <span class="nv">l&#39;</span> : T) :
  {near F, is_fun f} -&gt; f `@ F --&gt; l -&gt; f `@ F --&gt; l&#39; -&gt; close l l&#39;.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_prop fFl fFl&#39;.
<span class="nb">suff</span> f_totalfun: infer {near F, is_totalfun f} <span class="bp">by</span> <span class="bp">exact</span>: cvg_close fFl fFl&#39;.
<span class="nb">apply</span>: filter_app f_prop; near <span class="kp">do</span> <span class="nb">split</span>=&gt; //=.
<span class="nb">have</span>: (f `@ F) setT <span class="bp">by</span> <span class="nb">apply</span>: fFl; <span class="nb">apply</span>: filterT.
<span class="bp">by</span> <span class="nb">rewrite</span> fmapiE; <span class="nb">apply</span>: filterS =&gt; x [y []]; <span class="kr">exists</span> <span class="nv">y</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">cvg_toi_locally_close</span> := @cvgi_close.

<span class="kn">Lemma</span> <span class="nf">open_hausdorff</span> : hausdorff_space T =
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x != y -&gt;
    <span class="kr">exists2</span> AB, (x \<span class="kr">in</span> AB.<span class="mi">1</span> /\ y \<span class="kr">in</span> AB.<span class="mi">2</span>) &amp;
                [/\ open AB.<span class="mi">1</span>, open AB.<span class="mi">2</span> &amp; AB.<span class="mi">1</span> `&amp;` AB.<span class="mi">2</span> == set0].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [T_filterT2|T_openT2] x y.
  <span class="nb">have</span> := @contra_not _ _ (T_filterT2 x y); <span class="nb">rewrite</span> (rwP eqP) (rwP negP).  <span class="c">(* change @contra_not _ _ to contra_not when requiring MathComp &gt; 1.14 *)</span>
  <span class="nb">move</span>=&gt; /[<span class="nb">apply</span>] /asboolPn/existsp_asboolPn[A]; <span class="nb">rewrite</span> -existsNE =&gt; -[B].
  <span class="nb">rewrite</span> [nbhs _ _ -&gt; _](rwP imply_asboolP) =&gt; /negP.
  <span class="nb">rewrite</span> asbool_imply !negb_imply =&gt; /andP[/asboolP xA] /andP[/asboolP yB].
  <span class="nb">move</span>=&gt; /asboolPn; <span class="nb">rewrite</span> -set0P =&gt; /negP; <span class="nb">rewrite</span> negbK =&gt; /eqP AIB_eq0.
  <span class="nb">move</span>: xA yB; <span class="nb">rewrite</span> !nbhsE.
  <span class="nb">move</span>=&gt; - [oA [oA_open oAx] oAA] [oB [oB_open oBx] oBB].
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">oA</span>, oB); <span class="nb">rewrite</span> <span class="nl">?inE</span>; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: subsetI_eq0 AIB_eq0.
<span class="nb">apply</span>: contraPP =&gt; /eqP /T_openT2[[/=A B]].
<span class="nb">rewrite</span> !inE =&gt; - [xA yB] [Aopen Bopen /eqP AIB_eq0].
<span class="nb">move</span>=&gt; /(_ A B (open_nbhs_nbhs _) (open_nbhs_nbhs _)).
<span class="bp">by</span> <span class="nb">rewrite</span> -set0P =&gt; /(_ _ _)/negP; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">hausdorff_accessible</span> : hausdorff_space T -&gt; accessible_space.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> open_hausdorff =&gt; hsdfT =&gt; x y /hsdfT [[U V] [xU yV]] [/= ? ? /eqP].
<span class="nb">rewrite</span> setIC =&gt; /disjoints_subset VUc; <span class="kr">exists</span> <span class="nv">U</span>; <span class="kp">repeat</span> <span class="nb">split</span> =&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> inE; <span class="nb">apply</span>: VUc; <span class="nb">rewrite</span> -inE.
<span class="kn">Qed</span>.

<span class="kn">Hypothesis</span> <span class="nv">sep</span> : hausdorff_space T.

<span class="kn">Lemma</span> <span class="nf">closeE</span> <span class="nv">x</span> <span class="nv">y</span> : close x y = (x = y).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="bp">exact</span>: close_refl.
<span class="bp">by</span> <span class="nb">rewrite</span> closeEnbhs; <span class="bp">exact</span>: sep.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">close_eq</span> <span class="nv">x</span> <span class="nv">y</span> : close x y -&gt; x = y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> closeE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_unique</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} : is_subset1 [<span class="nb">set</span> x : T | F --&gt; x].
<span class="kn">Proof</span>. <span class="nb">move</span>=&gt; Fx Fy; <span class="nb">rewrite</span> -closeE //; <span class="bp">exact</span>: (@cvg_close F). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_eq</span> <span class="nv">x</span> <span class="nv">y</span> : x --&gt; y -&gt; x = y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -closeE //; <span class="nb">apply</span>: cvg_close. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_id</span> <span class="nv">x</span> : lim x = x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/esym/cvg_eq/cvg_ex; <span class="kr">exists</span> <span class="nv">x</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_lim</span> {<span class="nv">U</span> : <span class="kt">Type</span>} {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">f</span> : U -&gt; T) (<span class="nv">l</span> : T) :
  f @ F --&gt; l -&gt; lim (f @ F) = l.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /[dup] /cvgP /cvg_unique; <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_near_cst</span> {<span class="nv">U</span>} {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">l</span> : T) (<span class="nv">f</span> : U -&gt; T) :
   (\<span class="kr">forall</span> <span class="nv">x</span> \near F, f x = l) -&gt; lim (f @ F) = l.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvg_near_cst/cvg_lim. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_cst</span> {<span class="nv">U</span>} {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">k</span> : T) :
   lim ((<span class="kr">fun</span> <span class="nv">_</span> : U =&gt; k) @ F) = k.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: cvg_lim; <span class="nb">apply</span>: cvg_cst. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgi_unique</span> {<span class="nv">U</span> : <span class="kt">Type</span>} {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">f</span> : U -&gt; <span class="nb">set</span> T) :
  {near F, is_fun f} -&gt; is_subset1 [<span class="nb">set</span> x : T | f `@ F --&gt; x].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ffun fx fy; <span class="nb">rewrite</span> -closeE //; <span class="bp">exact</span>: cvgi_close. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgi_lim</span> {<span class="nv">U</span>} {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">f</span> : U -&gt; T -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : T) :
  F (<span class="kr">fun</span> <span class="nv">x</span> : U =&gt; is_subset1 (f x)) -&gt;
  f `@ F --&gt; l -&gt; lim (f `@ F) = l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_prop fl; <span class="nb">apply</span>: get_unique =&gt; // l&#39; fl&#39;; <span class="bp">exact</span>: cvgi_unique _ fl&#39; fl.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">separated_topologicalType</span>.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `cvg_lim`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_map_lim</span> := cvg_lim.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `cvgi_lim`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgi_map_lim</span> := cvgi_lim.

<span class="kn">Section</span> <span class="nf">connected_sets</span>.
<span class="kn">Variable</span> <span class="nv">T</span> : topologicalType.
<span class="kn">Implicit Types</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="nb">set</span> T.

<span class="kn">Definition</span> <span class="nf">connected</span> <span class="nv">A</span> :=
  <span class="kr">forall</span> <span class="nv">B</span>, B !=set0 -&gt; (<span class="kr">exists2</span> C, open C &amp; B = A `&amp;` C) -&gt;
  (<span class="kr">exists2</span> C, closed C &amp; B = A `&amp;` C) -&gt; B = A.

<span class="kn">Lemma</span> <span class="nf">connected0</span> : connected (@set0 T).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? [? ?]; <span class="nb">rewrite</span> set0I. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">separated</span> <span class="nv">A</span> <span class="nv">B</span> :=
  (closure A) `&amp;` B = set0 /\ A `&amp;` (closure B) = set0.

<span class="kn">Lemma</span> <span class="nf">separatedC</span> <span class="nv">A</span> <span class="nv">B</span> : separated A B = separated B A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /separated andC setIC (setIC _ B). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">separated_disjoint</span> <span class="nv">A</span> <span class="nv">B</span> : separated A B -&gt; A `&amp;` B = set0.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; AB; <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; // -[Ax Bx].
<span class="bp">by</span> <span class="nb">move</span>: AB; <span class="nb">rewrite</span> /separated =&gt; -[&lt;- _]; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: subset_closure.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connectedPn</span> <span class="nv">A</span> : ~ connected A &lt;-&gt;
  <span class="kr">exists</span> <span class="nv">E</span> : bool -&gt; <span class="nb">set</span> T, [/\ <span class="kr">forall</span> <span class="nv">b</span>, E b !=set0,
    A = E false `|` E true &amp; separated (E false) (E true)].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -propeqE; <span class="nb">apply</span> notLR; <span class="nb">rewrite</span> propeqE.
<span class="nb">split</span>=&gt; [conE [E [E0 EU [E1 E2]]]|conE B B0 [C oC BAC] [D cD BAD]].
  <span class="nb">suff</span> : E true = A.
    <span class="nb">move</span>/esym/(congr1 (setD^~ (closure (E true)))); <span class="nb">rewrite</span> EU setDUl.
    <span class="nb">have</span> := @subset_closure _ (E true); <span class="nb">rewrite</span> -setD_eq0 =&gt; -&gt;; <span class="nb">rewrite</span> setU0.
    <span class="bp">by</span> <span class="nb">move</span>/setDidPl : E2 =&gt; -&gt;; <span class="bp">exact</span>/eqP/set0P.
  <span class="nb">apply</span>: (conE _ (E0 true)).
  - <span class="kr">exists</span> (~` (closure (E false))); <span class="kp">first</span> <span class="bp">exact</span>/closed_openC/closed_closure.
    <span class="nb">rewrite</span> EU setIUl.
    <span class="nb">have</span> /subsets_disjoint -&gt; := @subset_closure _ (E false); <span class="nb">rewrite</span> set0U.
    <span class="bp">by</span> <span class="nb">apply</span>/esym/setIidPl/disjoints_subset; <span class="nb">rewrite</span> setIC.
  - <span class="kr">exists</span> (<span class="nv">closure</span> (E true)); <span class="kp">first</span> <span class="bp">exact</span>: closed_closure.
    <span class="bp">by</span> <span class="nb">rewrite</span> EU setIUl E2 set0U; <span class="bp">exact</span>/esym/setIidPl/subset_closure.
<span class="nb">apply</span>: contrapT =&gt; AF; <span class="nb">apply</span>: conE.
<span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> =&gt; <span class="kr">if</span> i <span class="kr">is</span> false <span class="kr">then</span> A `\` C <span class="kr">else</span> A `&amp;` C); <span class="nb">split</span>.
- <span class="nb">case</span>=&gt; /=; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -BAC.
  <span class="nb">apply</span>/set0P/eqP =&gt; /disjoints_subset; <span class="nb">rewrite</span> setCK =&gt; EC.
  <span class="bp">by</span> <span class="nb">apply</span>: AF; <span class="nb">rewrite</span> BAC; <span class="bp">exact</span>/setIidPl.
- <span class="bp">by</span> <span class="nb">rewrite</span> setDE -setIUr setUCl setIT.
- <span class="nb">split</span>.
  + <span class="nb">rewrite</span> setIC; <span class="nb">apply</span>/disjoints_subset; <span class="nb">rewrite</span> closureC =&gt; x [? ?].
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">C</span> =&gt; //; <span class="nb">split</span>=&gt; //; <span class="nb">rewrite</span> setDE setCI setCK; <span class="nb">right</span>.
  + <span class="nb">apply</span>/disjoints_subset =&gt; y -[Ay Cy].
    <span class="nb">rewrite</span> -BAC BAD=&gt; /closureI[_]; <span class="nb">rewrite</span> -(proj1 (@closure_id _ _) cD)=&gt; Dy.
    <span class="bp">by</span> <span class="nb">have</span> : B y; [<span class="bp">by</span> <span class="nb">rewrite</span> BAD; <span class="nb">split</span>|<span class="nb">rewrite</span> BAC =&gt; -[]].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connectedP</span> <span class="nv">A</span> : connected A &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">E</span> : bool -&gt; <span class="nb">set</span> T, ~ [/\ <span class="kr">forall</span> <span class="nv">b</span>, E b !=set0,
    A = E false `|` E true &amp; separated (E false) (E true)].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -propeqE forallNE; <span class="nb">apply</span>: notRL; <span class="nb">rewrite</span> propeqE; <span class="bp">exact</span>: connectedPn.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_subset</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : separated A B -&gt; C `&lt;=` A `|` B -&gt;
  connected C -&gt; C `&lt;=` A \/ C `&lt;=` B.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; AB CAB; <span class="nb">have</span> -&gt; : C = (C `&amp;` A) `|` (C `&amp;` B).
  <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [Cx|[] [] //].
  <span class="bp">by</span> <span class="nb">have</span> [Ax|Bx] := CAB _ Cx; [<span class="nb">left</span>|<span class="nb">right</span>].
<span class="nb">move</span>/connectedP/(_ (<span class="kr">fun</span> <span class="nv">b</span> =&gt; <span class="kr">if</span> b <span class="kr">then</span> C `&amp;` B <span class="kr">else</span> C `&amp;` A)) =&gt; /not_and3P[]//.
  <span class="bp">by</span> <span class="nb">move</span>/existsNP =&gt; [b /set0P/negP/negPn]; <span class="nb">case</span>: b =&gt; /eqP -&gt;;
    <span class="nb">rewrite</span> !(setU0,set0U); [<span class="nb">left</span>|<span class="nb">right</span>]; <span class="nb">apply</span>: subIset; <span class="nb">right</span>.
<span class="nb">case</span>/not_andP =&gt; /eqP/set0P[x []].
- <span class="nb">move</span>=&gt; /closureI[cCx cAx] [Cx Bx]; <span class="nb">exfalso</span>.
  <span class="bp">by</span> <span class="nb">move</span>: AB; <span class="nb">rewrite</span> /separated =&gt; -[] + _; <span class="nb">apply</span>/eqP/set0P; <span class="kr">exists</span> <span class="nv">x</span>.
- <span class="nb">move</span>=&gt; [Cx Ax] /closureI[cCx cBx]; <span class="nb">exfalso</span>.
  <span class="bp">by</span> <span class="nb">move</span>: AB; <span class="nb">rewrite</span> /separated =&gt; -[] _; <span class="nb">apply</span>/eqP/set0P; <span class="kr">exists</span> <span class="nv">x</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected1</span> <span class="nv">x</span> : connected [<span class="nb">set</span> x].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; X [y +] [O Oopen XO] [C Cclosed XC]; <span class="nb">rewrite</span> XO.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [{y}-&gt; Ox]; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; y =&gt; [[-&gt;//]|-&gt;].
<span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> connected1 : core.

<span class="kn">Lemma</span> <span class="nf">bigcup_connected</span> <span class="nv">I</span> (<span class="nv">A</span> : I -&gt; <span class="nb">set</span> T) (<span class="nv">P</span> : I -&gt; <span class="kt">Prop</span>) :
  \bigcap_(i <span class="kr">in</span> P) (A i) !=set0 -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; connected (A i)) -&gt;
  connected (\bigcup_(i <span class="kr">in</span> P) (A i)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [c AIc] cA; <span class="nb">have</span> [[i Pi]|] := pselect (<span class="kr">exists</span> <span class="nv">i</span>, P i); <span class="nb">last first</span>.
  <span class="nb">move</span>/forallNP =&gt; P0.
  <span class="nb">rewrite</span> (_ : P = set0) <span class="nl">?bigcup_set0</span>; <span class="kp">first</span> <span class="bp">exact</span>: connected0.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: P0.
<span class="nb">apply</span>/connectedP =&gt; [E [E0 EU sE]].
<span class="nb">wlog</span> E0c : E E0 EU sE / E false c.
  <span class="nb">move</span>=&gt; G; <span class="nb">have</span> : (\bigcup_(i <span class="kr">in</span> P) A i) c <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="bp">exact</span>: AIc.
  <span class="nb">rewrite</span> EU =&gt; -[E0c|E1c]; <span class="kp">first</span> <span class="bp">exact</span>: G.
  <span class="bp">by</span> <span class="nb">apply</span>: (G (E \o negb)) =&gt; //;
    [<span class="nb">case</span> =&gt; /=|<span class="nb">rewrite</span> EU setUC|<span class="nb">rewrite</span> separatedC].
<span class="nb">move</span>: (E0 true) =&gt; /set0P/eqP; <span class="nb">apply</span>.
<span class="nb">have</span> [/eqP //|/set0P[d E1d]] := boolP (E true == set0).
<span class="nb">have</span> : \bigcup_(i <span class="kr">in</span> P) A i `&lt;=` E false.
  <span class="nb">suff</span> AE : <span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; A i `&lt;=` E false <span class="bp">by</span> <span class="nb">move</span>=&gt; x [j ? ?]; <span class="bp">exact</span>: (AE j).
  <span class="nb">move</span>=&gt; j Pj.
  <span class="nb">move</span>: (@connected_subset _ _ (A j) sE).
  <span class="nb">rewrite</span> -EU =&gt; /(_ (bigcup_sup _) (cA _ Pj)) [//| | AjE1]; <span class="kp">first</span> <span class="bp">exact</span>.
  <span class="nb">exfalso</span>; <span class="nb">have</span> E1c := AjE1 _ (AIc _ Pj).
  <span class="bp">by</span> <span class="nb">move</span>/separated_disjoint : sE; <span class="nb">apply</span>/eqP/set0P; <span class="kr">exists</span> <span class="nv">c</span>.
<span class="nb">rewrite</span> EU subUset =&gt; -[_] /(_ _ E1d) E0d; <span class="nb">exfalso</span>.
<span class="bp">by</span> <span class="nb">move</span>/separated_disjoint : sE; <span class="nb">apply</span>/eqP/set0P; <span class="kr">exists</span> <span class="nv">d</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connectedU</span> <span class="nv">A</span> <span class="nv">B</span> : A `&amp;` B !=set0 -&gt; connected A -&gt; connected B -&gt;
   connected (A `|` B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [x [Ax Bx]] Ac Bc; <span class="nb">rewrite</span> -bigcup2inE; <span class="nb">apply</span>: bigcup_connected.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span> =&gt; //= -[|[|[]]].
<span class="bp">by</span> <span class="nb">move</span>=&gt; [|[|[]]].
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">connected_component</span> (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T) :=
  \bigcup_(A <span class="kr">in</span> [<span class="nb">set</span> C : <span class="nb">set</span> T | [/\ C x, C `&lt;=` A &amp; connected C]]) A.

<span class="kn">Lemma</span> <span class="nf">component_connected</span> <span class="nv">A</span> <span class="nv">x</span> : connected (connected_component A x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: bigcup_connected; [<span class="kr">exists</span> <span class="nv">x</span> =&gt; C []|<span class="nb">move</span>=&gt; C []]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_component_sub</span> <span class="nv">A</span> <span class="nv">x</span> : connected_component A x `&lt;=` A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; y [B [_ + _]] =&gt; /[<span class="nb">apply</span>]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_component_id</span> <span class="nv">A</span> <span class="nv">x</span> :
  A x -&gt; connected A -&gt; connected_component A x = A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Ax Ac; <span class="nb">apply</span>/seteqP; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: connected_component_sub.
<span class="bp">by</span> <span class="nb">move</span>=&gt; y Ay; <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="nb">split</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_component_out</span> <span class="nv">A</span> <span class="nv">x</span> :
  ~ A x -&gt; connected_component A x = set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; NAx; <span class="nb">rewrite</span> -subset0 =&gt; y [B [/[<span class="nb">swap</span>]/[<span class="nb">apply</span>]]]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_component_max</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">x</span> : B x -&gt; B `&lt;=` A -&gt;
  connected B -&gt; B `&lt;=` connected_component A x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Bx BA Bc y By; <span class="kr">exists</span> <span class="nv">B</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_component_refl</span> <span class="nv">A</span> <span class="nv">x</span> : A x -&gt; connected_component A x x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Ax; <span class="kr">exists</span> [<span class="nb">set</span> x] =&gt; //; <span class="nb">split</span> =&gt; // _ -&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_component_cover</span> <span class="nv">A</span> :
  \bigcup_(A <span class="kr">in</span> connected_component A @` A) A = A.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/predeqP =&gt; x; <span class="nb">split</span>=&gt; [[B [y By &lt;- /connected_component_sub//]]|Ax].
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">connected_component</span> <span class="nv">A</span> <span class="nv">x</span>) =&gt; //; <span class="nb">apply</span>: connected_component_refl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_component_sym</span> <span class="nv">A</span> <span class="nv">x</span> <span class="nv">y</span> :
  connected_component A x y -&gt; connected_component A y x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; [B [*]]; <span class="kr">exists</span> <span class="nv">B</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_component_trans</span> <span class="nv">A</span> <span class="nv">y</span> <span class="nv">x</span> <span class="nv">z</span> :
    connected_component A x y -&gt; connected_component A y z -&gt;
  connected_component A x z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B [Bx BA Ac Ay]] [C [Cy CA Cc Cz]]; <span class="kr">exists</span> (<span class="nv">B</span> `|` C); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">right</span>.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">left</span> | <span class="nb">rewrite</span> subUset | <span class="nb">apply</span>: connectedU=&gt; //; <span class="kr">exists</span> <span class="nv">y</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">same_connected_component</span> <span class="nv">A</span> <span class="nv">x</span> <span class="nv">y</span> : connected_component A x y -&gt;
  connected_component A x = connected_component A y.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Axy; <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; z; <span class="nb">apply</span>: connected_component_trans =&gt; //.
<span class="bp">by</span> <span class="nb">apply</span>: connected_component_sym.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">connected_sets</span>.
<span class="kn">Arguments</span> connected {T}.
<span class="kn">Arguments</span> connected_component {T}.

<span class="kn">Section</span> <span class="nf">DiscreteTopology</span>.
<span class="kn">Section</span> <span class="nf">DiscreteMixin</span>.
<span class="kn">Context</span> {<span class="nv">X</span> : <span class="kt">Type</span>}.

<span class="kn">Lemma</span> <span class="nf">discrete_sing</span> (<span class="nv">p</span> : X) (<span class="nv">A</span> : <span class="nb">set</span> X) : principal_filter p A -&gt; A p.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /principal_filterP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">discrete_nbhs</span> (<span class="nv">p</span> : X) (<span class="nv">A</span> : <span class="nb">set</span> X) :
  principal_filter p A -&gt; principal_filter p (principal_filter^~ A).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>/principal_filterP. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">discrete_topological_mixin</span> :=
  topologyOfFilterMixin principal_filter_proper discrete_sing discrete_nbhs.

<span class="kn">End</span> <span class="nf">DiscreteMixin</span>.

<span class="kn">Definition</span> <span class="nf">discrete_space</span> (<span class="nv">X</span> : topologicalType) :=
  @nbhs X _ = @principal_filter X.

<span class="kn">Context</span> {<span class="nv">X</span> : topologicalType} {<span class="nv">dsc</span>: discrete_space X}.

<span class="kn">Lemma</span> <span class="nf">discrete_open</span> (<span class="nv">A</span> : <span class="nb">set</span> X) : open A.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> openE =&gt; ? ?; <span class="nb">rewrite</span> /interior dsc; <span class="bp">exact</span>/principal_filterP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">discrete_set1</span> (<span class="nv">x</span> : X) : nbhs x [<span class="nb">set</span> x].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span> open_nbhs_nbhs; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: discrete_open. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">discrete_closed</span> (<span class="nv">A</span> : <span class="nb">set</span> X) : closed A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -[A]setCK closedC; <span class="bp">exact</span>: discrete_open. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">discrete_cvg</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> X)) (<span class="nv">x</span> : X) :
  Filter F -&gt; F --&gt; x &lt;-&gt; F [<span class="nb">set</span> x].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /filter_of dsc nbhs_simpl; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Fx U /principal_filterP ?; <span class="nb">apply</span>: filterS Fx =&gt; ? -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">discrete_hausdorff</span> : hausdorff_space X.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; p q /(_ _ _ (discrete_set1 p) (discrete_set1 q))[x [] -&gt; -&gt;].
<span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">bool_discrete_topology</span> : topologicalType :=
  TopologicalType bool discrete_topological_mixin.

<span class="kn">Lemma</span> <span class="nf">discrete_bool</span> : discrete_space bool_discrete_topology.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bool_compact</span> : compact [<span class="nb">set</span>: bool].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> setT_bool; <span class="nb">apply</span>/compactU; <span class="bp">exact</span>: compact_set1. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">DiscreteTopology</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> discrete_bool : core.

<span class="kn">Section</span> <span class="nf">perfect_sets</span>.

<span class="kn">Implicit Types</span> (<span class="nv">T</span> : topologicalType).

<span class="kn">Definition</span> <span class="nf">perfect_set</span> {<span class="nv">T</span>} (<span class="nv">A</span> : <span class="nb">set</span> T) := closed A /\ limit_point A = A.

<span class="kn">Lemma</span> <span class="nf">perfectTP</span> {<span class="nv">T</span>} : perfect_set [<span class="nb">set</span>: T] &lt;-&gt; <span class="kr">forall</span> <span class="nv">x</span> : T, ~ open [<span class="nb">set</span> x].
<span class="kn">Proof</span>.
<span class="nb">split</span>.
  <span class="nb">case</span>=&gt; _; <span class="nb">rewrite</span> eqEsubset; <span class="nb">case</span>=&gt; _ + x Ox =&gt; /(_ x I [<span class="nb">set</span> x]).
  <span class="bp">by</span> <span class="nb">case</span>; [<span class="bp">by</span> <span class="nb">apply</span>: open_nbhs_nbhs; <span class="nb">split</span> |] =&gt; y [+ _] =&gt; /[<span class="nb">swap</span>] -&gt; /eqP.
<span class="nb">move</span>=&gt; NOx; <span class="nb">split</span>; [<span class="bp">exact</span>: closedT |]; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; x // _.
<span class="nb">move</span>=&gt; U; <span class="nb">rewrite</span> nbhsE; <span class="nb">case</span>=&gt; V [] oV Vx VU.
<span class="nb">have</span> Vnx: V != [<span class="nb">set</span> x] <span class="bp">by</span> <span class="nb">apply</span>/eqP =&gt; M; <span class="nb">apply</span>: (NOx x); <span class="nb">rewrite</span> -M.
<span class="nb">have</span> /existsNP [y /existsNP [Vy Ynx]] : ~ <span class="kr">forall</span> <span class="nv">y</span>, V y -&gt; y = x.
  <span class="nb">move</span>/negP: Vnx; <span class="nb">apply</span>: contra_not =&gt; Vxy; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eqEsubset.
  <span class="bp">by</span> <span class="nb">split</span> =&gt; // ? -&gt;.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">split</span> =&gt; //; [<span class="bp">exact</span>/eqP | <span class="bp">exact</span>: VU].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">perfect_prod</span> {<span class="nv">I</span> : <span class="kt">Type</span>} (<span class="nv">i</span> : I) (<span class="nv">K</span> : I -&gt; topologicalType) :
  perfect_set [<span class="nb">set</span>: K i] -&gt; perfect_set [<span class="nb">set</span>: product_topologicalType K].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /perfectTP KPo; <span class="nb">apply</span>/perfectTP =&gt; f oF; <span class="nb">apply</span>: (KPo (f i)).
<span class="nb">rewrite</span> (_ : [<span class="nb">set</span> f i] = proj i @` [<span class="nb">set</span> f]).
  <span class="bp">by</span> <span class="nb">apply</span>: (@proj_open (classicType_choiceType I) _ i); <span class="bp">exact</span>: oF.
<span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; ? //; [<span class="nb">move</span>=&gt; -&gt; /=; <span class="kr">exists</span> <span class="nv">f</span> | <span class="nb">case</span>=&gt; g -&gt;].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">perfect_diagonal</span> (<span class="nv">K</span> : nat_topologicalType -&gt; topologicalType) :
  (<span class="kr">forall</span> <span class="nv">i</span>, <span class="kr">exists</span> (<span class="nv">xy</span>: K i * K i), xy.<span class="mi">1</span> != xy.<span class="mi">2</span>) -&gt;
  perfect_set [<span class="nb">set</span>: product_topologicalType K].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; npts; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: closedT.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; f // _.
<span class="nb">pose</span> distincts (i : nat) := projT1 (sigW (npts i)).
<span class="nb">pose</span> derange (i : nat) (z : K i) :=
  <span class="kr">if</span> z == (distincts i).<span class="mi">1</span> <span class="kr">then</span> (distincts i).<span class="mi">2</span> <span class="kr">else</span> (distincts i).<span class="mi">1</span>.
<span class="nb">pose</span> g (N i : nat) := <span class="kr">if</span> (i &lt; N)%nat <span class="kr">then</span> f i <span class="kr">else</span> derange _ (f i).
<span class="nb">have</span> gcvg : g @ \oo --&gt; (f : product_topologicalType K).
  <span class="nb">apply</span>/(@cvg_sup (product_topologicalType K)) =&gt; N U [V] [][W] oW &lt;- WfN WU.
  <span class="bp">by</span> <span class="nb">apply</span>: (filterS WU); <span class="nb">rewrite</span> nbhs_simpl /g; <span class="kr">exists</span> <span class="nv">N</span>.+<span class="mi">1</span> =&gt; // i /= -&gt;.
<span class="nb">move</span>=&gt; A /gcvg; <span class="nb">rewrite</span> nbhs_simpl; <span class="nb">case</span>=&gt; N _ An.
<span class="kr">exists</span> (<span class="nv">g</span> <span class="nv">N</span>); <span class="nb">split</span> =&gt; //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: An; <span class="nb">rewrite</span> /= <span class="nl">?leqnn</span> //.
<span class="nb">apply</span>/eqP =&gt; M; <span class="nb">suff</span>: g N N != f N <span class="bp">by</span> <span class="nb">rewrite</span> M; <span class="nb">move</span>/eqP.
<span class="nb">rewrite</span> /g ltnn /derange eq_sym; <span class="nb">case</span>: (eqVneq (f N) (distincts N).<span class="mi">1</span>) =&gt; //.
<span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">have</span> := projT2 (sigW (npts N)). 
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">perfect_sets</span>.</span></pre><div class="doc">
<a id="lab17"></a><h1 class="section">Uniform spaces</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;A ^-1&quot;</span> := ([<span class="nb">set</span> xy | A (xy.<span class="mi">2</span>, xy.<span class="mi">1</span>)]) : classical_set_scope.

<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;&#39;to_set&#39; A x&quot;</span> := ([<span class="nb">set</span> y | A (x, y)])
  (<span class="kn">at level</span> <span class="mi">0</span>, A <span class="kn">at level</span> <span class="mi">0</span>) : classical_set_scope.

<span class="kn">Definition</span> <span class="nf">nbhs_</span> {<span class="nv">T</span> <span class="nv">T&#39;</span>} (<span class="nv">ent</span> : <span class="nb">set</span> (<span class="nb">set</span> (T * T&#39;))) (<span class="nv">x</span> : T) :=
  filter_from ent (<span class="kr">fun</span> <span class="nv">A</span> =&gt; to_set A x).

<span class="kn">Lemma</span> <span class="nf">nbhs_E</span> {<span class="nv">T</span> <span class="nv">T&#39;</span>} (<span class="nv">ent</span> : <span class="nb">set</span> (<span class="nb">set</span> (T * T&#39;))) <span class="nv">x</span> :
  nbhs_ ent x = filter_from ent (<span class="kr">fun</span> <span class="nv">A</span> =&gt; to_set A x).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Module</span> <span class="nf">Uniform</span>.

<span class="kn">Record</span> <span class="nf">mixin_of</span> (<span class="nv">M</span> : <span class="kt">Type</span>) (<span class="nv">nbhs</span> : M -&gt; <span class="nb">set</span> (<span class="nb">set</span> M)) := Mixin {
  entourage : (M * M -&gt; <span class="kt">Prop</span>) -&gt; <span class="kt">Prop</span> ;
  ax1 : Filter entourage ;
  ax2 : <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; [<span class="nb">set</span> xy | xy.<span class="mi">1</span> = xy.<span class="mi">2</span>] `&lt;=` A ;
  ax3 : <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; entourage (A^-<span class="mi">1</span>)%classic ;
  ax4 : <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; <span class="kr">exists2</span> B, entourage B &amp; B \; B `&lt;=` A ;
  ax5 : nbhs = nbhs_ entourage
}.

<span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">M</span> : <span class="kt">Type</span>) := <span class="kn">Class</span> {
  base : Topological.class_of M;
  mixin : mixin_of (Filtered.nbhs_op base)
}.

<span class="kn">Section</span> <span class="nf">ClassDef</span>.

<span class="kn">Structure</span> <span class="nf">type</span> := Pack { sort; _ : class_of sort }.
<span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type).
<span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of cT <span class="kr">in</span> c.

<span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack T c.
<span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.
<span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of xT).
<span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Topological.class_of.
<span class="kn">Local Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; mixin_of.

<span class="kn">Definition</span> <span class="nf">pack</span> <span class="nv">nbhs</span> (<span class="nv">m</span> : @mixin_of T nbhs) :=
  <span class="kr">fun</span> <span class="nv">bT</span> (<span class="nv">b</span> : Topological.class_of T) <span class="nv">of</span> <span class="nv">phant_id</span> (@Topological.class bT) <span class="nv">b</span> =&gt;
  <span class="kr">fun</span> <span class="nv">m&#39;</span>   <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">m</span> (<span class="nv">m&#39;</span> : @mixin_of T (Filtered.nbhs_op b)) =&gt;
  @Pack T (@<span class="kn">Class</span> <span class="nf">_</span> <span class="nv">b</span> <span class="nv">m&#39;</span>).

<span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">pointedType</span> := @Pointed.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">filteredType</span> := @Filtered.Pack cT cT xclass.
<span class="kn">Definition</span> <span class="nf">topologicalType</span> := @Topological.Pack cT xclass.

<span class="kn">End</span> <span class="nf">ClassDef</span>.

<span class="kn">Module</span> <span class="nf">Exports</span>.

<span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Topological.class_of.
<span class="kn">Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; mixin_of.
<span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.
<span class="kn">Canonical</span> <span class="nf">eqType</span>.
<span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.
<span class="kn">Canonical</span> <span class="nf">choiceType</span>.
<span class="kn">Coercion</span> <span class="nf">pointedType</span> : type &gt;-&gt; Pointed.type.
<span class="kn">Canonical</span> <span class="nf">pointedType</span>.
<span class="kn">Coercion</span> <span class="nf">filteredType</span> : type &gt;-&gt; Filtered.type.
<span class="kn">Canonical</span> <span class="nf">filteredType</span>.
<span class="kn">Coercion</span> <span class="nf">topologicalType</span> : type &gt;-&gt; Topological.type.
<span class="kn">Canonical</span> <span class="nf">topologicalType</span>.
<span class="kn">Notation</span> <span class="nf">uniformType</span> := type.
<span class="kn">Notation</span> <span class="nf">UniformType</span> T m := (@pack T _ m _ _ idfun _ idfun).
<span class="kn">Notation</span> <span class="nf">UniformMixin</span> := Mixin.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;uniformType&#39; &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> :=  (@clone T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;uniformType&#39;  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;uniformType&#39; &#39;of&#39; T ]&quot;</span> := (@clone T _ _ id)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;uniformType&#39;  &#39;of&#39;  T ]&quot;</span>) : form_scope.

<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">Uniform</span>.

<span class="kn">Export</span> Uniform.Exports.

<span class="kn">Section</span> <span class="nf">UniformTopology</span>.

<span class="kn">Program Definition</span> <span class="nf">topologyOfEntourageMixin</span> (<span class="nv">T</span> : <span class="kt">Type</span>)
  (<span class="nv">nbhs</span> : T -&gt; <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">m</span> : Uniform.mixin_of nbhs) :
  Topological.mixin_of nbhs := topologyOfFilterMixin _ _ _.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; T nbhsT m p.
<span class="nb">rewrite</span> (Uniform.ax5 m) nbhs_E; <span class="nb">apply</span> filter_from_proper; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; A entA; <span class="kr">exists</span> <span class="nv">p</span>; <span class="nb">apply</span>: Uniform.ax2 entA _ _.
<span class="nb">apply</span>: filter_from_filter.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span>; <span class="nb">apply</span>: @filterT (Uniform.ax1 m).
<span class="nb">move</span>=&gt; A B entA entB; <span class="kr">exists</span> (<span class="nv">A</span> `&amp;` B) =&gt; //.
<span class="bp">exact</span>: (@filterI _ _ (Uniform.ax1 m)).
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; T nbhsT m p A; <span class="nb">rewrite</span> (Uniform.ax5 m) nbhs_E  =&gt; - [B entB sBpA].
<span class="bp">by</span> <span class="nb">apply</span>: sBpA; <span class="nb">apply</span>: Uniform.ax2 entB _ _.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; T nbhsT m p A; <span class="nb">rewrite</span> (Uniform.ax5 m) nbhs_E =&gt; - [B entB sBpA].
<span class="nb">have</span> /Uniform.ax4 [C entC sC2B] := entB.
<span class="kr">exists</span> <span class="nv">C</span> =&gt; // q Cpq; <span class="nb">rewrite</span> nbhs_E; <span class="kr">exists</span> <span class="nv">C</span> =&gt; // r Cqr.
<span class="bp">by</span> <span class="nb">apply</span>/sBpA/sC2B; <span class="kr">exists</span> <span class="nv">q</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">UniformTopology</span>.

<span class="kn">Definition</span> <span class="nf">entourage</span> {<span class="nv">M</span> : uniformType} := Uniform.entourage (Uniform.class M).

<span class="kn">Lemma</span> <span class="nf">nbhs_entourageE</span> {<span class="nv">M</span> : uniformType} : nbhs_ (@entourage M) = nbhs.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: M=&gt; [?[?[]]]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourage_sym</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} <span class="nv">E</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) :
  E (x, y) &lt;-&gt; (E ^-<span class="mi">1</span>)%classic (y, x).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_from_entourageE</span> {<span class="nv">M</span> : uniformType} <span class="nv">x</span> :
  filter_from (@entourage M) (<span class="kr">fun</span> <span class="nv">A</span> =&gt; to_set A x) = nbhs x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -nbhs_entourageE. <span class="kn">Qed</span>.

<span class="kn">Module</span> <span class="nf">Export</span> NbhsEntourage.
<span class="kn">Definition</span> <span class="nf">nbhs_simpl</span> :=
  (nbhs_simpl,@filter_from_entourageE,@nbhs_entourageE).
<span class="kn">End</span> <span class="nf">NbhsEntourage</span>.

<span class="kn">Lemma</span> <span class="nf">nbhsP</span> {<span class="nv">M</span> : uniformType} (<span class="nv">x</span> : M) <span class="nv">P</span> :
  nbhs x P &lt;-&gt; nbhs_ entourage x P.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> nbhs_simpl. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">uniformType1</span>.
<span class="kn">Context</span> {<span class="nv">M</span> : uniformType}.

<span class="kn">Lemma</span> <span class="nf">entourage_refl</span> (<span class="nv">A</span> : <span class="nb">set</span> (M * M)) <span class="nv">x</span> :
  entourage A -&gt; A (x, x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; entA; <span class="nb">apply</span>: Uniform.ax2 entA _ _. <span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">entourage_filter</span> : ProperFilter (@entourage M).
<span class="kn">Proof</span>.
<span class="nb">apply</span> Build_ProperFilter; <span class="nb">last</span> <span class="bp">exact</span>: Uniform.ax1.
<span class="bp">by</span> <span class="nb">move</span>=&gt; A entA; <span class="kr">exists</span> (<span class="nv">point</span>, point); <span class="nb">apply</span>: entourage_refl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourageT</span> : entourage [<span class="nb">set</span>: M * M].
<span class="kn">Proof</span>. <span class="bp">exact</span>: filterT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourage_inv</span> (<span class="nv">A</span> : <span class="nb">set</span> (M * M)) : entourage A -&gt; entourage (A^-<span class="mi">1</span>)%classic.
<span class="kn">Proof</span>. <span class="bp">exact</span>: Uniform.ax3. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourage_split_ex</span> (<span class="nv">A</span> : <span class="nb">set</span> (M * M)) :
  entourage A -&gt; <span class="kr">exists2</span> B, entourage B &amp; B \; B `&lt;=` A.
<span class="kn">Proof</span>. <span class="bp">exact</span>: Uniform.ax4. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">split_ent</span> (<span class="nv">A</span> : <span class="nb">set</span> (M * M)) :=
  get (entourage `&amp;` [<span class="nb">set</span> B | B \; B `&lt;=` A]).

<span class="kn">Lemma</span> <span class="nf">split_entP</span> (<span class="nv">A</span> : <span class="nb">set</span> (M * M)) : entourage A -&gt;
  entourage (split_ent A) /\ split_ent A \; split_ent A `&lt;=` A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/entourage_split_ex/exists2P/getPex. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourage_split_ent</span> (<span class="nv">A</span> : <span class="nb">set</span> (M * M)) : entourage A -&gt;
  entourage (split_ent A).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /split_entP []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subset_split_ent</span> (<span class="nv">A</span> : <span class="nb">set</span> (M * M)) : entourage A -&gt;
  split_ent A \; split_ent A `&lt;=` A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /split_entP []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourage_split</span> (<span class="nv">z</span> <span class="nv">x</span> <span class="nv">y</span> : M) <span class="nv">A</span> : entourage A -&gt;
  split_ent A (x,z) -&gt; split_ent A (z,y) -&gt; A (x,y).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /subset_split_ent sA ??; <span class="nb">apply</span>: sA; <span class="kr">exists</span> <span class="nv">z</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_entourage</span> (<span class="nv">x</span> : M) <span class="nv">A</span> : entourage A -&gt; nbhs x (to_set A x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>/nbhsP; <span class="kr">exists</span> <span class="nv">A</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_entourageP</span> <span class="nv">F</span> (<span class="nv">FF</span> : Filter F) (<span class="nv">p</span> : M) :
  F --&gt; p &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; \<span class="kr">forall</span> <span class="nv">q</span> \near F, A (p, q).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -filter_fromP !nbhs_simpl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_entourage</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} (<span class="nv">y</span> : M) :
  F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, A (y,y&#39;).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/cvg_entourageP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_app_entourageP</span> <span class="nv">T</span> (<span class="nv">f</span> : T -&gt; M) <span class="nv">F</span> (<span class="nv">FF</span> : Filter F) <span class="nv">p</span> :
  f @ F --&gt; p &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, A (p, f t).
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvg_entourageP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourage_invI</span> (<span class="nv">E</span> : <span class="nb">set</span> (M * M)) :
  entourage E -&gt; entourage (E `&amp;` E^-<span class="mi">1</span>)%classic.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: filterI; <span class="nb">last</span> <span class="bp">exact</span>: entourage_inv. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">split_ent_subset</span> (<span class="nv">E</span> : <span class="nb">set</span> (M * M)) : entourage E -&gt; split_ent E `&lt;=` E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; entE; <span class="nb">case</span>=&gt; x y splitxy; <span class="nb">apply</span>: subset_split_ent =&gt; //; <span class="kr">exists</span> <span class="nv">y</span> =&gt; //.
<span class="bp">by</span> <span class="nb">apply</span>: entourage_refl; <span class="bp">exact</span>: entourage_split_ent.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">uniformType1</span>.

#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (entourage (split_ent _)) =&gt; <span class="bp">exact</span>: entourage_split_ent : core.
#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (entourage (get _)) =&gt; <span class="bp">exact</span>: entourage_split_ent : core.
#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (entourage (_^-<span class="mi">1</span>)%classic) =&gt; <span class="bp">exact</span>: entourage_inv : core.
<span class="kn">Arguments</span> entourage_split {M} z {x y A}.
#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (nbhs _ (to_set _ _)) =&gt; <span class="bp">exact</span>: nbhs_entourage : core.

<span class="kn">Lemma</span> <span class="nf">continuous_withinNx</span> {<span class="nv">U</span> <span class="nv">V</span> : uniformType} (<span class="nv">f</span> : U -&gt; V) <span class="nv">x</span> :
  {<span class="kr">for</span> x, continuous f} &lt;-&gt; f @ x^&#39; --&gt; f x.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; - cfx P /= fxP.
  <span class="nb">rewrite</span> /dnbhs !near_simpl near_withinE.
  <span class="bp">by</span> <span class="nb">rewrite</span> /dnbhs; <span class="nb">apply</span>: cvg_within; <span class="nb">apply</span>: cfx.
<span class="nb">rewrite</span> !nbhs_nearE !near_map !near_nbhs <span class="kr">in</span> fxP *; <span class="nb">have</span> /= := cfx P fxP.
<span class="nb">rewrite</span> !near_simpl near_withinE near_simpl =&gt; Pf; near=&gt; y.
<span class="bp">by</span> <span class="nb">have</span> [-&gt;|] := eqVneq y x; [<span class="bp">by</span> <span class="nb">apply</span>: nbhs_singleton|near: y].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="c">(* This property is primarily useful only for metrizability on uniform spaces *)</span>
<span class="kn">Definition</span> <span class="nf">countable_uniformity</span> (<span class="nv">T</span> : uniformType) :=
  <span class="kr">exists</span> <span class="nv">R</span> : <span class="nb">set</span> (<span class="nb">set</span> (T * T)), [/\
    countable R,
    R `&lt;=` entourage &amp;
    <span class="kr">forall</span> <span class="nv">P</span>, entourage P -&gt; <span class="kr">exists2</span> Q, R Q &amp; Q `&lt;=` P].

<span class="kn">Lemma</span> <span class="nf">countable_uniformityP</span> {<span class="nv">T</span> : uniformType} :
  countable_uniformity T &lt;-&gt; <span class="kr">exists2</span> f : nat -&gt; <span class="nb">set</span> (T * T),
    (<span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; <span class="kr">exists</span> <span class="nv">N</span>, f N `&lt;=` A) &amp;
    (<span class="kr">forall</span> <span class="nv">n</span>, entourage (f n)).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [[M []]|[f fsubE entf]].
  <span class="nb">move</span>=&gt; /pfcard_geP[-&gt; _ /(_ _ entourageT)[]//|/unsquash f eM Msub].
  <span class="kr">exists</span> <span class="nv">f</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">apply</span>: eM; <span class="bp">exact</span>: funS.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? /Msub [Q + ?] =&gt; /(@surj _ _ _ _ f)[n _ fQ]; <span class="kr">exists</span> <span class="nv">n</span>; <span class="nb">rewrite</span> fQ.
<span class="kr">exists</span> (<span class="nv">range</span> <span class="nv">f</span>); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: card_image_le.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; E [n _] &lt;-; <span class="bp">exact</span>: entf.
<span class="bp">by</span> <span class="nb">move</span>=&gt; E /fsubE [n fnA]; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">n</span>) =&gt; //; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">uniform_closeness</span>.

<span class="kn">Variable</span> (<span class="nv">U</span> : uniformType).

<span class="kn">Lemma</span> <span class="nf">open_nbhs_entourage</span> (<span class="nv">x</span> : U) (<span class="nv">A</span> : <span class="nb">set</span> (U * U)) :
  entourage A -&gt; open_nbhs x (to_set A x)^¬∞.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; entA; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: open_interior.
<span class="bp">by</span> <span class="nb">apply</span>: nbhs_singleton; <span class="nb">apply</span>: nbhs_interior; <span class="nb">apply</span>: nbhs_entourage.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourage_close</span> (<span class="nv">x</span> <span class="nv">y</span> : U) : close x y = <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; A (x, y).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [cxy A entA|cxy].
  <span class="nb">have</span> /entourage_split_ent entsA := entA; <span class="nb">rewrite</span> closeEnbhs <span class="kr">in</span> cxy.
  <span class="nb">have</span> yl := nbhs_entourage _ (entourage_inv entsA).
  <span class="nb">have</span> yr := nbhs_entourage _ entsA.
  <span class="nb">have</span> [z [zx zy]] := cxy _ _ (yr x) (yl y).
  <span class="bp">exact</span>: (entourage_split z).
<span class="nb">rewrite</span> closeEnbhs =&gt; A B /nbhsP[E1 entE1 sE1A] /nbhsP[E2 entE2 sE2B].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">split</span>;[<span class="nb">apply</span>: sE1A; <span class="nb">apply</span>: cxy|<span class="nb">apply</span>: sE2B; <span class="nb">apply</span>: entourage_refl].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">close_trans</span> (<span class="nv">y</span> <span class="nv">x</span> <span class="nv">z</span> : U) : close x y -&gt; close y z -&gt; close x z.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> !entourage_close =&gt; cxy cyz A entA.
<span class="bp">exact</span>: entourage_split (cxy _ _) (cyz _ _).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">close_cvgxx</span> (<span class="nv">x</span> <span class="nv">y</span> : U) : close x y -&gt; x --&gt; y.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> entourage_close =&gt; cxy P /= /nbhsP[A entA sAP].
<span class="nb">apply</span>/nbhsP; <span class="kr">exists</span> (<span class="nv">split_ent</span> <span class="nv">A</span>) =&gt; // z xz; <span class="nb">apply</span>: sAP.
<span class="nb">apply</span>: (entourage_split x) =&gt; //.
<span class="bp">by</span> <span class="nb">have</span> := cxy _ (entourage_inv (entourage_split_ent entA)).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_closeP</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)) (<span class="nv">l</span> : U) : ProperFilter F -&gt;
  F --&gt; l &lt;-&gt; ([cvg F <span class="kr">in</span> U] /\ close (lim F) l).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">split</span>=&gt; [Fl|[cvF]Cl].
  <span class="bp">by</span> <span class="nb">have</span> /cvgP := Fl; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: (@cvg_close _ F).
<span class="bp">by</span> <span class="nb">apply</span>: cvg_trans (close_cvgxx Cl).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">uniform_closeness</span>.

<span class="kn">Definition</span> <span class="nf">unif_continuous</span> (<span class="nv">U</span> <span class="nv">V</span> : uniformType) (<span class="nv">f</span> : U -&gt; V) :=
  (<span class="kr">fun</span> <span class="nv">xy</span> =&gt; (f xy.<span class="mi">1</span>, f xy.<span class="mi">2</span>)) @ entourage --&gt; entourage.</span></pre><div class="doc">
product of two uniform spaces 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">prod_Uniform</span>.

<span class="kn">Context</span> {<span class="nv">U</span> <span class="nv">V</span> : uniformType}.
<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> ((U * V) * (U * V)).

<span class="kn">Definition</span> <span class="nf">prod_ent</span> :=
  [<span class="nb">set</span> A : <span class="nb">set</span> ((U * V) * (U * V)) |
    filter_prod (@entourage U) (@entourage V)
    [<span class="nb">set</span> ((xy.<span class="mi">1</span>.<span class="mi">1</span>,xy.<span class="mi">2</span>.<span class="mi">1</span>),(xy.<span class="mi">1</span>.<span class="mi">2</span>,xy.<span class="mi">2</span>.<span class="mi">2</span>)) | xy <span class="kr">in</span> A]].

<span class="kn">Lemma</span> <span class="nf">prod_entP</span> (<span class="nv">A</span> : <span class="nb">set</span> (U * U)) (<span class="nv">B</span> : <span class="nb">set</span> (V * V)) :
  entourage A -&gt; entourage B -&gt;
  prod_ent [<span class="nb">set</span> xy | A (xy.<span class="mi">1</span>.<span class="mi">1</span>, xy.<span class="mi">2</span>.<span class="mi">1</span>) /\ B (xy.<span class="mi">1</span>.<span class="mi">2</span>, xy.<span class="mi">2</span>.<span class="mi">2</span>)].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; entA entB; <span class="kr">exists</span> (<span class="nv">A</span>,B) =&gt; // xy ABxy.
<span class="bp">by</span> <span class="kr">exists</span> ((xy.<span class="mi">1</span>.<span class="mi">1</span>, xy.<span class="mi">2</span>.<span class="mi">1</span>),(xy.<span class="mi">1</span>.<span class="mi">2</span>,xy.<span class="mi">2</span>.<span class="mi">2</span>)); <span class="nb">rewrite</span> /= -!surjective_pairing.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_ent_filter</span> : Filter prod_ent.
<span class="kn">Proof</span>.
<span class="nb">have</span> prodF := filter_prod_filter (@entourage_filter U) (@entourage_filter V).
<span class="nb">split</span>; <span class="nb">rewrite</span> /prod_ent; <span class="nb">last</span> <span class="mi">1</span> <span class="kp">first</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; A B sAB /=; <span class="nb">apply</span>: filterS =&gt; ? [xy /sAB ??]; <span class="kr">exists</span> <span class="nv">xy</span>.
- <span class="nb">rewrite</span> -setMTT; <span class="nb">apply</span>: prod_entP filterT filterT.
<span class="nb">move</span>=&gt; A B /= entA entB; <span class="nb">apply</span>: filterS (filterI entA entB) =&gt; xy [].
<span class="nb">move</span>=&gt; [zt Azt ztexy] [zt&#39; Bzt&#39; zt&#39;exy]; <span class="kr">exists</span> <span class="nv">zt</span> =&gt; //; <span class="nb">split</span>=&gt; //.
<span class="nb">move</span>/eqP: ztexy; <span class="nb">rewrite</span> -zt&#39;exy !xpair_eqE.
<span class="bp">by</span> <span class="nb">rewrite</span> andbACA -!xpair_eqE -!surjective_pairing =&gt; /eqP-&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_ent_refl</span> <span class="nv">A</span> : prod_ent A -&gt; [<span class="nb">set</span> xy | xy.<span class="mi">1</span> = xy.<span class="mi">2</span>] `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B [entB1 entB2] sBA] xy /eqP.
<span class="nb">rewrite</span> [_.<span class="mi">1</span>]surjective_pairing [xy.<span class="mi">2</span>]surjective_pairing xpair_eqE.
<span class="nb">move</span>=&gt; /andP [/eqP xy1e /eqP xy2e].
<span class="nb">have</span> /sBA : (B.<span class="mi">1</span> `*` B.<span class="mi">2</span>) ((xy.<span class="mi">1</span>.<span class="mi">1</span>, xy.<span class="mi">2</span>.<span class="mi">1</span>), (xy.<span class="mi">1</span>.<span class="mi">2</span>, xy.<span class="mi">2</span>.<span class="mi">2</span>)).
  <span class="bp">by</span> <span class="nb">rewrite</span> xy1e xy2e; <span class="nb">split</span>=&gt; /=; <span class="nb">apply</span>: entourage_refl.
<span class="nb">move</span>=&gt; [zt Azt /eqP]; <span class="nb">rewrite</span> !xpair_eqE.
<span class="bp">by</span> <span class="nb">rewrite</span> andbACA -!xpair_eqE -!surjective_pairing =&gt; /eqP&lt;-.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_ent_inv</span> <span class="nv">A</span> : prod_ent A -&gt; prod_ent (A^-<span class="mi">1</span>)%classic.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B [/entourage_inv entB1 /entourage_inv entB2] sBA].
<span class="nb">have</span>:= prod_entP entB1 entB2; <span class="nb">rewrite</span> /prod_ent/=; <span class="nb">apply</span>: filterS.
<span class="nb">move</span>=&gt; _ [p /(sBA (_,_)) [[x y] ? xyE] &lt;-]; <span class="kr">exists</span> (<span class="nv">y</span>,x) =&gt; //; <span class="nb">move</span>/eqP: xyE.
<span class="bp">by</span> <span class="nb">rewrite</span> !xpair_eqE =&gt; /andP[/andP[/eqP-&gt; /eqP-&gt;] /andP[/eqP-&gt; /eqP-&gt;]].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_ent_split</span> <span class="nv">A</span> : prod_ent A -&gt; <span class="kr">exists2</span> B, prod_ent B &amp; B \; B `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B [entB1 entB2]] sBA; <span class="kr">exists</span> [<span class="nb">set</span> xy | split_ent B.<span class="mi">1</span> (xy.<span class="mi">1</span>.<span class="mi">1</span>,xy.<span class="mi">2</span>.<span class="mi">1</span>) /\
  split_ent B.<span class="mi">2</span> (xy.<span class="mi">1</span>.<span class="mi">2</span>,xy.<span class="mi">2</span>.<span class="mi">2</span>)].
  <span class="bp">by</span> <span class="nb">apply</span>: prod_entP; <span class="nb">apply</span>: entourage_split_ent.
<span class="nb">move</span>=&gt; xy [uv /= [hB1xyuv1 hB2xyuv1] [hB1xyuv2 hB2xyuv2]].
<span class="nb">have</span> /sBA : (B.<span class="mi">1</span> `*` B.<span class="mi">2</span>) ((xy.<span class="mi">1</span>.<span class="mi">1</span>, xy.<span class="mi">2</span>.<span class="mi">1</span>),(xy.<span class="mi">1</span>.<span class="mi">2</span>,xy.<span class="mi">2</span>.<span class="mi">2</span>)).
  <span class="bp">by</span> <span class="nb">split</span>=&gt; /=; <span class="nb">apply</span>: subset_split_ent =&gt; //; [<span class="kr">exists</span> <span class="nv">uv</span>.<span class="mi">1</span>|<span class="kr">exists</span> <span class="nv">uv</span>.<span class="mi">2</span>].
<span class="nb">move</span>=&gt; [zt Azt /eqP]; <span class="nb">rewrite</span> !xpair_eqE andbACA -!xpair_eqE.
<span class="bp">by</span> <span class="nb">rewrite</span> -!surjective_pairing =&gt; /eqP&lt;-.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_ent_nbhsE</span> : nbhs = nbhs_ prod_ent.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeq2E =&gt; xy A; <span class="nb">split</span>=&gt; [[B []] | [B [C [entC1 entC2] sCB] sBA]].
  <span class="nb">rewrite</span> -!nbhs_entourageE =&gt; - [C1 entC1 sCB1] [C2 entC2 sCB2] sBA.
  <span class="kr">exists</span> [<span class="nb">set</span> xy | C1 (xy.<span class="mi">1</span>.<span class="mi">1</span>, xy.<span class="mi">2</span>.<span class="mi">1</span>) /\ C2 (xy.<span class="mi">1</span>.<span class="mi">2</span>, xy.<span class="mi">2</span>.<span class="mi">2</span>)].
    <span class="bp">exact</span>: prod_entP.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; uv [/= /sCB1 Buv1 /sCB2 /(conj Buv1) /sBA].
<span class="kr">exists</span> (<span class="nv">to_set</span> (C.<span class="mi">1</span>) (xy.<span class="mi">1</span>), to_set (C.<span class="mi">2</span>) (xy.<span class="mi">2</span>)).
  <span class="bp">by</span> <span class="nb">rewrite</span> -!nbhs_entourageE; <span class="nb">split</span>; [<span class="kr">exists</span> <span class="nv">C</span>.<span class="mi">1</span>|<span class="kr">exists</span> <span class="nv">C</span>.<span class="mi">2</span>].
<span class="nb">move</span>=&gt; uv [/= Cxyuv1 Cxyuv2]; <span class="nb">apply</span>: sBA.
<span class="nb">have</span> /sCB : (C.<span class="mi">1</span> `*` C.<span class="mi">2</span>) ((xy.<span class="mi">1</span>,uv.<span class="mi">1</span>),(xy.<span class="mi">2</span>,uv.<span class="mi">2</span>)) <span class="bp">by</span> [].
<span class="nb">move</span>=&gt; [zt Bzt /eqP]; <span class="nb">rewrite</span> !xpair_eqE andbACA -!xpair_eqE.
<span class="bp">by</span> <span class="nb">rewrite</span> /= -!surjective_pairing =&gt; /eqP&lt;-.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">prod_uniformType_mixin</span> :=
  Uniform.Mixin prod_ent_filter prod_ent_refl prod_ent_inv prod_ent_split
  prod_ent_nbhsE.

<span class="kn">End</span> <span class="nf">prod_Uniform</span>.

<span class="kn">Canonical</span> <span class="nf">prod_uniformType</span> (U V : uniformType) :=
  UniformType (U * V) (@prod_uniformType_mixin U V).</span></pre><div class="doc">
matrices 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">matrix_Uniform</span>.

<span class="kn">Variables</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">T</span> : uniformType).

<span class="kn">Implicit Types</span> <span class="nv">A</span> : <span class="nb">set</span> (&#39;M[T]_(m, n) * &#39;M[T]_(m, n)).

<span class="kn">Definition</span> <span class="nf">mx_ent</span> :=
  filter_from
  [<span class="nb">set</span> P : &#39;I_m -&gt; &#39;I_n -&gt; <span class="nb">set</span> (T * T) | <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, entourage (P i j)]
  (<span class="kr">fun</span> <span class="nv">P</span> =&gt; [<span class="nb">set</span> MN : &#39;M[T]_(m, n) * &#39;M[T]_(m, n) |
    <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, P i j (MN.<span class="mi">1</span> i j, MN.<span class="mi">2</span> i j)]).

<span class="kn">Lemma</span> <span class="nf">mx_ent_filter</span> : Filter mx_ent.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: filter_from_filter =&gt; [|A B entA entB].
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; setT) =&gt; _ _; <span class="nb">apply</span>: filterT.
<span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; A i j `&amp;` B i j); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="nb">apply</span>: filterI.
<span class="bp">by</span> <span class="nb">move</span>=&gt; MN ABMN; <span class="nb">split</span>=&gt; i j; <span class="nb">have</span> [] := ABMN i j.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_ent_refl</span> <span class="nv">A</span> : mx_ent A -&gt; [<span class="nb">set</span> MN | MN.<span class="mi">1</span> = MN.<span class="mi">2</span>] `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B entB sBA] MN MN1e2; <span class="nb">apply</span>: sBA =&gt; i j.
<span class="bp">by</span> <span class="nb">rewrite</span> MN1e2; <span class="nb">apply</span>: entourage_refl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_ent_inv</span> <span class="nv">A</span> : mx_ent A -&gt; mx_ent (A^-<span class="mi">1</span>)%classic.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B entB sBA]; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; ((B i j)^-<span class="mi">1</span>)%classic).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i j; <span class="nb">apply</span>: entourage_inv.
<span class="bp">by</span> <span class="nb">move</span>=&gt; MN BMN; <span class="nb">apply</span>: sBA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_ent_split</span> <span class="nv">A</span> : mx_ent A -&gt; <span class="kr">exists2</span> B, mx_ent B &amp; B \; B `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B entB sBA].
<span class="nb">have</span> Bsplit : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, <span class="kr">exists</span> <span class="nv">C</span>, entourage C /\ C \; C `&lt;=` B i j.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="nb">apply</span>/exists2P/entourage_split_ex.
<span class="kr">exists</span> [<span class="nb">set</span> MN : &#39;M[T]_(m, n) * &#39;M[T]_(m, n) |
  <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, get [<span class="nb">set</span> C | entourage C /\ C \; C `&lt;=` B i j]
  (MN.<span class="mi">1</span> i j, MN.<span class="mi">2</span> i j)].
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; get [<span class="nb">set</span> C | entourage C /\ C \; C `&lt;=` B i j]).
<span class="nb">move</span>=&gt; MN [P CMN1P CPMN2]; <span class="nb">apply</span>/sBA =&gt; i j.
<span class="nb">have</span> /getPex [_] := Bsplit i j; <span class="nb">apply</span>; <span class="kr">exists</span> (<span class="nv">P</span> <span class="nv">i</span> <span class="nv">j</span>); <span class="kp">first</span> <span class="bp">exact</span>: CMN1P.
<span class="bp">exact</span>: CPMN2.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_ent_nbhsE</span> : nbhs = nbhs_ mx_ent.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeq2E =&gt; M A; <span class="nb">split</span>.
  <span class="nb">move</span>=&gt; [B]; <span class="nb">rewrite</span> -nbhs_entourageE =&gt; M_B sBA.
  <span class="nb">set</span> sB := <span class="kr">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; [<span class="nb">set</span> C | entourage C /\ to_set C (M i j) `&lt;=` B i j].
  <span class="nb">have</span> {}M_B : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, sB i j !=set0 <span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="nb">apply</span>/exists2P/M_B.
  <span class="kr">exists</span> [<span class="nb">set</span> MN : &#39;M[T]_(m, n) * &#39;M[T]_(m, n) | <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>,
    get (sB i j) (MN.<span class="mi">1</span> i j, MN.<span class="mi">2</span> i j)].
    <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; get (sB i j)) =&gt; // i j; <span class="nb">have</span> /getPex [] := M_B i j.
  <span class="nb">move</span>=&gt; N CMN; <span class="nb">apply</span>/sBA =&gt; i j; <span class="nb">have</span> /getPex [_] := M_B i j; <span class="nb">apply</span>.
  <span class="bp">exact</span>/CMN.
<span class="nb">move</span>=&gt; [B [C entC sCB] sBA]; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; to_set (C i j) (M i j)).
  <span class="bp">by</span> <span class="nb">rewrite</span> -nbhs_entourageE =&gt; i j; <span class="kr">exists</span> (<span class="nv">C</span> <span class="nv">i</span> <span class="nv">j</span>).
<span class="bp">by</span> <span class="nb">move</span>=&gt; N CMN; <span class="nb">apply</span>/sBA/sCB.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">matrix_uniformType_mixin</span> :=
  Uniform.Mixin mx_ent_filter mx_ent_refl mx_ent_inv mx_ent_split
  mx_ent_nbhsE.

<span class="kn">Canonical</span> <span class="nf">matrix_uniformType</span> :=
  UniformType &#39;M[T]_(m, n) matrix_uniformType_mixin.

<span class="kn">End</span> <span class="nf">matrix_Uniform</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_mx_entourageP</span> (<span class="nv">T</span> : uniformType) <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> &#39;M[T]_(m,n)))
  (<span class="nv">FF</span> : Filter F) (<span class="nv">M</span> : &#39;M[T]_(m,n)) :
  F --&gt; M &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; \<span class="kr">forall</span> <span class="nv">N</span> \near F,
  <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, A (M i j, (N : &#39;M[T]_(m,n)) i j).
<span class="kn">Proof</span>.
<span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> filter_fromP =&gt; FM A ?; <span class="nb">apply</span>: (FM (<span class="kr">fun</span> <span class="nv">i</span> <span class="nv">j</span> =&gt; to_set A (M i j))).
<span class="nb">move</span>=&gt; FM; <span class="nb">apply</span>/cvg_entourageP =&gt; A [P entP sPA]; near=&gt; N.
<span class="nb">apply</span>: sPA =&gt; /=; near: N; <span class="nb">set</span> Q := \bigcap_ij P ij.<span class="mi">1</span> ij.<span class="mi">2</span>.
<span class="nb">apply</span>: filterS (FM Q _); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; N QN i j; <span class="nb">apply</span>: (QN _ _ (i, j)).
<span class="nb">have</span> -&gt; : Q =
  \bigcap_(ij <span class="kr">in</span> [<span class="nb">set</span> k | k \<span class="kr">in</span> [fset x <span class="kr">in</span> predT]%fset]) P ij.<span class="mi">1</span> ij.<span class="mi">2</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>=&gt; Qt ij _; <span class="nb">apply</span>: Qt =&gt; //=; <span class="nb">rewrite</span> !inE.
<span class="bp">by</span> <span class="nb">apply</span>: filter_bigI =&gt; ??; <span class="nb">apply</span>: entP.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.</span></pre><div class="doc">
Functional metric spaces 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">fct_Uniform</span>.

<span class="kn">Variable</span> (<span class="nv">T</span> : choiceType) (<span class="nv">U</span> : uniformType).

<span class="kn">Definition</span> <span class="nf">fct_ent</span> :=
  filter_from
  (@entourage U)
  (<span class="kr">fun</span> <span class="nv">P</span> =&gt; [<span class="nb">set</span> fg | <span class="kr">forall</span> <span class="nv">t</span> : T, P (fg.<span class="mi">1</span> t, fg.<span class="mi">2</span> t)]).

<span class="kn">Lemma</span> <span class="nf">fct_ent_filter</span> : Filter fct_ent.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: filter_from_filter; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span>; <span class="nb">apply</span>: filterT.
<span class="nb">move</span>=&gt; A B entA entB.
<span class="kr">exists</span> (<span class="nv">A</span> `&amp;` B); <span class="kp">first</span> <span class="bp">exact</span>: filterI.
<span class="bp">by</span> <span class="nb">move</span>=&gt; fg ABfg; <span class="nb">split</span>=&gt; t; <span class="nb">have</span> [] := ABfg t.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fct_ent_refl</span> <span class="nv">A</span> : fct_ent A -&gt; [<span class="nb">set</span> fg | fg.<span class="mi">1</span> = fg.<span class="mi">2</span>] `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B entB sBA] fg feg; <span class="nb">apply</span>/sBA =&gt; t; <span class="nb">rewrite</span> feg.
<span class="bp">exact</span>: entourage_refl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fct_ent_inv</span> <span class="nv">A</span> : fct_ent A -&gt; fct_ent (A^-<span class="mi">1</span>)%classic.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B entB sBA]; <span class="kr">exists</span> (<span class="nv">B</span>^-<span class="mi">1</span>)%classic; <span class="kp">first</span> <span class="bp">exact</span>: entourage_inv.
<span class="bp">by</span> <span class="nb">move</span>=&gt; fg Bgf; <span class="nb">apply</span>/sBA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fct_ent_split</span> <span class="nv">A</span> : fct_ent A -&gt; <span class="kr">exists2</span> B, fct_ent B &amp; B \; B `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B entB sBA].
<span class="c">(* have Bsplit : exists C, entourage C /\ C \o C `&lt;=` B. *)</span>
<span class="c">(*   exact/exists2P/entourage_split_ex. *)</span>
<span class="kr">exists</span> [<span class="nb">set</span> fg | <span class="kr">forall</span> <span class="nv">t</span>, split_ent B (fg.<span class="mi">1</span> t, fg.<span class="mi">2</span> t)].
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">split_ent</span> <span class="nv">B</span>).
<span class="nb">move</span>=&gt; fg [h spBfh spBhg].
<span class="bp">by</span> <span class="nb">apply</span>: sBA =&gt; t; <span class="nb">apply</span>: entourage_split (spBfh t) (spBhg t).
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">fct_uniformType_mixin</span> :=
  UniformMixin fct_ent_filter fct_ent_refl fct_ent_inv fct_ent_split erefl.

<span class="kn">Definition</span> <span class="nf">fct_topologicalTypeMixin</span> :=
  topologyOfEntourageMixin fct_uniformType_mixin.

<span class="kn">Canonical</span> <span class="nf">generic_source_filter</span> := @Filtered.Source _ _ _ (nbhs_ fct_ent).
<span class="kn">Canonical</span> <span class="nf">fct_topologicalType</span> :=
  TopologicalType (T -&gt; U) fct_topologicalTypeMixin.
<span class="kn">Canonical</span> <span class="nf">fct_uniformType</span> := UniformType (T -&gt; U) fct_uniformType_mixin.

<span class="kn">End</span> <span class="nf">fct_Uniform</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_fct_entourageP</span> (<span class="nv">T</span> : choiceType) (<span class="nv">U</span> : uniformType)
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (T -&gt; U))) (<span class="nv">FF</span> : Filter F) (<span class="nv">f</span> : T -&gt; U) :
  F --&gt; f &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt;
  \<span class="kr">forall</span> <span class="nv">g</span> \near F, <span class="kr">forall</span> <span class="nv">t</span>, A (f t, g t).
<span class="kn">Proof</span>.
<span class="nb">split</span>.
  <span class="nb">move</span>=&gt; /cvg_entourageP Ff A entA.
  <span class="bp">by</span> <span class="nb">apply</span>: (Ff [<span class="nb">set</span> fg | <span class="kr">forall</span> <span class="nv">t</span> : T, A (fg.<span class="mi">1</span> t, fg.<span class="mi">2</span> t)]); <span class="kr">exists</span> <span class="nv">A</span>.
<span class="nb">move</span>=&gt; Ff; <span class="nb">apply</span>/cvg_entourageP =&gt; A [P entP sPA].
<span class="bp">by</span> near=&gt; g <span class="kp">do</span> <span class="nb">apply</span>: sPA; <span class="nb">apply</span>: Ff.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">entourage_set</span> (<span class="nv">U</span> : uniformType) (<span class="nv">A</span> : <span class="nb">set</span> ((<span class="nb">set</span> U) * (<span class="nb">set</span> U))) :=
  <span class="kr">exists2</span> B, entourage B &amp; <span class="kr">forall</span> <span class="nv">PQ</span>, A PQ -&gt; <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span>,
    PQ.<span class="mi">1</span> p -&gt; PQ.<span class="mi">2</span> q -&gt; B (p,q).
<span class="kn">Canonical</span> <span class="nf">set_filter_source</span> (U : uniformType) :=
  @Filtered.Source <span class="kt">Prop</span> _ U (<span class="kr">fun</span> <span class="nv">A</span> =&gt; nbhs_ (@entourage_set U) A).</span></pre><div class="doc">
<a id="lab18"></a><h1 class="section">PseudoMetric spaces defined using balls</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">entourage_</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">T</span> <span class="nv">T&#39;</span>} (<span class="nv">ball</span> : T -&gt; R -&gt; <span class="nb">set</span> T&#39;) :=
  @filter_from R _ [<span class="nb">set</span> x | <span class="mi">0</span> &lt; x] (<span class="kr">fun</span> <span class="nv">e</span> =&gt; [<span class="nb">set</span> xy | ball xy.<span class="mi">1</span> e xy.<span class="mi">2</span>]).

<span class="kn">Lemma</span> <span class="nf">entourage_E</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">T</span> <span class="nv">T&#39;</span>} (<span class="nv">ball</span> : T -&gt; R -&gt; <span class="nb">set</span> T&#39;) :
  entourage_ ball =
  @filter_from R _ [<span class="nb">set</span> x | <span class="mi">0</span> &lt; x] (<span class="kr">fun</span> <span class="nv">e</span> =&gt; [<span class="nb">set</span> xy | ball xy.<span class="mi">1</span> e xy.<span class="mi">2</span>]).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">map_pair</span> {<span class="nv">S</span> <span class="nv">U</span>} (<span class="nv">f</span> : S -&gt; U) (<span class="nv">x</span> : (S * S)) : (U * U) :=
  (f x.<span class="mi">1</span>, f x.<span class="mi">2</span>).

<span class="kn">Section</span> <span class="nf">weak_uniform</span>.

<span class="kn">Variable</span> (<span class="nv">pS</span> : pointedType) (<span class="nv">U</span> : uniformType) (<span class="nv">f</span> : pS -&gt; U).

<span class="kn">Let</span> <span class="nf">S</span> := weak_topologicalType f.

<span class="kn">Definition</span> <span class="nf">weak_ent</span> : <span class="nb">set</span> (<span class="nb">set</span> (S * S)) :=
  filter_from (@entourage U) (<span class="kr">fun</span> <span class="nv">V</span> =&gt; (map_pair f)@^-<span class="mi">1</span>` V).

<span class="kn">Lemma</span> <span class="nf">weak_ent_filter</span> : Filter weak_ent.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: filter_from_filter; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span>; <span class="bp">exact</span>: entourageT.
<span class="bp">by</span> <span class="nb">move</span>=&gt; P Q ??; (<span class="kr">exists</span> (<span class="nv">P</span> `&amp;` Q); <span class="kp">first</span> <span class="bp">exact</span>: filterI) =&gt; ?.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">weak_ent_refl</span> <span class="nv">A</span> : weak_ent A -&gt; [<span class="nb">set</span> fg | fg.<span class="mi">1</span> = fg.<span class="mi">2</span>] `&lt;=` A.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [B ? sBA] [x y] /= -&gt;; <span class="nb">apply</span>/sBA; <span class="bp">exact</span>: entourage_refl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">weak_ent_inv</span> <span class="nv">A</span> : weak_ent A -&gt; weak_ent (A^-<span class="mi">1</span>)%classic.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B ? sBA]; <span class="kr">exists</span> (<span class="nv">B</span>^-<span class="mi">1</span>)%classic; <span class="kp">first</span> <span class="bp">exact</span>: entourage_inv.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="bp">exact</span>/sBA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">weak_ent_split</span> <span class="nv">A</span> : weak_ent A -&gt; <span class="kr">exists2</span> B, weak_ent B &amp; B \; B `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B entB sBA]; <span class="nb">have</span> : <span class="kr">exists</span> <span class="nv">C</span>, entourage C /\ C \; C `&lt;=` B.
  <span class="bp">exact</span>/exists2P/entourage_split_ex.
<span class="nb">case</span>=&gt; C [entC CsubB]; <span class="kr">exists</span> ((map_pair f)@^-<span class="mi">1</span>` C); <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">C</span>.
<span class="bp">by</span> <span class="nb">case</span>=&gt; x y [a ? ?]; <span class="nb">apply</span>/sBA/CsubB; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">a</span>).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">weak_ent_nbhs</span> : nbhs = nbhs_ weak_ent.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeq2E =&gt; x V; <span class="nb">split</span>.
  <span class="nb">case</span>=&gt; [? [[B  ? &lt;-] ? BsubV]]; <span class="nb">have</span>: nbhs (f x) B <span class="bp">by</span> <span class="nb">apply</span>: open_nbhs_nbhs.
  <span class="nb">move</span>=&gt; /nbhsP [W ? WsubB]; <span class="kr">exists</span> ((map_pair f) @^-<span class="mi">1</span>` W); <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">W</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt;??; <span class="bp">exact</span>/BsubV/WsubB.
<span class="nb">case</span>=&gt; W [V&#39; entV&#39; V&#39;subW] /filterS; <span class="nb">apply</span>.
<span class="nb">have</span> : nbhs (f x) to_set V&#39; (f x) <span class="bp">by</span> <span class="nb">apply</span>/nbhsP; <span class="kr">exists</span> <span class="nv">V&#39;</span>.
<span class="nb">rewrite</span> (@nbhsE U) =&gt; [[O [openU Ofx Osub]]].
(<span class="kr">exists</span> (<span class="nv">f</span> @^-<span class="mi">1</span>` O); <span class="kp">repeat</span> <span class="nb">split</span> =&gt; //); <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">O</span> =&gt; //.
<span class="bp">by</span> <span class="nb">move</span>=&gt; w ? ; <span class="nb">apply</span>: V&#39;subW; <span class="bp">exact</span>: Osub.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">weak_uniform_mixin</span> :=
  @UniformMixin S nbhs weak_ent
    weak_ent_filter weak_ent_refl weak_ent_inv weak_ent_split weak_ent_nbhs.

<span class="kn">Definition</span> <span class="nf">weak_uniformType</span> :=
  UniformType S weak_uniform_mixin.

<span class="kn">End</span> <span class="nf">weak_uniform</span>.

<span class="kn">Section</span> <span class="nf">sup_uniform</span>.

<span class="kn">Variable</span> (<span class="nv">T</span> : pointedType) (<span class="nv">Ii</span> : <span class="kt">Type</span>) (<span class="nv">Tc</span> : Ii -&gt; Uniform.class_of T).

<span class="kn">Let</span> <span class="nf">I</span> : choiceType := classicType_choiceType Ii.
<span class="kn">Let</span> <span class="nf">TS</span> := <span class="kr">fun</span> <span class="nv">i</span> =&gt; Uniform.Pack (Tc i).
<span class="kn">Let</span> <span class="nf">Tt</span> := @sup_topologicalType T I Tc.
<span class="kn">Let</span> <span class="nf">ent_of</span> (<span class="nv">p</span> : I * <span class="nb">set</span> (T * T)) := `[&lt; @entourage (TS p.<span class="mi">1</span>) p.<span class="mi">2</span>&gt;].
<span class="kn">Let</span> <span class="nf">IEnt</span> := ChoiceType {p : (I * <span class="nb">set</span> (T * T)) | ent_of p} (sig_choiceMixin _).

<span class="kn">Local Lemma</span> <span class="nf">IEnt_pointT</span> (<span class="nv">i</span> : I) : ent_of (i, setT).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/asboolP; <span class="bp">exact</span>: entourageT. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">sup_ent</span> : (<span class="nb">set</span> (<span class="nb">set</span> (T * T))) :=
  filter_from (finI_from [<span class="nb">set</span>: IEnt] (<span class="kr">fun</span> <span class="nv">p</span> =&gt; (projT1 p).<span class="mi">2</span>)) id.

<span class="kn">Ltac</span> <span class="nf">IEntP</span> := <span class="nb">move</span>=&gt; [[ /= + + /[dup] /asboolP]].

<span class="kn">Definition</span> <span class="nf">sup_ent_filter</span> : Filter sup_ent.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: finI_filter; <span class="nb">move</span>=&gt; J JsubEnt /=; <span class="kr">exists</span> (<span class="nv">point</span>, point).
<span class="bp">by</span> IEntP =&gt; i b /= /entourage_refl ? ? _.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sup_ent_refl</span> <span class="nv">A</span> : sup_ent A -&gt; [<span class="nb">set</span> fg | fg.<span class="mi">1</span> = fg.<span class="mi">2</span>] `&lt;=` A.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [B [F ? &lt;-] BA] [??] /= -&gt;; <span class="nb">apply</span>/BA; IEntP =&gt; i w /= /entourage_refl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sup_ent_inv</span> <span class="nv">A</span> : sup_ent A -&gt; sup_ent (A^-<span class="mi">1</span>)%classic.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [B [F ? FB] BA]; <span class="kr">exists</span> (<span class="nv">B</span>^-<span class="mi">1</span>)%classic; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: BA.
<span class="nb">have</span> inv : <span class="kr">forall</span> <span class="nv">ie</span> : IEnt, ent_of ((projT1 ie).<span class="mi">1</span>, ((projT1 ie).<span class="mi">2</span>)^-<span class="mi">1</span>)%classic.
  <span class="bp">by</span> IEntP=&gt; ?? /entourage_inv ??; <span class="bp">exact</span>/asboolP.
<span class="kr">exists</span> [fset (<span class="kr">fun</span> <span class="nv">x</span> =&gt; @exist (I * <span class="nb">set</span> (T * T)) _ _ (inv x)) w | w <span class="kr">in</span> F]%fset.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? /imfsetP; IEntP =&gt; ???? -&gt;; <span class="bp">exact</span>: in_setT.
<span class="nb">rewrite</span> -FB eqEsubset; <span class="nb">split</span>; <span class="nb">case</span>=&gt; x y + ie.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /(_ (exist ent_of _ (inv ie))) + ?; <span class="nb">apply</span>; <span class="nb">apply</span>/imfsetP; <span class="kr">exists</span> <span class="nv">ie</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; + /imfsetP [v vW -&gt;]; <span class="bp">exact</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sup_ent_split</span> <span class="nv">A</span> : sup_ent A -&gt; <span class="kr">exists2</span> B, sup_ent B &amp; B \; B `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">have</span> spt : (<span class="kr">forall</span> <span class="nv">ie</span> : IEnt, ent_of ((projT1 ie).<span class="mi">1</span>,
    ((@split_ent (TS (projT1 ie).<span class="mi">1</span>) (projT1 ie).<span class="mi">2</span>)))).
  <span class="bp">by</span> <span class="nb">case</span>=&gt; [[/= ??] /asboolP/entourage_split_ent ?]; <span class="bp">exact</span>/asboolP.
<span class="nb">pose</span> g : (IEnt -&gt; IEnt) := <span class="kr">fun</span> <span class="nv">x</span> =&gt; exist ent_of _ (spt x).
<span class="nb">case</span> =&gt; W [F _ &lt;-] sA; <span class="kr">exists</span> (\bigcap_(x <span class="kr">in</span> [<span class="nb">set</span>` F]) (projT1 (g x)).<span class="mi">2</span>).
  <span class="kr">exists</span> (\bigcap_(ie <span class="kr">in</span> [<span class="nb">set</span>`F]) (projT1 (g ie)).<span class="mi">2</span>) =&gt; //.
  <span class="kr">exists</span> [fset (g ie) | ie <span class="kr">in</span> F]%fset; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; /= ??; <span class="bp">exact</span>: in_setT.
  <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="nb">case</span>=&gt; x y Igxy ie.
    <span class="bp">by</span> <span class="nb">move</span> =&gt; ?; <span class="nb">apply</span>/(Igxy (g ie))/imfsetP; <span class="kr">exists</span> <span class="nv">ie</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /imfsetP [?? -&gt;]; <span class="bp">exact</span>: Igxy.
<span class="nb">case</span> =&gt; ?? [z Fxz Fzy]; <span class="nb">apply</span>: sA; IEntP=&gt; i e ? ? eF.
<span class="nb">apply</span>: ((@entourage_split (TS i)) z) =&gt; //.
  <span class="bp">exact</span>: (Fxz _ eF).
<span class="bp">exact</span>: (Fzy _ eF).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sup_ent_nbhs</span> : @nbhs Tt Tt = nbhs_ sup_ent.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeq2E =&gt; x V; <span class="nb">split</span>.
  <span class="nb">rewrite</span> /nbhs_of_open =&gt; [[? [[B  + &lt;-] [W BW Wx] BV]]] =&gt; /(_ W BW) [].
  <span class="nb">move</span>=&gt; F Fsup Weq; <span class="nb">move</span>: Weq Wx BW =&gt; &lt;- Fx BF.
  <span class="nb">case</span> (pselect ([<span class="nb">set</span>: I] = set0)) =&gt; [I0 | /eqP/set0P [i0 _]].
    <span class="nb">suff</span> -&gt; : V = setT  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span>; <span class="nb">apply</span>: filterT; <span class="bp">exact</span>: sup_ent_filter.
    <span class="nb">rewrite</span> -subTset =&gt; ??; <span class="nb">apply</span>: BV; <span class="kr">exists</span> (\bigcap_(i <span class="kr">in</span> [<span class="nb">set</span>` F]) i) =&gt; //.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; w /Fsup/set_mem; <span class="nb">rewrite</span> /sup_subbase I0 bigcup_set0.
  <span class="nb">have</span> f : <span class="kr">forall</span> <span class="nv">w</span>, {p : IEnt |  w \<span class="kr">in</span> F -&gt; to_set ((projT1 p).<span class="mi">2</span>) x `&lt;=` w}.
    <span class="nb">move</span>=&gt; /= v; <span class="nb">apply</span> cid; <span class="nb">case</span> (pselect (v \<span class="kr">in</span> F)); <span class="kp">first</span> <span class="nb">last</span>.
      <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="kr">exists</span> (<span class="nv">exist</span> <span class="nv">ent_of</span> <span class="nv">_</span> (IEnt_pointT i0)).
    <span class="nb">move</span>=&gt; /[dup] /Fx vx /Fsup/set_mem [i _]; <span class="nb">rewrite</span> openE =&gt; /(_ x vx).
    <span class="bp">by</span> <span class="nb">move</span>=&gt; /(@nbhsP (TS i)) [w /asboolP ent ?]; <span class="kr">exists</span> (<span class="nv">exist</span> <span class="nv">_</span> (i, w) ent).
  <span class="kr">exists</span> (\bigcap_(w <span class="kr">in</span> [<span class="nb">set</span>` F]) (projT1 (projT1 (f w))).<span class="mi">2</span>); <span class="kp">first</span> <span class="nb">last</span>.
    <span class="nb">move</span>=&gt; v /= Fgw; <span class="nb">apply</span>: BV; <span class="kr">exists</span> (\bigcap_(i <span class="kr">in</span> [<span class="nb">set</span>` F]) i) =&gt; //.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; w /[dup] ? /Fgw /= /(projT2 (f w)); <span class="bp">exact</span>.
  <span class="kr">exists</span> (\bigcap_(w <span class="kr">in</span> [<span class="nb">set</span>` F]) (projT1 (projT1 (f w))).<span class="mi">2</span>) =&gt; //.
  <span class="kr">exists</span> [fset (<span class="kr">fun</span> <span class="nv">i</span> =&gt; (projT1 (f i))) w | w <span class="kr">in</span> F]%fset.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; u ?; <span class="bp">exact</span>: in_setT.
  <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; y + z.
    <span class="bp">by</span> <span class="nb">move</span>=&gt;/(_ (projT1 (f z))) =&gt; + ?; <span class="nb">apply</span>; <span class="nb">apply</span>/imfsetP; <span class="kr">exists</span> <span class="nv">z</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Fgy /imfsetP [/= u uF -&gt;]; <span class="bp">exact</span>: Fgy.
<span class="nb">case</span>=&gt; E [D [/= F FsubEnt &lt;-] FsubE EsubV]; <span class="nb">apply</span>: (filterS EsubV).
<span class="nb">pose</span> f : IEnt -&gt; <span class="nb">set</span> T := <span class="kr">fun</span> <span class="nv">w</span> =&gt;
  @interior (TS (projT1 w).<span class="mi">1</span>) (to_set ((projT1 w).<span class="mi">2</span>) (x)).
<span class="kr">exists</span> (\bigcap_(w <span class="kr">in</span> [<span class="nb">set</span>` F]) f w); <span class="kp">repeat</span> <span class="nb">split</span>.
- <span class="kr">exists</span> [<span class="nb">set</span> \bigcap_(w <span class="kr">in</span> [<span class="nb">set</span>` F]) f w]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> bigcup_set1.
  <span class="nb">move</span>=&gt; ? -&gt;; <span class="kr">exists</span> [fset f w | w <span class="kr">in</span> F]%fset.
    <span class="nb">move</span>=&gt; /= ? /imfsetP [[[/= i w /[dup] /asboolP entw ? Fiw -&gt;]]].
    <span class="bp">by</span> <span class="nb">apply</span>/mem_set; <span class="nb">rewrite</span> /f /=; <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="bp">exact</span>: open_interior.
  <span class="bp">by</span> <span class="nb">rewrite</span> set_imfset bigcap_image //=.
- <span class="bp">by</span> IEntP=&gt; ? ? /open_nbhs_entourage entw ??; <span class="nb">apply</span> entw.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; t /= Ifwt; <span class="nb">apply</span>: FsubE =&gt; it /Ifwt/interior_subset.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">sup_uniform_mixin</span>:=
  @UniformMixin Tt nbhs
    sup_ent sup_ent_filter sup_ent_refl sup_ent_inv sup_ent_split sup_ent_nbhs.

<span class="kn">Definition</span> <span class="nf">sup_uniformType</span> := UniformType Tt sup_uniform_mixin.

<span class="kn">Lemma</span> <span class="nf">countable_sup_ent</span> :
  countable [<span class="nb">set</span>: Ii] -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, countable_uniformity (TS n)) -&gt;
  countable_uniformity sup_uniformType.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Icnt countable_ent; <span class="nb">pose</span> f n := cid (countable_ent n).
<span class="nb">pose</span> g (n : Ii) : <span class="nb">set</span> (<span class="nb">set</span> (T * T)) := projT1 (f n).
<span class="nb">have</span> [I0 | /set0P [i0 _]] := eqVneq [<span class="nb">set</span>: I] set0.
  <span class="kr">exists</span> [<span class="nb">set</span> setT]; <span class="nb">split</span>; [<span class="bp">exact</span>: countable1|<span class="nb">move</span>=&gt; A -&gt;; <span class="bp">exact</span>: entourageT|].
  <span class="nb">move</span>=&gt; P [w [A _]] &lt;- subP; <span class="kr">exists</span> <span class="nv">setT</span> =&gt; //.
  <span class="nb">apply</span>: subset_trans subP; <span class="nb">apply</span>: sub_bigcap =&gt; i _ ? _.
  <span class="bp">by</span> <span class="nb">suff</span> : [<span class="nb">set</span>: I] (projT1 i).<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> I0.
<span class="kr">exists</span> (<span class="nv">finI_from</span> (\bigcup_n g n) id); <span class="nb">split</span>.
- <span class="bp">by</span> <span class="nb">apply</span>/finI_from_countable/bigcup_countable =&gt; //i _; <span class="nb">case</span>: (projT2 (f i)).
- <span class="nb">move</span>=&gt; E [A AsubGn AE]; <span class="kr">exists</span> <span class="nv">E</span> =&gt; //.
  <span class="nb">have</span> h (w : <span class="nb">set</span> (T * T)) : { p : IEnt | w \<span class="kr">in</span> A -&gt; w = (projT1 p).<span class="mi">2</span> }.
    <span class="nb">apply</span> cid; <span class="nb">have</span> [|] := boolP (w \<span class="kr">in</span> A); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">exist</span> <span class="nv">ent_of</span> <span class="nv">_</span> (IEnt_pointT i0)).
    <span class="nb">move</span>=&gt; /[dup] /AsubGn /set_mem [n _ gnw] wA.
    <span class="nb">suff</span> ent : ent_of (n, w) <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">exist</span> <span class="nv">ent_of</span> (n, w) ent).
    <span class="bp">by</span> <span class="nb">apply</span>/asboolP; <span class="nb">have</span> [_ + _] := projT2 (f n); <span class="bp">exact</span>.
  <span class="kr">exists</span> [fset sval (h w) | w <span class="kr">in</span> A]%fset; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: in_setT.
  <span class="nb">rewrite</span> -AE; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; t Ia.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; w Aw; <span class="nb">rewrite</span> (svalP (h w) Aw); <span class="nb">apply</span>/Ia/imfsetP; <span class="kr">exists</span> <span class="nv">w</span>.
  <span class="nb">case</span>=&gt; [[n w]] p /imfsetP [x /= xA M]; <span class="nb">apply</span>: Ia.
  <span class="bp">by</span> <span class="nb">rewrite</span> (_ : w = x) // (svalP (h x) xA) -M.
- <span class="nb">move</span>=&gt; E [w] [ A _ wIA wsubE].
  <span class="nb">have</span> ent_Ip (i : IEnt) : @entourage (TS (projT1 i).<span class="mi">1</span>) (projT1 i).<span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">apply</span>/asboolP; <span class="bp">exact</span>: (projT2 i).
  <span class="nb">pose</span> h (i : IEnt) : {x : <span class="nb">set</span> (T * T) | _} := cid2 (and3_rec
    (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">P</span> =&gt; P) (projT2 (f (projT1 i).<span class="mi">1</span>)) (projT1 i).<span class="mi">2</span> (ent_Ip i)).
  <span class="nb">have</span> ehi (i : IEnt) : ent_of ((projT1 i).<span class="mi">1</span>, projT1 (h i)).
    <span class="nb">apply</span>/asboolP =&gt; /=; <span class="nb">have</span> [] := projT2 (h i).
    <span class="bp">by</span> <span class="nb">have</span> [_ + _ ? ?] := projT2 (f (projT1 i).<span class="mi">1</span>); <span class="bp">exact</span>.
  <span class="nb">pose</span> AH := [fset projT1 (h w) | w <span class="kr">in</span> A]%fset.
  <span class="kr">exists</span> (\bigcap_(i <span class="kr">in</span> [<span class="nb">set</span>` AH]) i).
    <span class="kr">exists</span> <span class="nv">AH</span> =&gt; // p /imfsetP [i iA -&gt;]; <span class="nb">rewrite</span> inE //.
    <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">projT1</span> <span class="nv">i</span>).<span class="mi">1</span> =&gt; //; <span class="nb">have</span> [] := projT2 (h i).
  <span class="nb">apply</span>: subset_trans wsubE; <span class="nb">rewrite</span> -wIA =&gt; ? It i ?.
  <span class="bp">by</span> <span class="nb">have</span> [?] := projT2 (h i); <span class="nb">apply</span>; <span class="nb">apply</span>: It; <span class="nb">apply</span>/imfsetP; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sup_uniform</span>.

<span class="kn">Section</span> <span class="nf">product_uniform</span>.

<span class="kn">Variable</span> (<span class="nv">I</span> : choiceType) (<span class="nv">T</span> : I -&gt; uniformType).

<span class="kn">Definition</span> <span class="nf">product_uniformType</span> :=
  sup_uniformType (<span class="kr">fun</span> <span class="nv">i</span> =&gt; Uniform.class
    (weak_uniformType (<span class="kr">fun</span> <span class="nv">f</span> : dep_arrow_pointedType T =&gt; f i))).

<span class="kn">End</span> <span class="nf">product_uniform</span>.

<span class="kn">Module</span> <span class="nf">PseudoMetric</span>.

<span class="kn">Record</span> <span class="nf">mixin_of</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">M</span> : <span class="kt">Type</span>) (<span class="nv">entourage</span> : <span class="nb">set</span> (<span class="nb">set</span> (M * M))) := Mixin {
  ball : M -&gt; R -&gt; M -&gt; <span class="kt">Prop</span> ;
  ax1 : <span class="kr">forall</span> <span class="nv">x</span> (<span class="nv">e</span> : R), <span class="mi">0</span> &lt; e -&gt; ball x e x ;
  ax2 : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> (<span class="nv">e</span> : R), ball x e y -&gt; ball y e x ;
  ax3 : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">e1</span> <span class="nv">e2</span>, ball x e1 y -&gt; ball y e2 z -&gt; ball x (e1 + e2) z;
  ax4 : entourage = entourage_ ball
}.

<span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">M</span> : <span class="kt">Type</span>) := <span class="kn">Class</span> {
  base : Uniform.class_of M;
  mixin : mixin_of R (Uniform.entourage base)
}.

<span class="kn">Section</span> <span class="nf">ClassDef</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : numDomainType.
<span class="kn">Structure</span> <span class="nf">type</span> := Pack { sort; _ : class_of R sort }.
<span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type).
<span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of R cT <span class="kr">in</span> c.

<span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack T c.
<span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.
<span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of R xT).
<span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Uniform.class_of.
<span class="kn">Local Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; mixin_of.

<span class="kn">Definition</span> <span class="nf">pack</span> <span class="nv">ent</span> (<span class="nv">m</span> : @mixin_of R T ent) :=
  <span class="kr">fun</span> <span class="nv">bT</span> (<span class="nv">b</span> : Uniform.class_of T) <span class="nv">of</span> <span class="nv">phant_id</span> (@Uniform.class bT) <span class="nv">b</span> =&gt;
  <span class="kr">fun</span> <span class="nv">m&#39;</span>   <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">m</span> (<span class="nv">m&#39;</span> : @mixin_of R T (Uniform.entourage b)) =&gt;
  @Pack T (@<span class="kn">Class</span> <span class="nf">R</span> <span class="nv">_</span> <span class="nv">b</span> <span class="nv">m&#39;</span>).

<span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">pointedType</span> := @Pointed.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">filteredType</span> := @Filtered.Pack cT cT xclass.
<span class="kn">Definition</span> <span class="nf">topologicalType</span> := @Topological.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">uniformType</span> := @Uniform.Pack cT xclass.

<span class="kn">End</span> <span class="nf">ClassDef</span>.

<span class="kn">Module</span> <span class="nf">Exports</span>.

<span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Uniform.class_of.
<span class="kn">Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; mixin_of.
<span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.
<span class="kn">Canonical</span> <span class="nf">eqType</span>.
<span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.
<span class="kn">Canonical</span> <span class="nf">choiceType</span>.
<span class="kn">Coercion</span> <span class="nf">pointedType</span> : type &gt;-&gt; Pointed.type.
<span class="kn">Canonical</span> <span class="nf">pointedType</span>.
<span class="kn">Coercion</span> <span class="nf">filteredType</span> : type &gt;-&gt; Filtered.type.
<span class="kn">Canonical</span> <span class="nf">filteredType</span>.
<span class="kn">Coercion</span> <span class="nf">topologicalType</span> : type &gt;-&gt; Topological.type.
<span class="kn">Canonical</span> <span class="nf">topologicalType</span>.
<span class="kn">Coercion</span> <span class="nf">uniformType</span> : type &gt;-&gt; Uniform.type.
<span class="kn">Canonical</span> <span class="nf">uniformType</span>.
<span class="kn">Notation</span> <span class="nf">pseudoMetricType</span> := type.
<span class="kn">Notation</span> <span class="nf">PseudoMetricType</span> T m := (@pack _ T _ m _ _ idfun _ idfun).
<span class="kn">Notation</span> <span class="nf">PseudoMetricMixin</span> := Mixin.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;pseudoMetricType&#39; R &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> := (@clone R T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;pseudoMetricType&#39;  R  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;pseudoMetricType&#39; R &#39;of&#39; T ]&quot;</span> := (@clone R T _ _ id)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;pseudoMetricType&#39;  R  &#39;of&#39;  T ]&quot;</span>) : form_scope.

<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">PseudoMetric</span>.

<span class="kn">Export</span> PseudoMetric.Exports.

<span class="kn">Section</span> <span class="nf">PseudoMetricUniformity</span>.

<span class="kn">Lemma</span> <span class="nf">my_ball_le</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">M</span> : <span class="kt">Type</span>) (<span class="nv">ent</span> : <span class="nb">set</span> (<span class="nb">set</span> (M * M))) (<span class="nv">m</span> : PseudoMetric.mixin_of R ent) :
  <span class="kr">forall</span> (<span class="nv">x</span> : M), {homo PseudoMetric.ball m x : e1 e2 / e1 &lt;= e2 &gt;-&gt; e1 `&lt;=` e2}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x e1 e2 le12 y xe1_y.
<span class="nb">move</span>: le12; <span class="nb">rewrite</span> le_eqVlt =&gt; /orP [/eqP &lt;- //|].
<span class="nb">rewrite</span> -subr_gt0 =&gt; lt12.
<span class="nb">rewrite</span> -[e2](subrK e1); <span class="nb">apply</span>: PseudoMetric.ax3 xe1_y.
<span class="nb">suff</span> : PseudoMetric.ball m x (PosNum lt12)%:num x <span class="bp">by</span> [].
<span class="bp">exact</span>: PseudoMetric.ax1.
<span class="kn">Qed</span>.

<span class="kn">Program Definition</span> <span class="nf">uniformityOfBallMixin</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : <span class="kt">Type</span>)
  (<span class="nv">ent</span> : <span class="nb">set</span> (<span class="nb">set</span> (T * T))) (<span class="nv">nbhs</span> : T -&gt; <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">nbhsE</span> : nbhs = nbhs_ ent)
  (<span class="nv">m</span> : PseudoMetric.mixin_of R ent) : Uniform.mixin_of nbhs :=
  UniformMixin _ _ _ _ nbhsE.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; R T ent nbhs nbhsE m; <span class="nb">rewrite</span> (PseudoMetric.ax4 m).
<span class="nb">apply</span>: filter_from_filter; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">1</span> =&gt; /=.
<span class="nb">move</span>=&gt; _ _ /posnumP[e1] /posnumP[e2]; <span class="kr">exists</span> (<span class="nv">Num</span>.min e1 e2)%:num =&gt; //=.
<span class="bp">by</span> <span class="nb">rewrite</span> subsetI; <span class="nb">split</span>=&gt; ?; <span class="nb">apply</span>: my_ball_le;
   <span class="nb">rewrite</span> -leEsub// le_minl lexx <span class="nl">?orbT</span>.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; R T ent nbhs nbhsE m A; <span class="nb">rewrite</span> (PseudoMetric.ax4 m).
<span class="nb">move</span>=&gt; [e egt0 sbeA] xy xey.
<span class="nb">apply</span>: sbeA; <span class="nb">rewrite</span> /= xey; <span class="bp">exact</span>: PseudoMetric.ax1.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; R T ent nbhs nbhsE m A; <span class="nb">rewrite</span> (PseudoMetric.ax4 m) =&gt; - [e egt0 sbeA].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">e</span> =&gt; // xy xye; <span class="nb">apply</span>: sbeA; <span class="nb">apply</span>: PseudoMetric.ax2.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; R T ent nbhs nbhsE m A; <span class="nb">rewrite</span> (PseudoMetric.ax4 m).
<span class="nb">move</span>=&gt; [_/posnumP[e] sbeA].
<span class="kr">exists</span> [<span class="nb">set</span> xy | PseudoMetric.ball m xy.<span class="mi">1</span> (e%:num / <span class="mi">2</span>) xy.<span class="mi">2</span>].
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">e</span>%:num / <span class="mi">2</span>) =&gt; /=.
<span class="nb">move</span>=&gt; xy [z xzhe zyhe]; <span class="nb">apply</span>: sbeA.
<span class="bp">by</span> <span class="nb">rewrite</span> [e%:num]splitr; <span class="nb">apply</span>: PseudoMetric.ax3 zyhe.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">PseudoMetricUniformity</span>.

<span class="kn">Definition</span> <span class="nf">ball</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">M</span> : pseudoMetricType R} := PseudoMetric.ball (PseudoMetric.class M).

<span class="kn">Lemma</span> <span class="nf">entourage_ballE</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">M</span> : pseudoMetricType R} : entourage_ (@ball R M) = entourage.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: M=&gt; [?[?[]]]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourage_from_ballE</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">M</span> : pseudoMetricType R} :
  @filter_from R _ [<span class="nb">set</span> x : R | <span class="mi">0</span> &lt; x]
    (<span class="kr">fun</span> <span class="nv">e</span> =&gt; [<span class="nb">set</span> xy | @ball R M xy.<span class="mi">1</span> e xy.<span class="mi">2</span>]) = entourage.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -entourage_ballE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">entourage_ball</span> {<span class="nv">R</span> : numDomainType} (<span class="nv">M</span> : pseudoMetricType R)
  (<span class="nv">e</span> : {posnum R}) : entourage [<span class="nb">set</span> xy : M * M | ball xy.<span class="mi">1</span> e%:num xy.<span class="mi">2</span>].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -entourage_ballE; <span class="kr">exists</span> <span class="nv">e</span>%:num =&gt; /=. <span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> entourage_ball : core.

<span class="kn">Definition</span> <span class="nf">nbhs_ball_</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">T</span> <span class="nv">T&#39;</span>} (<span class="nv">ball</span> : T -&gt; R -&gt; <span class="nb">set</span> T&#39;)
  (<span class="nv">x</span> : T) := @filter_from R _ [<span class="nb">set</span> e | e &gt; <span class="mi">0</span>] (ball x).

<span class="kn">Definition</span> <span class="nf">nbhs_ball</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">M</span> : pseudoMetricType R} :=
  nbhs_ball_ (@ball R M).

<span class="kn">Lemma</span> <span class="nf">nbhs_ballE</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">M</span> : pseudoMetricType R} : (@nbhs_ball R M) = nbhs.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeq2E =&gt; x P; <span class="nb">rewrite</span> -nbhs_entourageE; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [_/posnumP[e] sbxeP]; <span class="kr">exists</span> [<span class="nb">set</span> xy | ball xy.<span class="mi">1</span> e%:num xy.<span class="mi">2</span>].
<span class="nb">rewrite</span> -entourage_ballE; <span class="nb">move</span>=&gt; [A [e egt0 sbeA] sAP].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">e</span> =&gt; // ??; <span class="nb">apply</span>/sAP/sbeA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_from_ballE</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">M</span> : pseudoMetricType R} <span class="nv">x</span> :
  @filter_from R _ [<span class="nb">set</span> x : R | <span class="mi">0</span> &lt; x] (@ball R M x) = nbhs x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -nbhs_ballE. <span class="kn">Qed</span>.

<span class="kn">Module</span> <span class="nf">Export</span> NbhsBall.
<span class="kn">Definition</span> <span class="nf">nbhs_simpl</span> := (nbhs_simpl,@filter_from_ballE,@nbhs_ballE).
<span class="kn">End</span> <span class="nf">NbhsBall</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_ballP</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">M</span> : pseudoMetricType R} (<span class="nv">x</span> : M) <span class="nv">P</span> :
  nbhs x P &lt;-&gt; nbhs_ball x P.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> nbhs_simpl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ball_center</span> {<span class="nv">R</span> : numDomainType} (<span class="nv">M</span> : pseudoMetricType R) (<span class="nv">x</span> : M)
  (<span class="nv">e</span> : {posnum R}) : ball x e%:num x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: PseudoMetric.ax1. <span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> ball_center : core.

<span class="kn">Section</span> <span class="nf">pseudoMetricType_numDomainType</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">M</span> : pseudoMetricType R}.

<span class="kn">Lemma</span> <span class="nf">ballxx</span> (<span class="nv">x</span> : M) (<span class="nv">e</span> : R) : <span class="mi">0</span> &lt; e -&gt; ball x e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; e_gt0; <span class="nb">apply</span>: ball_center (PosNum e_gt0). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ball_sym</span> (<span class="nv">x</span> <span class="nv">y</span> : M) (<span class="nv">e</span> : R) : ball x e y -&gt; ball y e x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: PseudoMetric.ax2. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ball_triangle</span> (<span class="nv">y</span> <span class="nv">x</span> <span class="nv">z</span> : M) (<span class="nv">e1</span> <span class="nv">e2</span> : R) :
  ball x e1 y -&gt; ball y e2 z -&gt; ball x (e1 + e2) z.
<span class="kn">Proof</span>. <span class="bp">exact</span>: PseudoMetric.ax3. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhsx_ballx</span> (<span class="nv">x</span> : M) (<span class="nv">eps</span> : {posnum R}) : nbhs x (ball x eps%:num).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/nbhs_ballP; <span class="kr">exists</span> <span class="nv">eps</span>%:num =&gt; /=. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_nbhs_ball</span> (<span class="nv">x</span> : M) (<span class="nv">eps</span> : {posnum R}) : open_nbhs x ((ball x eps%:num)^¬∞).
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: open_interior.
<span class="bp">by</span> <span class="nb">apply</span>: nbhs_singleton; <span class="nb">apply</span>: nbhs_interior; <span class="nb">apply</span>:nbhsx_ballx.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">le_ball</span> (<span class="nv">x</span> : M) (<span class="nv">e1</span> <span class="nv">e2</span> : R) : e1 &lt;= e2 -&gt; ball x e1 `&lt;=` ball x e2.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; le12 y. <span class="nb">case</span>: comparableP le12 =&gt; [lte12 _|//|//|-&gt;//].
<span class="bp">by</span> <span class="nb">rewrite</span> -[e2](subrK e1); <span class="nb">apply</span>/ball_triangle/ballxx; <span class="nb">rewrite</span> subr_gt0.
<span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">entourage_proper_filter</span> : ProperFilter (@entourage M).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: Build_ProperFilter; <span class="nb">rewrite</span> -entourage_ballE =&gt; A [_/posnumP[e] sbeA].
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">point</span>, point); <span class="nb">apply</span>: sbeA; <span class="nb">apply</span>: ballxx.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_ball</span> (<span class="nv">y</span> : M) (<span class="nv">eps</span> : {posnum R}) :
   \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near y, ball y eps%:num y&#39;.
<span class="kn">Proof</span>. <span class="bp">exact</span>: nbhsx_ballx. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fcvg_ballP</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} (<span class="nv">y</span> : M) :
  F --&gt; y &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span> : R, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, ball y eps y&#39;.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -filter_fromP !nbhs_simpl /=. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvg_ballPpos</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} (<span class="nv">y</span> : M) :
  F --&gt; y &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span> : {posnum R}, \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, ball y eps%:num y&#39;.
<span class="kn">Proof</span>.
<span class="nb">split</span> =&gt; [/fcvg_ballP + eps|pos]; <span class="kp">first</span> <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">apply</span>/fcvg_ballP=&gt; _/posnumP[eps] //.
<span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use a combination of `cvg_ballP` and `posnumP`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_ballPpos</span> := __deprecated__cvg_ballPpos.

<span class="kn">Lemma</span> <span class="nf">fcvg_ball</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} (<span class="nv">y</span> : M) :
  F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">eps</span> : R, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, ball y eps y&#39;.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/fcvg_ballP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_ballP</span> {<span class="nv">T</span>} {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; M) <span class="nv">y</span> :
  f @ F --&gt; y &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span> : R, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, ball y eps (f x).
<span class="kn">Proof</span>. <span class="bp">exact</span>: fcvg_ballP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_ball</span> {<span class="nv">T</span>} {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; M) <span class="nv">y</span> :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">eps</span> : R, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, ball y eps (f x).
<span class="kn">Proof</span>. <span class="bp">exact</span>: fcvg_ball. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgi_ballP</span> <span class="nv">T</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; M -&gt; <span class="kt">Prop</span>) <span class="nv">y</span> :
  f `@ F --&gt; y &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">eps</span> : R, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, <span class="kr">exists</span> <span class="nv">z</span>, f x z /\ ball y eps z.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [Fy _/posnumP[eps] |Fy P] /=; <span class="kp">first</span> <span class="bp">exact</span>/Fy/nbhsx_ballx.
<span class="nb">move</span>=&gt; /nbhs_ballP[_ /posnumP[eps] subP].
<span class="nb">rewrite</span> near_simpl near_mapi; near=&gt; x.
<span class="nb">have</span> [//|z [fxz yz]] := near (Fy _ (gt0 eps)) x.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">z</span> =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: subP.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">cvg_toi_locally</span> := @cvgi_ballP.

<span class="kn">Lemma</span> <span class="nf">cvgi_ball</span> <span class="nv">T</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; M -&gt; <span class="kt">Prop</span>) <span class="nv">y</span> :
  f `@ F --&gt; y -&gt;
  <span class="kr">forall</span> <span class="nv">eps</span> : R, <span class="mi">0</span> &lt; eps -&gt; F [<span class="nb">set</span> x | <span class="kr">exists</span> <span class="nv">z</span>, f x z /\ ball y eps z].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/cvgi_ballP. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">pseudoMetricType_numDomainType</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> nbhsx_ballx : core.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> close_refl : core.
<span class="kn">Arguments</span> close_cvg {T} F1 F2 {FF2} _.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed `cvg_ball`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">app_cvg_locally</span> := cvg_ball.

<span class="kn">Section</span> <span class="nf">pseudoMetricType_numFieldType</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numFieldType} {<span class="nv">M</span> : pseudoMetricType R}.

<span class="kn">Lemma</span> <span class="nf">ball_split</span> (<span class="nv">z</span> <span class="nv">x</span> <span class="nv">y</span> : M) (<span class="nv">e</span> : R) :
  ball x (e / <span class="mi">2</span>) z -&gt; ball z (e / <span class="mi">2</span>) y -&gt; ball x e y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /ball_triangle h /h; <span class="nb">rewrite</span> -splitr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ball_splitr</span> (<span class="nv">z</span> <span class="nv">x</span> <span class="nv">y</span> : M) (<span class="nv">e</span> : R) :
  ball z (e / <span class="mi">2</span>) x -&gt; ball z (e / <span class="mi">2</span>) y -&gt; ball x e y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /ball_sym /ball_split; <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ball_splitl</span> (<span class="nv">z</span> <span class="nv">x</span> <span class="nv">y</span> : M) (<span class="nv">e</span> : R) :
  ball x (e / <span class="mi">2</span>) z -&gt; ball y (e / <span class="mi">2</span>) z -&gt; ball x e y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; bxz /ball_sym /(ball_split bxz). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ball_close</span> (<span class="nv">x</span> <span class="nv">y</span> : M) :
  close x y = <span class="kr">forall</span> <span class="nv">eps</span> : {posnum R}, ball x eps%:num y.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [cxy eps|cxy].
  <span class="nb">have</span> := !! cxy _ (open_nbhs_ball _ (eps%:num/<span class="mi">2</span>)%:pos).
  <span class="nb">rewrite</span> closureEonbhs/= meetsC meets_globallyr.
  <span class="nb">move</span>/(_ _ (open_nbhs_ball _ (eps%:num/<span class="mi">2</span>)%:pos)) =&gt; [z [zx zy]].
  <span class="bp">by</span> <span class="nb">apply</span>: (@ball_splitl z); <span class="nb">apply</span>: interior_subset.
<span class="nb">rewrite</span> closeEnbhs =&gt; B A /nbhs_ballP[_/posnumP[e2 e2B]]
  /nbhs_ballP[_/posnumP[e1 e1A]].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">split</span>; [<span class="nb">apply</span>/e2B|<span class="nb">apply</span>/e1A; <span class="bp">exact</span>: ballxx].
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">pseudoMetricType_numFieldType</span>.

<span class="kn">Section</span> <span class="nf">ball_hausdorff</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">T</span> : pseudoMetricType R).

<span class="kn">Lemma</span> <span class="nf">ball_hausdorff</span> : hausdorff_space T =
  <span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : T), a != b -&gt;
  <span class="kr">exists</span> <span class="nv">r</span> : {posnum R} * {posnum R},
    ball a r.<span class="mi">1</span>%:num `&amp;` ball b r.<span class="mi">2</span>%:num == set0.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE open_hausdorff; <span class="nb">split</span> =&gt; T2T a b /T2T[[/=]].
  <span class="nb">move</span>=&gt; A B; <span class="nb">rewrite</span> <span class="mi">2</span>!inE =&gt; [[aA bB] [oA oB /eqP ABeq0]].
  <span class="nb">have</span> /nbhs_ballP[_/posnumP[r] rA]: nbhs a A <span class="bp">by</span> <span class="nb">apply</span>: open_nbhs_nbhs.
  <span class="nb">have</span> /nbhs_ballP[_/posnumP[s] rB]: nbhs b B <span class="bp">by</span> <span class="nb">apply</span>: open_nbhs_nbhs.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">r</span>, s) =&gt; /=; <span class="nb">rewrite</span> (subsetI_eq0 _ _ ABeq0).
<span class="nb">move</span>=&gt; r s /eqP brs_eq0; <span class="kr">exists</span> ((ball a r%:num)^¬∞, (ball b s%:num)^¬∞) =&gt; /=.
  <span class="nb">split</span>; <span class="bp">by</span> <span class="nb">rewrite</span> inE; <span class="nb">apply</span>: nbhs_singleton; <span class="nb">apply</span>: nbhs_interior;
            <span class="nb">apply</span>/nbhs_ballP; <span class="nb">apply</span>: in_filter_from =&gt; /=.
<span class="nb">split</span>; <span class="kp">do</span> <span class="nl">?by</span> <span class="nb">apply</span>: open_interior.
<span class="bp">by</span> <span class="nb">rewrite</span> (subsetI_eq0 _ _ brs_eq0)//; <span class="nb">apply</span>: interior_subset.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">ball_hausdorff</span>.

<span class="kn">Section</span> <span class="nf">entourages</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : numDomainType.
<span class="kn">Lemma</span> <span class="nf">unif_continuousP</span> (<span class="nv">U</span> <span class="nv">V</span> : pseudoMetricType R) (<span class="nv">f</span> : U -&gt; V) :
  unif_continuous f &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">e</span>, e &gt; <span class="mi">0</span> -&gt; <span class="kr">exists2</span> d, d &gt; <span class="mi">0</span> &amp;
    <span class="kr">forall</span> <span class="nv">x</span>, ball x.<span class="mi">1</span> d x.<span class="mi">2</span> -&gt; ball (f x.<span class="mi">1</span>) e (f x.<span class="mi">2</span>).
<span class="kn">Proof</span>.
<span class="nb">have</span> fappF : Filter ((<span class="kr">fun</span> <span class="nv">xy</span> =&gt; (f xy.<span class="mi">1</span>, f xy.<span class="mi">2</span>)) @ entourage_ ball).
  <span class="bp">by</span> <span class="nb">rewrite</span> entourage_ballE; <span class="nb">apply</span>: fmap_filter.
<span class="bp">by</span> <span class="nb">rewrite</span> /unif_continuous -!entourage_ballE filter_fromP.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">entourages</span>.

<span class="kn">Lemma</span> <span class="nf">countable_uniformity_metric</span> {<span class="nv">R</span> : realType} {<span class="nv">T</span> : pseudoMetricType R} :
  countable_uniformity T.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/countable_uniformityP.
<span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">n</span> =&gt; [<span class="nb">set</span> xy : T * T | ball xy.<span class="mi">1</span> n.+<span class="mi">1</span>%:R^-<span class="mi">1</span> xy.<span class="mi">2</span>]); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="bp">exact</span>: (entourage_ball _ n.+<span class="mi">1</span>%:R^-<span class="mi">1</span>%:pos).
<span class="nb">move</span>=&gt; E; <span class="nb">rewrite</span> -entourage_ballE =&gt; -[e e0 subE].
<span class="kr">exists</span> `|floor e^-<span class="mi">1</span>|%N; <span class="nb">apply</span>: subset_trans subE =&gt; xy; <span class="nb">apply</span>: le_ball.
<span class="nb">rewrite</span> /= -[leRHS]invrK lef_pinv <span class="nl">?posrE</span> <span class="nl">?invr_gt0</span>// -natr1.
<span class="bp">by</span> <span class="nb">rewrite</span> natr_absz ger0_norm <span class="nl">?floor_ge0</span> <span class="nl">?invr_ge0</span>// <span class="mi">1</span><span class="nl">?ltW</span>// lt_succ_floor.
<span class="kn">Qed</span>.</span></pre><div class="doc">
<a id="lab19"></a><h2 class="section">Specific pseudoMetric spaces</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
matrices 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">matrix_PseudoMetric</span>.
<span class="kn">Variables</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">R</span> : numDomainType) (<span class="nv">T</span> : pseudoMetricType R).
<span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> : &#39;M[T]_(m, n).
<span class="kn">Definition</span> <span class="nf">mx_ball</span> <span class="nv">x</span> (<span class="nv">e</span> : R) <span class="nv">y</span> := <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, ball (x i j) e (y i j).
<span class="kn">Lemma</span> <span class="nf">mx_ball_center</span> <span class="nv">x</span> (<span class="nv">e</span> : R) : <span class="mi">0</span> &lt; e -&gt; mx_ball x e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ???; <span class="nb">apply</span>: ballxx. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mx_ball_sym</span> <span class="nv">x</span> <span class="nv">y</span> (<span class="nv">e</span> : R) : mx_ball x e y -&gt; mx_ball y e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; xe_y ??; <span class="nb">apply</span>/ball_sym/xe_y. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">mx_ball_triangle</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> (<span class="nv">e1</span> <span class="nv">e2</span> : R) :
  mx_ball x e1 y -&gt; mx_ball y e2 z -&gt; mx_ball x (e1 + e2) z.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; xe1_y ye2_z ??; <span class="nb">apply</span>: ball_triangle; [<span class="nb">apply</span>: xe1_y| <span class="nb">apply</span>: ye2_z].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_entourage</span> : entourage = entourage_ mx_ball.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE=&gt; A; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; [_/posnumP[e] sbeA].
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; [<span class="nb">set</span> xy | ball xy.<span class="mi">1</span> e%:num xy.<span class="mi">2</span>]).
<span class="nb">move</span>=&gt; [P]; <span class="nb">rewrite</span> -entourage_ballE =&gt; entP sPA.
<span class="nb">set</span> diag := <span class="kr">fun</span> (<span class="nv">e</span> : {posnum R}) =&gt; [<span class="nb">set</span> xy : T * T | ball xy.<span class="mi">1</span> e%:num xy.<span class="mi">2</span>].
<span class="kr">exists</span> (\big[Num.min/<span class="mi">1</span>%:pos]_i \big[Num.min/<span class="mi">1</span>%:pos]_j xget <span class="mi">1</span>%:pos
  (<span class="kr">fun</span> <span class="nv">e</span> : {posnum R} =&gt; diag e `&lt;=` P i j))%:num =&gt; //=.
<span class="nb">move</span>=&gt; MN MN_min; <span class="nb">apply</span>: sPA =&gt; i j.
<span class="nb">have</span> /(xgetPex <span class="mi">1</span>%:pos): <span class="kr">exists</span> <span class="nv">e</span> : {posnum R}, diag e `&lt;=` P i j.
  <span class="bp">by</span> <span class="nb">have</span> [_/posnumP[e]] := entP i j; <span class="kr">exists</span> <span class="nv">e</span>.
<span class="nb">apply</span>; <span class="nb">apply</span>: le_ball (MN_min i j).
<span class="nb">apply</span>: le_trans (@bigmin_le _ [orderType of {posnum R}] _ _ i _) _.
<span class="bp">exact</span>: bigmin_le.
<span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">matrix_pseudoMetricType_mixin</span> :=
  PseudoMetric.Mixin mx_ball_center mx_ball_sym mx_ball_triangle mx_entourage.
<span class="kn">Canonical</span> <span class="nf">matrix_pseudoMetricType</span> :=
  PseudoMetricType &#39;M[T]_(m, n) matrix_pseudoMetricType_mixin.
<span class="kn">End</span> <span class="nf">matrix_PseudoMetric</span>.</span></pre><div class="doc">
product of two pseudoMetric spaces 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">prod_PseudoMetric</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">U</span> <span class="nv">V</span> : pseudoMetricType R}.
<span class="kn">Implicit Types</span> (<span class="nv">x</span> <span class="nv">y</span> : U * V).
<span class="kn">Definition</span> <span class="nf">prod_point</span> : U * V := (point, point).
<span class="kn">Definition</span> <span class="nf">prod_ball</span> <span class="nv">x</span> (<span class="nv">eps</span> : R) <span class="nv">y</span> :=
  ball (fst x) eps (fst y) /\ ball (snd x) eps (snd y).
<span class="kn">Lemma</span> <span class="nf">prod_ball_center</span> <span class="nv">x</span> (<span class="nv">eps</span> : R) : <span class="mi">0</span> &lt; eps -&gt; prod_ball x eps x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /posnumP[?]. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">prod_ball_sym</span> <span class="nv">x</span> <span class="nv">y</span> (<span class="nv">eps</span> : R) : prod_ball x eps y -&gt; prod_ball y eps x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; [bxy1 bxy2]; <span class="nb">split</span>; <span class="nb">apply</span>: ball_sym. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">prod_ball_triangle</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> (<span class="nv">e1</span> <span class="nv">e2</span> : R) :
  prod_ball x e1 y -&gt; prod_ball y e2 z -&gt; prod_ball x (e1 + e2) z.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [bxy1 bxy2] [byz1 byz2]; <span class="nb">split</span>; <span class="nb">apply</span>: ball_triangle; <span class="bp">eassumption</span>.
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">prod_entourage</span> : entourage = entourage_ prod_ball.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; P; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; [_/posnumP[e] sbeP].
  <span class="kr">exists</span> ([<span class="nb">set</span> xy | ball xy.<span class="mi">1</span> e%:num xy.<span class="mi">2</span>],
          [<span class="nb">set</span> xy | ball xy.<span class="mi">1</span> e%:num xy.<span class="mi">2</span>]) =&gt; //=.
  <span class="nb">move</span>=&gt; [[a b] [c d]] [bab bcd]; <span class="kr">exists</span> ((a, c), (b, d))=&gt; //=.
  <span class="bp">exact</span>: sbeP.
<span class="nb">move</span>=&gt; [[A B]] /=; <span class="nb">rewrite</span> -!entourage_ballE.
<span class="nb">move</span>=&gt; [[_/posnumP[eA] sbA] [_/posnumP[eB] sbB] sABP].
<span class="kr">exists</span> (<span class="nv">Num</span>.min eA eB)%:num =&gt; //= -[[a b] [c d] [/= bac bbd]].
<span class="nb">suff</span> /sABP [] : (A `*` B) ((a, c), (b, d)) <span class="bp">by</span> <span class="nb">move</span>=&gt; [[??] [??]] ? [&lt;-&lt;-&lt;-&lt;-].
<span class="nb">split</span>; [<span class="nb">apply</span>: sbA|<span class="nb">apply</span>: sbB] =&gt; /=.
  <span class="bp">by</span> <span class="nb">apply</span>: le_ball bac; <span class="nb">rewrite</span> -leEsub le_minl lexx.
<span class="bp">by</span> <span class="nb">apply</span>: le_ball bbd; <span class="nb">rewrite</span> -leEsub le_minl lexx orbT.
<span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">prod_pseudoMetricType_mixin</span> :=
  PseudoMetric.Mixin prod_ball_center prod_ball_sym prod_ball_triangle prod_entourage.
<span class="kn">End</span> <span class="nf">prod_PseudoMetric</span>.
<span class="kn">Canonical</span> <span class="nf">prod_pseudoMetricType</span> (R : numDomainType) (U V : pseudoMetricType R) :=
  PseudoMetricType (U * V) (@prod_pseudoMetricType_mixin R U V).

<span class="kn">Section</span> <span class="nf">Nbhs_fct2</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">R</span> : numDomainType} {<span class="nv">U</span> <span class="nv">V</span> : pseudoMetricType R}.
<span class="kn">Lemma</span> <span class="nf">fcvg_ball2P</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> V)}
  {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} (<span class="nv">y</span> : U) (<span class="nv">z</span> : V):
  (F, G) --&gt; (y, z) &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">eps</span> : R, eps &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F &amp; z&#39; \near G,
                ball y eps y&#39; /\ ball z eps z&#39;.
<span class="kn">Proof</span>. <span class="bp">exact</span>: fcvg_ballP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_ball2P</span> {<span class="nv">I</span> <span class="nv">J</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> J)}
  {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} (<span class="nv">f</span> : I -&gt; U) (<span class="nv">g</span> : J -&gt; V) (<span class="nv">y</span> : U) (<span class="nv">z</span> : V):
  (f @ F, g @ G) --&gt; (y, z) &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">eps</span> : R, eps &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">i</span> \near F &amp; j \near G,
                ball y eps (f i) /\ ball z eps (g j).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> fcvg_ball2P; <span class="nb">split</span>=&gt; + e e0 =&gt; /(_ e e0).
  <span class="bp">by</span> <span class="nb">rewrite</span> near_map2; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; fgyz; <span class="nb">rewrite</span> near_map2; <span class="nb">apply</span>: fgyz.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Nbhs_fct2</span>.</span></pre><div class="doc">
Functional metric spaces 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">fct_PseudoMetric</span>.
<span class="kn">Variable</span> (<span class="nv">T</span> : choiceType) (<span class="nv">R</span> : numFieldType) (<span class="nv">U</span> : pseudoMetricType R).
<span class="kn">Definition</span> <span class="nf">fct_ball</span> (<span class="nv">x</span> : T -&gt; U) (<span class="nv">eps</span> : R) (<span class="nv">y</span> : T -&gt; U) :=
  <span class="kr">forall</span> <span class="nv">t</span> : T, ball (x t) eps (y t).
<span class="kn">Lemma</span> <span class="nf">fct_ball_center</span> (<span class="nv">x</span> : T -&gt; U) (<span class="nv">e</span> : R) : <span class="mi">0</span> &lt; e -&gt; fct_ball x e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /posnumP[{}e] ?. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fct_ball_sym</span> (<span class="nv">x</span> <span class="nv">y</span> : T -&gt; U) (<span class="nv">e</span> : R) : fct_ball x e y -&gt; fct_ball y e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; P t; <span class="nb">apply</span>: ball_sym. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">fct_ball_triangle</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : T -&gt; U) (<span class="nv">e1</span> <span class="nv">e2</span> : R) :
  fct_ball x e1 y -&gt; fct_ball y e2 z -&gt; fct_ball x (e1 + e2) z.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; xy yz t; <span class="nb">apply</span>: (@ball_triangle _ _ (y t)). <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">fct_entourage</span> : entourage = entourage_ fct_ball.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [_/posnumP[e] sbeA]; <span class="kr">exists</span> [<span class="nb">set</span> xy | ball xy.<span class="mi">1</span> e%:num xy.<span class="mi">2</span>].
<span class="nb">move</span>=&gt; [P]; <span class="nb">rewrite</span> -entourage_ballE =&gt; -[_/posnumP[e] sbeP] sPA.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">e</span>%:num =&gt; //= fg fg_e; <span class="nb">apply</span>: sPA =&gt; t; <span class="nb">apply</span>: sbeP; <span class="nb">apply</span>: fg_e.
<span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">fct_pseudoMetricType_mixin</span> :=
  PseudoMetricMixin fct_ball_center fct_ball_sym fct_ball_triangle fct_entourage.
<span class="kn">Canonical</span> <span class="nf">fct_pseudoMetricType</span> := PseudoMetricType (T -&gt; U) fct_pseudoMetricType_mixin.
<span class="kn">End</span> <span class="nf">fct_PseudoMetric</span>.

<span class="kn">Definition</span> <span class="nf">quotient_topology</span> (<span class="nv">T</span> : topologicalType) (<span class="nv">Q</span> : quotType T) := Q.

<span class="kn">Section</span> <span class="nf">quotients</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> quotient_scope.
<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType} {<span class="nv">Q0</span> : quotType T}.

<span class="kn">Let</span> <span class="nf">Q</span> := quotient_topology Q0.

<span class="kn">Canonical</span> <span class="nf">quotient_eq</span> := EqType Q gen_eqMixin.
<span class="kn">Canonical</span> <span class="nf">quotient_choice</span> := ChoiceType Q gen_choiceMixin.
<span class="kn">Canonical</span> <span class="nf">quotient_pointed</span> := PointedType Q (\pi_Q point).

<span class="kn">Definition</span> <span class="nf">quotient_open</span> <span class="nv">U</span> := open (\pi_Q @^-<span class="mi">1</span>` U).

<span class="kn">Program Definition</span> <span class="nf">quotient_topologicalType_mixin</span> :=
  @topologyOfOpenMixin Q quotient_open _ _ _.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /quotient_open preimage_setT; <span class="bp">exact</span>: openT. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ? ?; <span class="bp">exact</span>: openI. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; I f ofi; <span class="nb">apply</span>: bigcup_open =&gt; i _; <span class="bp">exact</span>: ofi. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">quotient_filtered</span> := Filtered.<span class="kn">Class</span> (Pointed.class quotient_pointed)
  (nbhs_of_open quotient_open).

<span class="kn">Canonical</span> <span class="nf">quotient_topologicalType</span> := @Topological.Pack Q
  (@Topological.<span class="kn">Class</span> <span class="nf">_</span> <span class="nv">quotient_filtered</span> <span class="nv">quotient_topologicalType_mixin</span>).

<span class="kn">Let</span> <span class="nf">Q&#39;</span> := quotient_topologicalType.

<span class="kn">Lemma</span> <span class="nf">pi_continuous</span> : continuous (\pi_Q : T -&gt; Q&#39;).
<span class="kn">Proof</span>. <span class="bp">exact</span>/continuousP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">quotient_continuous</span> {<span class="nv">Z</span> : topologicalType} (<span class="nv">f</span> : Q&#39; -&gt; Z) :
  continuous f &lt;-&gt; continuous (f \o \pi_Q).
<span class="kn">Proof</span>.
<span class="nb">split</span> =&gt; /continuousP /= cts; <span class="nb">apply</span>/continuousP =&gt; A oA; <span class="nb">last</span> <span class="bp">exact</span>: cts.
<span class="bp">by</span> <span class="nb">rewrite</span> comp_preimage; <span class="nb">move</span>/continuousP: pi_continuous; <span class="nb">apply</span>; <span class="bp">exact</span>: cts.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">repr_comp_continuous</span> (<span class="nv">Z</span> : topologicalType) (<span class="nv">g</span> : T -&gt; Z) :
  continuous g -&gt; {homo g : a b / a == b %[mod Q] &gt;-&gt; a == b} -&gt;
  continuous (g \o repr : Q&#39; -&gt; Z).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /continuousP ctsG rgE; <span class="nb">apply</span>/continuousP =&gt; A oA.
<span class="nb">rewrite</span> /open/= /quotient_open (_ : _ @^-<span class="mi">1</span>` _ = g @^-<span class="mi">1</span>` A); <span class="kp">first</span> <span class="bp">exact</span>: ctsG.
<span class="nb">have</span> greprE x : g (repr (\pi_Q x)) = g x <span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> rgE// reprK.
<span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; x /=; <span class="nb">rewrite</span> greprE.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">quotients</span>.</span></pre><div class="doc">
<a id="lab20"></a><h2 class="section">Complete uniform spaces</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">cauchy</span> {<span class="nv">T</span> : uniformType} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) := (F, F) --&gt; entourage.

<span class="kn">Lemma</span> <span class="nf">cvg_cauchy</span> {<span class="nv">T</span> : uniformType} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) : Filter F -&gt;
  [cvg F <span class="kr">in</span> T] -&gt; cauchy F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF cvF A entA; <span class="nb">have</span> /entourage_split_ex [B entB sB2A] := entA.
<span class="kr">exists</span> (<span class="nv">to_set</span> ((B^-<span class="mi">1</span>)%classic) (lim F), to_set B (lim F)).
  <span class="nb">split</span>=&gt; /=; <span class="nb">apply</span>: cvF; <span class="nb">rewrite</span> /= -nbhs_entourageE; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">B</span>.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">B</span>^-<span class="mi">1</span>)%classic =&gt; //; <span class="nb">apply</span>: entourage_inv.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ab [/= Balima Blimb]; <span class="nb">apply</span>: sB2A; <span class="kr">exists</span> (<span class="nv">lim</span> <span class="nv">F</span>).
<span class="kn">Qed</span>.

<span class="kn">Module</span> <span class="nf">Complete</span>.
<span class="kn">Definition</span> <span class="nf">axiom</span> (<span class="nv">T</span> : uniformType) :=
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)), ProperFilter F -&gt; cauchy F -&gt; F --&gt; lim F.
<span class="kn">Section</span> <span class="nf">ClassDef</span>.
<span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">T</span> : <span class="kt">Type</span>) := <span class="kn">Class</span> {
  base : Uniform.class_of T ;
  mixin : axiom (Uniform.Pack base)
}.
<span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Uniform.class_of.
<span class="kn">Local Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; Complete.axiom.
<span class="kn">Structure</span> <span class="nf">type</span> := Pack { sort; _ : class_of sort }.
<span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type).
<span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of cT <span class="kr">in</span> c.
<span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack T c.
<span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.
<span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of xT).
<span class="kn">Definition</span> <span class="nf">pack</span> <span class="nv">b0</span> (<span class="nv">m0</span> : axiom (@Uniform.Pack T b0)) :=
  <span class="kr">fun</span> <span class="nv">bT</span> <span class="nv">b</span> <span class="nv">of</span> <span class="nv">phant_id</span> (@Uniform.class bT) <span class="nv">b</span> =&gt;
  <span class="kr">fun</span> <span class="nv">m</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">m</span> <span class="nv">m0</span> =&gt; @Pack T (@<span class="kn">Class</span> <span class="nf">T</span> <span class="nv">b</span> <span class="nv">m</span>).
<span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">pointedType</span> := @Pointed.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">filteredType</span> := @Filtered.Pack cT cT xclass.
<span class="kn">Definition</span> <span class="nf">topologicalType</span> := @Topological.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">uniformType</span> := @Uniform.Pack cT xclass.
<span class="kn">End</span> <span class="nf">ClassDef</span>.
<span class="kn">Module</span> <span class="nf">Exports</span>.
<span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Uniform.class_of.
<span class="kn">Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; axiom.
<span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.
<span class="kn">Canonical</span> <span class="nf">eqType</span>.
<span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.
<span class="kn">Canonical</span> <span class="nf">choiceType</span>.
<span class="kn">Coercion</span> <span class="nf">pointedType</span> : type &gt;-&gt; Pointed.type.
<span class="kn">Canonical</span> <span class="nf">pointedType</span>.
<span class="kn">Coercion</span> <span class="nf">filteredType</span> : type &gt;-&gt; Filtered.type.
<span class="kn">Canonical</span> <span class="nf">filteredType</span>.
<span class="kn">Coercion</span> <span class="nf">topologicalType</span> : type &gt;-&gt; Topological.type.
<span class="kn">Canonical</span> <span class="nf">topologicalType</span>.
<span class="kn">Coercion</span> <span class="nf">uniformType</span> : type &gt;-&gt; Uniform.type.
<span class="kn">Canonical</span> <span class="nf">uniformType</span>.
<span class="kn">Notation</span> <span class="nf">completeType</span> := type.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;completeType&#39; &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> :=  (@clone T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;completeType&#39;  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;completeType&#39; &#39;of&#39; T ]&quot;</span> := (@clone T _ _ id)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;completeType&#39;  &#39;of&#39;  T ]&quot;</span>) : form_scope.
<span class="kn">Notation</span> <span class="nf">CompleteType</span> T m := (@pack T _ m _ _ idfun _ idfun).
<span class="kn">End</span> <span class="nf">Exports</span>.
<span class="kn">End</span> <span class="nf">Complete</span>.
<span class="kn">Export</span> Complete.Exports.

<span class="kn">Section</span> <span class="nf">completeType1</span>.

<span class="kn">Context</span> {<span class="nv">T</span> : completeType}.

<span class="kn">Lemma</span> <span class="nf">cauchy_cvg</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : ProperFilter F) :
  cauchy F -&gt; cvg F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: T F FF =&gt; [? [?]]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cauchy_cvgP</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : ProperFilter F) : cauchy F &lt;-&gt; cvg F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; [/cauchy_cvg|/cvg_cauchy]. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">completeType1</span>.
<span class="kn">Arguments</span> cauchy_cvg {T} F {FF} _.
<span class="kn">Arguments</span> cauchy_cvgP {T} F {FF}.

<span class="kn">Section</span> <span class="nf">matrix_Complete</span>.

<span class="kn">Variables</span> (<span class="nv">T</span> : completeType) (<span class="nv">m</span> <span class="nv">n</span> : nat).

<span class="kn">Lemma</span> <span class="nf">mx_complete</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> &#39;M[T]_(m, n))) :
  ProperFilter F -&gt; cauchy F -&gt; cvg F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF Fc.
<span class="nb">have</span> /(_ _ _) /cauchy_cvg /cvg_app_entourageP cvF :
  cauchy ((<span class="kr">fun</span> <span class="nv">M</span> : &#39;M[T]_(m, n) =&gt; M _ _) @ F).
  <span class="nb">move</span>=&gt; i j A /= entA; <span class="nb">rewrite</span> near_simpl -near2E near_map2.
  <span class="bp">by</span> <span class="nb">apply</span>: Fc; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; A).
<span class="nb">apply</span>/cvg_ex.
<span class="nb">set</span> Mlim := \matrix_(i, j) (lim ((<span class="kr">fun</span> <span class="nv">M</span> : &#39;M[T]_(m, n) =&gt; M i j) @ F) : T).
<span class="kr">exists</span> <span class="nv">Mlim</span>; <span class="nb">apply</span>/cvg_mx_entourageP =&gt; A entA; near=&gt; M =&gt; i j; near F =&gt; M&#39;.
<span class="nb">apply</span>: subset_split_ent =&gt; //; <span class="kr">exists</span> (<span class="nv">M&#39;</span> <span class="nv">i</span> <span class="nv">j</span>) =&gt; /=.
  <span class="bp">by</span> near: M&#39;; <span class="nb">rewrite</span> mxE; <span class="nb">apply</span>: cvF.
<span class="nb">move</span>: (i) (j); near: M&#39;; near: M; <span class="nb">apply</span>: nearP_dep; <span class="nb">apply</span>: Fc.
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; (split_ent A)^-<span class="mi">1</span>%classic) =&gt; ?? //; <span class="nb">apply</span>: entourage_inv.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">matrix_completeType</span> := CompleteType &#39;M[T]_(m, n) mx_complete.

<span class="kn">End</span> <span class="nf">matrix_Complete</span>.

<span class="kn">Section</span> <span class="nf">fun_Complete</span>.

<span class="kn">Context</span> {<span class="nv">T</span> : choiceType} {<span class="nv">U</span> : completeType}.

<span class="kn">Lemma</span> <span class="nf">fun_complete</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (T -&gt; U)))
  {<span class="nv">FF</span> :  ProperFilter F} : cauchy F -&gt; cvg F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Fc.
<span class="nb">have</span> /(_ _) /cauchy_cvg /cvg_app_entourageP cvF : cauchy (@^~_ @ F).
  <span class="nb">move</span>=&gt; t A /= entA; <span class="nb">rewrite</span> near_simpl -near2E near_map2.
  <span class="bp">by</span> <span class="nb">apply</span>: Fc; <span class="kr">exists</span> <span class="nv">A</span>.
<span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">t</span> =&gt; lim (@^~t @ F)).
<span class="nb">apply</span>/cvg_fct_entourageP =&gt; A entA; near=&gt; f =&gt; t; near F =&gt; g.
<span class="nb">apply</span>: (entourage_split (g t)) =&gt; //; <span class="kp">first</span> <span class="bp">by</span> near: g; <span class="nb">apply</span>: cvF.
<span class="nb">move</span>: (t); near: g; near: f; <span class="nb">apply</span>: nearP_dep; <span class="nb">apply</span>: Fc.
<span class="kr">exists</span> ((split_ent A)^-<span class="mi">1</span>)%classic=&gt; //=.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">fun_completeType</span> := CompleteType (T -&gt; U) fun_complete.

<span class="kn">End</span> <span class="nf">fun_Complete</span>.</span></pre><div class="doc">
<a id="lab21"></a><h2 class="section">Limit switching</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">Cvg_switch</span>.
<span class="kn">Context</span> {<span class="nv">T1</span> <span class="nv">T2</span> : choiceType}.

<span class="kn">Lemma</span> <span class="nf">cvg_switch_1</span> {<span class="nv">U</span> : uniformType}
  <span class="nv">F1</span> {<span class="nv">FF1</span> : ProperFilter F1} <span class="nv">F2</span> {<span class="nv">FF2</span> : Filter F2}
  (<span class="nv">f</span> : T1 -&gt; T2 -&gt; U) (<span class="nv">g</span> : T2 -&gt; U) (<span class="nv">h</span> : T1 -&gt; U) (<span class="nv">l</span> : U) :
  f @ F1 --&gt; g -&gt; (<span class="kr">forall</span> <span class="nv">x1</span>, f x1 @ F2 --&gt; h x1) -&gt; h @ F1 --&gt; l -&gt;
  g @ F2 --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fg fh hl; <span class="nb">apply</span>/cvg_app_entourageP =&gt; A entA.
near F1 =&gt; x1; near=&gt; x2; <span class="nb">apply</span>: (entourage_split (h x1)) =&gt; //.
  <span class="bp">by</span> near: x1; <span class="nb">apply</span>/(hl (to_set _ l)) =&gt; /=.
<span class="nb">apply</span>: (entourage_split (f x1 x2)) =&gt; //.
  <span class="bp">by</span> near: x2; <span class="nb">apply</span>/(fh x1 (to_set _ _)) =&gt; /=.
<span class="nb">move</span>: (x2); near: x1; <span class="nb">have</span> /cvg_fct_entourageP /(_ (_^-<span class="mi">1</span>%classic)):= fg; <span class="nb">apply</span>.
<span class="bp">exact</span>: entourage_inv.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_switch_2</span> {<span class="nv">U</span> : completeType}
  <span class="nv">F1</span> {<span class="nv">FF1</span> : ProperFilter F1} <span class="nv">F2</span> {<span class="nv">FF2</span> : ProperFilter F2}
  (<span class="nv">f</span> : T1 -&gt; T2 -&gt; U) (<span class="nv">g</span> : T2 -&gt; U) (<span class="nv">h</span> : T1 -&gt; U) :
  f @ F1 --&gt; g -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, f x @ F2 --&gt; h x) -&gt;
  [cvg h @ F1 <span class="kr">in</span> U].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fg fh; <span class="nb">apply</span>: cauchy_cvg =&gt; A entA.
<span class="nb">rewrite</span> !near_simpl -near2_pair near_map2; near=&gt; x1 y1 =&gt; /=; near F2 =&gt; x2.
<span class="nb">apply</span>: (entourage_split (f x1 x2)) =&gt; //.
  <span class="bp">by</span> near: x2; <span class="nb">apply</span>/(fh _ (to_set _ _)) =&gt; /=.
<span class="nb">apply</span>: (entourage_split (f y1 x2)) =&gt; //; <span class="nb">last first</span>.
  near: x2; <span class="nb">apply</span>/(fh _ (to_set ((_^-<span class="mi">1</span>)%classic) _)).
  <span class="bp">exact</span>: nbhs_entourage (entourage_inv _).
<span class="nb">apply</span>: (entourage_split (g x2)) =&gt; //; <span class="nb">move</span>: (x2); [near: x1|near: y1].
  <span class="nb">have</span> /cvg_fct_entourageP /(_ (_^-<span class="mi">1</span>)%classic) := fg; <span class="nb">apply</span>.
  <span class="bp">exact</span>: entourage_inv.
<span class="bp">by</span> <span class="nb">have</span> /cvg_fct_entourageP := fg; <span class="nb">apply</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_switch</span> {<span class="nv">U</span> : completeType}
  <span class="nv">F1</span> (<span class="nv">FF1</span> : ProperFilter F1) <span class="nv">F2</span> (<span class="nv">FF2</span> : ProperFilter F2)
  (<span class="nv">f</span> : T1 -&gt; T2 -&gt; U) (<span class="nv">g</span> : T2 -&gt; U) (<span class="nv">h</span> : T1 -&gt; U) :
  f @ F1 --&gt; g -&gt; (<span class="kr">forall</span> <span class="nv">x1</span>, f x1 @ F2 --&gt; h x1) -&gt;
  <span class="kr">exists</span> <span class="nv">l</span> : U, h @ F1 --&gt; l /\ g @ F2 --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Hfg Hfh; <span class="nb">have</span> hcv := !! cvg_switch_2 Hfg Hfh.
<span class="bp">by</span> <span class="kr">exists</span> [lim h @ F1 <span class="kr">in</span> U]; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>: cvg_switch_1 Hfg Hfh hcv.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Cvg_switch</span>.</span></pre><div class="doc">
<a id="lab22"></a><h2 class="section">Complete pseudoMetric spaces</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">cauchy_ex</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">T</span> : pseudoMetricType R} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :=
  <span class="kr">forall</span> <span class="nv">eps</span> : R, <span class="mi">0</span> &lt; eps -&gt; <span class="kr">exists</span> <span class="nv">x</span>, F (ball x eps).

<span class="kn">Definition</span> <span class="nf">cauchy_ball</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">T</span> : pseudoMetricType R} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :=
  <span class="kr">forall</span> <span class="nv">e</span>, e &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">x</span> &amp; y \near F, ball x e y.

<span class="kn">Lemma</span> <span class="nf">cauchy_ballP</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">T</span>  : pseudoMetricType R)
    (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : Filter F) :
  cauchy_ball F &lt;-&gt; cauchy F.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; cauchyF; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; _/posnumP[eps]; <span class="nb">apply</span>/cauchyF/entourage_ball.
<span class="nb">move</span>=&gt; U; <span class="nb">rewrite</span> -entourage_ballE =&gt; - [_/posnumP[eps] xyepsU].
<span class="bp">by</span> near <span class="kp">do</span> <span class="nb">apply</span>: xyepsU; <span class="nb">apply</span>: cauchyF.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> cauchy_ballP {R T} F {FF}.

<span class="kn">Lemma</span> <span class="nf">cauchy_exP</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : pseudoMetricType R)
    (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : Filter F) :
  cauchy_ex F -&gt; cauchy F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Fc A; <span class="nb">rewrite</span> !nbhs_simpl /= -entourage_ballE =&gt; -[_/posnumP[e] sdeA].
<span class="nb">have</span> /Fc [z /= Fze] := [gt0 of e%:num / <span class="mi">2</span>]; near=&gt; x y; <span class="nb">apply</span>: sdeA =&gt; /=.
<span class="bp">by</span> <span class="nb">apply</span>: (@ball_splitr _ _ z); [near: x|near: y].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> cauchy_exP {R T} F {FF}.

<span class="kn">Lemma</span> <span class="nf">cauchyP</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">T</span> : pseudoMetricType R)
    (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">PF</span> : ProperFilter F) :
  cauchy F &lt;-&gt; cauchy_ex F.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [Fcauchy _/posnumP[e] |/cauchy_exP//].
near F =&gt; x; <span class="kr">exists</span> <span class="nv">x</span>; near: x; <span class="nb">apply</span>: (@nearP_dep _ _ F F).
<span class="bp">exact</span>/Fcauchy/entourage_ball.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> cauchyP {R T} F {PF}.

<span class="kn">Module</span> <span class="nf">CompletePseudoMetric</span>.
<span class="kn">Section</span> <span class="nf">ClassDef</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : numDomainType.
<span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">T</span> : <span class="kt">Type</span>) := <span class="kn">Class</span> {
  base : PseudoMetric.class_of R T;
  mixin : Complete.axiom (Uniform.Pack base)
}.
<span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; PseudoMetric.class_of.
<span class="kn">Definition</span> <span class="nf">base2</span> <span class="nv">T</span> <span class="nv">m</span> := Complete.<span class="kn">Class</span> (@mixin T m).
<span class="kn">Local Coercion</span> <span class="nf">base2</span> : class_of &gt;-&gt; Complete.class_of.

<span class="kn">Structure</span> <span class="nf">type</span> := Pack { sort; _ : class_of sort }.
<span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type).
<span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of cT <span class="kr">in</span> c.
<span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack T c.
<span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.
<span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of xT).
<span class="kn">Definition</span> <span class="nf">pack</span> :=
  <span class="kr">fun</span> <span class="nv">bT</span> <span class="nv">b</span> &amp; phant_id (@PseudoMetric.class R bT) (b : PseudoMetric.class_of R T) =&gt;
  <span class="kr">fun</span> <span class="nv">mT</span> <span class="nv">m</span> &amp; phant_id (Complete.class mT) (@Complete.<span class="kn">Class</span> <span class="nf">T</span> <span class="nv">b</span> <span class="nv">m</span>) =&gt;
  Pack (@<span class="kn">Class</span> <span class="nf">T</span> <span class="nv">b</span> <span class="nv">m</span>).
<span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">pointedType</span> := @Pointed.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">filteredType</span> := @Filtered.Pack cT cT xclass.
<span class="kn">Definition</span> <span class="nf">topologicalType</span> := @Topological.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">uniformType</span> := @Uniform.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">completeType</span> := @Complete.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetricType</span> := @PseudoMetric.Pack R cT xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetric_completeType</span> := @Complete.Pack pseudoMetricType xclass.
<span class="kn">End</span> <span class="nf">ClassDef</span>.
<span class="kn">Module</span> <span class="nf">Exports</span>.
<span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; PseudoMetric.class_of.
<span class="kn">Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; Complete.axiom.
<span class="kn">Coercion</span> <span class="nf">base2</span> : class_of &gt;-&gt; Complete.class_of.
<span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.
<span class="kn">Canonical</span> <span class="nf">eqType</span>.
<span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.
<span class="kn">Canonical</span> <span class="nf">choiceType</span>.
<span class="kn">Coercion</span> <span class="nf">pointedType</span> : type &gt;-&gt; Pointed.type.
<span class="kn">Canonical</span> <span class="nf">pointedType</span>.
<span class="kn">Coercion</span> <span class="nf">filteredType</span> : type &gt;-&gt; Filtered.type.
<span class="kn">Canonical</span> <span class="nf">filteredType</span>.
<span class="kn">Coercion</span> <span class="nf">topologicalType</span> : type &gt;-&gt; Topological.type.
<span class="kn">Canonical</span> <span class="nf">topologicalType</span>.
<span class="kn">Coercion</span> <span class="nf">uniformType</span> : type &gt;-&gt; Uniform.type.
<span class="kn">Canonical</span> <span class="nf">uniformType</span>.
<span class="kn">Coercion</span> <span class="nf">completeType</span> : type &gt;-&gt; Complete.type.
<span class="kn">Canonical</span> <span class="nf">completeType</span>.
<span class="kn">Coercion</span> <span class="nf">pseudoMetricType</span> : type &gt;-&gt; PseudoMetric.type.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_completeType</span>.
<span class="kn">Notation</span> <span class="nf">completePseudoMetricType</span> := type.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;completePseudoMetricType&#39; &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> :=  (@clone T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;completePseudoMetricType&#39;  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;completePseudoMetricType&#39; &#39;of&#39; T ]&quot;</span> := (@clone T _ _ id)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;completePseudoMetricType&#39;  &#39;of&#39;  T ]&quot;</span>) : form_scope.
<span class="kn">Notation</span> <span class="nf">CompletePseudoMetricType</span> T m := (@pack _ T _ _ id _ _ id).
<span class="kn">End</span> <span class="nf">Exports</span>.
<span class="kn">End</span> <span class="nf">CompletePseudoMetric</span>.
<span class="kn">Export</span> CompletePseudoMetric.Exports.

<span class="kn">Canonical</span> <span class="nf">matrix_completePseudoMetricType</span> (R : numFieldType)
  (T : completePseudoMetricType R) (m n : nat) :=
  CompletePseudoMetricType &#39;M[T]_(m, n) mx_complete.

<span class="kn">Canonical</span> <span class="nf">fct_completePseudoMetricType</span> (T : choiceType) (R : numFieldType)
  (U : completePseudoMetricType R) :=
  CompletePseudoMetricType (T -&gt; U) fun_complete.

<span class="kn">Definition</span> <span class="nf">pointed_of_zmodule</span> (<span class="nv">R</span> : zmodType) : pointedType := PointedType R <span class="mi">0</span>.

<span class="kn">Definition</span> <span class="nf">ball_</span>
  (<span class="nv">R</span> : numDomainType) (<span class="nv">V</span> : zmodType) (<span class="nv">norm</span> : V -&gt; R) (<span class="nv">x</span> : V) (<span class="nv">e</span> : R) :=
  [<span class="nb">set</span> y | norm (x - y) &lt; e].
<span class="kn">Arguments</span> ball_ {R} {V} norm x e%R y /.

<span class="kn">Lemma</span> <span class="nf">subset_ball_prop_in_itv</span> (<span class="nv">R</span> : realDomainType) (<span class="nv">x</span> : R) <span class="nv">e</span> <span class="nv">P</span> :
  (ball_ Num.Def.normr x e `&lt;=` P)%classic &lt;-&gt;
  {<span class="kr">in</span> `](x - e), (x + e)[, <span class="kr">forall</span> <span class="nv">y</span>, P y}.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>=&gt; exP y /=; <span class="nb">rewrite</span> <span class="nl">?in_itv</span> (ltr_distlC, =^~ltr_distlC); <span class="nb">apply</span>: exP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subset_ball_prop_in_itvcc</span> (<span class="nv">R</span> : realDomainType) (<span class="nv">x</span> : R) <span class="nv">e</span> <span class="nv">P</span> : <span class="mi">0</span> &lt; e -&gt;
  (ball_ Num.Def.normr x (<span class="mi">2</span> * e) `&lt;=` P)%classic -&gt;
  {<span class="kr">in</span> `[(x - e), (x + e)], <span class="kr">forall</span> <span class="nv">y</span>, P y}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; e_gt0 PP y; <span class="nb">rewrite</span> in_itv/= -ler_distlC =&gt; ye; <span class="nb">apply</span>: PP =&gt; /=.
<span class="bp">by</span> <span class="nb">rewrite</span> (le_lt_trans ye)// ltr_pmull// ltr1n.
<span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">ball_filter</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">t</span> : R) : Filter
  [<span class="nb">set</span> P | <span class="kr">exists2</span> i : R, <span class="mi">0</span> &lt; i &amp; ball_ Num.norm t i `&lt;=` P].
<span class="kn">Proof</span>.
<span class="nb">apply</span> Build_Filter; [<span class="bp">by</span> <span class="kr">exists</span> <span class="mi">1</span> | <span class="nb">move</span>=&gt; P Q | <span class="nb">move</span>=&gt; P Q PQ]; <span class="nb">rewrite</span> /mkset.
- <span class="nb">move</span>=&gt; -[x x0 xP] [y ? yQ]; <span class="kr">exists</span> (<span class="nv">Num</span>.min x y); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> lt_minr x0.
  <span class="nb">move</span>=&gt; z tz; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">apply</span> xP; <span class="nb">rewrite</span> /= (lt_le_trans tz) // le_minl lexx.
  <span class="bp">by</span> <span class="nb">apply</span> yQ; <span class="nb">rewrite</span> /= (lt_le_trans tz) // le_minl lexx orbT.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; -[x ? xP]; <span class="kr">exists</span> <span class="nv">x</span> =&gt; //; <span class="nb">apply</span>: (subset_trans xP).
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">filtered_of_normedZmod</span> (<span class="nv">K</span> : numDomainType) (<span class="nv">R</span> : normedZmodType K)
  : filteredType R := Filtered.Pack (Filtered.<span class="kn">Class</span>
    (@Pointed.class (pointed_of_zmodule R))
    (nbhs_ball_ (ball_ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|x|)))).

<span class="kn">Section</span> <span class="nf">pseudoMetric_of_normedDomain</span>.
<span class="kn">Variables</span> (<span class="nv">K</span> : numDomainType) (<span class="nv">R</span> : normedZmodType K).
<span class="kn">Lemma</span> <span class="nf">ball_norm_center</span> (<span class="nv">x</span> : R) (<span class="nv">e</span> : K) : <span class="mi">0</span> &lt; e -&gt; ball_ Num.norm x e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? /=; <span class="nb">rewrite</span> subrr normr0. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">ball_norm_symmetric</span> (<span class="nv">x</span> <span class="nv">y</span> : R) (<span class="nv">e</span> : K) :
  ball_ Num.norm x e y -&gt; ball_ Num.norm y e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /= distrC. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">ball_norm_triangle</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : R) (<span class="nv">e1</span> <span class="nv">e2</span> : K) :
  ball_ Num.norm x e1 y -&gt; ball_ Num.norm y e2 z -&gt; ball_ Num.norm x (e1 + e2) z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /= ? ?; <span class="nb">rewrite</span> -(subr0 x) -(subrr y) opprD opprK (addrA x _ y) -addrA.
<span class="bp">by</span> <span class="nb">rewrite</span> (le_lt_trans (ler_norm_add _ _)) // ltr_add.
<span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">pseudoMetric_of_normedDomain</span>
  : PseudoMetric.mixin_of K (@entourage_ K R R (ball_ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|x|)))
  := PseudoMetricMixin ball_norm_center ball_norm_symmetric ball_norm_triangle erefl.
<span class="kn">Lemma</span> <span class="nf">nbhs_ball_normE</span> :
  @nbhs_ball_ K R R (ball_ Num.norm) = nbhs_ (entourage_ (ball_ Num.norm)).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /nbhs_ entourage_E predeq2E =&gt; x A; <span class="nb">split</span>.
  <span class="nb">move</span>=&gt; [e egt0 sbeA].
  <span class="bp">by</span> <span class="kr">exists</span> [<span class="nb">set</span> xy | ball_ Num.norm xy.<span class="mi">1</span> e xy.<span class="mi">2</span>] =&gt; //; <span class="kr">exists</span> <span class="nv">e</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [E [e egt0 sbeE] sEA]; <span class="kr">exists</span> <span class="nv">e</span> =&gt; // ??; <span class="nb">apply</span>/sEA/sbeE.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">pseudoMetric_of_normedDomain</span>.

<span class="kn">Module</span> <span class="nf">regular_topology</span>.

<span class="kn">Section</span> <span class="nf">regular_topology</span>.
<span class="kn">Local Canonical</span> <span class="nf">pointedType</span> (R : zmodType) : pointedType :=
  [pointedType of R^o <span class="kr">for</span> pointed_of_zmodule R].
<span class="kn">Local Canonical</span> <span class="nf">filteredType</span> (R : numDomainType) : filteredType R :=
  [filteredType R of R^o <span class="kr">for</span> filtered_of_normedZmod R].
<span class="kn">Local Canonical</span> <span class="nf">topologicalType</span> (R : numFieldType) : topologicalType :=
  TopologicalType R^o (topologyOfEntourageMixin (uniformityOfBallMixin
      (@nbhs_ball_normE _ _) (pseudoMetric_of_normedDomain _))).
<span class="kn">Local Canonical</span> <span class="nf">uniformType</span> (R : numFieldType) : uniformType :=
  UniformType R^o (uniformityOfBallMixin
                     (@nbhs_ball_normE _ _) (pseudoMetric_of_normedDomain _)).
<span class="kn">Local Canonical</span> <span class="nf">pseudoMetricType</span> (R : numFieldType) :=
  PseudoMetricType R^o (@pseudoMetric_of_normedDomain R R).
<span class="kn">End</span> <span class="nf">regular_topology</span>.

<span class="kn">Module</span> <span class="nf">Exports</span>.
<span class="kn">Canonical</span> <span class="nf">pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricType</span>.
<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">regular_topology</span>.
<span class="kn">Export</span> regular_topology.Exports.

<span class="kn">Module</span> <span class="nf">numFieldTopology</span>.

<span class="kn">Section</span> <span class="nf">realType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : realType).
<span class="kn">Local Canonical</span> <span class="nf">real_pointedType</span> := [pointedType of R <span class="kr">for</span> [pointedType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_filteredType</span> :=
  [filteredType R of R <span class="kr">for</span> [filteredType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_topologicalType</span> :=
  [topologicalType of R <span class="kr">for</span> [topologicalType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_uniformType</span> := [uniformType of R <span class="kr">for</span> [uniformType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_pseudoMetricType</span> :=
  [pseudoMetricType R of R <span class="kr">for</span> [pseudoMetricType R of R^o]].
<span class="kn">End</span> <span class="nf">realType</span>.

<span class="kn">Section</span> <span class="nf">rcfType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : rcfType).
<span class="kn">Local Canonical</span> <span class="nf">rcf_pointedType</span> := [pointedType of R <span class="kr">for</span> [pointedType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_filteredType</span> :=
  [filteredType R of R <span class="kr">for</span> [filteredType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_topologicalType</span> :=
  [topologicalType of R <span class="kr">for</span> [topologicalType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_uniformType</span> := [uniformType of R <span class="kr">for</span> [uniformType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_pseudoMetricType</span> :=
  [pseudoMetricType R of R <span class="kr">for</span> [pseudoMetricType R of R^o]].
<span class="kn">End</span> <span class="nf">rcfType</span>.

<span class="kn">Section</span> <span class="nf">archiFieldType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : archiFieldType).
<span class="kn">Local Canonical</span> <span class="nf">archiField_pointedType</span> :=
  [pointedType of R <span class="kr">for</span> [pointedType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_filteredType</span> :=
  [filteredType R of R <span class="kr">for</span> [filteredType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_topologicalType</span> :=
  [topologicalType of R <span class="kr">for</span> [topologicalType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_uniformType</span> :=
  [uniformType of R <span class="kr">for</span> [uniformType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_pseudoMetricType</span> :=
  [pseudoMetricType R of R <span class="kr">for</span> [pseudoMetricType R of R^o]].
<span class="kn">End</span> <span class="nf">archiFieldType</span>.

<span class="kn">Section</span> <span class="nf">realFieldType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : realFieldType).
<span class="kn">Local Canonical</span> <span class="nf">realField_pointedType</span> :=
  [pointedType of R <span class="kr">for</span> [pointedType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_filteredType</span> :=
  [filteredType R of R <span class="kr">for</span> [filteredType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_topologicalType</span> :=
  [topologicalType of R <span class="kr">for</span> [topologicalType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_uniformType</span> :=
  [uniformType of R <span class="kr">for</span> [uniformType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_pseudoMetricType</span> :=
  [pseudoMetricType R of R <span class="kr">for</span> [pseudoMetricType R of R^o]].
<span class="kn">Definition</span> <span class="nf">pointed_latticeType</span> := [latticeType of realField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_distrLatticeType</span> :=
  [distrLatticeType of realField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_orderType</span> := [orderType of realField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_realDomainType</span> :=
  [realDomainType of realField_pointedType].
<span class="kn">Definition</span> <span class="nf">filtered_latticeType</span> := [latticeType of realField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_distrLatticeType</span> :=
  [distrLatticeType of realField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_orderType</span> := [orderType of realField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_realDomainType</span> :=
  [realDomainType of realField_filteredType].
<span class="kn">Definition</span> <span class="nf">topological_latticeType</span> :=
  [latticeType of realField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_distrLatticeType</span> :=
  [distrLatticeType of realField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_orderType</span> := [orderType of realField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_realDomainType</span> :=
  [realDomainType of realField_topologicalType].
<span class="kn">Definition</span> <span class="nf">uniform_latticeType</span> := [latticeType of realField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_distrLatticeType</span> :=
  [distrLatticeType of realField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_orderType</span> := [orderType of realField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_realDomainType</span> := [realDomainType of realField_uniformType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_latticeType</span> :=
  [latticeType of realField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_distrLatticeType</span> :=
  [distrLatticeType of realField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_orderType</span> := [orderType of realField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_realDomainType</span> :=
  [realDomainType of realField_pseudoMetricType].
<span class="kn">End</span> <span class="nf">realFieldType</span>.

<span class="kn">Section</span> <span class="nf">numClosedFieldType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : numClosedFieldType).
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_pointedType</span> :=
  [pointedType of R <span class="kr">for</span> [pointedType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_filteredType</span> :=
  [filteredType R of R <span class="kr">for</span> [filteredType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_topologicalType</span> :=
  [topologicalType of R <span class="kr">for</span> [topologicalType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_uniformType</span> :=
  [uniformType of R <span class="kr">for</span> [uniformType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_pseudoMetricType</span> :=
  [pseudoMetricType R of R <span class="kr">for</span> [pseudoMetricType R of R^o]].
<span class="kn">Definition</span> <span class="nf">pointed_decFieldType</span> :=
  [decFieldType of numClosedField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_closedFieldType</span> :=
  [closedFieldType of numClosedField_pointedType].
<span class="kn">Definition</span> <span class="nf">filtered_decFieldType</span> :=
  [decFieldType of numClosedField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_closedFieldType</span> :=
  [closedFieldType of numClosedField_filteredType].
<span class="kn">Definition</span> <span class="nf">topological_decFieldType</span> :=
  [decFieldType of numClosedField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_closedFieldType</span> :=
  [closedFieldType of numClosedField_topologicalType].
<span class="kn">Definition</span> <span class="nf">uniform_decFieldType</span> := [decFieldType of numClosedField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_closedFieldType</span> :=
  [closedFieldType of numClosedField_uniformType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_decFieldType</span> :=
  [decFieldType of numClosedField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_closedFieldType</span> :=
  [closedFieldType of numClosedField_pseudoMetricType].
<span class="kn">End</span> <span class="nf">numClosedFieldType</span>.

<span class="kn">Section</span> <span class="nf">numFieldType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : numFieldType).
<span class="kn">Local Canonical</span> <span class="nf">numField_pointedType</span> :=
  [pointedType of R <span class="kr">for</span> [pointedType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_filteredType</span> :=
  [filteredType R of R <span class="kr">for</span> [filteredType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_topologicalType</span> :=
  [topologicalType of R <span class="kr">for</span> [topologicalType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_uniformType</span> :=
  [uniformType of R <span class="kr">for</span> [uniformType of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_pseudoMetricType</span> :=
  [pseudoMetricType R of R <span class="kr">for</span> [pseudoMetricType R of R^o]].
<span class="kn">Definition</span> <span class="nf">pointed_ringType</span> := [ringType of numField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_comRingType</span> := [comRingType of numField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_unitRingType</span> := [unitRingType of numField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_comUnitRingType</span> := [comUnitRingType of numField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_idomainType</span> := [idomainType of numField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_fieldType</span> := [fieldType of numField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_porderType</span> := [porderType of numField_pointedType].
<span class="kn">Definition</span> <span class="nf">pointed_numDomainType</span> := [numDomainType of numField_pointedType].
<span class="kn">Definition</span> <span class="nf">filtered_ringType</span> := [ringType of numField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_comRingType</span> := [comRingType of numField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_unitRingType</span> := [unitRingType of numField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_comUnitRingType</span> :=
  [comUnitRingType of numField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_idomainType</span> := [idomainType of numField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_fieldType</span> := [fieldType of numField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_porderType</span> := [porderType of numField_filteredType].
<span class="kn">Definition</span> <span class="nf">filtered_numDomainType</span> := [numDomainType of numField_filteredType].
<span class="kn">Definition</span> <span class="nf">topological_ringType</span> := [ringType of numField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_comRingType</span> := [comRingType of numField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_unitRingType</span> :=
  [unitRingType of numField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_comUnitRingType</span> :=
  [comUnitRingType of numField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_idomainType</span> := [idomainType of numField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_fieldType</span> := [fieldType of numField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_porderType</span> := [porderType of numField_topologicalType].
<span class="kn">Definition</span> <span class="nf">topological_numDomainType</span> :=
  [numDomainType of numField_topologicalType].
<span class="kn">Definition</span> <span class="nf">uniform_ringType</span> := [ringType of numField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_comRingType</span> := [comRingType of numField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_unitRingType</span> := [unitRingType of numField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_comUnitRingType</span> := [comUnitRingType of numField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_idomainType</span> := [idomainType of numField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_fieldType</span> := [fieldType of numField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_porderType</span> := [porderType of numField_uniformType].
<span class="kn">Definition</span> <span class="nf">uniform_numDomainType</span> := [numDomainType of numField_uniformType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_ringType</span> := [ringType of numField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_comRingType</span> :=
  [comRingType of numField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_unitRingType</span> :=
  [unitRingType of numField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_comUnitRingType</span> :=
  [comUnitRingType of numField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_idomainType</span> :=
  [idomainType of numField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_fieldType</span> := [fieldType of numField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_porderType</span> := [porderType of numField_pseudoMetricType].
<span class="kn">Definition</span> <span class="nf">pseudoMetric_numDomainType</span> :=
  [numDomainType of numField_pseudoMetricType].
<span class="kn">End</span> <span class="nf">numFieldType</span>.

<span class="kn">Module</span> <span class="nf">Exports</span>.
<span class="c">(* realType *)</span>
<span class="kn">Canonical</span> <span class="nf">real_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">real_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">real_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">real_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">real_pseudoMetricType</span>.
<span class="kn">Coercion</span> <span class="nf">real_pointedType</span> : realType &gt;-&gt; pointedType.
<span class="kn">Coercion</span> <span class="nf">real_filteredType</span> : realType &gt;-&gt; filteredType.
<span class="kn">Coercion</span> <span class="nf">real_topologicalType</span> : realType &gt;-&gt; topologicalType.
<span class="kn">Coercion</span> <span class="nf">real_uniformType</span> : realType &gt;-&gt; uniformType.
<span class="kn">Coercion</span> <span class="nf">real_pseudoMetricType</span> : realType &gt;-&gt; pseudoMetricType.
<span class="c">(* rcfType *)</span>
<span class="kn">Canonical</span> <span class="nf">rcf_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_pseudoMetricType</span>.
<span class="kn">Coercion</span> <span class="nf">rcf_pointedType</span> : rcfType &gt;-&gt; pointedType.
<span class="kn">Coercion</span> <span class="nf">rcf_filteredType</span> : rcfType &gt;-&gt; filteredType.
<span class="kn">Coercion</span> <span class="nf">rcf_topologicalType</span> : rcfType &gt;-&gt; topologicalType.
<span class="kn">Coercion</span> <span class="nf">rcf_uniformType</span> : rcfType &gt;-&gt; uniformType.
<span class="kn">Coercion</span> <span class="nf">rcf_pseudoMetricType</span> : rcfType &gt;-&gt; pseudoMetricType.
<span class="c">(* archiFieldType *)</span>
<span class="kn">Canonical</span> <span class="nf">archiField_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_pseudoMetricType</span>.
<span class="kn">Coercion</span> <span class="nf">archiField_pointedType</span> : archiFieldType &gt;-&gt; pointedType.
<span class="kn">Coercion</span> <span class="nf">archiField_filteredType</span> : archiFieldType &gt;-&gt; filteredType.
<span class="kn">Coercion</span> <span class="nf">archiField_topologicalType</span> : archiFieldType &gt;-&gt; topologicalType.
<span class="kn">Coercion</span> <span class="nf">archiField_uniformType</span> : archiFieldType &gt;-&gt; uniformType.
<span class="kn">Coercion</span> <span class="nf">archiField_pseudoMetricType</span> : archiFieldType &gt;-&gt; pseudoMetricType.
<span class="c">(* realFieldType *)</span>
<span class="kn">Canonical</span> <span class="nf">realField_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_realDomainType</span>.
<span class="kn">Coercion</span> <span class="nf">realField_pointedType</span> : realFieldType &gt;-&gt; pointedType.
<span class="kn">Coercion</span> <span class="nf">realField_filteredType</span> : realFieldType &gt;-&gt; filteredType.
<span class="kn">Coercion</span> <span class="nf">realField_topologicalType</span> : realFieldType &gt;-&gt; topologicalType.
<span class="kn">Coercion</span> <span class="nf">realField_uniformType</span> : realFieldType &gt;-&gt; uniformType.
<span class="kn">Coercion</span> <span class="nf">realField_pseudoMetricType</span> : realFieldType &gt;-&gt; pseudoMetricType.
<span class="c">(* numClosedFieldType *)</span>
<span class="kn">Canonical</span> <span class="nf">numClosedField_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_closedFieldType</span>.
<span class="kn">Coercion</span> <span class="nf">numClosedField_pointedType</span> : numClosedFieldType &gt;-&gt; pointedType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_filteredType</span> : numClosedFieldType &gt;-&gt; filteredType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_topologicalType</span> :
  numClosedFieldType &gt;-&gt; topologicalType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_uniformType</span> : numClosedFieldType &gt;-&gt; uniformType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_pseudoMetricType</span> :
  numClosedFieldType &gt;-&gt; pseudoMetricType.
<span class="c">(* numFieldType *)</span>
<span class="kn">Canonical</span> <span class="nf">numField_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_ringType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_comRingType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_unitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_comUnitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_idomainType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_fieldType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_ringType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_comRingType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_unitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_comUnitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_idomainType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_fieldType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_ringType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_comRingType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_unitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_comUnitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_idomainType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_fieldType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_ringType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_comRingType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_unitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_comUnitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_idomainType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_fieldType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_ringType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_comRingType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_unitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_comUnitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_idomainType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_fieldType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_numDomainType</span>.
<span class="kn">Coercion</span> <span class="nf">numField_pointedType</span> : numFieldType &gt;-&gt; pointedType.
<span class="kn">Coercion</span> <span class="nf">numField_filteredType</span> : numFieldType &gt;-&gt; filteredType.
<span class="kn">Coercion</span> <span class="nf">numField_topologicalType</span> : numFieldType &gt;-&gt; topologicalType.
<span class="kn">Coercion</span> <span class="nf">numField_uniformType</span> : numFieldType &gt;-&gt; uniformType.
<span class="kn">Coercion</span> <span class="nf">numField_pseudoMetricType</span> : numFieldType &gt;-&gt; pseudoMetricType.
<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">numFieldTopology</span>.
<span class="kn">Import</span> numFieldTopology.Exports.

<span class="kn">Global Instance</span> <span class="nf">Proper_dnbhs_regular_numFieldType</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">x</span> : R^o) :
  ProperFilter x^&#39;.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: Build_ProperFilter =&gt; A /nbhs_ballP[_/posnumP[e] Ae].
<span class="kr">exists</span> (<span class="nv">x</span> + e%:num / <span class="mi">2</span>)%R; <span class="nb">apply</span>: Ae; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym addrC -subr_eq subrr eq_sym.
<span class="nb">rewrite</span> /ball /= opprD addrA subrr distrC subr0 ger0_norm //.
<span class="bp">by</span> <span class="nb">rewrite</span> {<span class="mi">2</span>}(splitr e%:num) ltr_spaddl.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">RestrictedUniformTopology</span>.
<span class="kn">Context</span> {<span class="nv">U</span> : choiceType} (<span class="nv">A</span> : <span class="nb">set</span> U) {<span class="nv">V</span> : uniformType} .

<span class="kn">Definition</span> <span class="nf">fct_RestrictedUniform</span> := <span class="kr">let</span> <span class="nv">_</span> := A <span class="kr">in</span> U -&gt; V.
<span class="kn">Definition</span> <span class="nf">fct_RestrictedUniformTopology</span> :=
  @weak_uniformType
    ([pointedType of @fct_RestrictedUniform])
    (fct_uniformType [choiceType of { x : U | x \<span class="kr">in</span> A }] V)
    (@sigL U V A).

<span class="kn">Canonical</span> <span class="nf">fct_RestrictUniformFilteredType</span>:=
  [filteredType fct_RestrictedUniform of
      fct_RestrictedUniform <span class="kr">for</span>
      fct_RestrictedUniformTopology].

<span class="kn">Canonical</span> <span class="nf">fct_RestrictUniformTopologicalType</span> :=
  [topologicalType of fct_RestrictedUniform <span class="kr">for</span> fct_RestrictedUniformTopology].

<span class="kn">Canonical</span> <span class="nf">fct_restrictedUniformType</span> :=
  [uniformType of fct_RestrictedUniform <span class="kr">for</span> fct_RestrictedUniformTopology].

<span class="kn">Lemma</span> <span class="nf">uniform_nbhs</span> (<span class="nv">f</span> : fct_RestrictedUniformTopology) <span class="nv">P</span>:
  nbhs f P &lt;-&gt; (<span class="kr">exists</span> <span class="nv">E</span>, entourage E /\
    [<span class="nb">set</span> h | <span class="kr">forall</span> <span class="nv">y</span>, A y -&gt; E(f y, h y)] `&lt;=` P).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [[Q [[/= W oW &lt;- /=] Wf subP]]|[E [entE subP]]].
  <span class="nb">rewrite</span> openE /= /interior <span class="kr">in</span> oW.
  <span class="nb">case</span>: (oW _ Wf) =&gt; ? [ /= E entE] Esub subW.
  <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span>=&gt; // h Eh; <span class="nb">apply</span>/subP/subW/Esub =&gt; /= [[u Au]].
  <span class="bp">by</span> <span class="nb">apply</span>: Eh =&gt; /=; <span class="nb">rewrite</span> -inE.
near=&gt; g; <span class="nb">apply</span>: subP =&gt; y /mem_set Ay; <span class="nb">rewrite</span> -!(sigLE A).
<span class="nb">move</span>: (SigSub _); near: g.
<span class="nb">have</span> := (@cvg_image _ _ (sigL A) _ f (nbhs_filter f)
  (image_sigL point)).<span class="mi">1</span> cvg_id [<span class="nb">set</span> h | <span class="kr">forall</span> <span class="nv">y</span>, E (sigL A f y, h y)].
<span class="nb">case</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> [<span class="nb">set</span> fg | <span class="kr">forall</span> <span class="nv">y</span>, E (fg.<span class="mi">1</span> y, fg.<span class="mi">2</span> y)]; [<span class="kr">exists</span> <span class="nv">E</span>|].
<span class="nb">move</span>=&gt; B nbhsB rBrE; <span class="nb">apply</span>: (filterS _ nbhsB) =&gt; g Bg [y yA].
<span class="bp">by</span> <span class="nb">move</span>: rBrE; <span class="nb">rewrite</span> eqEsubset; <span class="nb">case</span> =&gt; [+ _]; <span class="nb">apply</span>; <span class="kr">exists</span> <span class="nv">g</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">uniform_entourage</span> :
  @entourage fct_restrictedUniformType =
  filter_from
    (@entourage V)
    (<span class="kr">fun</span> <span class="nv">P</span> =&gt; [<span class="nb">set</span> fg | <span class="kr">forall</span> <span class="nv">t</span> : U, A t -&gt; P (fg.<span class="mi">1</span> t, fg.<span class="mi">2</span> t)]).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; P /=.
  <span class="nb">case</span>=&gt; /= E [F entF FsubE EsubP]; <span class="kr">exists</span> <span class="nv">F</span> =&gt; //; <span class="nb">case</span>=&gt; f g Ffg.
  <span class="bp">by</span> <span class="nb">apply</span>/EsubP/FsubE=&gt; [[x p]] /=; <span class="nb">apply</span>: Ffg; <span class="nb">move</span>/set_mem: (p).
<span class="nb">case</span>=&gt; E entE EsubP; <span class="kr">exists</span> [<span class="nb">set</span> fg | <span class="kr">forall</span> <span class="nv">t</span>, E (fg.<span class="mi">1</span> t, fg.<span class="mi">2</span> t)].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">E</span>.
<span class="nb">case</span>=&gt; f g Efg; <span class="nb">apply</span>: EsubP =&gt; t /mem_set At.
<span class="bp">by</span> <span class="nb">move</span>: Efg =&gt; /= /(_ (@exist _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; in_mem x (mem A)) _ At)).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">RestrictedUniformTopology</span>.

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;uniform`&#39; A -&gt; V }&quot;</span> := (@fct_RestrictedUniform _ A V) :
  classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;uniform&#39; U -&gt; V }&quot;</span> := ({uniform` [<span class="nb">set</span>: U] -&gt; V}) :
  classical_set_scope.

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;uniform&#39; A , F --&gt; f }&quot;</span> :=
  (cvg_to [filter of F]
     (filter_of (Phantom (fct_RestrictedUniform A) f)))
   : classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;uniform&#39; , F --&gt; f }&quot;</span> :=
  (cvg_to [filter of F]
     (filter_of (Phantom (fct_RestrictedUniform setT) f)))
   : classical_set_scope.

<span class="c">(* We use this function to help coq identify the correct notation to use</span>
<span class="c">   when printing. Otherwise you get goals like `F --&gt; f -&gt; F --&gt; f`      *)</span>

<span class="kn">Lemma</span> <span class="nf">restricted_cvgE</span> {<span class="nv">U</span> : choiceType} {<span class="nv">V</span> : uniformType}
    (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) <span class="nv">A</span> (<span class="nv">f</span> : U -&gt; V) :
  {uniform A, F --&gt; f} = (F --&gt; (f : {uniform` A -&gt; V})).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">fct_Pointwise</span> <span class="nv">U</span> (<span class="nv">V</span>: topologicalType) := U -&gt; V.

<span class="kn">Definition</span> <span class="nf">fct_PointwiseTopology</span> (<span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">V</span> : topologicalType) :=
  @product_topologicalType U (<span class="kr">fun</span>=&gt; V).

<span class="kn">Canonical</span> <span class="nf">fct_PointwiseFilteredType</span> (U : <span class="kt">Type</span>) (V : topologicalType) :=
  [filteredType @fct_Pointwise U V of
     @fct_Pointwise U V <span class="kr">for</span>
     @fct_PointwiseTopology U V].

<span class="kn">Canonical</span> <span class="nf">fct_PointwiseTopologicalType</span> (U : <span class="kt">Type</span>) (V : topologicalType) :=
  [topologicalType of
     @fct_Pointwise U V <span class="kr">for</span>
     @fct_PointwiseTopology U V].

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;ptws&#39; U -&gt; V }&quot;</span> := (@fct_Pointwise U V).

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;ptws&#39; , F --&gt; f }&quot;</span> :=
  (cvg_to [filter of F] (filter_of (Phantom (@fct_Pointwise _ _) f)))
  : classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">pointwise_cvgE</span> {<span class="nv">U</span> : <span class="kt">Type</span>} {<span class="nv">V</span> : topologicalType}
    (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span>(U -&gt; V))) (<span class="nv">A</span> : <span class="nb">set</span> U) (<span class="nv">f</span> : U -&gt; V) :
  {ptws, F --&gt; f} = (F --&gt; (f : {ptws U -&gt; V})).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">UniformCvgLemmas</span>.
<span class="kn">Context</span> {<span class="nv">U</span> : choiceType} {<span class="nv">V</span> : uniformType}.

<span class="kn">Lemma</span> <span class="nf">uniform_set1</span> <span class="nv">F</span> (<span class="nv">f</span> : U -&gt; V) (<span class="nv">x</span> : U) :
  Filter F -&gt; {uniform [<span class="nb">set</span> x], F --&gt; f} = ((g x) @[g --&gt; F] --&gt; f x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>.
  <span class="nb">move</span>=&gt; + W =&gt; /(_ [<span class="nb">set</span> t | W (t x)]) +; <span class="nb">rewrite</span> /filter_of -nbhs_entourageE.
  <span class="nb">rewrite</span> uniform_nbhs =&gt; + [Q entQ subW].
  <span class="bp">by</span> <span class="nb">apply</span>; <span class="kr">exists</span> <span class="nv">Q</span>; <span class="nb">split</span> =&gt; // h Qf; <span class="bp">exact</span>/subW/Qf.
<span class="nb">move</span>=&gt; Ff W; <span class="nb">rewrite</span> /filter_of uniform_nbhs =&gt; [[E] [entE subW]].
<span class="nb">apply</span>: (filterS subW); <span class="nb">move</span>/(nbhs_entourage (f x))/Ff: entE =&gt; //=; near_simpl.
<span class="bp">by</span> <span class="nb">apply</span>: filter_app; <span class="nb">apply</span>: nearW=&gt; ? ? ? -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">uniform_subset_nbhs</span> (<span class="nv">f</span> : U -&gt; V) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> U) :
  B `&lt;=` A -&gt; nbhs (f : {uniform` A -&gt; V}) `=&gt;` nbhs (f : {uniform` B -&gt; V}).
<span class="kn">Proof</span>.
<span class="nb">move</span> =&gt; BsubA P /uniform_nbhs [E [entE EsubP]].
<span class="nb">apply</span>: (filterS EsubP); <span class="nb">apply</span>/uniform_nbhs; <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span> =&gt; //.
<span class="bp">by</span> <span class="nb">move</span>=&gt; h Eh y /BsubA Ay; <span class="bp">exact</span>: Eh.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">uniform_subset_cvg</span> (<span class="nv">f</span> : U -&gt; V) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> U) <span class="nv">F</span> :
  Filter F -&gt; B `&lt;=` A -&gt; {uniform A, F --&gt; f} -&gt; {uniform B, F --&gt; f}.
<span class="kn">Proof</span>.
<span class="nb">move</span> =&gt; FF /uniform_subset_nbhs =&gt; /(_ f).
<span class="bp">by</span> <span class="nb">move</span>=&gt; nbhsF Acvg; <span class="nb">apply</span>: cvg_trans; [<span class="bp">exact</span>: Acvg|<span class="bp">exact</span>: nbhsF].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pointwise_uniform_cvg</span>  (<span class="nv">f</span> : U -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) :
  Filter F -&gt; {uniform, F --&gt; f} -&gt; {ptws, F --&gt; f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">rewrite</span> cvg_sup =&gt; + i; <span class="nb">have</span> isubT : [<span class="nb">set</span> i] `&lt;=` setT <span class="bp">by</span> <span class="nb">move</span>=&gt; ?.
<span class="nb">move</span>=&gt; /(uniform_subset_cvg _ isubT); <span class="nb">rewrite</span> uniform_set1.
<span class="nb">rewrite</span> cvg_image; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; v // _; <span class="kr">exists</span> (<span class="nv">cst</span> <span class="nv">v</span>).
<span class="nb">apply</span>: cvg_trans =&gt; W /=; <span class="nb">rewrite</span> nbhs_simpl; <span class="kr">exists</span> (@^~ i @^-<span class="mi">1</span>` W) =&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> image_preimage // eqEsubset; <span class="nb">split</span>=&gt; // j _; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">_</span> =&gt; j).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_sigL</span> (<span class="nv">A</span> : <span class="nb">set</span> U) (<span class="nv">f</span> : U -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) :
    Filter F -&gt;
  {uniform A, F --&gt; f} &lt;-&gt;
  {uniform, sigL A @ F --&gt; sigL A f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">split</span>.
- <span class="nb">move</span>=&gt; cvgF P&#39; /= /uniform_nbhs [ E [/= entE EsubP]].
  <span class="nb">apply</span>: (filterS EsubP); <span class="nb">apply</span>: cvgF =&gt; /=.
  <span class="nb">apply</span>: (filterS ( P:= [<span class="nb">set</span> h | <span class="kr">forall</span> <span class="nv">y</span>, A y -&gt; E(f y, h y)])).
    + <span class="bp">by</span> <span class="nb">move</span>=&gt; h/= Eh [y ?] _; <span class="nb">apply</span> Eh; <span class="nb">rewrite</span> -inE.
    + <span class="bp">by</span> (<span class="nb">apply</span>/uniform_nbhs; <span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">eauto</span>).
- <span class="nb">move</span>=&gt; cvgF P&#39; /= /uniform_nbhs [ E [/= entE EsubP]].
  <span class="nb">apply</span>: (filterS EsubP).
  <span class="nb">move</span>: (cvgF  [<span class="nb">set</span> h | (<span class="kr">forall</span> <span class="nv">y</span> , E (sigL A f y, h y))]) =&gt; /=.
  <span class="nb">set</span> Q := (x <span class="kr">in</span> (_ -&gt; x) -&gt; _); <span class="nb">move</span>=&gt; W.
  <span class="nb">have</span>: Q <span class="bp">by</span> <span class="nb">apply</span> W, uniform_nbhs; <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span> =&gt; // h + ?; <span class="nb">apply</span>.
  <span class="nb">rewrite</span> {}/W {}/Q; near_simpl =&gt; /= R; <span class="nb">apply</span>: (filterS _ R) =&gt; h /=.
  <span class="bp">by</span> <span class="nb">rewrite</span> forall_sig /sigL /=.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_in_close</span> (<span class="nv">A</span> : <span class="nb">set</span> U) (<span class="nv">f</span> <span class="nv">g</span> : {uniform` A -&gt; V}) :
  {<span class="kr">in</span> A, f =<span class="mi">1</span> g} -&gt; close f g.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> entourage_close =&gt; /eq_sigLP eqfg ? [E entE]; <span class="nb">apply</span>=&gt; /=.
<span class="bp">by</span> <span class="nb">rewrite</span> /map_pair eqfg; <span class="bp">exact</span>: entourage_refl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">hausdorrf_close_eq_in</span> (<span class="nv">A</span> : <span class="nb">set</span> U) (<span class="nv">f</span> <span class="nv">g</span> : {uniform` A -&gt; V}) :
  hausdorff_space V -&gt; close f g = {<span class="kr">in</span> A, f =<span class="mi">1</span> g}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; hV.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: eq_in_close.
<span class="nb">rewrite</span> entourage_close =&gt; C u; <span class="nb">rewrite</span> inE =&gt; uA; <span class="nb">apply</span>: hV.
<span class="nb">rewrite</span> /cluster -nbhs_entourageE /= =&gt; X Y [X&#39; eX X&#39;X] [Y&#39; eY Y&#39;Y].
<span class="kr">exists</span> (<span class="nv">g</span> <span class="nv">u</span>); <span class="nb">split</span>; [<span class="nb">apply</span>: X&#39;X| <span class="nb">apply</span>: Y&#39;Y]; <span class="nb">last</span> <span class="bp">exact</span>: entourage_refl.
<span class="nb">apply</span>: (C [<span class="nb">set</span> fg | <span class="kr">forall</span> <span class="nv">y</span>, A y -&gt; X&#39; (fg.<span class="mi">1</span> y, fg.<span class="mi">2</span> y)]) =&gt; //=.
<span class="bp">by</span> <span class="nb">rewrite</span> uniform_entourage; <span class="kr">exists</span> <span class="nv">X&#39;</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">uniform_restrict_cvg</span>
    (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) (<span class="nv">f</span> : U -&gt; V) <span class="nv">A</span> : Filter F -&gt;
  {uniform A, F --&gt; f} &lt;-&gt; {uniform, restrict A @ F --&gt; restrict A f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">rewrite</span> cvg_sigL; <span class="nb">split</span>.
- <span class="nb">rewrite</span> -sigLK; <span class="nb">move</span>/(cvg_app valL) =&gt; D.
  <span class="nb">apply</span>: cvg_trans; <span class="kp">first</span> <span class="bp">exact</span>: D.
  <span class="nb">move</span>=&gt; P /uniform_nbhs [E [/=entE EsubP]]; <span class="nb">apply</span>: (filterS EsubP).
  <span class="nb">apply</span>/uniform_nbhs; <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span>=&gt; //= h /=.
  <span class="nb">rewrite</span> /sigL =&gt; R u _; <span class="nb">rewrite</span> oinv_set_val.
  <span class="bp">by</span> <span class="nb">case</span>: insubP=&gt; /= *; [<span class="nb">apply</span>: R|<span class="nb">apply</span>: entourage_refl].
- <span class="nb">move</span>/(@cvg_app _ _ _ _ (sigL A)).
  <span class="nb">rewrite</span> -fmap_comp sigL_restrict =&gt; D.
  <span class="nb">apply</span>: cvg_trans; <span class="kp">first</span> <span class="bp">exact</span>: D.
  <span class="nb">move</span>=&gt; P /uniform_nbhs [E [/=entE EsubP]]; <span class="nb">apply</span>: (filterS EsubP).
  <span class="nb">apply</span>/uniform_nbhs; <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span>=&gt; //= h /=.
  <span class="nb">rewrite</span> /sigL =&gt; R [u Au] _ /=.
  <span class="bp">by</span> <span class="nb">have</span> := R u I; <span class="nb">rewrite</span> /patch Au.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_uniformU</span> (<span class="nv">f</span> : U -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) <span class="nv">A</span> <span class="nv">B</span> : Filter F -&gt;
  {uniform A, F --&gt; f} -&gt; {uniform B, F --&gt; f} -&gt;
  {uniform (A `|` B), F --&gt; f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF AFf BFf Q /=/uniform_nbhs [E [entE EsubQ]].
<span class="nb">apply</span>: (filterS EsubQ).
<span class="nb">rewrite</span> (_:  [<span class="nb">set</span> h | (<span class="kr">forall</span> <span class="nv">y</span> : U, (A `|` B) y -&gt; E (f y, h y))] =
    [<span class="nb">set</span> h | <span class="kr">forall</span> <span class="nv">y</span>, A y -&gt; E (f y, h y)] `&amp;`
    [<span class="nb">set</span> h | <span class="kr">forall</span> <span class="nv">y</span>, B y -&gt; E (f y, h y)]).
- <span class="nb">apply</span> filterI; [<span class="nb">apply</span>: AFf| <span class="nb">apply</span>: BFf].
  + <span class="bp">by</span> <span class="nb">apply</span>/uniform_nbhs; <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span>.
  + <span class="bp">by</span> <span class="nb">apply</span>/uniform_nbhs; <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span>.
- <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; h.
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; R; <span class="nb">split</span>=&gt; t ?; <span class="nb">apply</span> R;[<span class="nb">left</span>| <span class="nb">right</span>].
  + <span class="bp">by</span> <span class="nb">move</span>=&gt; [R1 R2] y [? | ?]; [<span class="nb">apply</span> R1| <span class="nb">apply</span> R2].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_uniform_set0</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) (<span class="nv">f</span> : U -&gt; V) : Filter F -&gt;
  {uniform set0, F --&gt; f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF P /= /uniform_nbhs [E [? R]].
<span class="nb">suff</span> -&gt; : P = setT <span class="bp">by</span> <span class="nb">apply</span> filterT.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; //=.
<span class="bp">by</span> <span class="nb">apply</span>: subset_trans R =&gt; g _ ?.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">fct_UniformFamily</span> (<span class="nv">fam</span> : (<span class="nb">set</span> U) -&gt; <span class="kt">Prop</span>) := U -&gt; V.

<span class="kn">Definition</span> <span class="nf">family_cvg_uniformType</span> (<span class="nv">fam</span>: <span class="nb">set</span> U -&gt; <span class="kt">Prop</span>) :=
  @sup_uniformType  _
    (sigT fam)
    (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Uniform.class (@fct_restrictedUniformType U (projT1 k) V)).

<span class="kn">Canonical</span> <span class="nf">fct_UniformFamilyFilteredType</span> fam :=
  [filteredType fct_UniformFamily fam of
    fct_UniformFamily fam <span class="kr">for</span>
    family_cvg_uniformType fam].

<span class="kn">Canonical</span> <span class="nf">fct_UniformFamilyTopologicalType</span> fam :=
  [topologicalType of
     fct_UniformFamily fam <span class="kr">for</span>
     family_cvg_uniformType fam].

<span class="kn">Canonical</span> <span class="nf">fct_UniformFamilyUniformType</span> fam :=
  [uniformType of
     fct_UniformFamily fam <span class="kr">for</span>
     family_cvg_uniformType fam].

<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;{ &#39;family&#39; fam , F --&gt; f }&quot;</span> :=
  (cvg_to [filter of F] (filter_of (Phantom (fct_UniformFamily fam) f)))
  : classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">fam_cvgP</span> (<span class="nv">fam</span> : <span class="nb">set</span> U -&gt; <span class="kt">Prop</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) (<span class="nv">f</span> : U -&gt; V) :
  Filter F -&gt; {family fam, F --&gt; f} &lt;-&gt;
  (<span class="kr">forall</span> <span class="nv">A</span> : <span class="nb">set</span> U, fam A -&gt; {uniform A, F --&gt; f }).
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvg_sup + A FA; <span class="nb">move</span>/(_ (existT _ _ FA)).
<span class="bp">by</span> <span class="nb">move</span>=&gt; famFf /=; <span class="nb">apply</span>/cvg_sup =&gt; [[? ?] FA]; <span class="nb">apply</span>: famFf.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">family_cvg_subset</span> (<span class="nv">famA</span> <span class="nv">famB</span> : <span class="nb">set</span> U -&gt; <span class="kt">Prop</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V)))
    (<span class="nv">f</span> : U -&gt; V) : Filter F -&gt;
  famA `&lt;=` famB -&gt; {family famB, F --&gt; f} -&gt; {family famA, F --&gt; f}.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; FF S /fam_cvgP famBFf; <span class="nb">apply</span>/fam_cvgP =&gt; A ?; <span class="nb">apply</span>/famBFf/S.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">family_cvg_finite_covers</span> (<span class="nv">famA</span> <span class="nv">famB</span> : <span class="nb">set</span> U -&gt; <span class="kt">Prop</span>)
  (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) (<span class="nv">f</span> : U -&gt; V) : Filter F -&gt;
  (<span class="kr">forall</span> <span class="nv">P</span>, famA P -&gt;
    <span class="kr">exists</span> (<span class="nv">I</span> : choiceType) <span class="nv">f</span>,
      (<span class="kr">forall</span> <span class="nv">i</span>, famB (f i)) /\ finite_subset_cover [<span class="nb">set</span>: I] f P) -&gt;
  {family famB, F --&gt; f} -&gt; {family famA, F --&gt; f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF ex_finCover /fam_cvgP rFf; <span class="nb">apply</span>/fam_cvgP =&gt; A famAA.
<span class="nb">move</span>: ex_finCover =&gt; /(_ _ famAA) [R [g [g_famB [D _]]]].
<span class="nb">move</span>/uniform_subset_cvg; <span class="nb">apply</span>.
<span class="nb">elim</span>/finSet_rect: D =&gt; X IHX.
<span class="nb">have</span> [-&gt;|/set0P[x xX]] := eqVneq [<span class="nb">set</span>` X] set0.
  <span class="bp">by</span> <span class="nb">rewrite</span> coverE bigcup_set0; <span class="nb">apply</span>: cvg_uniform_set0.
<span class="nb">rewrite</span> coverE (bigcup_fsetD1 x)//; <span class="nb">apply</span>: cvg_uniformU.
  <span class="bp">exact</span>/rFf/g_famB.
<span class="bp">exact</span>/IHX/fproperD1.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">UniformCvgLemmas</span>.

<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;family&#39; fam , U -&gt; V }&quot;</span> :=  (@fct_UniformFamily U V fam).
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;family&#39; fam , F --&gt; f }&quot;</span> :=
  (cvg_to [filter of F] (filter_of (Phantom (fct_UniformFamily fam) f)))
  : classical_set_scope.

<span class="kn">Lemma</span> <span class="nf">fam_cvgE</span> {<span class="nv">U</span> : choiceType} {<span class="nv">V</span> : uniformType} (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V)))
    (<span class="nv">f</span> : U -&gt; V) <span class="nv">fam</span> :
  {family fam, F --&gt; f} = (F --&gt; (f : {family fam, U -&gt; V})).
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fam_nbhs</span> {<span class="nv">U</span> : choiceType} {<span class="nv">V</span> : uniformType} (<span class="nv">fam</span> : <span class="nb">set</span> U -&gt; <span class="kt">Prop</span>)
    (<span class="nv">A</span> : <span class="nb">set</span> U) (<span class="nv">E</span> : <span class="nb">set</span> (V * V)) (<span class="nv">f</span> : {family fam, U -&gt; V}) :
  entourage E -&gt; fam A -&gt; nbhs f [<span class="nb">set</span> g | <span class="kr">forall</span> <span class="nv">y</span>, A y -&gt; E (f y, g y)].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; entE famA; <span class="nb">have</span> /fam_cvgP /(_ A) : (nbhs f --&gt; f) <span class="bp">by</span> []; <span class="nb">apply</span> =&gt; //.
<span class="bp">by</span> <span class="nb">apply</span> uniform_nbhs; <span class="kr">exists</span> <span class="nv">E</span>; <span class="nb">split</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">compactly_in</span> {<span class="nv">U</span> : topologicalType} (<span class="nv">A</span> : <span class="nb">set</span> U) :=
  [<span class="nb">set</span> B | B `&lt;=` A /\ compact B].

<span class="kn">Lemma</span> <span class="nf">compact_cvg_within_compact</span> {<span class="nv">U</span> : topologicalType} {<span class="nv">V</span> : uniformType}
    (<span class="nv">C</span> : <span class="nb">set</span> U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) (<span class="nv">f</span> : U -&gt; V) :
  Filter F -&gt; compact C -&gt;
  {uniform C, F --&gt; f} &lt;-&gt; {family compactly_in C, F --&gt; f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF CC.
<span class="nb">apply</span>: (iff_trans _ (iff_sym (fam_cvgP _ _ FF))); <span class="nb">split</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; CFf D [/uniform_subset_cvg + _]; <span class="nb">apply</span>.
- <span class="bp">by</span> <span class="nb">apply</span>; <span class="nb">split</span>.
<span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">Proper_dnbhs_numFieldType</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">x</span> : R) :
  ProperFilter x^&#39;.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: Build_ProperFilter =&gt; A /nbhs_ballP[_/posnumP[e] Ae].
<span class="kr">exists</span> (<span class="nv">x</span> + e%:num / <span class="mi">2</span>)%R; <span class="nb">apply</span>: Ae; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym addrC -subr_eq subrr eq_sym.
<span class="nb">rewrite</span> /ball /= opprD addrA subrr distrC subr0 ger0_norm //.
<span class="bp">by</span> <span class="nb">rewrite</span> {<span class="mi">2</span>}(splitr e%:num) ltr_spaddl.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">dense</span> (<span class="nv">T</span> : topologicalType) (<span class="nv">S</span> : <span class="nb">set</span> T) :=
  <span class="kr">forall</span> (<span class="nv">O</span> : <span class="nb">set</span> T), O !=set0 -&gt; open O -&gt; O `&amp;` S !=set0.

<span class="kn">Lemma</span> <span class="nf">denseNE</span> (<span class="nv">T</span> : topologicalType) (<span class="nv">S</span> : <span class="nb">set</span> T) : ~ dense S -&gt;
  <span class="kr">exists</span> <span class="nv">O</span>, (<span class="kr">exists</span> <span class="nv">x</span>, open_nbhs x O) /\ (O `&amp;` S = set0).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /dense /open_nbhs.
<span class="nb">move</span>=&gt; /existsNP[X /not_implyP[[x Xx] /not_implyP[ Ox /forallNP A]]].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">X</span>; <span class="nb">split</span>; [<span class="kr">exists</span> <span class="nv">x</span> | <span class="nb">rewrite</span> -subset0; <span class="nb">apply</span>/A].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dense_rat</span> (<span class="nv">R</span> : realType) : dense (@ratr R @` setT).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A [r Ar]; <span class="nb">rewrite</span> openE =&gt; /(_ _ Ar)/nbhs_ballP[_/posnumP[e] reA].
<span class="nb">have</span> /rat_in_itvoo[q /itvP qre] : r &lt; r + e%:num <span class="bp">by</span> <span class="nb">rewrite</span> ltr_addl.
<span class="kr">exists</span> (<span class="nv">ratr</span> <span class="nv">q</span>) =&gt; //; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">q</span>.
<span class="nb">apply</span>: reA; <span class="nb">rewrite</span> /ball /= distrC ltr_distl qre andbT.
<span class="bp">by</span> <span class="nb">rewrite</span> (@le_lt_trans _ _ r)// <span class="nl">?qre</span>// ler_subl_addl ler_addr ltW.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">weak_pseudoMetric</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : realType} (<span class="nv">pS</span> : pointedType) (<span class="nv">U</span> : pseudoMetricType R) .
<span class="kn">Variable</span> (<span class="nv">f</span> : pS -&gt; U).

<span class="kn">Let</span> <span class="nf">S</span> := weak_uniformType f.

<span class="kn">Definition</span> <span class="nf">weak_ball</span> (<span class="nv">x</span> : S) (<span class="nv">r</span> : R) (<span class="nv">y</span> : S) := ball (f x) r (f y).

<span class="kn">Program Definition</span> <span class="nf">weak_pseudoMetricType_mixin</span> :=
  @PseudoMetric.Mixin R S entourage weak_ball
  _ _ _ _.

<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? _/posnumP[e]; <span class="bp">exact</span>: ball_center. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; <span class="bp">exact</span>: ball_sym. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="nb">move</span>=&gt; ? ? ? ? ?; <span class="bp">exact</span>: ball_triangle. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">rewrite</span> /entourage /= /weak_ent -entourage_ballE /entourage_.
<span class="nb">have</span> -&gt; : (<span class="kr">fun</span> <span class="nv">e</span> =&gt; [<span class="nb">set</span> xy | ball (f xy.<span class="mi">1</span>) e (f xy.<span class="mi">2</span>)]) =
   (preimage (map_pair f) \o <span class="kr">fun</span> <span class="nv">e</span> =&gt; [<span class="nb">set</span> xy | ball xy.<span class="mi">1</span> e xy.<span class="mi">2</span>])%FUN.
  <span class="bp">by</span> [].
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="nb">apply</span>/filter_fromP.
- <span class="nb">apply</span>: filter_from_filter; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">1</span> =&gt; /=.
  <span class="nb">move</span>=&gt; e1 e2 e1pos e2pos; <span class="nb">wlog</span> e1lee2 : e1 e2 e1pos e2pos / e1 &lt;= e2.
    <span class="bp">by</span> <span class="nb">have</span> [?|/ltW ?] := lerP e1 e2; [<span class="bp">exact</span> | <span class="nb">rewrite</span> setIC; <span class="bp">exact</span>].
  <span class="kr">exists</span> <span class="nv">e1</span> =&gt; //; <span class="nb">rewrite</span> -preimage_setI; <span class="nb">apply</span>: preimage_subset.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: le_ball; <span class="kp">first</span> <span class="bp">exact</span>: e1lee2.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; E [e ?] heE; <span class="kr">exists</span> <span class="nv">e</span> =&gt; //; <span class="nb">apply</span>: preimage_subset.
- <span class="nb">apply</span>: filter_from_filter.
    <span class="bp">by</span> <span class="kr">exists</span> [<span class="nb">set</span> xy | (ball xy.<span class="mi">1</span> <span class="mi">1</span> xy.<span class="mi">2</span>)]; <span class="kr">exists</span> <span class="mi">1</span> =&gt; /=.
  <span class="nb">move</span>=&gt; E1 E2 [e1 e1pos he1E1] [e2 e2pos he2E2].
  <span class="nb">wlog</span> ? : E1 E2 e1 e2 e1pos e2pos he1E1 he2E2 / e1 &lt;= e2.
    <span class="nb">have</span> [? /(_ _ _ e1 e2)|/ltW ? ] := lerP e1 e2; <span class="kp">first</span> <span class="bp">exact</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> setIC =&gt; /(_ _ _ e2 e1); <span class="bp">exact</span>.
  <span class="kr">exists</span> (<span class="nv">E1</span> `&amp;` E2) =&gt; //; <span class="kr">exists</span> <span class="nv">e1</span> =&gt; // xy /= B; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: he1E1.
  <span class="bp">by</span> <span class="nb">apply</span>/he2E2/le_ball; <span class="nb">last</span> <span class="bp">exact</span>: B.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; e ?; <span class="kr">exists</span> ([<span class="nb">set</span> xy | ball xy.<span class="mi">1</span> e xy.<span class="mi">2</span>]) =&gt; //; <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">e</span> =&gt; /=.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">weak_pseudoMetricType</span> :=
  PseudoMetricType S weak_pseudoMetricType_mixin.

<span class="kn">Lemma</span> <span class="nf">weak_ballE</span> (<span class="nv">e</span> : R) (<span class="nv">x</span> : weak_pseudoMetricType) :
  f@^-<span class="mi">1</span>` (ball (f x) e) = ball x e.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">weak_pseudoMetric</span>.

<span class="c">(* This section proves that uniform spaces, with a countable base for their</span>
<span class="c">   entourage, are metrizable. The definition of this metric is rather arcane,</span>
<span class="c">   and the proof is tough. That&#39;s ok because the resulting metric is not</span>
<span class="c">   intended to be used explicitly. Instead, this is typically used in</span>
<span class="c">   applications that do not depend on the metric:</span>
<span class="c">   - `metric spaces are T4`</span>
<span class="c">   - `in metric spaces, compactness and sequential compactness agree`</span>
<span class="c">   - infinite products of metric spaces are metrizable</span>
<span class="c">*)</span>
<span class="kn">Section</span> <span class="nf">countable_uniform</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : realType} {<span class="nv">T</span> : uniformType}.

<span class="kn">Hypothesis</span> <span class="nv">cnt_unif</span> : @countable_uniformity T.

<span class="kn">Let</span> <span class="nf">f_</span> := projT1 (cid2 (iffLR countable_uniformityP cnt_unif)).

<span class="kn">Local Lemma</span> <span class="nf">countableBase</span> : <span class="kr">forall</span> <span class="nv">A</span>, entourage A -&gt; <span class="kr">exists</span> <span class="nv">N</span>, f_ N `&lt;=` A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> [] := projT2 (cid2 (iffLR countable_uniformityP cnt_unif)). <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">entF</span> : <span class="kr">forall</span> <span class="nv">n</span>, entourage (f_ n).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> [] := projT2 (cid2 (iffLR countable_uniformityP cnt_unif)). <span class="kn">Qed</span>.

<span class="c">(* Step 1:</span>
<span class="c">   We build a nicer base `g` for `entourage` with better assumptions than `f`</span>
<span class="c">   - each (g_ n) is symmetric</span>
<span class="c">   - the sets (g_ n) are nested downward</span>
<span class="c">   - g_ n.+1 \o g_ n.+1 \o g_ n.+1 `&lt;=` g_ n says the sets descend `quickly`</span>
<span class="c"> *)</span>

<span class="kn">Local Fixpoint</span> <span class="nf">g_</span> (<span class="nv">n</span> : nat) : <span class="nb">set</span> (T * T) :=
  <span class="kr">if</span> n <span class="kr">is</span> S n <span class="kr">then</span> <span class="kr">let</span> <span class="nv">W</span> := split_ent (split_ent (g_ n)) `&amp;` f_ n <span class="kr">in</span> W `&amp;` W^-<span class="mi">1</span>
  <span class="kr">else</span> [<span class="nb">set</span>: T*T].

<span class="kn">Let</span> <span class="nf">entG</span> (<span class="nv">n</span> : nat) : entourage (g_ n).
<span class="kn">Proof</span>.
<span class="nb">elim</span>: n =&gt; /=; <span class="kp">first</span> <span class="bp">exact</span>: entourageT.
<span class="bp">by</span> <span class="nb">move</span>=&gt; n entg; <span class="nb">apply</span>/entourage_invI; <span class="bp">exact</span>: filterI.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">symG</span> (<span class="nv">n</span> : nat) : ((g_ n)^-<span class="mi">1</span>)%classic = g_ n.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">case</span>: n =&gt; // n; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="nb">case</span>=&gt; ? ?; <span class="nb">rewrite</span> /= andC.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">descendG1</span> <span class="nv">n</span> : g_ n.+<span class="mi">1</span> `&lt;=` g_ n.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: subIset; <span class="nb">left</span>; <span class="nb">apply</span>: subIset; <span class="nb">left</span>; <span class="nb">apply</span>: subset_trans.
  <span class="bp">by</span> <span class="nb">apply</span>: split_ent_subset; <span class="bp">exact</span>: entourage_split_ent.
<span class="bp">by</span> <span class="nb">apply</span>: subset_trans; <span class="nb">last</span> <span class="bp">exact</span>: split_ent_subset.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">descendG</span> (<span class="nv">n</span> <span class="nv">m</span>: nat) : (m &lt;= n)%N -&gt; g_ n `&lt;=` g_ m.
<span class="kn">Proof</span>.
<span class="nb">elim</span>: n; <span class="nb">rewrite</span> <span class="nl">?leqn0</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt;/eqP -&gt;.
<span class="nb">move</span>=&gt; n IH; <span class="nb">rewrite</span> leq_eqVlt ltnS =&gt; /orP [/eqP &lt;- //|] /IH.
<span class="bp">by</span> <span class="nb">apply</span>: subset_trans; <span class="bp">exact</span>: descendG1.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">splitG3</span> <span class="nv">n</span> : g_ n.+<span class="mi">1</span> \; g_ n.+<span class="mi">1</span> \; g_ n.+<span class="mi">1</span> `&lt;=` g_ n.
<span class="kn">Proof</span>.
<span class="nb">suff</span> g2split : g_ n.+<span class="mi">1</span> \; g_ n.+<span class="mi">1</span> `&lt;=` split_ent (g_ n).
  <span class="nb">apply</span>: subset_trans; <span class="nb">last</span> <span class="bp">exact</span>: subset_split_ent (entG n).
  <span class="nb">apply</span>: set_compose_subset (g2split); <span class="nb">rewrite</span> -[_ n.+<span class="mi">1</span>]set_compose_diag.
  <span class="nb">apply</span>: subset_trans g2split; <span class="nb">apply</span>: set_compose_subset =&gt; //.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [_ _] [z _] [&lt;- &lt;-]; <span class="bp">exact</span>: entourage_refl.
<span class="nb">apply</span>: subset_trans; <span class="nb">last</span> <span class="bp">exact</span>: subset_split_ent.
<span class="bp">by</span> <span class="nb">apply</span>: set_compose_subset; <span class="nb">apply</span>: subIset; <span class="nb">left</span>; <span class="nb">apply</span>: subIset; <span class="nb">left</span>.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">gsubf</span> <span class="nv">n</span> : g_ n.+<span class="mi">1</span> `&lt;=` f_ n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: subIset; <span class="nb">left</span>; <span class="nb">apply</span>: subIset; <span class="nb">right</span>. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">countableBaseG</span> <span class="nv">A</span> : entourage A -&gt; <span class="kr">exists</span> <span class="nv">N</span>, g_ N `&lt;=` A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /countableBase [N] fnA; <span class="kr">exists</span> <span class="nv">N</span>.+<span class="mi">1</span>.
<span class="bp">by</span> <span class="nb">apply</span>: subset_trans fnA; <span class="bp">exact</span>: gsubf.
<span class="kn">Qed</span>.

<span class="c">(* Step 2.</span>
<span class="c">   We build a sensible notion of balls for our metric.</span>
<span class="c">   The naive attempt,</span>
<span class="c">                     `ball x e y := g_ (distN e) (x,y))</span>
<span class="c">   doesn&#39;t respect triangle inequality. We need to cook triangle inequality</span>
<span class="c">   into the balls themselves. So we define balls in terms of steps:</span>
<span class="c">      `ball x e y := there are n steps x_0 = x,...,x_i,..., x_n.+1 = y and</span>
<span class="c">                     e_1,...,e_n such that</span>
<span class="c">                           g_ (distN e_i) (x_i,x_i+1)</span>
<span class="c">                                    and</span>
<span class="c">                               sum (e_i) = e</span>
<span class="c">*)</span>

<span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.

<span class="kn">Local Definition</span> <span class="nf">distN</span> (<span class="nv">e</span> : R) : nat := `|floor e^-<span class="mi">1</span>|%N.

<span class="kn">Local Lemma</span> <span class="nf">distN0</span> : distN <span class="mi">0</span> = <span class="mi">0</span>%N.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /distN invr0 floor0. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">distN_nat</span> (<span class="nv">n</span> : nat): distN (n%:R^-<span class="mi">1</span>) = n.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> /distN invrK floor_natz -[RHS]distn0; <span class="nb">congr</span> absz; <span class="nb">rewrite</span> subr0 intz.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">distN_le</span> <span class="nv">e1</span> <span class="nv">e2</span> : e1 &gt; <span class="mi">0</span> -&gt; e1 &lt;= e2 -&gt; (distN e2 &lt;= distN e1)%N.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; e1pos e1e2; <span class="nb">rewrite</span> /distN; <span class="nb">apply</span>: lez_abs2.
  <span class="bp">by</span> <span class="nb">rewrite</span> floor_ge0 ltW// invr_gt0 (lt_le_trans _ e1e2).
<span class="bp">by</span> <span class="nb">rewrite</span> le_floor// lef_pinv <span class="nl">?invrK</span> <span class="nl">?invr_gt0</span>//; <span class="bp">exact</span>: (lt_le_trans _ e1e2).
<span class="kn">Qed</span>.

<span class="kn">Local Fixpoint</span> <span class="nf">n_step_ball</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">e</span> <span class="nv">z</span> :=
  <span class="kr">if</span> n <span class="kr">is</span> S n <span class="kr">then</span> <span class="kr">exists</span> <span class="nv">y</span> <span class="nv">d1</span> <span class="nv">d2</span>,
    [/\ n_step_ball n x d1 y,
        <span class="mi">0</span> &lt; d1,
        <span class="mi">0</span> &lt; d2,
        g_ (distN d2) (y, z) &amp;
        d1 + d2 = e]
  <span class="kr">else</span> e &gt; <span class="mi">0</span> /\ g_ (distN e) (x, z).

<span class="kn">Local Definition</span> <span class="nf">step_ball</span> <span class="nv">x</span> <span class="nv">e</span> <span class="nv">z</span> := <span class="kr">exists</span> <span class="nv">i</span>, (n_step_ball i x e z).

<span class="kn">Local Lemma</span> <span class="nf">n_step_ball_pos</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">e</span> <span class="nv">z</span> : n_step_ball n x e z -&gt; <span class="mi">0</span> &lt; e.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">case</span>: n =&gt; [[]|] // n; <span class="nb">case</span>=&gt; [?] [?] [?] [] ? ? ? ? &lt;-; <span class="nb">apply</span>: addr_gt0.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">step_ball_pos</span> <span class="nv">x</span> <span class="nv">e</span> <span class="nv">z</span> : step_ball x e z -&gt; <span class="mi">0</span> &lt; e.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span> =&gt; ?; <span class="bp">exact</span>: n_step_ball_pos. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">entourage_nball</span> <span class="nv">e</span> :
  <span class="mi">0</span> &lt; e -&gt; entourage [<span class="nb">set</span> xy | step_ball xy.<span class="mi">1</span> e xy.<span class="mi">2</span>].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; epos; <span class="nb">apply</span>: (@filterS _ _ _ (g_ (distN e))) =&gt; // [[x y]] ?.
<span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>%N.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">n_step_ball_center</span> <span class="nv">x</span> <span class="nv">e</span> : <span class="mi">0</span> &lt; e -&gt; n_step_ball <span class="mi">0</span> x e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; epos; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: entourage_refl. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">step_ball_center</span> <span class="nv">x</span> <span class="nv">e</span> : <span class="mi">0</span> &lt; e -&gt; step_ball x e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; epos; <span class="kr">exists</span> <span class="mi">0</span>%N; <span class="nb">apply</span>: n_step_ball_center. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">n_step_ball_triangle</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">d1</span> <span class="nv">d2</span> :
  n_step_ball n x d1 y -&gt;
  n_step_ball m y d2 z -&gt;
  n_step_ball (n + m).+<span class="mi">1</span> x (d1 + d2) z.
<span class="kn">Proof</span>.
<span class="nb">move</span>: n z d2; <span class="nb">elim</span>: m =&gt; [n z d2 Nxy [? ?]|n IH m z d2 Oxy].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>, d1, d2; <span class="nb">split</span>; <span class="nb">rewrite</span> <span class="nl">?addn0</span> // (n_step_ball_pos Nxy).
<span class="nb">move</span>=&gt; [w] [e1] [e2] [Oyw ? ? ? &lt;-].
<span class="kr">exists</span> <span class="nv">w</span>, (d1 + e1), e2; <span class="nb">rewrite</span> addnS addrA.
<span class="nb">split</span> =&gt; //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> addr_gt0//; <span class="bp">exact</span>: n_step_ball_pos Oxy.
<span class="bp">by</span> <span class="nb">case</span>: (IH m w e1 Oxy Oyw) =&gt; t [e3] [e4] [] Oxt ? ? ? &lt;-; <span class="kr">exists</span> <span class="nv">t</span>, e3, e4.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">step_ball_triangle</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">d1</span> <span class="nv">d2</span> :
  step_ball x d1 y -&gt; step_ball y d2 z -&gt; step_ball x (d1 + d2) z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [n Oxy] [m Oyz]; <span class="kr">exists</span> (<span class="nv">n</span> + m).+<span class="mi">1</span>.
<span class="bp">exact</span>: n_step_ball_triangle Oxy Oyz.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">n_step_ball_sym</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">e</span> :
  n_step_ball n x e y -&gt; n_step_ball n y e x.
<span class="kn">Proof</span>.
<span class="nb">move</span>: x y e; <span class="nb">elim</span>: n; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; <span class="nb">rewrite</span> /= -{<span class="mi">1</span>}symG.
<span class="nb">move</span>=&gt; n IH x y e [t] [d1] [d2] [] /IH Oty ? ?.
<span class="nb">rewrite</span> addrC -symG -[n]add0n =&gt; gty &lt;-; <span class="nb">apply</span>: (n_step_ball_triangle _ Oty).
<span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: gty.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">step_ball_sym</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">e</span> : step_ball x e y -&gt; step_ball y e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>=&gt; n /n_step_ball_sym ?; <span class="kr">exists</span> <span class="nv">n</span>. <span class="kn">Qed</span>.

<span class="c">(* Step 3:</span>
<span class="c">   We prove that step_ball respects the original entourage. This requires an</span>
<span class="c">   induction on the length of the steps, which is pretty tricky. The central</span>
<span class="c">   lemma is `split_n_step_ball`, which lets us break a list into parts three</span>
<span class="c">   parts as: half + one_step + half. Then our we can break apart our n +1 path</span>

<span class="c">                         nlong + one_step</span>
<span class="c">   into</span>
<span class="c">                  (half + one_step + half) + one_step</span>
<span class="c">                                =</span>
<span class="c">                  half + one_step + (half + one_step)</span>

<span class="c">   and we can we can use our (strong) induction hypothesis.</span>
<span class="c">   And lastly we finish with splitG3.</span>
<span class="c">*)</span>

<span class="kn">Local Lemma</span> <span class="nf">n_step_ball_le</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">e1</span> <span class="nv">e2</span> :
  e1 &lt;= e2 -&gt; n_step_ball n x e1 `&lt;=` n_step_ball n x e2.
<span class="kn">Proof</span>.
<span class="nb">move</span>: x e1 e2; <span class="nb">elim</span>: n.
  <span class="nb">move</span>=&gt; x e1 e2 e1e2 y [?] gxy; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: (lt_le_trans _ e1e2).
  <span class="bp">by</span> <span class="nb">apply</span>: descendG; <span class="nb">last</span> (<span class="bp">exact</span>: gxy); <span class="bp">exact</span>: distN_le.
<span class="nb">move</span>=&gt; n IH x e1 e2 e1e2 z [y] [d1] [d2] [] /IH P d1pos d2pos gyz d1d2e1.
<span class="nb">have</span> d1e1d2 : d1 = e1 - d2 <span class="bp">by</span> <span class="nb">rewrite</span> -d1d2e1 -addrA subrr addr0.
<span class="nb">have</span> e2d2le : e1 - d2 &lt;= e2 - d2 <span class="bp">by</span> <span class="bp">exact</span>: ler_sub.
<span class="kr">exists</span> <span class="nv">y</span>, (e2 - d2), d2; <span class="nb">split</span> =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: P; <span class="nb">apply</span>: le_trans e2d2le; <span class="nb">rewrite</span> d1e1d2.
- <span class="bp">by</span> <span class="nb">apply</span>: lt_le_trans e2d2le; <span class="nb">rewrite</span> -d1e1d2.
- <span class="bp">by</span> <span class="nb">rewrite</span> -addrA [-_ + _]addrC subrr addr0.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">step_ball_le</span> <span class="nv">x</span> <span class="nv">e1</span> <span class="nv">e2</span> :
  e1 &lt;= e2 -&gt; step_ball x e1 `&lt;=` step_ball x e2.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; e1e2 ? [n P]; <span class="kr">exists</span> <span class="nv">n</span>; <span class="bp">exact</span>: (n_step_ball_le e1e2). <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">distN_half</span> (<span class="nv">n</span> : nat) : n.+<span class="mi">1</span>%:R^-<span class="mi">1</span> / (<span class="mi">2</span>:R) &lt;= n.+<span class="mi">2</span>%:R^-<span class="mi">1</span>.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -invrM //; [|<span class="bp">exact</span>: unitf_gt0 |<span class="bp">exact</span>: unitf_gt0].
<span class="nb">rewrite</span> lef_pinv <span class="nl">?posrE</span> // -<span class="nl">?natrM</span> <span class="nl">?ler_nat</span> -addn1 -addn1 -addnA mulnDr.
<span class="bp">by</span> <span class="nb">rewrite</span> muln1 leq_add2r leq_pmull.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">split_n_step_ball</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">z</span> :
  <span class="mi">0</span> &lt; e1 -&gt; <span class="mi">0</span> &lt; e2 -&gt; n_step_ball n.+<span class="mi">1</span> x (e1 + e2) z -&gt;
    <span class="kr">exists</span> <span class="nv">t1</span> <span class="nv">t2</span> <span class="nv">a</span> <span class="nv">b</span>,
    [/\
      n_step_ball a x e1 t1,
      n_step_ball <span class="mi">0</span> t1 (e1 + e2) t2,
      n_step_ball b t2 e2 z &amp;
      (a + b = n)%N
    ].
<span class="kn">Proof</span>.
<span class="nb">move</span>: e1 e2 x z; <span class="nb">elim</span>: n.
  <span class="nb">move</span>=&gt; e1 e2 x z e1pos e2pos [y] [d1] [d2] [] Oxy ? ? gd2yz deE.
  <span class="nb">case</span>: (pselect (e1 &lt;= d1)).
    <span class="nb">move</span>=&gt; e1d1; <span class="kr">exists</span> <span class="nv">x</span>, y, <span class="mi">0</span>%N, <span class="mi">0</span>%N; <span class="nb">split</span>.
    - <span class="bp">exact</span>: n_step_ball_center.
    - <span class="nb">apply</span>: n_step_ball_le; <span class="nb">last</span> <span class="bp">exact</span>: Oxy.
      <span class="bp">by</span> <span class="nb">rewrite</span> -deE ler_addl; <span class="nb">apply</span>: ltW.
    - <span class="nb">apply</span>: (@n_step_ball_le _ _ d2); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">split</span>.
      <span class="nb">rewrite</span> -[e2]addr0 -(subrr e1) addrA -ler_subl_addr opprK addrC.
      <span class="bp">by</span> <span class="nb">rewrite</span> [e2 + _]addrC -deE; <span class="bp">exact</span>: ler_add.
    - <span class="bp">by</span> <span class="nb">rewrite</span> addn0.
  <span class="nb">move</span>=&gt; /negP; <span class="nb">rewrite</span> -real_ltNge <span class="nl">?num_real</span> //.
  <span class="nb">move</span>=&gt; e1d1; <span class="kr">exists</span> <span class="nv">y</span>, z, <span class="mi">0</span>%N, <span class="mi">0</span>%N; <span class="nb">split</span>.
  - <span class="bp">by</span> <span class="nb">apply</span>: n_step_ball_le; <span class="nb">last</span> (<span class="bp">exact</span>: Oxy); <span class="bp">exact</span>: ltW.
  - <span class="nb">rewrite</span> -deE; <span class="nb">apply</span>: (@n_step_ball_le _ _ d2) =&gt; //.
    <span class="bp">by</span> <span class="nb">rewrite</span> ler_addr; <span class="nb">apply</span>: ltW.
  - <span class="bp">exact</span>: n_step_ball_center.
  - <span class="bp">by</span> <span class="nb">rewrite</span> addn0.
<span class="nb">move</span>=&gt; n IH e1 e2 x z e1pos e2pos [y] [d1] [d2] [] Od1xy d1pos d2pos gd2yz deE.
<span class="nb">case</span>: (pselect (e2 &lt;= d2)).
  <span class="nb">move</span>=&gt; e2d2; <span class="kr">exists</span> <span class="nv">y</span>, z, n.+<span class="mi">1</span>, <span class="mi">0</span>%N; <span class="nb">split</span>.
  - <span class="nb">apply</span>: (@n_step_ball_le _ _ d1); <span class="nb">rewrite</span> // -[e1]addr0 -(subrr e2) addrA.
    <span class="bp">by</span> <span class="nb">rewrite</span> -deE -ler_subl_addr opprK ler_add.
  - <span class="nb">apply</span>: (@n_step_ball_le _ _ d2); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">split</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -deE ler_addr; <span class="bp">exact</span>: ltW.
  - <span class="bp">exact</span>: n_step_ball_center.
  - <span class="bp">by</span> <span class="nb">rewrite</span> addn0.
<span class="nb">have</span> d1E&#39; : d1 = e1 + (e2 - d2).
  <span class="bp">by</span> <span class="nb">move</span>: deE; <span class="nb">rewrite</span> addrA [e1 + _]addrC =&gt; &lt;-; <span class="nb">rewrite</span> -addrA subrr addr0.
<span class="nb">move</span>=&gt; /negP; <span class="nb">rewrite</span> -<span class="nl">?real_ltNge</span> // <span class="nl">?num_real</span> // =&gt; d2lee2.
  <span class="nb">case</span>: (IH e1 (e2 - d2) x y); <span class="nb">rewrite</span> <span class="nl">?subr_gt0</span> // -d1E&#39; //.
  <span class="nb">move</span>=&gt; t1 [t2] [c1] [c2] [] Oxy1 gt1t2 t2y &lt;-.
  <span class="kr">exists</span> <span class="nv">t1</span>, t2, c1, c2.+<span class="mi">1</span>; <span class="nb">split</span> =&gt; //.
  - <span class="bp">by</span> <span class="nb">apply</span>: (@n_step_ball_le _ _ d1); <span class="nb">rewrite</span> -<span class="nl">?deE</span> // <span class="nl">?ler_addl</span>; <span class="bp">exact</span>: ltW.
  - <span class="kr">exists</span> <span class="nv">y</span>, (e2 - d2), d2; <span class="nb">split</span>; <span class="nb">rewrite</span> // <span class="nl">?subr_gt0</span>//.
    <span class="bp">by</span> <span class="nb">rewrite</span> -addrA [-_ + _]addrC subrr addr0.
  - <span class="bp">by</span> <span class="nb">rewrite</span> addnS.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">n_step_ball_le_g</span> <span class="nv">x</span> <span class="nv">n</span> :
  n_step_ball <span class="mi">0</span> x n%:R^-<span class="mi">1</span> `&lt;=` [<span class="nb">set</span> y | g_ n (x,y)].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; y [] ?; <span class="nb">rewrite</span> distN_nat. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">subset_n_step_ball</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">N</span> :
  n_step_ball n x N.+<span class="mi">1</span>%:R^-<span class="mi">1</span> `&lt;=` [<span class="nb">set</span> y | (g_ N) (x, y)].
<span class="kn">Proof</span>.
<span class="nb">move</span>: N x; <span class="nb">elim</span>: n {-<span class="mi">2</span>}n (leqnn n) =&gt; n.
  <span class="nb">rewrite</span> leqn0 =&gt; /eqP -&gt; N x; <span class="nb">apply</span>: subset_trans.
    <span class="bp">exact</span>: n_step_ball_le_g.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; y ?; <span class="bp">exact</span>: descendG.
<span class="nb">move</span>=&gt; IH1 + + N x1 x4; <span class="nb">case</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? [?] P; <span class="nb">apply</span>: descendG _ P; <span class="nb">rewrite</span> distN_nat.
<span class="nb">move</span>=&gt; l ln1 Ox1x4.
<span class="nb">case</span>: (@split_n_step_ball l x1 (N.+<span class="mi">1</span>%:R^-<span class="mi">1</span>/<span class="mi">2</span>) (N.+<span class="mi">1</span>%:R^-<span class="mi">1</span>/<span class="mi">2</span>) x4) =&gt; //.
  <span class="bp">by</span> <span class="nb">rewrite</span> -splitr.
<span class="nb">move</span>=&gt; x2 [x3] [l1] [l2] [] P1 [? +] P3 l1l2; <span class="nb">rewrite</span> -splitr distN_nat =&gt; ?.
<span class="nb">have</span> l1n : (l1 &lt;= n)%N.
  <span class="bp">by</span> <span class="nb">apply</span> (leq_trans (leq_addr l2 l1)); <span class="nb">rewrite</span> l1l2 -ltnS.
<span class="nb">have</span> l2n : (l2 &lt;= n)%N.
  <span class="bp">by</span> <span class="nb">apply</span> (leq_trans (leq_addl l1 l2)); <span class="nb">rewrite</span> l1l2 -ltnS.
<span class="nb">apply</span>: splitG3; <span class="kr">exists</span> <span class="nv">x3</span>; [<span class="kr">exists</span> <span class="nv">x2</span> =&gt; //|].
  <span class="bp">by</span> <span class="nb">move</span>/(n_step_ball_le (distN_half N))/(IH1 _ l1n) : P1.
<span class="bp">by</span> <span class="nb">move</span>/(n_step_ball_le (distN_half N))/(IH1 _ l2n) : P3.
<span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">subset_step_ball</span> <span class="nv">x</span> <span class="nv">N</span> :
  step_ball x N.+<span class="mi">1</span>%:R^-<span class="mi">1</span> `&lt;=` [<span class="nb">set</span> y | (g_ N) (x, y)].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; y [] n; <span class="bp">exact</span>: subset_n_step_ball. <span class="kn">Qed</span>.

<span class="kn">Local Lemma</span> <span class="nf">step_ball_entourage</span> : entourage = entourage_ step_ball.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; E; <span class="nb">split</span>; <span class="kp">first</span> <span class="nb">last</span>.
  <span class="bp">by</span> <span class="nb">case</span>=&gt; e /= epos esubE; <span class="nb">apply</span>: (filterS esubE); <span class="bp">exact</span>: entourage_nball.
<span class="nb">move</span>=&gt; entE; <span class="nb">case</span>: (countableBase entE) =&gt; N fN.
<span class="kr">exists</span> <span class="nv">N</span>.+<span class="mi">2</span>%:R^-<span class="mi">1</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /= invr_gt0.
<span class="nb">apply</span>: (subset_trans _ fN); <span class="nb">apply</span>: subset_trans; <span class="nb">last</span> <span class="nb">apply</span>: gsubf.
<span class="bp">by</span> <span class="nb">case</span>=&gt; x y /= N1ball; <span class="nb">apply</span>: (@subset_step_ball x N.+<span class="mi">1</span>).
<span class="kn">Qed</span>.

<span class="c">(* Note this is the only non-local result from this section *)</span>
<span class="kn">Definition</span> <span class="nf">countable_uniform_pseudoMetricType_mixin</span> := PseudoMetric.Mixin
  step_ball_center step_ball_sym step_ball_triangle step_ball_entourage.

<span class="kn">End</span> <span class="nf">countable_uniform</span>.

<span class="kn">Section</span> <span class="nf">sup_pseudometric</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : realType) (<span class="nv">T</span> : pointedType) (<span class="nv">Ii</span> : <span class="kt">Type</span>).
<span class="kn">Variable</span> (<span class="nv">Tc</span> : Ii -&gt; PseudoMetric.class_of R T).

<span class="kn">Hypothesis</span> <span class="nv">Icnt</span> : countable [<span class="nb">set</span>: Ii].

<span class="kn">Let</span> <span class="nf">I</span> : choiceType := classicType_choiceType Ii.
<span class="kn">Let</span> <span class="nf">TS</span> := <span class="kr">fun</span> <span class="nv">i</span> =&gt; PseudoMetric.Pack (Tc i).

<span class="kn">Definition</span> <span class="nf">countable_uniformityT</span> := @countable_sup_ent T Ii Tc Icnt
  (<span class="kr">fun</span> <span class="nv">i</span> =&gt; @countable_uniformity_metric _ (TS i)).

<span class="kn">Definition</span> <span class="nf">sup_pseudoMetric_mixin</span> := @countable_uniform_pseudoMetricType_mixin R
  (sup_uniformType Tc) countable_uniformityT.

<span class="kn">Definition</span> <span class="nf">sup_pseudoMetricType</span> :=
  PseudoMetricType (sup_uniformType Tc) sup_pseudoMetric_mixin.

<span class="kn">End</span> <span class="nf">sup_pseudometric</span>.

<span class="kn">Section</span> <span class="nf">product_pseudometric</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : realType) (<span class="nv">Ii</span> : countType) (<span class="nv">Tc</span> : Ii -&gt; pseudoMetricType R).

<span class="kn">Hypothesis</span> <span class="nv">Icnt</span> : countable [<span class="nb">set</span>: Ii].

<span class="kn">Definition</span> <span class="nf">product_pseudoMetricType</span> :=
  sup_pseudoMetricType (<span class="kr">fun</span> <span class="nv">i</span> =&gt; PseudoMetric.class
    (weak_pseudoMetricType (<span class="kr">fun</span> <span class="nv">f</span> : dep_arrow_pointedType Tc =&gt; f i)))
    Icnt.

<span class="kn">End</span> <span class="nf">product_pseudometric</span>.

<span class="kn">Definition</span> <span class="nf">subspace</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">A</span> : <span class="nb">set</span> T) := T.
<span class="kn">Arguments</span> subspace {T} _ : <span class="nb">simpl</span> never.

<span class="kn">Definition</span> <span class="nf">incl_subspace</span> {<span class="nv">T</span> <span class="nv">A</span>} (<span class="nv">x</span> : subspace A) : T := x.

<span class="kn">Section</span> <span class="nf">Subspace</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType} (<span class="nv">A</span> : <span class="nb">set</span> T).

<span class="kn">Definition</span> <span class="nf">nbhs_subspace</span> (<span class="nv">x</span> : subspace A) : <span class="nb">set</span> (<span class="nb">set</span> (subspace A)) :=
  <span class="kr">if</span> x \<span class="kr">in</span> A <span class="kr">then</span> within A (nbhs x) <span class="kr">else</span> globally [<span class="nb">set</span> x].

<span class="kn">Variant</span> <span class="nf">nbhs_subspace_spec</span> <span class="nv">x</span> : <span class="kt">Prop</span> -&gt; <span class="kt">Prop</span> -&gt; bool -&gt; <span class="nb">set</span> (<span class="nb">set</span> T) -&gt; <span class="kt">Type</span> :=
  | WithinSubspace :
      A x -&gt; nbhs_subspace_spec x <span class="kt">True</span> <span class="kt">False</span> true (within A (nbhs x))
  | WithoutSubspace :
    ~ A x -&gt; nbhs_subspace_spec x <span class="kt">False</span> <span class="kt">True</span> false (globally [<span class="nb">set</span> x]).

<span class="kn">Lemma</span> <span class="nf">nbhs_subspaceP</span> <span class="nv">x</span> :
  nbhs_subspace_spec x (A x) (~ A x) (x \<span class="kr">in</span> A) (nbhs_subspace x).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /nbhs_subspace; <span class="nb">case</span>:(boolP (x \<span class="kr">in</span> A)); <span class="nb">rewrite</span> ?(inE, notin_set) =&gt; xA.
  <span class="bp">by</span> <span class="nb">rewrite</span> (@propext (A x) <span class="kt">True</span>)// not_True; <span class="nb">constructor</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> (@propext (A x) <span class="kt">False</span>)// not_False; <span class="nb">constructor</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_subspace_in</span> (<span class="nv">x</span> : T) : A x -&gt; within A (nbhs x) = nbhs_subspace x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: nbhs_subspaceP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_subspace_out</span> (<span class="nv">x</span> : T) : ~ A x -&gt; globally [<span class="nb">set</span> x] = nbhs_subspace x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: nbhs_subspaceP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_subspace_filter</span> (<span class="nv">x</span> : subspace A) : ProperFilter (nbhs_subspace x).
<span class="kn">Proof</span>.
<span class="nb">case</span>: nbhs_subspaceP =&gt; ?; <span class="nb">last</span> <span class="bp">exact</span>: globally_properfilter.
<span class="bp">by</span> <span class="nb">apply</span>: within_nbhs_proper; <span class="nb">apply</span>: subset_closure.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">subspace_pointedType</span> := PointedType (subspace A) point.

<span class="kn">Canonical</span> <span class="nf">subspace_filteredType</span> :=
  FilteredType (subspace A) (subspace A) nbhs_subspace.

<span class="kn">Program Definition</span> <span class="nf">subspace_topologicalMixin</span> :
  Topological.mixin_of (nbhs_subspace) := @topologyOfFilterMixin
    (subspace A) nbhs_subspace nbhs_subspace_filter _ _.
<span class="kn">Next Obligation</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; p A0; <span class="nb">case</span>: nbhs_subspaceP =&gt; ? =&gt; [/nbhs_singleton|]; <span class="nb">apply</span>.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; p A0; <span class="nb">case</span>: nbhs_subspaceP =&gt; [|] Ap.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /nbhs_interior; <span class="nb">apply</span>: filterS =&gt; y A0y Ay; <span class="nb">case</span>: nbhs_subspaceP.
<span class="bp">by</span> <span class="nb">move</span>=&gt; E x -&gt;; <span class="nb">case</span>: nbhs_subspaceP.
<span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">subspace_topologicalType</span> :=
  TopologicalType (subspace A) subspace_topologicalMixin.

<span class="kn">Lemma</span> <span class="nf">subspace_cvgP</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">x</span> : T) :
  Filter F -&gt; A x -&gt;
  (F --&gt; (x : subspace A)) &lt;-&gt; (F --&gt; within A (nbhs x)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: (y <span class="kr">in</span> F --&gt; y) / nbhs_subspaceP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subspace_continuousP</span> {<span class="nv">S</span> : topologicalType} (<span class="nv">f</span> : T -&gt; S) :
  continuous (f : subspace A -&gt; S) &lt;-&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; f @ within A (nbhs x) --&gt; f x) .
<span class="kn">Proof</span>.
<span class="nb">split</span> =&gt; [ctsf x Ax W /=|wA x].
  <span class="bp">by</span> <span class="nb">rewrite</span> nbhs_simpl //= nbhs_subspace_in //=; <span class="nb">apply</span>: ctsf.
<span class="nb">case</span>: (y <span class="kr">in</span> _ @[_ --&gt; y]) / (nbhs_subspaceP x) =&gt; Ax.
  <span class="bp">exact</span>: (cvg_trans _ (wA _ Ax)).
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? /nbhs_singleton //= ?; <span class="nb">rewrite</span> nbhs_simpl =&gt; ? -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subspace_eq_continuous</span> {<span class="nv">S</span> : topologicalType} (<span class="nv">f</span> <span class="nv">g</span> : subspace A -&gt; S) :
  {<span class="kr">in</span> A, f =<span class="mi">1</span> g} -&gt; continuous f -&gt; continuous g.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> <span class="nl">?subspace_continuousP</span>=&gt; feq L x Ax; <span class="nb">rewrite</span> -(feq x) <span class="nl">?inE</span> //.
<span class="bp">by</span> <span class="nb">apply</span>: cvg_trans _ (L x Ax); <span class="nb">apply</span>: fmap_within_eq=&gt; ? ?; <span class="nb">rewrite</span> feq.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_subspace_in</span> {<span class="nv">U</span> : topologicalType} (<span class="nv">f</span> : subspace A -&gt; U) :
  continuous f = {<span class="kr">in</span> A, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE in_setP subspace_continuousP/filter_of/nbhs //=; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; Q x Ax; <span class="nb">case</span>: (nbhs_subspaceP x) =&gt; //=; <span class="bp">exact</span>: Q.
<span class="bp">by</span> <span class="nb">move</span>=&gt; + x Ax =&gt; /(_ x Ax); <span class="nb">case</span>: (nbhs_subspaceP x) =&gt; //=; <span class="bp">exact</span>: Q.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_subspace_interior</span> (<span class="nv">x</span> : T) :
  A^¬∞ x -&gt; nbhs x = (nbhs (x : subspace A)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /[dup] /[dup] /interior_subset ? /within_interior &lt;- ?.
<span class="bp">by</span> <span class="nb">case</span>: RHS / nbhs_subspaceP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_subspace_ex</span> (<span class="nv">U</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T) : A x -&gt;
  nbhs (x : subspace A) U &lt;-&gt;
  <span class="kr">exists2</span> V, nbhs (x : T) V &amp; U `&amp;` A = V `&amp;` A.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: (nbhs _) / nbhs_subspaceP; <span class="nb">rewrite</span> // <span class="nl">?withinE</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">incl_subspace_continuous</span> : continuous incl_subspace.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/subspace_continuousP =&gt; x Ax; <span class="nb">apply</span>: cvg_within. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">SubspaceOpen</span>.

<span class="kn">Lemma</span> <span class="nf">open_subspace1out</span> (<span class="nv">x</span> : subspace A) : ~ A x -&gt; open [<span class="nb">set</span> x].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /nbhs_subspace_out E; <span class="nb">have</span> : nbhs x [<span class="nb">set</span> x] <span class="bp">by</span> <span class="nb">rewrite</span> /nbhs //= -E.
<span class="nb">rewrite</span> nbhsE =&gt; [[U []]] oU Ux Usub; <span class="nb">suff</span> : U = [<span class="nb">set</span> x] <span class="bp">by</span> <span class="nb">move</span>=&gt; &lt;-.
<span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; // t -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_subspace_out</span> (<span class="nv">U</span> : <span class="nb">set</span> (subspace A)) : U `&lt;=` ~` A -&gt; open U.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Usub; <span class="nb">rewrite</span> (_ : U = \bigcup_(i <span class="kr">in</span> U) [<span class="nb">set</span> i]).
  <span class="bp">by</span> <span class="nb">apply</span>: bigcup_open =&gt; ? ?; <span class="nb">apply</span>: open_subspace1out; <span class="bp">exact</span>: Usub.
<span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; x; [<span class="nb">move</span>=&gt; ?; <span class="kr">exists</span> <span class="nv">x</span>|<span class="nb">case</span>=&gt; i ? -&gt;].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_subspaceT</span> : open (A : <span class="nb">set</span> (subspace A)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">case</span>: nbhs_subspaceP =&gt; //= ? ?; <span class="nb">apply</span>: withinT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_subspaceIT</span> (<span class="nv">U</span> : <span class="nb">set</span> (subspace A)) : open (U `&amp;` A) = open U.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/propext; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; oU; <span class="nb">apply</span>: openI =&gt; //; <span class="nb">apply</span>: open_subspaceT.
<span class="nb">move</span>=&gt; oUA; <span class="nb">rewrite</span> (_ : U = (U `&amp;` A) `|` (U `&amp;` ~`A)).
  <span class="bp">by</span> <span class="nb">apply</span>: openU =&gt; //; <span class="nb">apply</span>: open_subspace_out =&gt; ? [].
<span class="bp">by</span> <span class="nb">rewrite</span> -setIUr setUCr setIT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_subspaceTI</span> (<span class="nv">U</span> : <span class="nb">set</span> (subspace A)) :
  open (A `&amp;` U : <span class="nb">set</span> (subspace A)) = open U.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> setIC open_subspaceIT. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_subspaceT</span> : closed (A : <span class="nb">set</span> (subspace A)).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -(setCK A);
<span class="bp">by</span> <span class="nb">apply</span>: open_closedC; <span class="nb">rewrite</span> -open_subspaceIT setICl; <span class="bp">exact</span>: open0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_subspaceP</span> (<span class="nv">U</span> : <span class="nb">set</span> T) :
  open (U : <span class="nb">set</span> (subspace A)) &lt;-&gt;
  <span class="kr">exists</span> <span class="nv">V</span>, open (V : <span class="nb">set</span> T) /\ V `&amp;` A = U `&amp;` A.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [|[V [oV UV]]]; <span class="kp">first</span> <span class="nb">last</span>.
  <span class="nb">rewrite</span> -open_subspaceIT -UV =&gt; x //= []; <span class="nb">case</span>: nbhs_subspaceP =&gt; //=.
  <span class="nb">rewrite</span> withinE /= =&gt; Ax Vx _; <span class="kr">exists</span> <span class="nv">V</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -setIA setIid.
  <span class="bp">by</span> <span class="nb">move</span>: oV; <span class="nb">rewrite</span> openE; <span class="bp">exact</span>.
<span class="nb">rewrite</span> -open_subspaceIT =&gt; oUA.
<span class="nb">have</span> oxF x : (U `&amp;` A) x -&gt; <span class="kr">exists2</span> V, open_nbhs x V &amp; V `&amp;` A `&lt;=` U `&amp;` A.
  <span class="nb">move</span>=&gt; /[dup] UAx [Ux Ax]; <span class="nb">move</span>: (oUA _ UAx); <span class="nb">case</span>: nbhs_subspaceP =&gt; // _.
  <span class="nb">rewrite</span> withinE /= =&gt; -[V nbhsV]; <span class="nb">rewrite</span> -setIA setIid =&gt; UV.
  <span class="kr">exists</span> <span class="nv">V</span>^¬∞; <span class="nb">rewrite</span> <span class="nl">?open_nbhsE</span>.
  - <span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">exact</span>: open_interior|<span class="bp">exact</span>: nbhs_interior].
  - <span class="bp">by</span> <span class="nb">rewrite</span> UV =&gt; t [/interior_subset].
<span class="nb">pose</span> f x :=
  <span class="kr">if</span> pselect ((U `&amp;` A) x) <span class="kr">is</span> <span class="nb">left</span> e <span class="kr">then</span> projT1 (cid2 (oxF x e)) <span class="kr">else</span> set0.
<span class="kr">exists</span> (\bigcup_(x <span class="kr">in</span> U `&amp;` A) f x); <span class="nb">split</span>.
  <span class="nb">apply</span>: bigcup_open =&gt; i UAi; <span class="nb">rewrite</span> /f; <span class="nb">case</span>: pselect =&gt; // ?.
  <span class="bp">by</span> <span class="nb">case</span>: (cid2 _) =&gt; //= W; <span class="nb">rewrite</span> open_nbhsE =&gt; -[].
<span class="nb">rewrite</span> eqEsubset /f; <span class="nb">split</span>.
  <span class="nb">move</span>=&gt; t [[u UAu]] /=; <span class="nb">case</span>: pselect =&gt; //= ?.
  <span class="bp">by</span> <span class="nb">case</span>: (cid2 _) =&gt; /= W _ + ? ?; <span class="bp">exact</span>.
<span class="nb">move</span>=&gt; t UAt; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>: UAt.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">t</span> =&gt; //; <span class="nb">case</span>: pselect =&gt; //= -[Ut At]; <span class="nb">case</span>: (cid2 _) =&gt; //= W [].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_subspaceP</span> (<span class="nv">U</span> : <span class="nb">set</span> T) :
  closed (U : <span class="nb">set</span> (subspace A)) &lt;-&gt;
  <span class="kr">exists</span> <span class="nv">V</span>, closed (V : <span class="nb">set</span> T) /\ V `&amp;` A = U `&amp;` A.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -openC open_subspaceP.
<span class="nb">under</span> [X <span class="kr">in</span> _ &lt;-&gt; X] eq_exists =&gt; V <span class="kp">do</span> <span class="nb">rewrite</span> -openC.
<span class="bp">by</span> <span class="nb">split</span> =&gt; -[V [? VU]]; <span class="kr">exists</span> (~` V); <span class="nb">split</span>; <span class="nb">rewrite</span> <span class="nl">?setCK</span> //;
  <span class="nb">move</span>/(congr1 setC): VU; <span class="nb">rewrite</span> <span class="nl">?eqEsubset</span> <span class="nl">?setCI</span> <span class="nl">?setCK</span>; <span class="nb">firstorder</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_subspaceW</span> (<span class="nv">U</span> : <span class="nb">set</span> T) :
  open (U : <span class="nb">set</span> T) -&gt; open (U : <span class="nb">set</span> (subspace A)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; oU; <span class="nb">apply</span>/open_subspaceP; <span class="kr">exists</span> <span class="nv">U</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_subspaceW</span> (<span class="nv">U</span> : <span class="nb">set</span> T) :
  closed (U : <span class="nb">set</span> T) -&gt; closed (U : <span class="nb">set</span> (subspace A)).
<span class="kn">Proof</span>.  <span class="bp">by</span> <span class="nb">move</span>=&gt; /closed_openC/open_subspaceW/open_closedC; <span class="nb">rewrite</span> setCK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_setIS</span> (<span class="nv">U</span> : <span class="nb">set</span> (subspace A)) : open A -&gt;
  open (U `&amp;` A : <span class="nb">set</span> T) = open U.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; oA; <span class="nb">apply</span>/propext; <span class="nb">rewrite</span> open_subspaceP.
<span class="nb">split</span>=&gt; [|[V [oV &lt;-]]]; <span class="nb">last</span> <span class="bp">exact</span>: openI.
<span class="bp">by</span> <span class="nb">move</span>=&gt; oUA; <span class="kr">exists</span> (<span class="nv">U</span> `&amp;` A); <span class="nb">rewrite</span> -setIA setIid.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_setSI</span> (<span class="nv">U</span> : <span class="nb">set</span> (subspace A)) : open A -&gt; open (A `&amp;` U) = open U.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; oA; <span class="nb">rewrite</span> -setIC open_setIS. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_setIS</span> (<span class="nv">U</span> : <span class="nb">set</span> (subspace A)) : closed A -&gt;
  closed (U `&amp;` A : <span class="nb">set</span> T) = closed U.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; oA; <span class="nb">apply</span>/propext; <span class="nb">rewrite</span> closed_subspaceP.
<span class="nb">split</span>=&gt; [|[V [oV &lt;-]]]; <span class="nb">last</span> <span class="bp">exact</span>: closedI.
<span class="bp">by</span> <span class="nb">move</span>=&gt; oUA; <span class="kr">exists</span> (<span class="nv">U</span> `&amp;` A); <span class="nb">rewrite</span> -setIA setIid.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_setSI</span> (<span class="nv">U</span> : <span class="nb">set</span> (subspace A)) :
  closed A -&gt; closed (A `&amp;` U) = closed U.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; oA; <span class="nb">rewrite</span> -setIC closed_setIS. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closure_subspaceW</span> (<span class="nv">U</span> : <span class="nb">set</span> T) :
  U `&lt;=` A -&gt; closure (U : <span class="nb">set</span> (subspace A)) = closure (U : <span class="nb">set</span> T) `&amp;` A.
<span class="kn">Proof</span>.
<span class="nb">have</span> /closed_subspaceP := (@closed_closure _ (U : <span class="nb">set</span> (subspace A))).
<span class="nb">move</span>=&gt; [V] [clV VAclUA] /[dup] /(@closure_subset subspace_topologicalType).
<span class="nb">have</span>/closure_id &lt;- := (closed_subspaceT) =&gt; /setIidr &lt;-; <span class="nb">rewrite</span> setIC.
<span class="nb">move</span>=&gt; UsubA; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.
  <span class="nb">apply</span>: setSI; <span class="nb">rewrite</span> closureE; <span class="nb">apply</span>: smallest_sub (@subset_closure _ U).
  <span class="bp">by</span> <span class="nb">apply</span>: closed_subspaceW; <span class="bp">exact</span>: closed_closure.
<span class="nb">rewrite</span> -VAclUA; <span class="nb">apply</span> setSI; <span class="nb">rewrite</span> closureE //=; <span class="nb">apply</span>: smallest_sub =&gt; //.
<span class="nb">apply</span>: subset_trans (@subIsetl _ V A); <span class="nb">rewrite</span> VAclUA subsetI; <span class="nb">split</span> =&gt; //.
<span class="bp">exact</span>: (@subset_closure _ (U : <span class="nb">set</span> (subspace A))).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subspace_hausdorff</span> :
  hausdorff_space T -&gt; hausdorff_space [topologicalType of subspace A].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> <span class="nl">?open_hausdorff</span> =&gt; + x y xNy =&gt; /(_ x y xNy).
<span class="nb">move</span>=&gt; [[P Q]] /= [Px Qx] /= [/open_subspaceW oP /open_subspaceW oQ].
<span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="kr">exists</span> (<span class="nv">P</span>, Q).
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">SubspaceOpen</span>.

<span class="kn">Lemma</span> <span class="nf">compact_subspaceIP</span> (<span class="nv">U</span> : <span class="nb">set</span> T) :
  compact (U `&amp;` A : <span class="nb">set</span> (subspace A)) &lt;-&gt; compact (U `&amp;` A : <span class="nb">set</span> T).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> <span class="nl">?compact_ultra</span> /=.
<span class="nb">split</span>=&gt; + F UF FUA =&gt; /(_ F UF FUA) [x] [[Ux Ax] Fp].
  <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>=&gt; //; <span class="nb">move</span>/subspace_cvgP: Fp =&gt; /(_ Ax) Fx.
  <span class="bp">by</span> <span class="nb">apply</span>: cvg_trans; [<span class="bp">exact</span>: Fx | <span class="bp">exact</span>: cvg_within].
<span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>/subspace_cvgP =&gt; //.
<span class="nb">rewrite</span> withinE =&gt; W/= -[V nbhsV WV]; <span class="nb">apply</span>: filterS (V `&amp;` (U `&amp;` A)) _ _ _.
  <span class="bp">by</span> <span class="nb">rewrite</span> setIC -setIA [A `&amp;` _]setIC -WV=&gt;?[]?[].
<span class="bp">by</span> <span class="nb">apply</span>: filterI; <span class="nb">rewrite</span> nbhs_simpl //; <span class="bp">exact</span>: Fp.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Subspace</span>.

<span class="kn">Global Instance</span> <span class="nf">subspace_filter</span> {<span class="nv">T</span> : topologicalType}
     (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : subspace A) :
   Filter (nbhs_subspace x) := nbhs_subspace_filter x.

<span class="kn">Global Instance</span> <span class="nf">subspace_proper_filter</span> {<span class="nv">T</span> : topologicalType}
     (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : subspace A) :
   ProperFilter (nbhs_subspace x) := nbhs_subspace_filter x.

<span class="c">(*Notation &quot;{ &#39;within&#39; A , &#39;continuous&#39; f }&quot; :=</span>
<span class="c">  (continuous (f : subspace A -&gt; _)).*)</span>
<span class="kn">Notation</span> <span class="s2">&quot;{ &#39;within&#39; A , &#39;continuous&#39; f }&quot;</span> := (<span class="kr">forall</span> <span class="nv">x</span>,
  cvg_to [filter of fmap f (filter_of (Phantom (subspace A) x))]
         [filter of f x]) : classical_set_scope.

<span class="kn">Section</span> <span class="nf">SubspaceRelative</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType}.
<span class="kn">Implicit Types</span> (<span class="nv">U</span> : topologicalType) (<span class="nv">A</span> <span class="nv">B</span> : <span class="nb">set</span> T).

<span class="kn">Lemma</span> <span class="nf">nbhs_subspace_subset</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">x</span> : T) :
  A `&lt;=` B -&gt; nbhs (x : subspace B) `&lt;=` nbhs (x : subspace A).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /nbhs //= =&gt; AB; <span class="nb">case</span>: (nbhs_subspaceP A); <span class="nb">case</span>: (nbhs_subspaceP B).
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: within_subset =&gt; //=; <span class="bp">exact</span>: (nbhs_filter x).
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? /AB.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; Bx ? W /nbhs_singleton /(_ Bx) ? ? -&gt;.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_subspaceW</span> {<span class="nv">U</span>} <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : T -&gt; U) :
  A `&lt;=` B -&gt;
  {within B, continuous f} -&gt; {within A, continuous f}.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? ctsF ? ? ?; <span class="nb">apply</span>: (@nbhs_subspace_subset A B) =&gt; //; <span class="bp">exact</span>: ctsF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_subspaceT</span> (<span class="nv">x</span> : T) : nbhs (x : subspace setT) = nbhs x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> {<span class="mi">1</span>}/nbhs //=; <span class="nb">have</span> [_|] := nbhs_subspaceP [<span class="nb">set</span>: T]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">cbn</span>.
<span class="nb">rewrite</span> eqEsubset withinE; <span class="nb">split</span> =&gt; [W [V nbhsV]|W ?]; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">W</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span>!setIT =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_subspaceT_for</span> {<span class="nv">U</span>} <span class="nv">A</span> (<span class="nv">f</span> : T -&gt; U) (<span class="nv">x</span> : T) :
  A x -&gt; {<span class="kr">for</span> x, continuous f} -&gt; {<span class="kr">for</span> x, continuous (f : subspace A -&gt; U)}.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /filter_of/nbhs/=/prop_for =&gt; inA ctsf.
<span class="nb">have</span> [_|//] := nbhs_subspaceP A x.
<span class="nb">apply</span>: (cvg_trans _ ctsf); <span class="nb">apply</span>: cvg_fmap2; <span class="nb">apply</span>: cvg_within.
<span class="bp">by</span> <span class="nb">rewrite</span> /subspace; <span class="bp">exact</span>: nbhs_filter.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_in_subspaceT</span> {<span class="nv">U</span>} <span class="nv">A</span> (<span class="nv">f</span> : T -&gt; U) :
  {<span class="kr">in</span> A, continuous f} -&gt; {within A, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> continuous_subspace_in <span class="nl">?in_setP</span> =&gt; ctsf t At.
<span class="bp">by</span> <span class="nb">apply</span> continuous_subspaceT_for =&gt; //=; <span class="nb">apply</span>: ctsf.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_subspaceT</span> {<span class="nv">U</span>} <span class="nv">A</span> (<span class="nv">f</span> : T -&gt; U) :
  continuous f -&gt; {within A, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ctsf; <span class="nb">rewrite</span> continuous_subspace_in =&gt; ? ?.
<span class="bp">exact</span>: continuous_in_subspaceT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_open_subspace</span> {<span class="nv">U</span>} <span class="nv">A</span> (<span class="nv">f</span> : T -&gt; U) :
  open A -&gt; {within A, continuous f} = {<span class="kr">in</span> A, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> openE continuous_subspace_in /= =&gt; oA; <span class="nb">rewrite</span> propeqE <span class="nl">?in_setP</span>.
<span class="bp">by</span> <span class="nb">split</span> =&gt; + x /[dup] Ax /oA Aox =&gt; /(_ _ Ax);
  <span class="nb">rewrite</span> /filter_of -(nbhs_subspace_interior Aox).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_inP</span> {<span class="nv">U</span>} <span class="nv">A</span> (<span class="nv">f</span> : T -&gt; U) : open A -&gt;
  {<span class="kr">in</span> A, continuous f} &lt;-&gt; <span class="kr">forall</span> <span class="nv">X</span>, open X -&gt; open (A `&amp;` f @^-<span class="mi">1</span>` X).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; oA; <span class="nb">rewrite</span> -continuous_open_subspace// continuousP.
<span class="bp">by</span> <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> -open_setSI//.
<span class="kn">Qed</span>.

<span class="c">(* pasting lemma *)</span>
<span class="kn">Lemma</span> <span class="nf">withinU_continuous</span> {<span class="nv">U</span>} <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : T -&gt; U) : closed A -&gt; closed B -&gt;
  {within A, continuous f} -&gt; {within B, continuous f} -&gt;
  {within A `|` B, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ? ? ctsA ctsB; <span class="nb">apply</span>/continuous_closedP =&gt; W oW.
<span class="nb">case</span>/continuous_closedP/(_ _ oW)/closed_subspaceP: ctsA =&gt; V1 [? V1W].
<span class="nb">case</span>/continuous_closedP/(_ _ oW)/closed_subspaceP: ctsB =&gt; V2 [? V2W].
<span class="nb">apply</span>/closed_subspaceP; <span class="kr">exists</span> ((V1 `&amp;` A) `|` (V2 `&amp;` B)); <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: closedU; <span class="bp">exact</span>: closedI.
<span class="nb">rewrite</span> [RHS]setIUr -V2W -V1W eqEsubset; <span class="nb">split</span>=&gt; ?.
  <span class="bp">by</span> <span class="nb">case</span>=&gt; [[][]] ? ? [] ?; [<span class="nb">left</span> | <span class="nb">left</span> | <span class="nb">right</span> | <span class="nb">right</span>]; <span class="nb">split</span>.
<span class="bp">by</span> <span class="nb">case</span>=&gt; [][] ? ?; <span class="nb">split</span>=&gt; []; [<span class="nb">left</span>; <span class="nb">split</span> | <span class="nb">left</span> | <span class="nb">right</span>; <span class="nb">split</span> | <span class="nb">right</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subspaceT_continuous</span> {<span class="nv">U</span>} <span class="nv">A</span> (<span class="nv">B</span> : <span class="nb">set</span> U) (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">A</span> &gt;-&gt; B}) :
  {within A, continuous f} -&gt; continuous (f : subspace A -&gt; subspace B).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /continuousP ctsf; <span class="nb">apply</span>/continuousP =&gt; O /open_subspaceP [V [oV VBOB]].
<span class="nb">rewrite</span> -open_subspaceIT; <span class="nb">apply</span>/open_subspaceP.
<span class="nb">case</span>/open_subspaceP: (ctsf _ oV) =&gt; W [oW fVA]; <span class="kr">exists</span> <span class="nv">W</span>; <span class="nb">split</span> =&gt; //.
<span class="nb">rewrite</span> fVA -setIA setIid eqEsubset; <span class="nb">split</span> =&gt; x [fVx Ax]; <span class="nb">split</span> =&gt; //.
- <span class="bp">by</span> <span class="nb">have</span> /[!VBOB]-[] : (V `&amp;` B) (f x) <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: funS.
- <span class="bp">by</span> <span class="nb">have</span> /[!esym VBOB]-[] : (O `&amp;` B) (f x) <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: funS.
<span class="kn">Qed</span>.


<span class="kn">Lemma</span> <span class="nf">continuous_subspace0</span> {<span class="nv">U</span>} (<span class="nv">f</span> : T -&gt; U) : {within set0, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x Q; <span class="nb">rewrite</span> nbhs_simpl /= {<span class="mi">2</span>}/nbhs /=.
<span class="bp">by</span> <span class="nb">case</span>: (nbhs_subspaceP (@set0 T) x) =&gt; // _ /nbhs_singleton /= ? ? -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_subspace1</span> {<span class="nv">U</span>} (<span class="nv">a</span> : T) (<span class="nv">f</span> : T -&gt; U) :
  {within [<span class="nb">set</span> a], continuous f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x Q; <span class="nb">rewrite</span> nbhs_simpl /= {<span class="mi">2</span>}/nbhs /=.
<span class="nb">case</span>: (nbhs_subspaceP [<span class="nb">set</span> a] x); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; _ /nbhs_singleton /= ? ? -&gt;.
<span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt; /nbhs_singleton ?; <span class="nb">apply</span>: nearW =&gt; ? -&gt;.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">SubspaceRelative</span>.

<span class="kn">Section</span> <span class="nf">SubspaceUniform</span>.
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;A ^-1&quot;</span> := ([<span class="nb">set</span> xy | A (xy.<span class="mi">2</span>, xy.<span class="mi">1</span>)]) : classical_set_scope.
<span class="kn">Context</span> {<span class="nv">X</span> : uniformType} (<span class="nv">A</span> : <span class="nb">set</span> X).

<span class="kn">Definition</span> <span class="nf">subspace_ent</span> :=
  filter_from (@entourage X)
  (<span class="kr">fun</span> <span class="nv">E</span> =&gt; [<span class="nb">set</span> xy | (xy.<span class="mi">1</span> = xy.<span class="mi">2</span>) \/ (A xy.<span class="mi">1</span> /\ A xy.<span class="mi">2</span> /\ E xy)]).

<span class="kn">Program Definition</span> <span class="nf">subspace_uniformMixin</span> :=
  @Uniform.Mixin (subspace A) (@nbhs_subspace _ _) subspace_ent _ _ _ _ _.
<span class="kn">Next Obligation</span>.
<span class="nb">apply</span>: filter_from_filter; <span class="kp">first</span> <span class="bp">by</span> (<span class="kr">exists</span> <span class="nv">setT</span>; <span class="bp">exact</span>: filterT).
<span class="nb">move</span>=&gt; P Q entP entQ; <span class="kr">exists</span> (<span class="nv">P</span> `&amp;` Q); <span class="kp">first</span> <span class="bp">exact</span>: filterI.
<span class="nb">move</span>=&gt; [x y] /=; <span class="nb">case</span>; <span class="kp">first</span> (<span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">split</span>=&gt; /=; <span class="nb">left</span>).
<span class="bp">by</span> <span class="nb">move</span>=&gt; [Ax [Ay [Pxy Qxy]]]; <span class="nb">split</span>=&gt; /=; <span class="nb">right</span>.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? + [x y]/= -&gt;; <span class="nb">case</span>=&gt; V entV; <span class="nb">apply</span>; <span class="nb">left</span>. <span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; ?; <span class="nb">case</span>=&gt; V ? Vsub; <span class="kr">exists</span> (<span class="nv">V</span>^-<span class="mi">1</span>)%classic; <span class="kp">first</span> <span class="bp">exact</span>: entourage_inv.
<span class="nb">move</span>=&gt; [x y] /= G; <span class="nb">apply</span>: Vsub; <span class="nb">case</span>: G; <span class="kp">first</span> <span class="bp">by</span> (<span class="nb">move</span>=&gt; &lt;-; <span class="nb">left</span>).
<span class="bp">by</span> <span class="nb">move</span>=&gt; [? [? Vxy]]; <span class="nb">right</span>; <span class="kp">repeat</span> <span class="nb">split</span> =&gt; //.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; ?; <span class="nb">case</span>=&gt; E entE Esub.
<span class="kr">exists</span>  [<span class="nb">set</span> xy | xy.<span class="mi">1</span> = xy.<span class="mi">2</span> \/ A xy.<span class="mi">1</span> /\ A xy.<span class="mi">2</span> /\ split_ent E xy].
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">split_ent</span> <span class="nv">E</span>).
<span class="nb">move</span>=&gt; [x y] [z /= Ez zE] /=; <span class="nb">case</span>: Ez; <span class="nb">case</span>: zE.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt; -&gt;; <span class="nb">apply</span> Esub; <span class="nb">left</span>.
  - <span class="nb">move</span>=&gt; [ ? []] ? G xy; <span class="nb">subst</span>; <span class="nb">apply</span> Esub; <span class="nb">right</span>; <span class="kp">repeat</span> <span class="nb">split</span> =&gt; //=.
    <span class="bp">by</span> <span class="nb">apply</span>: entourage_split =&gt; //=; <span class="kp">first</span> <span class="bp">exact</span>: G; <span class="bp">exact</span>: entourage_refl.
  - <span class="nb">move</span>=&gt; -&gt; [ ? []] ? G; <span class="nb">apply</span> Esub; <span class="nb">right</span>; <span class="kp">repeat</span> <span class="nb">split</span> =&gt; //=.
    <span class="bp">by</span> <span class="nb">apply</span>: entourage_split =&gt; //=; <span class="kp">first</span> <span class="bp">exact</span>: G; <span class="bp">exact</span>: entourage_refl.
  - <span class="nb">move</span>=&gt; []? []? ?[]?[]??; <span class="nb">apply</span> Esub; <span class="nb">right</span>; <span class="kp">repeat</span> <span class="nb">split</span> =&gt; //=.
    <span class="bp">by</span> <span class="nb">apply</span>: subset_split_ent =&gt; //; <span class="kr">exists</span> <span class="nv">z</span>.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">pose</span>  EA := [<span class="nb">set</span> xy | xy.<span class="mi">1</span> = xy.<span class="mi">2</span> \/ A xy.<span class="mi">1</span> /\ A xy.<span class="mi">2</span>].
<span class="nb">have</span> entEA : subspace_ent EA.
  <span class="kr">exists</span> <span class="nv">setT</span>; <span class="kp">first</span> <span class="bp">exact</span>: filterT.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [??] /= [ -&gt;|[?] [?]];[<span class="nb">left</span>|<span class="nb">right</span>].
<span class="nb">rewrite</span> funeq2E=&gt; x U.
<span class="nb">case</span>: (@nbhs_subspaceP X A x); <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; //=.
- <span class="nb">rewrite</span> withinE; <span class="nb">case</span>=&gt; V /[dup] nbhsV =&gt; [/nbhsP [E entE Esub] UV].
  <span class="kr">exists</span> [<span class="nb">set</span> xy | xy.<span class="mi">1</span> = xy.<span class="mi">2</span> \/ A xy.<span class="mi">1</span> /\ A xy.<span class="mi">2</span> /\ E xy].
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">E</span> =&gt; //= [[??]] /= [-&gt;| [?[]]//]; <span class="bp">exact</span>: entourage_refl.
  <span class="nb">move</span>=&gt; y /= [&lt;-|].
    <span class="nb">suff</span> : (U `&amp;` A) x <span class="bp">by</span> <span class="nb">case</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> UV; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: (@nbhs_singleton X).
  <span class="nb">case</span>=&gt; _ [Ay Ey]; <span class="nb">suff</span> : (U `&amp;` A) y <span class="bp">by</span> <span class="nb">case</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> UV; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: Esub.
- <span class="nb">move</span>=&gt; [] W [E eentE subW] subU //=.
  near=&gt; w; <span class="nb">apply</span>: subU; <span class="nb">apply</span>: subW; <span class="nb">right</span>; <span class="kp">repeat</span> <span class="nb">split</span> =&gt; //=.
    <span class="bp">by</span> <span class="bp">exact</span>: (near (withinT _ (@nbhs_filter X _))).
  <span class="bp">by</span> near: w; <span class="nb">apply</span>/nbhsP; <span class="kr">exists</span> <span class="nv">E</span> =&gt; // y /= Ey.
- <span class="nb">move</span>=&gt; //= Ux; <span class="kr">exists</span> <span class="nv">EA</span> =&gt; //.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; y /= [|[]] //= &lt;-; <span class="nb">apply</span>: Ux.
- <span class="nb">rewrite</span> //= =&gt; [[W [W&#39; entW&#39; subW] subU]] ? -&gt;.
  <span class="bp">by</span> <span class="nb">apply</span>: subU; <span class="nb">apply</span>: subW; <span class="nb">left</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">subspace_uniformType</span> :=
  UniformType (subspace A) subspace_uniformMixin.
<span class="kn">End</span> <span class="nf">SubspaceUniform</span>.

<span class="kn">Section</span> <span class="nf">SubspacePseudoMetric</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">X</span> : pseudoMetricType R} (<span class="nv">A</span> : <span class="nb">set</span> X).

<span class="kn">Definition</span> <span class="nf">subspace_ball</span> (<span class="nv">x</span> : subspace A) (<span class="nv">r</span> : R) :=
  <span class="kr">if</span> x \<span class="kr">in</span> A <span class="kr">then</span> A `&amp;` ball (x : X) r <span class="kr">else</span> [<span class="nb">set</span> x].

<span class="kn">Program Definition</span> <span class="nf">subspace_pseudoMetricType_mixin</span> :=
  @PseudoMetric.Mixin R (subspace A) (subspace_ent A) (subspace_ball)
  _ _ _ _.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; x e; <span class="nb">rewrite</span> /subspace_ball; <span class="nb">case</span>: ifP =&gt; //= /asboolP ? ?.
<span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="bp">exact</span>: ballxx.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; x y e; <span class="nb">rewrite</span> /subspace_ball; <span class="nb">case</span>: ifP =&gt; //= /asboolP ?.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [] Ay /ball_sym yBx; <span class="nb">case</span>: ifP =&gt; /asboolP.
<span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">case</span>: ifP =&gt; /asboolP.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">move</span>=&gt; x y z e1 e2; <span class="nb">rewrite</span> /subspace_ball; (<span class="kp">repeat</span> <span class="nb">case</span>: ifP =&gt; /asboolP).
- <span class="bp">by</span> <span class="nb">move</span>=&gt;?? [??] [??]; <span class="nb">split</span> =&gt; //=; <span class="nb">apply</span>: ball_triangle; <span class="nb">eauto</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ?? [??] -&gt;.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; + /[<span class="nb">swap</span>] =&gt; /[<span class="nb">swap</span>] =&gt; -&gt;.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; _ _ -&gt; -&gt;.
<span class="kn">Qed</span>.
<span class="kn">Next Obligation</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="nb">rewrite</span> /subspace_ball.
  <span class="nb">move</span>=&gt; U [W + subU]; <span class="nb">rewrite</span> -entourage_ballE =&gt; [[eps] nneg subW].
  <span class="kr">exists</span> <span class="nv">eps</span> =&gt; //; <span class="nb">apply</span>: (subset_trans _ subU).
  <span class="nb">move</span>=&gt; [x y] /=; <span class="nb">case</span>: ifP =&gt; /asboolP ?.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; [Ay xBy]; <span class="nb">right</span>; <span class="kp">repeat</span> <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: subW.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">left</span>.
<span class="nb">move</span>=&gt; E [eps nneg subE]; <span class="kr">exists</span> [<span class="nb">set</span> xy | ball (xy.<span class="mi">1</span> : X) eps xy.<span class="mi">2</span>].
  <span class="bp">by</span> <span class="nb">rewrite</span> -entourage_ballE; <span class="kr">exists</span> <span class="nv">eps</span>.
<span class="nb">move</span>=&gt; [x y] /= [-&gt;|[]Ax []Ay xBy]; <span class="nb">apply</span>: subE =&gt; //=.
  <span class="bp">by</span> <span class="nb">case</span>: ifP =&gt; /asboolP; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: ballxx.
<span class="bp">by</span> <span class="nb">case</span>: ifP =&gt; /asboolP.
<span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">subspace_pseudoMetricType</span> :=
  PseudoMetricType (subspace A) subspace_pseudoMetricType_mixin.

<span class="kn">End</span> <span class="nf">SubspacePseudoMetric</span>.

<span class="kn">Section</span> <span class="nf">SubspaceWeak</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType} {<span class="nv">U</span> : pointedType}.
<span class="kn">Variables</span> (<span class="nv">f</span> : U -&gt; T).

<span class="kn">Let</span> <span class="nf">U&#39;</span> := weak_topologicalType f.

<span class="kn">Lemma</span> <span class="nf">weak_subspace_open</span> (<span class="nv">A</span> : <span class="nb">set</span> U&#39;) :
  open A -&gt; open (f @` A : <span class="nb">set</span> (subspace (range f))).
<span class="kn">Proof</span>.
<span class="nb">case</span>=&gt; B oB &lt;-; <span class="nb">apply</span>/open_subspaceP; <span class="kr">exists</span> <span class="nv">B</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> eqEsubset.
<span class="nb">split</span> =&gt; z [] /[<span class="nb">swap</span>]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>=&gt; w _ &lt;- ?; <span class="nb">split</span>; <span class="kr">exists</span> <span class="nv">w</span>.
<span class="bp">by</span> <span class="nb">case</span>=&gt; w _ &lt;- [v] ? &lt;-.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">SubspaceWeak</span>.

<span class="kn">Definition</span> <span class="nf">separate_points_from_closed</span> {<span class="nv">I</span> : <span class="kt">Type</span>} {<span class="nv">T</span> : topologicalType}
    {<span class="nv">U_</span> : I -&gt; topologicalType} (<span class="nv">f_</span> : <span class="kr">forall</span> <span class="nv">i</span>, T -&gt; U_ i) :=
  <span class="kr">forall</span> (<span class="nv">U</span> : <span class="nb">set</span> T) <span class="nv">x</span>,
  closed U -&gt; ~ U x -&gt; <span class="kr">exists</span> <span class="nv">i</span>, ~ (closure (f_ i @` U)) (f_ i x).

<span class="c">(* A handy technique for embedding a space T into a product. The key interface</span>
<span class="c">   is &#39;separate_points_from_closed&#39;, which guarantees that the topologies</span>
<span class="c">   - T&#39;s native topology</span>
<span class="c">   - sup (weak f_i) - the sup of all the weak topologies of f_i</span>
<span class="c">   - weak (x =&gt; (f_1 x, f_2 x,...)) - the weak topology from the product space</span>
<span class="c">  are equivalent (the last equivalence seems to require accessible_space).</span>
<span class="c">*)</span>
<span class="kn">Section</span> <span class="nf">product_embeddings</span>.
<span class="kn">Context</span> {<span class="nv">I</span> : choiceType} {<span class="nv">T</span> : topologicalType} {<span class="nv">U_</span> : I -&gt; topologicalType}.
<span class="kn">Variable</span> (<span class="nv">f_</span> : <span class="kr">forall</span> <span class="nv">i</span>, T -&gt; U_ i).

<span class="kn">Hypothesis</span> <span class="nv">sepf</span> : separate_points_from_closed f_.
<span class="kn">Hypothesis</span> <span class="nv">ctsf</span> : <span class="kr">forall</span> <span class="nv">i</span>, continuous (f_ i).

<span class="kn">Let</span> <span class="nf">weakT</span> := @sup_topologicalType T I
  (<span class="kr">fun</span> <span class="nv">i</span> =&gt; Topological.class (weak_topologicalType (f_ i))).

<span class="kn">Let</span> <span class="nf">PU</span> := product_topologicalType U_.

<span class="kn">Local Notation</span> <span class="nf">sup_open</span> := (@open weakT).
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;&#39;weak_open&#39; i&quot;</span> :=
  (@open (weak_topologicalType (f_ i))) (<span class="kn">at level</span> <span class="mi">0</span>).
<span class="kn">Local Notation</span> <span class="nf">natural_open</span> := (@open T).

<span class="kn">Lemma</span> <span class="nf">weak_sep_cvg</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">x</span> : T) :
  Filter F -&gt; (F --&gt; (x : T)) &lt;-&gt; (F --&gt; (x : weakT)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">split</span>.
  <span class="nb">move</span>=&gt; FTx; <span class="nb">apply</span>/cvg_sup =&gt; i U.
  <span class="nb">have</span> /= -&gt; := @nbhsE (weak_topologicalType (f_ i)) x.
  <span class="nb">case</span>=&gt; B [[C oC &lt;- ?]] /filterS; <span class="nb">apply</span>; <span class="nb">apply</span>: FTx; <span class="nb">rewrite</span> /= nbhsE.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f_</span> <span class="nv">i</span> @^-<span class="mi">1</span>` C) =&gt; //; <span class="nb">split</span> =&gt; //; <span class="bp">exact</span>: open_comp.
<span class="nb">move</span>/cvg_sup =&gt; wiFx U; <span class="nb">rewrite</span> /= nbhs_simpl nbhsE =&gt; [[B [oB ?]]].
<span class="nb">move</span>/filterS; <span class="nb">apply</span>; <span class="nb">have</span> [//|i nclfix] := @sepf _ x (open_closedC oB).
<span class="nb">apply</span>: (wiFx i); <span class="nb">have</span> /= -&gt; := @nbhsE (weak_topologicalType (f_ i)) x.
<span class="kr">exists</span> (<span class="nv">f_</span> <span class="nv">i</span> @^-<span class="mi">1</span>` (~` closure [<span class="nb">set</span> f_ i x | x <span class="kr">in</span> ~` B])); [<span class="nb">split</span>=&gt;//|].
  <span class="nb">apply</span>: open_comp; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?openC</span>; <span class="nb">last</span> <span class="nb">apply</span>: closed_closure.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; + _; <span class="bp">exact</span>: weak_continuous.
<span class="nb">rewrite</span> closureC preimage_bigcup =&gt; z [V [oV]] VnB =&gt; /VnB.
<span class="bp">by</span> <span class="nb">move</span>/forall2NP =&gt; /(_ z) [] // /contrapT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">weak_sep_nbhsE</span> <span class="nv">x</span> : @nbhs T T x = @nbhs T weakT x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; U; <span class="nb">split</span>; <span class="nb">move</span>: U.
  <span class="bp">by</span> <span class="nb">have</span> P := weak_sep_cvg x (nbhs_filter (x : weakT)); <span class="bp">exact</span>/P.
<span class="bp">by</span> <span class="nb">have</span> P := weak_sep_cvg x (nbhs_filter (x : T)); <span class="bp">exact</span>/P.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">weak_sep_openE</span> : @open T = @open weakT.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">rewrite</span> <span class="nl">?openE</span> /interior.
<span class="bp">by</span> <span class="nb">split</span> =&gt; + z =&gt; /(_ z); <span class="nb">rewrite</span> weak_sep_nbhsE.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">join_product</span> (<span class="nv">x</span> : T) : PU := f_ ^~ x.

<span class="kn">Lemma</span> <span class="nf">join_product_continuous</span> : continuous join_product.
<span class="kn">Proof</span>.
<span class="nb">suff</span> : continuous (join_product : weakT -&gt; PU).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; cts x U =&gt; /cts; <span class="nb">rewrite</span> nbhs_simpl /= -weak_sep_nbhsE.
<span class="nb">move</span>=&gt; x; <span class="nb">apply</span>/cvg_sup; <span class="kp">first</span> <span class="bp">exact</span>/fmap_filter/(nbhs_filter (x : weakT)).
<span class="nb">move</span>=&gt; i; <span class="nb">move</span>: x; <span class="nb">apply</span>/(@continuousP _ (weak_topologicalType _)) =&gt; A [B ? E].
<span class="nb">rewrite</span> -E (_ : @^~ i =  proj i) //.
<span class="nb">have</span> -&gt; : join_product @^-<span class="mi">1</span>` (proj i @^-<span class="mi">1</span>` B) = f_ i @^-<span class="mi">1</span>` B <span class="bp">by</span> [].
<span class="nb">apply</span>: open_comp =&gt; // + _; <span class="nb">rewrite</span> /cvg_to =&gt; x U.
<span class="bp">by</span> <span class="nb">rewrite</span> nbhs_simpl /= -weak_sep_nbhsE; <span class="nb">move</span>: x U; <span class="bp">exact</span>: ctsf.
<span class="kn">Qed</span>.

<span class="kn">Local Notation</span> <span class="nf">prod_open</span> :=
  (@open (subspace_topologicalType (range join_product))).

<span class="kn">Lemma</span> <span class="nf">join_product_open</span> (<span class="nv">A</span> : <span class="nb">set</span> T) : open A -&gt;
  open ((join_product @` A) : <span class="nb">set</span> (subspace (range join_product))).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; oA; <span class="nb">rewrite</span> openE =&gt; y /= [x Ax] jxy.
<span class="nb">have</span> [// | i nAfiy] := @sepf (~` A) x (open_closedC oA).
<span class="nb">pose</span> B : <span class="nb">set</span> PU := proj i @^-<span class="mi">1</span>` (~` closure (f_ i @` ~` A)).
<span class="nb">apply</span>: (@filterS _ _ _ (range join_product `&amp;` B)).
  <span class="nb">move</span>=&gt; z [[w ?]] wzE Bz; <span class="kr">exists</span> <span class="nv">w</span> =&gt; //.
  <span class="nb">move</span>: Bz; <span class="nb">rewrite</span> /B -wzE closureC; <span class="nb">case</span>=&gt; K [oK KsubA] /KsubA.
  <span class="nb">have</span> -&gt; : proj i (join_product w) = f_ i w <span class="bp">by</span> [].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /exists2P/forallNP/(_ w)/not_andP [] // /contrapT.
<span class="nb">apply</span>: open_nbhs_nbhs; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -jxy.
<span class="nb">apply</span>: openI; <span class="kp">first</span> <span class="bp">exact</span>: open_subspaceT.
<span class="nb">apply</span>: open_subspaceW; <span class="nb">apply</span>: open_comp; <span class="nb">last</span> <span class="bp">exact</span>/closed_openC/closed_closure.
<span class="bp">by</span> <span class="nb">move</span>=&gt; + _; <span class="bp">exact</span>: proj_continuous.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">join_product_inj</span> : accessible_space T -&gt; set_inj [<span class="nb">set</span>: T] join_product.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /accessible_closed_set1 cl1 x y; <span class="nb">case</span>: (eqVneq x y) =&gt; // xny _ _ jxjy.
<span class="nb">have</span> [] := (@sepf [<span class="nb">set</span> y] x (cl1 y)); <span class="kp">first</span> <span class="bp">by</span> <span class="bp">exact</span>/eqP.
<span class="nb">move</span>=&gt; i P; <span class="nb">suff</span> : join_product x i != join_product y i <span class="bp">by</span> <span class="nb">rewrite</span> jxjy =&gt; /eqP.
<span class="nb">apply</span>/negP; <span class="nb">move</span>: P; <span class="nb">apply</span>: contra_not =&gt; /eqP; <span class="nb">rewrite</span> /join_product =&gt; -&gt;.
<span class="bp">by</span> <span class="nb">apply</span> subset_closure; <span class="kr">exists</span> <span class="nv">y</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">join_product_weak</span> : set_inj [<span class="nb">set</span>: T] join_product -&gt;
  @open T = @open (weak_topologicalType join_product).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; inj; <span class="nb">rewrite</span> predeqE =&gt; U; <span class="nb">split</span>; <span class="kp">first</span> <span class="nb">last</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; [V ? &lt;-]; <span class="nb">apply</span> open_comp =&gt; // + _; <span class="bp">exact</span>: join_product_continuous.
<span class="nb">move</span>=&gt; /join_product_open/open_subspaceP [V [oU VU]].
<span class="kr">exists</span> <span class="nv">V</span> =&gt; //; <span class="nb">have</span> := @<span class="nb">f_equal</span> _ _ (preimage join_product) _ _ VU.
<span class="nb">rewrite</span> !preimage_setI // !preimage_range !setIT =&gt; -&gt;.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: preimage_image.
<span class="bp">by</span> <span class="nb">move</span>=&gt; z [w Uw] /inj &lt;- //; <span class="nb">rewrite</span> inE.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">product_embeddings</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_compact</span> {<span class="nv">T</span> <span class="nv">U</span> : topologicalType} (<span class="nv">f</span> : T -&gt; U) <span class="nv">A</span> :
  {within A, continuous f} -&gt; compact A -&gt; compact (f @` A).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fcont Aco F FF FfA; <span class="nb">set</span> G := filter_from F (<span class="kr">fun</span> <span class="nv">C</span> =&gt; A `&amp;` f @^-<span class="mi">1</span>` C).
<span class="nb">have</span> GF : ProperFilter G.
  <span class="nb">apply</span>: (filter_from_proper (filter_from_filter _ _)).
  - <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f</span> @` A).
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; C1 C2 F1 F2; <span class="kr">exists</span> (<span class="nv">C1</span> `&amp;` C2); [<span class="bp">exact</span>: filterI|<span class="nb">move</span>=&gt; ? [? []]].
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; C /(filterI FfA) /filter_ex [_ [[p ? &lt;-]]]; <span class="kr">exists</span> <span class="nv">p</span>.
<span class="nb">move</span>: Aco; <span class="nb">rewrite</span> -[A]setIid =&gt; /compact_subspaceIP; <span class="nb">rewrite</span> setIid.
<span class="nb">case</span> /(_ G); <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f</span> @` A) =&gt; // ? [].
<span class="nb">move</span>=&gt; p [Ap clsGp]; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">p</span>); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>/imageP.
<span class="nb">move</span>=&gt; B C FB /fcont p_Cf.
<span class="nb">have</span> : G (A `&amp;` f @^-<span class="mi">1</span>` B) <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">B</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /clsGp /(_ p_Cf) [q [[]]]; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">q</span>).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_continuous_connected</span> (<span class="nv">T</span> <span class="nv">U</span> : topologicalType)
    (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; U) :
  connected A -&gt; {within A, continuous f} -&gt; connected (f @` A).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cA cf; <span class="nb">apply</span> contrapT =&gt; /connectedPn[E [E0 fAE sE]].
<span class="nb">set</span> AfE := <span class="kr">fun</span> <span class="nv">b</span> =&gt;(A `&amp;` f @^-<span class="mi">1</span>` E b) : <span class="nb">set</span> (subspace A).
<span class="nb">suff</span> sAfE : separated (AfE false) (AfE true).
  <span class="nb">move</span>: cA; <span class="nb">apply</span>/connectedPn; <span class="kr">exists</span> <span class="nv">AfE</span>; <span class="nb">split</span>; <span class="nb">last</span> (<span class="nb">rewrite</span> /AfE; <span class="nb">split</span>).
  - <span class="nb">move</span>=&gt; b; <span class="nb">case</span>: (E0 b) =&gt; /= u Ebu.
    <span class="nb">have</span> [t Et ftu] : (f @` A) u <span class="bp">by</span> <span class="nb">rewrite</span> fAE; <span class="nb">case</span>: b Ebu; [<span class="nb">right</span>|<span class="nb">left</span>].
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">t</span>; <span class="nb">split</span> =&gt; //=; <span class="nb">rewrite</span> /preimage ftu.
  - <span class="bp">by</span> <span class="nb">rewrite</span> -setIUr -preimage_setU -fAE; <span class="bp">exact</span>/esym/setIidPl/preimage_image.
  + <span class="nb">rewrite</span> -{<span class="mi">2</span>}(setIid A) <span class="nl">?setIA</span> -(@closure_subspaceW _ A); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ?[].
    <span class="bp">by</span> <span class="nb">rewrite</span> -/(AfE false) -setIA -/(AfE true); <span class="nb">case</span>: sAfE.
  + <span class="nb">rewrite</span> -{<span class="mi">1</span>}(setIid A) setIC <span class="nl">?setIA</span> -(@closure_subspaceW _ A).
      <span class="bp">by</span> <span class="nb">rewrite</span> -/(AfE true) -setIA -/(AfE false) setIC; <span class="nb">case</span>: sAfE.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; ?[].
<span class="nb">suff</span> cI0 b : closure (AfE b) `&amp;` AfE (~~ b) = set0.
  <span class="bp">by</span> <span class="nb">rewrite</span> /separated cI0 setIC cI0.
<span class="nb">have</span> [fAfE cEIE] :
    f @` AfE (~~ b) = E (~~ b) /\ closure (E b) `&amp;` E (~~ b) = set0.
  <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>: sE =&gt; ? ?; <span class="nb">case</span>: b =&gt; //; <span class="nb">rewrite</span> setIC.
  <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [|u Ebu].
    <span class="nb">apply</span>: (subset_trans sub_image_setI).
    <span class="bp">by</span> <span class="nb">apply</span> subIset; <span class="nb">right</span>; <span class="bp">exact</span>: image_preimage_subset.
  <span class="nb">have</span> [t [At ftu]] : <span class="kr">exists</span> <span class="nv">t</span>, A t /\ f t = u.
    <span class="nb">suff</span> [t At ftu] : (f @` A) u <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">t</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> fAE; <span class="nb">case</span>: b Ebu; [<span class="nb">left</span>|<span class="nb">right</span>].
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">t</span> =&gt; //; <span class="nb">split</span> =&gt; //=; <span class="nb">rewrite</span> /preimage ftu.
<span class="nb">have</span> ? : f @` closure (AfE b) `&lt;=` closure (E b).
  <span class="nb">have</span> /(@image_subset _ _ f) : closure (AfE b) `&lt;=` f @^-<span class="mi">1</span>` closure (E b).
    <span class="nb">have</span> /closure_id -&gt; : closed (f @^-<span class="mi">1</span>` closure (E b) : <span class="nb">set</span> (subspace A)).
      <span class="bp">by</span> <span class="nb">apply</span>: closed_comp =&gt; //; <span class="bp">exact</span>: closed_closure.
    <span class="nb">apply</span>: closure_subset.
    <span class="nb">have</span> /(@preimage_subset _ _ f) A0cA0 := @subset_closure _ (E b).
    <span class="bp">by</span> <span class="nb">apply</span>: subset_trans A0cA0; <span class="nb">apply</span>: subIset; <span class="nb">right</span>.
  <span class="bp">by</span> <span class="nb">move</span>/subset_trans; <span class="nb">apply</span>; <span class="bp">exact</span>: image_preimage_subset.
<span class="nb">apply</span>/eqP/negPn/negP/set0P =&gt; -[t [? ?]].
<span class="nb">have</span> : f @` closure (AfE b) `&amp;` f @` AfE (~~ b) = set0.
  <span class="bp">by</span> <span class="nb">rewrite</span> fAfE; <span class="bp">exact</span>: subsetI_eq0 cEIE.
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; /(_ (f t)) [fcAfEb] _; <span class="nb">apply</span> fcAfEb; <span class="nb">split</span>; <span class="kr">exists</span> <span class="nv">t</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">uniform_limit_continuous</span> {<span class="nv">U</span> : topologicalType} {<span class="nv">V</span> : uniformType}
    (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) (<span class="nv">f</span> : U -&gt; V) :
  ProperFilter F -&gt; (\<span class="kr">forall</span> <span class="nv">g</span> \near F, continuous (g : U -&gt; V)) -&gt;
  {uniform, F --&gt; f} -&gt; continuous f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; PF ctsF Ff x; <span class="nb">apply</span>/cvg_app_entourageP =&gt; A entA; near F =&gt; g; near=&gt; y.
<span class="nb">apply</span>: (entourage_split (g x)) =&gt; //.
  <span class="bp">by</span> near: g; <span class="nb">apply</span>/Ff/uniform_nbhs; <span class="kr">exists</span> (<span class="nv">split_ent</span> <span class="nv">A</span>); <span class="nb">split</span> =&gt; // ?; <span class="bp">exact</span>.
<span class="nb">apply</span>: (entourage_split (g y)) =&gt; //; near: y; near: g.
  <span class="bp">by</span> <span class="nb">apply</span>: (filterS _ ctsF) =&gt; g /(_ x) /cvg_app_entourageP; <span class="bp">exact</span>.
<span class="nb">apply</span>/Ff/uniform_nbhs; <span class="kr">exists</span> (<span class="nv">split_ent</span> (split_ent A))^-<span class="mi">1</span>%classic.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">exact</span>: entourage_inv | <span class="nb">move</span>=&gt; g fg; near_simpl; near=&gt; z; <span class="bp">exact</span>: fg].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">uniform_limit_continuous_subspace</span> {<span class="nv">U</span> : topologicalType} {<span class="nv">V</span> : uniformType}
    (<span class="nv">K</span> : <span class="nb">set</span> U) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (U -&gt; V))) (<span class="nv">f</span> : subspace K -&gt; V) :
  ProperFilter F -&gt; (\<span class="kr">forall</span> <span class="nv">g</span> \near F, continuous (g : subspace K -&gt; V)) -&gt;
  {uniform K, F --&gt; f} -&gt; {within K, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; PF ctsF Ff; <span class="nb">apply</span>: (@subspace_eq_continuous _ _ _ (restrict K f)).
  <span class="bp">by</span> <span class="nb">rewrite</span> /restrict =&gt; ? -&gt;.
<span class="nb">apply</span>: (@uniform_limit_continuous
  (subspace_topologicalType K) _ (restrict K @ F) _).
  <span class="nb">apply</span>: (filterS _ ctsF) =&gt; g; <span class="nb">apply</span>: subspace_eq_continuous.
  <span class="bp">by</span> <span class="nb">rewrite</span> /restrict =&gt; ? -&gt;.
<span class="bp">by</span> <span class="nb">apply</span> (@uniform_restrict_cvg _ _ F ) =&gt; //; <span class="bp">exact</span>: PF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_localP</span> {<span class="nv">X</span> <span class="nv">Y</span> : topologicalType} (<span class="nv">f</span> : X -&gt; Y) :
  continuous f &lt;-&gt;
  <span class="kr">forall</span> (<span class="nv">x</span> : X), \<span class="kr">forall</span> <span class="nv">U</span> \near powerset_filter_from (nbhs x),
    {within U, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; near=&gt; U; <span class="nb">apply</span>: continuous_subspaceT=&gt; ?; <span class="bp">exact</span>.
<span class="nb">move</span>=&gt; + x =&gt; /(_ x)/near_powerset_filter_fromP.
<span class="nb">case</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="bp">exact</span>: continuous_subspaceW.
<span class="nb">move</span>=&gt; U nbhsU wctsf; <span class="nb">wlog</span> oU : U wctsf nbhsU / open U.
  <span class="nb">move</span>: nbhsU; <span class="nb">rewrite</span> nbhsE =&gt; -[] W [oW Wx WU] /(_ W).
  <span class="bp">by</span> <span class="nb">move</span>/(_ (continuous_subspaceW WU wctsf)); <span class="nb">apply</span> =&gt; //; <span class="kr">exists</span> <span class="nv">W</span>.
<span class="nb">move</span>/nbhs_singleton: nbhsU; <span class="nb">move</span>: x; <span class="nb">apply</span>/in_setP.
<span class="bp">by</span> <span class="nb">rewrite</span> -continuous_open_subspace.
<span class="kn">Unshelve</span>. end_near. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">UniformPointwise</span>.
<span class="kn">Context</span> {<span class="nv">U</span> : topologicalType} {<span class="nv">V</span> : uniformType}.

<span class="kn">Definition</span> <span class="nf">singletons</span> {<span class="nv">T</span> : <span class="kt">Type</span>} := [<span class="nb">set</span> [<span class="nb">set</span> x] | x <span class="kr">in</span> [<span class="nb">set</span>: T]].

<span class="kn">Lemma</span> <span class="nf">pointwise_cvg_family_singleton</span> <span class="nv">F</span> (<span class="nv">f</span>: U -&gt; V):
  Filter F -&gt; {ptws, F --&gt; f} = {family @singletons U, F --&gt; f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF; <span class="nb">rewrite</span> propeqE fam_cvgP cvg_sup; <span class="nb">split</span>.
  <span class="nb">move</span>=&gt; + A [x _ &lt;-] =&gt; /(_ x); <span class="nb">rewrite</span> uniform_set1.
  <span class="nb">rewrite</span> cvg_image; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; v // _; <span class="kr">exists</span> (<span class="nv">cst</span> <span class="nv">v</span>).
  <span class="nb">apply</span>: cvg_trans =&gt; W /=; <span class="nb">rewrite</span> <span class="nl">?nbhs_simpl</span> /fmap /= =&gt; [[W&#39; + &lt;-]].
  <span class="bp">by</span> <span class="nb">apply</span>: filterS =&gt; g W&#39;g /=; <span class="kr">exists</span> <span class="nv">g</span>.
<span class="nb">move</span>=&gt; + i; <span class="nb">have</span> /[<span class="nb">swap</span>] /[<span class="nb">apply</span>] : singletons [<span class="nb">set</span> i] <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>.
<span class="nb">rewrite</span> uniform_set1.
<span class="nb">rewrite</span> cvg_image; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; v // _; <span class="kr">exists</span> (<span class="nv">cst</span> <span class="nv">v</span>).
<span class="nb">move</span>=&gt; + W //=; <span class="nb">rewrite</span> <span class="nl">?nbhs_simpl</span> =&gt; Q =&gt; /Q Q&#39;; <span class="kr">exists</span> (@^~ i @^-<span class="mi">1</span>` W) =&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [j [? + &lt;-//]|j Wj]; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">_</span> =&gt; j).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pointwise_cvg_compact_family</span> <span class="nv">F</span> (<span class="nv">f</span> : U -&gt; V) :
  Filter F -&gt; {family compact, F --&gt; f} -&gt; {ptws, F --&gt; f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; PF; <span class="nb">rewrite</span> pointwise_cvg_family_singleton; <span class="nb">apply</span>: family_cvg_subset.
<span class="bp">by</span> <span class="nb">move</span>=&gt; A [x _ &lt;-]; <span class="bp">exact</span>: compact_set1.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">UniformPointwise</span>.

<span class="kn">Section</span> <span class="nf">ArzelaAscoli</span>.
<span class="kn">Context</span> {<span class="nv">X</span> : topologicalType}.
<span class="kn">Context</span> {<span class="nv">Y</span> : uniformType}.
<span class="kn">Context</span> {<span class="nv">hsdf</span> : hausdorff_space Y}.
<span class="kn">Implicit Types</span> (<span class="nv">I</span> : <span class="kt">Type</span>).

<span class="c">(* The key condition in Arzela-Ascoli that, like uniform continuity,</span>
<span class="c">   moves a quantifier around so all functions have the same &#39;deltas&#39;. *)</span>

<span class="kn">Definition</span> <span class="nf">equicontinuous</span> {<span class="nv">I</span>} (<span class="nv">W</span> : <span class="nb">set</span> I) (<span class="nv">d</span> : I -&gt; (X -&gt; Y)) :=
  <span class="kr">forall</span> <span class="nv">x</span> (<span class="nv">E</span> : <span class="nb">set</span> (Y * Y)), entourage E -&gt;
    \<span class="kr">forall</span> <span class="nv">y</span> \near x, <span class="kr">forall</span> <span class="nv">i</span>, W i -&gt; E(d i x, d i y).

<span class="kn">Lemma</span> <span class="nf">equicontinuous_subset</span> {<span class="nv">I</span> <span class="nv">J</span>} (<span class="nv">W</span> : <span class="nb">set</span> I) (<span class="nv">V</span> : <span class="nb">set</span> J)
    {<span class="nv">fW</span> : I -&gt; X -&gt; Y} {<span class="nv">fV</span> : J -&gt; X -&gt; Y} :
  fW @`W `&lt;=` fV @` V -&gt; equicontinuous V fV -&gt; equicontinuous W fW.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; WsubV + x E entE =&gt; /(_ x E entE); <span class="nb">apply</span>: filterS =&gt; y VE i Wi.
<span class="bp">by</span> <span class="nb">case</span>: (WsubV (fW i)); [<span class="kr">exists</span> <span class="nv">i</span> | <span class="nb">move</span>=&gt; j Vj &lt;-; <span class="bp">exact</span>: VE].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">equicontinuous_subset_id</span> (<span class="nv">W</span> <span class="nv">V</span> : <span class="nb">set</span> (X -&gt; Y)) :
  W `&lt;=` V -&gt; equicontinuous V id -&gt; equicontinuous W id.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; WsubV; <span class="nb">apply</span>: equicontinuous_subset =&gt; ? [y ? &lt;- /=]; <span class="kr">exists</span> <span class="nv">y</span> =&gt; //.
<span class="bp">exact</span>: WsubV.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">equicontinuous_continuous_for</span> {<span class="nv">I</span>} (<span class="nv">W</span> : <span class="nb">set</span> I) (<span class="nv">fW</span> : I -&gt; X -&gt; Y) <span class="nv">i</span> <span class="nv">x</span> :
  {<span class="kr">for</span> x, equicontinuous W fW} -&gt; W i -&gt; {<span class="kr">for</span> x, continuous (fW i)}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ectsW Wf; <span class="nb">apply</span>/cvg_entourageP =&gt; E entE; near_simpl.
<span class="bp">by</span> near=&gt; y; <span class="nb">apply</span>: (near (ectsW _ entE) y).
<span class="kn">Unshelve</span>. end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">equicontinuous_continuous</span> {<span class="nv">I</span>} (<span class="nv">W</span> : <span class="nb">set</span> I) (<span class="nv">fW</span> : I -&gt; (X -&gt; Y)) (<span class="nv">i</span> : I) :
  equicontinuous W fW -&gt; W i -&gt; continuous (fW i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ectsW Wf x; <span class="nb">apply</span>: equicontinuous_continuous_for; <span class="nb">last</span> <span class="bp">exact</span>: Wf.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: ectsW.
<span class="kn">Qed</span>.

<span class="c">(* A convenient notion that is in between compactness in</span>
<span class="c">   {family compact, X -&gt; y} and compactness in {ptws X -&gt; y}.*)</span>
<span class="kn">Definition</span> <span class="nf">pointwise_precompact</span> {<span class="nv">I</span>} (<span class="nv">W</span> : <span class="nb">set</span> I) (<span class="nv">d</span> : I -&gt; X -&gt; Y) :=
  <span class="kr">forall</span> <span class="nv">x</span>, precompact [<span class="nb">set</span> (d i x) | i <span class="kr">in</span> W].

<span class="kn">Lemma</span> <span class="nf">pointwise_precompact_subset</span> {<span class="nv">I</span> <span class="nv">J</span>} (<span class="nv">W</span> : <span class="nb">set</span> I) (<span class="nv">V</span> : <span class="nb">set</span> J)
    {<span class="nv">fW</span> : I -&gt; X -&gt; Y} {<span class="nv">fV</span> : J -&gt; X -&gt; Y} :
  fW @` W `&lt;=` fV @` V -&gt; pointwise_precompact V fV -&gt;
  pointwise_precompact W fW.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; WsubV + x =&gt; /(_ x) pcptV; <span class="nb">apply</span>: precompact_subset pcptV =&gt; y [i Wi &lt;-].
<span class="bp">by</span> <span class="nb">case</span>: (WsubV (fW i)); [<span class="kr">exists</span> <span class="nv">i</span> | <span class="nb">move</span>=&gt; j Vj &lt;-; <span class="kr">exists</span> <span class="nv">j</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pointwise_precompact_precompact</span> {<span class="nv">I</span>} (<span class="nv">W</span> : <span class="nb">set</span> I) (<span class="nv">fW</span> : I -&gt; (X -&gt; Y)) :
  pointwise_precompact W fW -&gt; precompact ((fW @` W) : <span class="nb">set</span> {ptws X -&gt; Y}).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> precompactE =&gt; ptwsPreW.
<span class="nb">pose</span> K := <span class="kr">fun</span> <span class="nv">x</span> =&gt; closure [<span class="nb">set</span> fW i x | i <span class="kr">in</span> W].
<span class="nb">set</span> R := [<span class="nb">set</span> f : {ptws X -&gt; Y} | <span class="kr">forall</span> <span class="nv">x</span> : X, K x (f x)].
<span class="nb">have</span> C : compact R.
  <span class="bp">by</span> <span class="nb">apply</span>: tychonoff =&gt; x; <span class="nb">rewrite</span> -precompactE; <span class="nb">move</span>: ptwsPreW; <span class="bp">exact</span>.
<span class="nb">apply</span>: (subclosed_compact _ C); <span class="kp">first</span> <span class="bp">exact</span>: closed_closure.
<span class="nb">have</span> WsubR : (fW @` W) `&lt;=` R.
  <span class="nb">move</span>=&gt; f Wf x; <span class="nb">rewrite</span> /R /K closure_limit_point; <span class="nb">left</span>.
  <span class="bp">by</span> <span class="nb">case</span>: Wf =&gt; i ? &lt;-; <span class="kr">exists</span> <span class="nv">i</span>.
<span class="nb">rewrite</span> closureE;  <span class="nb">apply</span>: smallest_sub (compact_closed _ C) WsubR.
<span class="bp">exact</span>: hausdorff_product.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">uniform_pointwise_compact</span> (<span class="nv">W</span> : <span class="nb">set</span> (X -&gt; Y)) :
  compact (W : <span class="nb">set</span> (@fct_UniformFamily X Y compact)) -&gt;
  compact (W : <span class="nb">set</span> {ptws X -&gt; Y}).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> [x <span class="kr">in</span> x _ -&gt; _]compact_ultra [x <span class="kr">in</span> _ -&gt; x _]compact_ultra.
<span class="nb">move</span>=&gt; + F UF FW =&gt; /(_ F UF FW) [h [Wh Fh]]; <span class="kr">exists</span> <span class="nv">h</span>; <span class="nb">split</span> =&gt; //.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Q Fq; <span class="nb">apply</span>: (pointwise_cvg_compact_family _ Fh).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">precompact_pointwise_precompact</span> (<span class="nv">W</span> : <span class="nb">set</span> {family compact, X -&gt; Y}) :
  precompact W -&gt; pointwise_precompact W id.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; + x; <span class="nb">rewrite</span> <span class="nl">?precompactE</span> =&gt; pcptW.
<span class="nb">have</span> : compact (proj x @` (closure W)).
  <span class="nb">apply</span>: continuous_compact =&gt; //; <span class="nb">apply</span>: continuous_subspaceT=&gt; g.
  <span class="nb">move</span>=&gt; E nbhsE; <span class="nb">have</span> := (@proj_continuous _ _ x g E nbhsE).
  <span class="bp">exact</span>: (@pointwise_cvg_compact_family _ _ (nbhs g)).
<span class="nb">move</span>=&gt; /[dup]/(compact_closed hsdf)/closure_id -&gt; /subclosed_compact.
<span class="nb">apply</span>; <span class="kp">first</span> <span class="bp">exact</span>: closed_closure.
<span class="bp">by</span> <span class="nb">apply</span>/closure_subset/image_subset; <span class="bp">exact</span>: (@subset_closure _ W).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pointwise_cvg_entourage</span> (<span class="nv">x</span> : X) (<span class="nv">f</span> : {ptws X -&gt; Y}) <span class="nv">E</span> :
  entourage E -&gt; \<span class="kr">forall</span> <span class="nv">g</span> \near f, E (f x, g x).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; entE; <span class="nb">have</span> : ({ptws, nbhs f --&gt; f}) <span class="bp">by</span> [].
<span class="nb">rewrite</span> pointwise_cvg_family_singleton =&gt; /fam_cvgP /(_ [<span class="nb">set</span> x]).
<span class="nb">rewrite</span> uniform_set1 =&gt; /(_ _ (to_set E (f x))); <span class="nb">apply</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>.
<span class="bp">by</span> <span class="nb">move</span>: E entE; <span class="bp">exact</span>/cvg_entourageP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">equicontinuous_closure</span> (<span class="nv">W</span> : <span class="nb">set</span> {ptws X -&gt; Y}) :
  equicontinuous W id -&gt; equicontinuous (closure W) id.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ectsW =&gt; x E entE; near=&gt; y =&gt; f clWf.
near (within W (nbhs (f : {ptws X -&gt; Y}))) =&gt; g.
near: g; <span class="nb">rewrite</span> near_withinE; near_simpl; near=&gt; g =&gt; Wg.
<span class="nb">apply</span>: (@entourage_split _ (g x)) =&gt; //.
  <span class="bp">exact</span>: (near (pointwise_cvg_entourage _ _ _)).
<span class="nb">apply</span>: (@entourage_split _ (g y)) =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: (near (@ectsW x _ _)).
<span class="bp">by</span> <span class="nb">apply</span>/entourage_sym; <span class="bp">exact</span>: (near (pointwise_cvg_entourage _ _ _)).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">small_ent_sub</span> := @small_set_sub _ _ (@entourage Y).

<span class="kn">Lemma</span> <span class="nf">pointwise_compact_cvg</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> {ptws X -&gt; Y})) (<span class="nv">f</span> : {ptws X -&gt; Y}) :
  ProperFilter F -&gt;
  (\<span class="kr">forall</span> <span class="nv">W</span> \near powerset_filter_from F, equicontinuous W id) -&gt;
  {ptws, F --&gt; f} &lt;-&gt; {family compact, F --&gt; f}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; PF /near_powerset_filter_fromP; <span class="nb">case</span>.
  <span class="bp">exact</span>: equicontinuous_subset_id.
<span class="nb">move</span>=&gt; W; <span class="nb">wlog</span> Wf : f W / W f.
  <span class="nb">move</span>=&gt; + FW /equicontinuous_closure =&gt; /(_ f (closure W)) Q.
  <span class="nb">split</span> =&gt; Ff; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: pointwise_cvg_compact_family.
  <span class="nb">apply</span> Q =&gt; //; <span class="nb">last</span> <span class="bp">by</span> (<span class="nb">apply</span>: (filterS _ FW); <span class="bp">exact</span>: subset_closure).
  <span class="bp">by</span> <span class="nb">rewrite</span> closureEcvg; <span class="kr">exists</span> <span class="nv">F</span>; [|<span class="nb">split</span>] =&gt; // ? /filterS; <span class="nb">apply</span>.
<span class="nb">move</span>=&gt; FW ectsW; <span class="nb">split</span>=&gt; [ptwsF|]; <span class="nb">last</span> <span class="bp">exact</span>: pointwise_cvg_compact_family.
<span class="nb">apply</span>/fam_cvgP =&gt; K ? U /=; <span class="nb">rewrite</span> uniform_nbhs =&gt; [[E [eE EsubU]]].
<span class="nb">suff</span> : \<span class="kr">forall</span> <span class="nv">g</span> \near within W (nbhs f), <span class="kr">forall</span> <span class="nv">y</span>, K y -&gt; E (f y, g y).
  <span class="nb">rewrite</span> near_withinE; near_simpl =&gt; N; <span class="nb">apply</span>: (filter_app _ _ FW).
  <span class="bp">by</span> <span class="nb">apply</span> ptwsF; near=&gt; g =&gt; ?; <span class="nb">apply</span> EsubU; <span class="nb">apply</span>: (near N g).
near (powerset_filter_from (@entourage Y)) =&gt; E&#39;.
<span class="nb">have</span> entE&#39; : entourage E&#39; <span class="bp">by</span> <span class="bp">exact</span>: (near (near_small_set _)).
<span class="nb">pose</span> Q := <span class="kr">fun</span> (<span class="nv">h</span> : X -&gt; Y) <span class="nv">x</span> =&gt; E&#39; (f x, h x).
<span class="nb">apply</span>: compact_near_coveringP.<span class="mi">1</span> =&gt; // x Kx.
near=&gt; y g =&gt; /=.
<span class="nb">apply</span>: (entourage_split (f x) eE).
  <span class="nb">apply</span> entourage_sym; <span class="nb">apply</span>: (near (small_ent_sub _) E&#39;) =&gt; //.
  <span class="bp">exact</span>: (near (ectsW x E&#39; entE&#39;) y).
<span class="nb">apply</span>: (@entourage_split _ (g x)) =&gt; //.
  <span class="nb">apply</span>: (near (small_ent_sub _) E&#39;) =&gt; //.
  near: g; near_simpl; <span class="nb">apply</span>: (@cvg_within _ (nbhs f)).
  <span class="bp">exact</span>: pointwise_cvg_entourage.
<span class="nb">apply</span>: (near (small_ent_sub _) E&#39;) =&gt; //.
<span class="nb">apply</span>: (near (ectsW x E&#39; entE&#39;)) =&gt; //.
<span class="bp">exact</span>: (near (withinT _ (nbhs_filter f))).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pointwise_compact_closure</span> (<span class="nv">W</span> : <span class="nb">set</span> (X -&gt; Y)) :
  equicontinuous W id -&gt;
  closure (W : <span class="nb">set</span> {family compact, X -&gt; Y}) =
  closure (W : <span class="nb">set</span> {ptws X -&gt; Y}).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> <span class="nl">?closureEcvg</span> // predeqE =&gt; ? ?.
<span class="nb">split</span>; <span class="nb">move</span>=&gt; [F PF [Fx WF]]; (<span class="kr">exists</span> <span class="nv">F</span>; <span class="nb">last</span> <span class="nb">split</span>) =&gt; //.
  <span class="nb">apply</span>/@pointwise_compact_cvg =&gt; //; <span class="nb">apply</span>/near_powerset_filter_fromP.
    <span class="bp">exact</span>: equicontinuous_subset_id.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">W</span> =&gt; //; <span class="bp">exact</span>: WF.
<span class="nb">apply</span>/@pointwise_compact_cvg =&gt; //; <span class="nb">apply</span>/near_powerset_filter_fromP.
  <span class="bp">exact</span>: equicontinuous_subset_id.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">W</span> =&gt; //; <span class="bp">exact</span>: WF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pointwise_precompact_equicontinuous</span> (<span class="nv">W</span> : <span class="nb">set</span> (X -&gt; Y)) :
  pointwise_precompact W id -&gt;
  equicontinuous W id -&gt;
  precompact (W : <span class="nb">set</span> {family compact, X -&gt; Y }).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /pointwise_precompact_precompact + ectsW.
<span class="nb">rewrite</span> <span class="nl">?precompactE</span> compact_ultra compact_ultra pointwise_compact_closure //.
<span class="nb">move</span>=&gt; /= + F UF FcW =&gt; /(_ F UF); <span class="nb">rewrite</span> image_id; <span class="nb">case</span> =&gt; // p [cWp Fp].
<span class="kr">exists</span> <span class="nv">p</span>; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>/(pointwise_compact_cvg) =&gt; //.
<span class="nb">apply</span>/near_powerset_filter_fromP; <span class="kp">first</span> <span class="bp">exact</span>: equicontinuous_subset_id.
<span class="kr">exists</span> (<span class="nv">closure</span> (W : <span class="nb">set</span> {ptws X -&gt; Y })) =&gt; //; <span class="bp">exact</span>: equicontinuous_closure.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">precompact_equicontinuous</span>.
<span class="kn">Hypothesis</span> <span class="nv">lcptX</span> : locally_compact [<span class="nb">set</span>: X].

<span class="kn">Let</span> <span class="nf">compact_equicontinuous</span> (<span class="nv">W</span> : <span class="nb">set</span> {family compact, X -&gt; Y}) :
  (<span class="kr">forall</span> <span class="nv">f</span>, W f -&gt; continuous f) -&gt;
  compact (W : <span class="nb">set</span> {family compact, X -&gt; Y}) -&gt;
  equicontinuous W id.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ctsW cptW x E entE.
<span class="nb">have</span> [//|U UWx [cptU clU]] := @lcptX x; <span class="nb">rewrite</span> withinET <span class="kr">in</span> UWx.
near (powerset_filter_from (@entourage Y)) =&gt; E&#39;.
<span class="nb">have</span> entE&#39; : entourage E&#39; <span class="bp">by</span> <span class="bp">exact</span>: (near (near_small_set _)).
<span class="nb">pose</span> Q := <span class="kr">fun</span> (<span class="nv">y</span> : X) (<span class="nv">f</span> : {family compact, X -&gt; Y}) =&gt; E&#39; (f x, f y).
<span class="nb">apply</span>: (compact_near_coveringP.<span class="mi">1</span> _ cptW) =&gt; f Wf; near=&gt; g y =&gt; /=.
<span class="nb">apply</span>: (entourage_split (f x) entE).
  <span class="nb">apply</span>/entourage_sym; <span class="nb">apply</span>: (near (small_ent_sub _) E&#39;) =&gt; //.
  <span class="bp">exact</span>: (near (fam_nbhs _ entE&#39; (@compact_set1 _ x)) g).
<span class="nb">apply</span>: (entourage_split (f y) (entourage_split_ent entE)).
  <span class="nb">apply</span>: (near (small_ent_sub _) E&#39;) =&gt; //.
  <span class="bp">by</span> near: y; <span class="nb">apply</span>: ((@ctsW f Wf x) (to_set _ _)); <span class="bp">exact</span>: nbhs_entourage.
<span class="nb">apply</span>: (near (small_ent_sub _) E&#39;) =&gt; //.
<span class="bp">by</span> <span class="nb">apply</span> (near (fam_nbhs _ entE&#39; cptU) g) =&gt; //; <span class="bp">exact</span>: (near UWx y).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">precompact_equicontinuous</span> (<span class="nv">W</span> : <span class="nb">set</span> {family compact, X -&gt; Y}) :
  (<span class="kr">forall</span> <span class="nv">f</span>, W f -&gt; continuous f) -&gt;
  precompact (W : <span class="nb">set</span> {family compact, X -&gt; Y}) -&gt;
  equicontinuous W id.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; pcptW ctsW; <span class="nb">apply</span> (equicontinuous_subset_id (@subset_closure _ W)).
<span class="nb">apply</span>: compact_equicontinuous; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -precompactE.
<span class="nb">move</span>=&gt; f; <span class="nb">rewrite</span> closureEcvg =&gt; [[G PG [Gf GW]]] x B /=.
<span class="nb">rewrite</span> -nbhs_entourageE =&gt; -[E entE] /filterS; <span class="nb">apply</span>; near_simpl.
<span class="nb">suff</span> ctsf : continuous f <span class="bp">by</span> <span class="nb">move</span>: E entE; <span class="nb">apply</span>/cvg_app_entourageP; <span class="bp">exact</span>: ctsf.
<span class="nb">apply</span>/continuous_localP =&gt; x&#39;; <span class="nb">apply</span>/near_powerset_filter_fromP.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="bp">exact</span>: continuous_subspaceW.
<span class="nb">case</span>: (@lcptX x&#39;) =&gt; // U; <span class="nb">rewrite</span> withinET =&gt; nbhsU [cptU _].
<span class="kr">exists</span> <span class="nv">U</span> =&gt; //; <span class="nb">apply</span>: (uniform_limit_continuous_subspace PG _ _).
  <span class="bp">by</span> near=&gt; g; <span class="nb">apply</span>: continuous_subspaceT; near: g; <span class="bp">exact</span>: GW.
<span class="bp">by</span> <span class="nb">move</span>/fam_cvgP/(_ _ cptU) : Gf.
<span class="kn">Unshelve</span>. end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">precompact_equicontinuous</span>.

<span class="kn">Theorem</span> <span class="nf">Ascoli</span> (<span class="nv">W</span> : <span class="nb">set</span> {family compact, X -&gt; Y}) :
    locally_compact [<span class="nb">set</span>: X] -&gt;
  pointwise_precompact W id /\ equicontinuous W id &lt;-&gt;
    (<span class="kr">forall</span> <span class="nv">f</span>, W f -&gt; continuous f) /\
    precompact (W : <span class="nb">set</span> {family compact, X -&gt; Y}).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; lcpt; <span class="nb">split</span> =&gt; [[Wid ectsW]|[fWf]pcptW].
  <span class="nb">split</span>=&gt; [?|]; <span class="kp">first</span> <span class="bp">exact</span>: equicontinuous_continuous.
  <span class="bp">exact</span>: pointwise_precompact_equicontinuous.
<span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: precompact_equicontinuous.
<span class="bp">exact</span>: precompact_pointwise_precompact.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ArzelaAscoli</span>.</span></pre></article></body></html>