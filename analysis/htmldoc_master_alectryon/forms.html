<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>forms.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp
<span class="kn">Require Import</span> all_ssreflect ssralg fingroup zmodp poly ssrnum.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predI _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predU _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predD _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predC _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ preim _ of _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closedM;
                   GRing.smulr_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedM; GRing.smulr_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed.
New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.sdivr_closed_div;
                   GRing.divr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.sdivr_closedM; GRing.smulr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subalg_closedBM;
                   GRing.subring_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subalg_closedZ; GRing.submod_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divring_closed_div;
                   GRing.sdivr_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divring_closedBM; GRing.subring_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divalg_closedBdiv;
                   GRing.divring_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divalg_closedZ; GRing.subalg_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.Pred.subring_smul;
                   GRing.Pred.smul_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.Pred.subring_semi; GRing.Pred.semiring_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> mathcomp
<span class="kn">Require Import</span> matrix mxalgebra vector falgebra ssrnum algC algnum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> mathcomp
<span class="kn">Require Import</span> fieldext.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> vector.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* From mathcomp Require classfun. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Strict Implicit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Printing Implicit Defensive</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> GRing.Theory Num.Theory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;[ u , v ]&quot;</span>
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;[hv&#39; &#39;&#39;[&#39; u , &#39;/ &#39;  v ] &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;[ u , v ]_ M&quot;</span>
         (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;[hv&#39; &#39;&#39;[&#39; u , &#39;/ &#39;  v ]_ M &#39;]&#39;&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;[ u ]_ M&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;[&#39; u ]_ M&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;&#39;[ u ]&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;[&#39; u ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;u &#39;``_&#39; i&quot;</span>
    (<span class="kn">at level</span> <span class="mi">3</span>, i <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">left associativity</span>, <span class="kn">format</span> <span class="s2">&quot;u &#39;``_&#39; i&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A ^_|_&quot;</span>    (<span class="kn">at level</span> <span class="mi">8</span>, <span class="kn">format</span> <span class="s2">&quot;A ^_|_&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;A _|_ B&quot;</span> (<span class="kn">at level</span> <span class="mi">69</span>, <span class="kn">format</span> <span class="s2">&quot;A  _|_  B&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;eps_theta .-sesqui&quot;</span> (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;eps_theta .-sesqui&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;u &#39;``_&#39; i&quot;</span> := (u (GRing.zero (Zp_zmodType O)) i) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;e_&#39; i&quot;</span> := (delta_mx <span class="mi">0</span> i)
 (<span class="kn">format</span> <span class="s2">&quot;&#39;&#39;e_&#39; i&quot;</span>, <span class="kn">at level</span> <span class="mi">3</span>) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;M ^ phi&quot;</span> := (map_mx phi M).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;M ^t phi&quot;</span> := (map_mx phi (M ^T)) (phi <span class="kn">at level</span> <span class="mi">30</span>, <span class="kn">at level</span> <span class="mi">30</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Structure</span> <span class="nf">revop</span> <span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span> (<span class="nv">f</span> : Y -&gt; X -&gt; Z) := RevOp {
  fun_of_revop :&gt; X -&gt; Y -&gt; Z;
  _ : <span class="kr">forall</span> <span class="nv">x</span>, f x =<span class="mi">1</span> fun_of_revop^~ x
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_map_mx</span> (<span class="nv">R</span> <span class="nv">S</span> : ringType) <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">M</span> : &#39;M[R]_(m,n))
      (<span class="nv">g</span> <span class="nv">f</span> : R -&gt; S) : f =<span class="mi">1</span> g -&gt; M ^ f = M ^ g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R, S</var><span class="hyp-type"><b>: </b><span>ringType</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>&#39;M_(m, n)</span></span></span><br><span><var>g, f</var><span class="hyp-type"><b>: </b><span>R -&gt; S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f =<span class="mi">1</span> g -&gt; M ^ f = M ^ g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; eq_fg; <span class="nb">apply</span>/matrixP=&gt; i j; <span class="nb">rewrite</span> !mxE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">map_mx_id</span> (<span class="nv">R</span> : ringType) <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">M</span> : &#39;M[R]_(m,n)) : M ^ id = M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>ringType</span></span></span><br><q>6</q><br><q>7</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M ^ id = M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/matrixP=&gt; i j; <span class="nb">rewrite</span> !mxE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_map_mx_id</span> (<span class="nv">R</span> : ringType) <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">M</span> : &#39;M[R]_(m,n)) (<span class="nv">f</span> : R -&gt; R) :
  f =<span class="mi">1</span> id -&gt; M ^ f = M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>6</q><br><q>7</q><br><span><var>f</var><span class="hyp-type"><b>: </b><span>R -&gt; R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f =<span class="mi">1</span> id -&gt; M ^ f = M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>13</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /eq_map_mx-&gt;; <span class="nb">rewrite</span> map_mx_id.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Bilinear</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ClassDef</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">R</span> : ringType) (<span class="nv">U</span> <span class="nv">U&#39;</span> : lmodType R) (<span class="nv">V</span> : zmodType) (<span class="nv">s</span> <span class="nv">s&#39;</span> : R -&gt; V -&gt; V).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Type</span> <span class="nf">phUU&#39;V</span> : phant (U -&gt; U&#39; -&gt; V).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Coercion</span> <span class="nf">GRing</span>.Scale.op : GRing.Scale.law &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">axiom</span> (<span class="nv">f</span> : U -&gt; U&#39; -&gt; V) (<span class="nv">s_law</span> : GRing.Scale.law s) (<span class="nv">eqs</span> : s = s_law)
                                    (<span class="nv">s&#39;_law</span> : GRing.Scale.law s&#39;) (<span class="nv">eqs&#39;</span> : s&#39; = s&#39;_law) :=
  ((<span class="kr">forall</span> <span class="nv">u&#39;</span>, GRing.Linear.axiom (f^~ u&#39;) eqs)
  * (<span class="kr">forall</span> <span class="nv">u</span>, GRing.Linear.axiom (f u) eqs&#39;))%type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">f</span> : U -&gt; U&#39; -&gt; V) : <span class="kt">Prop</span> := <span class="kn">Class</span> {
  basel : <span class="kr">forall</span> <span class="nv">u&#39;</span>, GRing.Linear.class_of s (f^~ u&#39;);
  baser : <span class="kr">forall</span> <span class="nv">u</span>, GRing.Linear.class_of s&#39; (f u)
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">class_of_axiom</span> <span class="nv">f</span> <span class="nv">s_law</span> <span class="nv">s&#39;_law</span> <span class="nv">Ds</span> <span class="nv">Ds&#39;</span> :
   @axiom f s_law Ds s&#39;_law Ds&#39; -&gt; class_of f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><span><var>U, U'</var><span class="hyp-type"><b>: </b><span>lmodType R</span></span></span><br><span><var>V</var><span class="hyp-type"><b>: </b><span>zmodType</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>R -&gt; V -&gt; V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>U -&gt; U&#39; -&gt; V</span></span></span><br><span><var>s_law</var><span class="hyp-type"><b>: </b><span>GRing.Scale.law s</span></span></span><br><span><var>s'_law</var><span class="hyp-type"><b>: </b><span>GRing.Scale.law s&#39;</span></span></span><br><span><var>Ds</var><span class="hyp-type"><b>: </b><span>s = s_law</span></span></span><br><span><var>Ds'</var><span class="hyp-type"><b>: </b><span>s&#39; = s&#39;_law</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">axiom f Ds Ds&#39; -&gt; class_of f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">pose</span> coa := GRing.Linear.class_of_axiom; <span class="nb">move</span>=&gt; [/(_ _) /coa ? /(_ _) /coa].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Structure</span> <span class="nf">map</span> <span class="nv">phUU&#39;V</span> := Pack {<span class="nb">apply</span>; _ : class_of <span class="nb">apply</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Coercion</span> <span class="nf">apply</span> : map &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">class</span> (<span class="nv">phUU&#39;V</span> : _)  (<span class="nv">cF</span> : map phUU&#39;V) :=
   <span class="kr">let</span>: Pack _ c <span class="kr">as</span> cF&#39; := cF <span class="kr">return</span> class_of cF&#39; <span class="kr">in</span> c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">additiver</span> phU&#39;V phUU&#39;V (u : U) cF := GRing.Additive.Pack phU&#39;V
  (baser (@class phUU&#39;V cF) u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">linearr</span> phU&#39;V  phUU&#39;V (u : U) cF := GRing.Linear.Pack phU&#39;V
  (baser (@class phUU&#39;V cF) u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Fact applyr_key : unit. Proof. exact. Qed. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">applyr_head</span> <span class="nv">t</span> (<span class="nv">f</span> : U -&gt; U&#39; -&gt; V) <span class="nv">u</span> <span class="nv">v</span> := <span class="kr">let</span>: tt := t <span class="kr">in</span> f v u.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">applyr</span> := (@applyr_head tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">additivel</span> phUV phUU&#39;V (u&#39; : U&#39;) (cF : map _) :=
  @GRing.Additive.Pack _ _ phUV (applyr cF u&#39;) (basel (@class phUU&#39;V cF) u&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">linearl</span> phUV phUU&#39;V  (u&#39; : U&#39;) (cF : map _) :=
  @GRing.Linear.Pack _ _ _ _ phUV (applyr cF u&#39;) (basel (@class phUU&#39;V cF) u&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pack</span> (<span class="nv">phUV</span> : phant (U -&gt; V)) (<span class="nv">phU&#39;V</span> : phant (U&#39; -&gt; V))
           (<span class="nv">revf</span> : U&#39; -&gt; U -&gt; V) (<span class="nv">rf</span> : revop revf) <span class="nv">f</span> (<span class="nv">g</span> : U -&gt; U&#39; -&gt; V) <span class="nv">of</span> (<span class="nv">g</span> = fun_of_revop rf) :=
  <span class="kr">fun</span> (<span class="nv">bFl</span> : U&#39; -&gt; GRing.Linear.map s phUV) <span class="nv">flc</span> <span class="nv">of</span> (<span class="nv">forall</span> <span class="nv">u&#39;</span>, revf u&#39; = bFl u&#39;) &amp;
      (<span class="kr">forall</span> <span class="nv">u&#39;</span>, phant_id (GRing.Linear.class (bFl u&#39;)) (flc u&#39;)) =&gt;
  <span class="kr">fun</span> (<span class="nv">bFr</span> : U -&gt; GRing.Linear.map s&#39; phU&#39;V) <span class="nv">frc</span> <span class="nv">of</span> (<span class="nv">forall</span> <span class="nv">u</span>, g u = bFr u) &amp;
      (<span class="kr">forall</span> <span class="nv">u</span>, phant_id (GRing.Linear.class (bFr u)) (frc u)) =&gt;
  @Pack (Phant _) f (<span class="kn">Class</span> <span class="nf">flc</span> <span class="nv">frc</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* (* Support for right-to-left rewriting with the generic linearZ rule. *) *)</span>
<span class="c">(* Notation mapUV := (map (Phant (U -&gt; U&#39; -&gt; V))). *)</span>
<span class="c">(* Definition map_class := mapUV. *)</span>
<span class="c">(* Definition map_at (a : R) := mapUV. *)</span>
<span class="c">(* Structure map_for a s_a := MapFor {map_for_map : mapUV; _ : s a = s_a}. *)</span>
<span class="c">(* Definition unify_map_at a (f : map_at a) := MapFor f (erefl (s a)). *)</span>
<span class="c">(* Structure wrapped := Wrap {unwrap : mapUV}. *)</span>
<span class="c">(* Definition wrap (f : map_class) := Wrap f. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ClassDef</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> linear_ring_scope <span class="kr">with</span> linR.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">bilinear_for</span> s s&#39; f := (axiom f (erefl s) (erefl s&#39;)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">bilinear</span> f := (bilinear_for *:%R *:%R f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">biscalar</span> f := (bilinear_for *%R *%R f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">bilmorphism_for</span> s s&#39; f := (class_of s s&#39; f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">bilmorphism</span> f := (bilmorphism_for *:%R *:%R f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">class_of_axiom</span> : axiom &gt;-&gt; bilmorphism_for.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">class_of_axiom does not respect the uniform
inheritance condition
[uniform-inheritance,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">baser</span> : bilmorphism_for &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">apply</span> : map &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &#39;bilinear&#39; fUV | s &amp; s&#39; }&quot;</span> := (map s s&#39; (Phant fUV))
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;bilinear&#39;  fUV  |  s  &amp;  s&#39; }&quot;</span>) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &#39;bilinear&#39; fUV | s }&quot;</span> := (map s.<span class="mi">1</span> s.<span class="mi">2</span> (Phant fUV))
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;bilinear&#39;  fUV  |  s }&quot;</span>) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &#39;bilinear&#39; fUV }&quot;</span> := {bilinear fUV | *:%R &amp; *:%R}
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;bilinear&#39;  fUV }&quot;</span>) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{ &#39;biscalar&#39; U }&quot;</span> := {bilinear U -&gt; U -&gt; _ | *%R &amp; *%R}
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;{ &#39;biscalar&#39;  U }&quot;</span>) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;bilinear&#39; &#39;of&#39; f &#39;as&#39; g ]&quot;</span> :=
  (@pack  _ _ _ _ _ _ _ _ _ _ f g erefl _ _
         (<span class="kr">fun</span>=&gt; erefl) (<span class="kr">fun</span>=&gt; idfun) _ _ (<span class="kr">fun</span>=&gt; erefl) (<span class="kr">fun</span>=&gt; idfun)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;bilinear&#39; &#39;of&#39; f ]&quot;</span> :=  [bilinear of f <span class="kr">as</span> f]
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;bilinear&#39;  &#39;of&#39;  f ]&quot;</span>) : form_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">additiver</span> : map &gt;-&gt; GRing.Additive.map.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">additiver does not respect the uniform inheritance
condition [uniform-inheritance,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [additiver; GRing.Additive.<span class="nb">apply</span>] : map &gt;-&gt; <span class="kt">Funclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[<span class="nb">apply</span>] : map &gt;-&gt; <span class="kt">Funclass</span>.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">linearr</span> : map &gt;-&gt;  GRing.Linear.map.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">linearr does not respect the uniform inheritance
condition [uniform-inheritance,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [linearr; GRing.Linear.additive] : map &gt;-&gt; GRing.Additive.map <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[additiver] : map &gt;-&gt; GRing.Additive.map.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">additiver</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Ignoring canonical projection to <span class="nb">apply</span> <span class="bp">by</span>
GRing.Additive.<span class="nb">apply</span> <span class="kr">in</span> additiver: redundant <span class="kr">with</span>
additiver [redundant-canonical-projection,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">linearr</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Ignoring canonical projection to <span class="nb">apply</span> <span class="bp">by</span>
GRing.Linear.<span class="nb">apply</span> <span class="kr">in</span> linearr: redundant <span class="kr">with</span> linearr
[redundant-canonical-projection,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">additivel</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Ignoring canonical projection to applyr_head <span class="bp">by</span>
GRing.Additive.<span class="nb">apply</span> <span class="kr">in</span> additivel: redundant <span class="kr">with</span>
additivel [redundant-canonical-projection,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">linearl</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Ignoring canonical projection to applyr_head <span class="bp">by</span>
GRing.Linear.<span class="nb">apply</span> <span class="kr">in</span> linearl: redundant <span class="kr">with</span> linearl
[redundant-canonical-projection,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">applyr</span> := (@applyr_head _ _ _ _ tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Canonical additive. *)</span>
<span class="c">(* (* Support for right-to-left rewriting with the generic linearZ rule. *) *)</span>
<span class="c">(* Coercion map_for_map : map_for &gt;-&gt; map. *)</span>
<span class="c">(* Coercion unify_map_at : map_at &gt;-&gt; map_for. *)</span>
<span class="c">(* Canonical unify_map_at. *)</span>
<span class="c">(* Coercion unwrap : wrapped &gt;-&gt; map. *)</span>
<span class="c">(* Coercion wrap : map_class &gt;-&gt; wrapped. *)</span>
<span class="c">(* Canonical wrap. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Bilinear</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Include</span> Bilinear.Exports.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Bilinear.additiver;
                   GRing.Additive.<span class="nb">apply</span>] : Bilinear.map &gt;-&gt; <span class="kt">Funclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[Bilinear.<span class="nb">apply</span>] : Bilinear.map &gt;-&gt; <span class="kt">Funclass</span>.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Bilinear.linearr;
                   GRing.Linear.additive] : Bilinear.map &gt;-&gt; GRing.Additive.map <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[Bilinear.additiver] : Bilinear.map &gt;-&gt; GRing.Additive.map.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">BilinearTheory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">R</span> : ringType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GenericProperties</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">U</span> <span class="nv">U&#39;</span> : lmodType R) (<span class="nv">V</span> : zmodType) (<span class="nv">s</span> : R -&gt; V -&gt; V) (<span class="nv">s&#39;</span> : R -&gt; V -&gt; V).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">f</span> : {bilinear U -&gt; U&#39; -&gt; V | s &amp; s&#39;}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linear0r</span> <span class="nv">z</span> : f z <span class="mi">0</span> = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>1d</q><br><q>1e</q><br><q>1f</q><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{bilinear U -&gt; U&#39; -&gt; V | s &amp; s&#39;}</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f z <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>30</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> raddf0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearNr</span> <span class="nv">z</span> : {morph f z : x / - x}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>32</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f z : x / - x &gt;-&gt; - x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>38</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: raddfN.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearDr</span> <span class="nv">z</span> : {morph f z : x y / x + y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>32</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f z : x y / x + y &gt;-&gt; x + y}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: raddfD.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearBr</span> <span class="nv">z</span> : {morph f z : x y / x - y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>32</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f z : x y / x - y &gt;-&gt; x - y}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>42</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: raddfB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearMnr</span> <span class="nv">z</span> <span class="nv">n</span> : {morph f z : x / x *+ n}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>1d</q><br><q>1e</q><br><q>1f</q><br><q>33</q><br><q>34</q><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f z : x / x *+ n &gt;-&gt; x *+ n}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>47</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: raddfMn.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearMNnr</span> <span class="nv">z</span> <span class="nv">n</span> : {morph f z : x / x *- n}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>49</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f z : x / x *- n &gt;-&gt; x *- n}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: raddfMNn.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linear_sumr</span> <span class="nv">z</span> <span class="nv">I</span> <span class="nv">r</span> (<span class="nv">P</span> : pred I) <span class="nv">E</span> :
  f z (\sum_(i &lt;- r | P i) E i) = \sum_(i &lt;- r | P i) f z (E i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>1d</q><br><q>1e</q><br><q>1f</q><br><q>33</q><br><q>34</q><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>seq I</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pred I</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>I -&gt; U&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f z (\sum_(i &lt;- r | P i) E i) =
\sum_(i &lt;- r | P i) f z (E i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>53</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: raddf_sum.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearZr_LR</span> <span class="nv">z</span> : scalable_for s&#39; (f z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>32</q><span class="goal-separator"><hr></span><div class="goal-conclusion">scalable_for s&#39; (f z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: linearZ_LR.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearPr</span> <span class="nv">z</span> <span class="nv">a</span> : {morph f z : u v / a *: u + v &gt;-&gt; s&#39; a u + v}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>1d</q><br><q>1e</q><br><q>1f</q><br><q>33</q><br><q>34</q><br><span><var>a</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f z : u v / a *: u + v &gt;-&gt; s&#39; a u + v}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>62</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: linearP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">applyrE</span> <span class="nv">x</span> : applyr f x =<span class="mi">1</span> f^~ x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>1d</q><br><q>1e</q><br><q>1f</q><br><q>33</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>U&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">applyr f x =<span class="mi">1</span> f^~ x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>69</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linear0l</span> <span class="nv">z</span> : f <span class="mi">0</span> z = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>1d</q><br><q>1e</q><br><q>1f</q><br><q>33</q><br><span><var>z</var><span class="hyp-type"><b>: </b><span>U&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f <span class="mi">0</span> z = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>70</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -applyrE raddf0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearNl</span> <span class="nv">z</span> : {morph f^~ z : x / - x}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>72</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f^~ z : x / - x &gt;-&gt; - x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>77</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> -applyrE raddfN.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearDl</span> <span class="nv">z</span> : {morph f^~ z : x y / x + y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>72</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f^~ z : x y / x + y &gt;-&gt; x + y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="nb">rewrite</span> -applyrE raddfD.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearBl</span> <span class="nv">z</span> : {morph f^~ z : x y / x - y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>72</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f^~ z : x y / x - y &gt;-&gt; x - y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>81</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="nb">rewrite</span> -applyrE raddfB.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearMnl</span> <span class="nv">z</span> <span class="nv">n</span> : {morph f^~ z : x / x *+ n}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>1d</q><br><q>1e</q><br><q>1f</q><br><q>33</q><br><q>73</q><br><q>4a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f^~ z : x / x *+ n &gt;-&gt; x *+ n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>86</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> -applyrE raddfMn.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearMNnl</span> <span class="nv">z</span> <span class="nv">n</span> : {morph f^~ z : x / x *- n}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>88</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f^~ z : x / x *- n &gt;-&gt; x *- n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> -applyrE raddfMNn.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linear_suml</span> <span class="nv">z</span> <span class="nv">I</span> <span class="nv">r</span> (<span class="nv">P</span> : pred I) <span class="nv">E</span> :
  f (\sum_(i &lt;- r | P i) E i) z = \sum_(i &lt;- r | P i) f (E i) z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>1d</q><br><q>1e</q><br><q>1f</q><br><q>33</q><br><q>73</q><br><q>56</q><br><q>57</q><br><q>58</q><br><span><var>E</var><span class="hyp-type"><b>: </b><span>I -&gt; U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (\sum_(i &lt;- r | P i) E i) z =
\sum_(i &lt;- r | P i) f (E i) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>91</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -applyrE raddf_sum.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearZl_LR</span> <span class="nv">z</span> : scalable_for s (f^~ z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>72</q><span class="goal-separator"><hr></span><div class="goal-conclusion">scalable_for s (f^~ z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>98</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="nb">rewrite</span> -applyrE linearZ_LR.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">linearPl</span> <span class="nv">z</span> <span class="nv">a</span> : {morph f^~ z : u v / a *: u + v &gt;-&gt; s a u + v}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>f</q><br><q>1d</q><br><q>1e</q><br><q>1f</q><br><q>33</q><br><q>73</q><br><q>65</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{morph f^~ z : u v / a *: u + v &gt;-&gt; s a u + v}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ??; <span class="nb">rewrite</span> -applyrE linearP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GenericProperties</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">BidirectionalLinearZ</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">U</span> : lmodType R) (<span class="nv">V</span> : zmodType) (<span class="nv">s</span> : R -&gt; V -&gt; V).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">S</span> : ringType) (<span class="nv">h</span> : S -&gt; V -&gt; V) (<span class="nv">h_law</span> : GRing.Scale.law h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Lemma linearZr z c a (h_c := GRing.Scale.op h_law c) (f : GRing.Linear.map_for U s a h_c) u : *)</span>
<span class="c">(*   f z (a *: u) = h_c (GRing.Linear.wrap (f z) u). *)</span>
<span class="c">(* Proof. by rewrite linearZ_LR; case: f =&gt; f /= -&gt;. Qed. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">BidirectionalLinearZ</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">BilinearTheory</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">rev_mulmx</span> (R : ringType) m n p := @RevOp _ _ _ (@mulmxr R m n p)
  (@mulmx R m n p) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; erefl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">mulmx_bilinear</span> (R : comRingType) m n p := [bilinear of @mulmx R m n p].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Section classfun. *)</span>
<span class="c">(* Import mathcomp.character.classfun. *)</span>

<span class="c">(* Canonical rev_cfdot (gT : finGroupType) (B : {set gT}) :=  *)</span>
<span class="c">(*   @RevOp _ _ _ (@cfdotr_head gT B tt) *)</span>
<span class="c">(*   (@cfdot gT B) (fun _ _ =&gt; erefl). *)</span>

<span class="c">(* Section Cfdot. *)</span>
<span class="c">(* Variables (gT : finGroupType) (G : {group gT}). *)</span>
<span class="c">(* Lemma cfdot_is_linear xi : linear_for (@conjC _ \; *%R) (cfdot xi : &#39;CF(G) -&gt; algC^o). *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move=&gt; /= a phi psi; rewrite cfdotC -cfdotrE linearD linearZ /=. *)</span>
<span class="c">(* by rewrite ![&#39;[_, xi]]cfdotC rmorphD rmorphM !conjCK. *)</span>
<span class="c">(* Qed. *)</span>
<span class="c">(* Canonical cfdot_additive xi := Additive (cfdot_is_linear xi). *)</span>
<span class="c">(* Canonical cfdot_linear xi := Linear (cfdot_is_linear xi). *)</span>
<span class="c">(* End Cfdot. *)</span>

<span class="c">(* Canonical cfdot_bilinear (gT : finGroupType) (B : {group gT}) := *)</span>
<span class="c">(*   [bilinear of @cfdot gT B]. *)</span>
<span class="c">(* End classfun. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">BilinearForms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">R</span> : fieldType) (<span class="nv">theta</span> : {rmorphism R -&gt; R}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">n</span> : nat) (<span class="nv">M</span> : &#39;M[R]_n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">a</span> <span class="nv">b</span> : R) (<span class="nv">u</span> <span class="nv">v</span> : &#39;rV[R]_n) (<span class="nv">N</span> <span class="nv">P</span> <span class="nv">Q</span> : &#39;M[R]_n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">form</span> <span class="nv">u</span> <span class="nv">v</span> := (u *m M *m (v ^t theta)) <span class="mi">0</span> <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;[&#39; u , v ]&quot;</span> := (form u%R v%R) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;[&#39; u ]&quot;</span> := &#39;[u, u] : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">form0l</span> <span class="nv">u</span> : &#39;[<span class="mi">0</span>, u] = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>fieldType</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>{rmorphism R -&gt; R}</span></span></span><br><q>4a</q><br><span><var>M</var><span class="hyp-type"><b>: </b><span>&#39;M_n</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>&#39;rV_n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[<span class="mi">0</span>, u] = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a3</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /form !mul0mx mxE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">form0r</span> <span class="nv">u</span> : &#39;[u, <span class="mi">0</span>] = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>a5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[u, <span class="mi">0</span>] = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ad</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /form trmx0 map_mx0 mulmx0 mxE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formDl</span> <span class="nv">u</span> <span class="nv">v</span> <span class="nv">w</span> : &#39;[u + v, w] = &#39;[u, w] + &#39;[v, w].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>a7</q><br><q>4a</q><br><q>a8</q><br><span><var>u, v, w</var><span class="hyp-type"><b>: </b><span>&#39;rV_n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[u + v, w] = &#39;[u, w] + &#39;[v, w]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b2</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /form !mulmxDl mxE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formDr</span> <span class="nv">u</span> <span class="nv">v</span> <span class="nv">w</span> : &#39;[u, v + w] = &#39;[u, v] + &#39;[u, w].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>a7</q><br><q>4a</q><br><q>a8</q><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>&#39;rV_n</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>matrix_zmodType R <span class="mi">1</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[u, v + w] = &#39;[u, v] + &#39;[u, w]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>b9</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /form linearD !map_mxD !mulmxDr mxE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formZr</span> <span class="nv">a</span> <span class="nv">u</span> <span class="nv">v</span> : &#39;[u, a *: v] = theta a * &#39;[u, v].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>a7</q><br><q>4a</q><br><q>a8</q><br><q>65</q><br><q>bc</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[u, a *: v] = theta a * &#39;[u, v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /form !(linearZ, map_mxZ) /= mxE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formZl</span> <span class="nv">a</span> <span class="nv">u</span> <span class="nv">v</span> : &#39;[a *: u, v] = a * &#39;[u, v].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[a *: u, v] = a * &#39;[u, v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c7</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kp">do</span> !<span class="nb">rewrite</span> /form  -[_ *: _ *m _]/(mulmxr _ _) linearZ /=; <span class="nb">rewrite</span> mxE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formNl</span> <span class="nv">u</span> <span class="nv">v</span> : &#39;[- u, v] = - &#39;[u, v].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>a7</q><br><q>4a</q><br><q>a8</q><br><q>bc</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[- u, v] = - &#39;[u, v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>cc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -scaleN1r formZl mulN1r.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formNr</span> <span class="nv">u</span> <span class="nv">v</span> : &#39;[u, - v] = - &#39;[u, v].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ce</q><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[u, - v] = - &#39;[u, v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>d2</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -scaleN1r formZr rmorphN1 mulN1r.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formee</span> <span class="nv">i</span> <span class="nv">j</span> : &#39;[&#39;e_i, &#39;e_j] = M i j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>a7</q><br><q>4a</q><br><q>a8</q><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>ordinal_finType n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[&#39;e_i, &#39;e_j] = M i j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>d7</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /form -rowE -map_trmx map_delta_mx -[M <span class="kr">in</span> LHS]trmxK.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d9</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(row i (M^T)^T *m &#39;e_j^T) <span class="mi">0</span> <span class="mi">0</span> = M i j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -tr_col -trmx_mul -rowE !mxE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">form0_eq0</span> : M = <span class="mi">0</span> -&gt; <span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span>, &#39;[u, v] = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>a7</q><br><q>4a</q><br><q>a8</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M = <span class="mi">0</span> -&gt; <span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span>, &#39;[u, v] = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>e2</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span>/form=&gt; -&gt; u v; <span class="nb">rewrite</span> mulmx0 mul0mx mxE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">BilinearForms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Sesquilinear</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">R</span> : fieldType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">n</span> : nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">a</span> <span class="nv">b</span> : R) (<span class="nv">u</span> <span class="nv">v</span> : &#39;rV[R]_n) (<span class="nv">N</span> <span class="nv">P</span> <span class="nv">Q</span> : &#39;M[R]_n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Def</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">eps_theta</span> : (bool * {rmorphism R -&gt; R}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sesqui</span> :=
  [qualify M : &#39;M_n | M == ((-<span class="mi">1</span>) ^+ eps_theta.<span class="mi">1</span>) *: M ^t eps_theta.<span class="mi">2</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">sesqui_key</span> : pred_key sesqui.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><span><var>eps_theta</var><span class="hyp-type"><b>: </b><span>(bool * {rmorphism R -&gt; R})%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pred_key sesqui</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>e8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">sesqui_keyed</span> := KeyedQualifier sesqui_key.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Def</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;eps_theta .-sesqui&quot;</span> := (sesqui eps_theta).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">eps</span> : bool) (<span class="nv">theta</span> : {rmorphism R -&gt; R}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">M</span> : &#39;M[R]_n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;[&#39; u , v ]&quot;</span> := (form theta M u%R v%R) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;&#39;&#39;[&#39; u ]&quot;</span> := &#39;[u, u] : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sesquiE</span> : (M \<span class="kr">is</span> (eps,theta).-sesqui) = (M == (-<span class="mi">1</span>) ^+ eps *: M ^t theta).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><span><var>eps</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><q>a7</q><br><q>a8</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(M \<span class="kr">is</span> (eps, theta).-sesqui) =
(M == (-<span class="mi">1</span>) ^+ eps *: M ^t theta)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ef</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> qualifE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sesquiP</span> : reflect (M = (-<span class="mi">1</span>) ^+ eps *: M ^t theta)
                        (M \<span class="kr">is</span> (eps,theta).-sesqui).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (M = (-<span class="mi">1</span>) ^+ eps *: M ^t theta)
  (M \<span class="kr">is</span> (eps, theta).-sesqui)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>f6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> sesquiE; <span class="nb">apply</span>/eqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> (<span class="nv">thetaK</span> : involutive theta).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> (<span class="nv">M_sesqui</span> : M \<span class="kr">is</span> (eps, theta).-sesqui).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trmx_sesqui</span> : M^T = (-<span class="mi">1</span>) ^+ eps *: M ^ theta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><span><var>thetaK</var><span class="hyp-type"><b>: </b><span>involutive theta</span></span></span><br><span><var>M_sesqui</var><span class="hyp-type"><b>: </b><span>M \<span class="kr">is</span> (eps, theta).-sesqui</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M^T = (-<span class="mi">1</span>) ^+ eps *: M ^ theta</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>fb</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> [<span class="kr">in</span> LHS](sesquiP _) // -mul_scalar_mx trmx_mul.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>fd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(M ^t theta)^T *m (((-<span class="mi">1</span>) ^+ eps)%:M)^T =
(-<span class="mi">1</span>) ^+ eps *: M ^ theta</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> tr_scalar_mx mul_mx_scalar map_trmx trmxK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">maptrmx_sesqui</span> : M^t theta = (-<span class="mi">1</span>) ^+ eps *: M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>fd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">M ^t theta = (-<span class="mi">1</span>) ^+ eps *: M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>107</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> trmx_sesqui map_mxZ rmorph_sign -map_mx_comp eq_map_mx_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formC</span> <span class="nv">u</span> <span class="nv">v</span> : &#39;[u, v] = (-<span class="mi">1</span>) ^+ eps * theta &#39;[v, u].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>bc</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[u, v] = (-<span class="mi">1</span>) ^+ eps * theta &#39;[v, u]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /form [M <span class="kr">in</span> LHS](sesquiP _) // -mulmxA !mxE rmorph_sum mulr_sumr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_j
   u``_j *
   ((-<span class="mi">1</span>) ^+ eps *: M ^t theta *m v ^t theta) j <span class="mi">0</span> =
\sum_i
   (-<span class="mi">1</span>) ^+ eps *
   theta ((v *m M) <span class="mi">0</span> i * (u ^t theta) i <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: eq_bigr =&gt; /= i _; <span class="nb">rewrite</span> !(mxE, mulr_sumr, mulr_suml, rmorph_sum).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>bc</q><br><span><var>i</var><span class="hyp-type"><b>: </b><span>&#39;I_n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_i0
   u``_i *
   (((-<span class="mi">1</span>) ^+ eps *: M ^t theta) i i0 *
    (v ^t theta) i0 <span class="mi">0</span>) =
\sum_i0
   (-<span class="mi">1</span>) ^+ eps * theta (v``_i0 * M i0 i * theta u``_i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: eq_bigr =&gt; /= j _; <span class="nb">rewrite</span> !mxE !rmorphM  mulrCA -!mulrA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>bc</q><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>&#39;I_n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(-<span class="mi">1</span>) ^+ eps * (theta (M j i) * (u``_i * theta v``_j)) =
(-<span class="mi">1</span>) ^+ eps *
(theta v``_j * (theta (M j i) * theta (theta u``_i)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">congr</span> (_ * _); <span class="nb">rewrite</span> mulrA mulrC thetaK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">form_eq0C</span> <span class="nv">u</span> <span class="nv">v</span> : (&#39;[u, v] == <span class="mi">0</span>) = (&#39;[v, u] == <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(&#39;[u, v] == <span class="mi">0</span>) = (&#39;[v, u] == <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>122</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> formC mulf_eq0 signr_eq0 /= fmorph_eq0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ortho</span> <span class="nv">m</span> (<span class="nv">B</span> : &#39;M_(m,n)) := (kermx (M *m (B ^t theta))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;B ^_|_&quot;</span> := (ortho B) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;A _|_ B&quot;</span> := (A%MS &lt;= B^_|_)%MS : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">normalE</span> <span class="nv">u</span> <span class="nv">v</span> : (u _|_ v) = (&#39;[u, v] == <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">u _|_ v = (&#39;[u, v] == <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>127</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (sameP sub_kermxP eqP) mulmxA [_ *m _^t _]mx11_scalar fmorph_eq0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">form_eq0P</span> {<span class="nv">u</span> <span class="nv">v</span>} : reflect (&#39;[u, v] = <span class="mi">0</span>) (u _|_ v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (&#39;[u, v] = <span class="mi">0</span>) (u _|_ v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>12c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> normalE; <span class="nb">apply</span>/eqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">normalP</span> <span class="nv">p</span> <span class="nv">q</span> (<span class="nv">A</span> : &#39;M_(p, n)) (<span class="nv">B</span> :&#39;M_(q, n)) :
  reflect (<span class="kr">forall</span> (<span class="nv">u</span> <span class="nv">v</span> : &#39;rV_n), (u &lt;= A)%MS -&gt; (v &lt;= B)%MS -&gt; u _|_ v)
          (A _|_ B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>&#39;M_(p, n)</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>&#39;M_(q, n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect
  (<span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span>, (u &lt;= A)%MS -&gt; (v &lt;= B)%MS -&gt; u _|_ v)
  (A _|_ B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>131</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP) =&gt; AnB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>134</q><br><q>135</q><br><q>136</q><br><span><var>AnB</var><span class="hyp-type"><b>: </b><span>A _|_ B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span>, (u &lt;= A)%MS -&gt; (v &lt;= B)%MS -&gt; u _|_ v</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>134</q><br><q>135</q><br><q>136</q><br><span><var>AnB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span>,
(u &lt;= A)%MS -&gt; (v &lt;= B)%MS -&gt; u _|_ v</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">A _|_ B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; u v uA vB; <span class="nb">rewrite</span> (submx_trans uA) // (submx_trans AnB) //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>134</q><br><q>135</q><br><q>136</q><br><q>13d</q><br><q>bc</q><br><span><var>uA</var><span class="hyp-type"><b>: </b><span>(u &lt;= A)%MS</span></span></span><br><span><var>vB</var><span class="hyp-type"><b>: </b><span>(v &lt;= B)%MS</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B^_|_ _|_ v</div></blockquote><q>13f</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/sub_kermxP; <span class="nb">have</span> /submxP [w -&gt;] := vB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>134</q><br><q>135</q><br><q>136</q><br><q>13d</q><br><q>bc</q><br><q>148</q><br><q>149</q><br><span><var>w</var><span class="hyp-type"><b>: </b><span>&#39;rV_q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B^_|_ *m (M *m (w *m B) ^t theta) = <span class="mi">0</span></div></blockquote><q>13f</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> trmx_mul map_mxM !mulmxA -[kermx _ *m _ *m _]mulmxA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>14e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">kermx (M *m B ^t theta) *m (M *m B ^t theta) *m w
                                                ^t theta =
<span class="mi">0</span></div></blockquote><q>13f</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> [kermx _ *m _](sub_kermxP _) // mul0mx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>141</q><span class="goal-separator"><hr></span><q>143</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/rV_subP =&gt; u /AnB /(_ _) /sub_kermxP uMv; <span class="nb">apply</span>/sub_kermxP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>134</q><br><q>135</q><br><q>136</q><br><q>142</q><br><q>a9</q><br><span><var>uMv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : &#39;rV_n,
(m &lt;= B)%MS -&gt; u *m (M *m m ^t theta) = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u *m (M *m B ^t theta) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">suff</span>: <span class="kr">forall</span> <span class="nv">m</span> (<span class="nv">v</span> : &#39;rV[R]_m),
  (<span class="kr">forall</span> <span class="nv">i</span>, v *m &#39;e_i ^t theta = <span class="mi">0</span> :&gt; &#39;M_1) -&gt; v = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>15b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">v</span> : &#39;rV_m),
 (<span class="kr">forall</span> <span class="nv">i</span> : ordinal_finType m, v *m &#39;e_i ^t theta = <span class="mi">0</span>) -&gt;
 v = <span class="mi">0</span>) -&gt; u *m (M *m B ^t theta) = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>15b</q><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">v</span> : &#39;rV_m),
(<span class="kr">forall</span> <span class="nv">i</span> : ordinal_finType m, v *m &#39;e_i ^t theta = <span class="mi">0</span>) -&gt;
v = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> =&gt; i; <span class="nb">rewrite</span> !mulmxA -!mulmxA -map_mxM -trmx_mul uMv //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>134</q><br><q>135</q><br><q>136</q><br><q>142</q><br><q>a9</q><br><q>15c</q><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ordinal_finType q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(&#39;e_i *m B &lt;= B)%MS</div></blockquote><q>162</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/submxP; <span class="kr">exists</span> <span class="nv">&#39;e_i</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>15b</q><span class="goal-separator"><hr></span><q>164</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; /= m v Hv; <span class="nb">apply</span>: (can_inj (@trmxK _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>134</q><br><q>135</q><br><q>136</q><br><q>142</q><br><q>a9</q><br><q>15c</q><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>&#39;rV_m</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : &#39;I_m, v *m &#39;e_i ^t theta = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v^T = <span class="mi">0</span>^T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> trmx0; <span class="nb">apply</span>/row_matrixP=&gt; i; <span class="nb">rewrite</span> row0 rowE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>134</q><br><q>135</q><br><q>136</q><br><q>142</q><br><q>a9</q><br><q>15c</q><br><q>172</q><br><q>173</q><br><q>174</q><br><span><var>i</var><span class="hyp-type"><b>: </b><span>&#39;I_m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;e_i *m v^T = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (can_inj (@trmxK _ _ _)); <span class="nb">rewrite</span> trmx0 trmx_mul trmxK.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>179</q><span class="goal-separator"><hr></span><div class="goal-conclusion">v *m &#39;e_i^T = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -(map_delta_mx theta) map_trmx Hv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">normalC</span> <span class="nv">p</span> <span class="nv">q</span> (<span class="nv">A</span> : &#39;M_(p, n)) (<span class="nv">B</span> :&#39;M_(q, n)) : (A _|_ B) = (B _|_ A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>133</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A _|_ B = B _|_ A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>181</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">gen have</span> nC : p q A B / A _|_ B -&gt; B _|_ A; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>/idP/idP; <span class="nb">apply</span>/nC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>133</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A _|_ B -&gt; B _|_ A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; AnB; <span class="nb">apply</span>/normalP =&gt; u v ? ?; <span class="nb">rewrite</span> normalE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>134</q><br><q>135</q><br><q>136</q><br><q>13d</q><br><q>bc</q><br><span><var>_Hyp_</var><span class="hyp-type"><b>: </b><span>(u &lt;= B)%MS</span></span></span><br><span><var>_Hyp1_</var><span class="hyp-type"><b>: </b><span>(v &lt;= A)%MS</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[u, v] == <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> formC mulf_eq0 <span class="nl">?fmorph_eq0</span> <span class="nl">?signr_eq0</span> /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>18c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[v, u] == <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -normalE (normalP _ _ AnB).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">normal_ortho_mx</span> <span class="nv">p</span> (<span class="nv">A</span> : &#39;M_(p, n)) : ((A^_|_) _|_ A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><q>135</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A^_|_ _|_ A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>195</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">normal_mx_ortho</span> <span class="nv">p</span> (<span class="nv">A</span> : &#39;M_(p, n)) : (A _|_ (A^_|_)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>197</q><span class="goal-separator"><hr></span><div class="goal-conclusion">A _|_ A^_|_</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>19c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> normalC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">rank_normal</span> <span class="nv">u</span> : (\rank (u ^_|_) &gt;= n.-<span class="mi">1</span>)%N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>a9</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n.-<span class="mi">1</span> &lt;= \rank u^_|_)%N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1a1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> mxrank_ker -subn1 leq_sub2l //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1a3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(\rank (M *m u ^t theta) &lt;= <span class="mi">1</span>)%N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (mxrankM_maxr  _ _)) // rank_leq_col.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rad</span> := <span class="mi">1</span>%:M^_|_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">rad_ker</span> : rad = kermx M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>fd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">rad = kermx M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1ab</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /rad /ortho trmx1 map_mx1 mulmx1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Pythagore *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">formDd</span> <span class="nv">u</span> <span class="nv">v</span> : u _|_ v -&gt; &#39;[u + v] = &#39;[u] + &#39;[v].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">u _|_ v -&gt; &#39;[u + v] = &#39;[u] + &#39;[v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1b0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; uNv; <span class="nb">rewrite</span> formDl !formDr [&#39;[v, u]]formC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>bc</q><br><span><var>uNv</var><span class="hyp-type"><b>: </b><span>u _|_ v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[u] + &#39;[u, v] + ((-<span class="mi">1</span>) ^+ eps * theta &#39;[u, v] + &#39;[v]) =
&#39;[u] + &#39;[v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> [&#39;[u, v]](form_eq0P _) // rmorph0 mulr0 addr0 add0r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formZ</span> <span class="nv">a</span> <span class="nv">u</span> : &#39;[a *: u]= (a * theta a) * &#39;[u].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>65</q><br><q>a9</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[a *: u] = a * theta a * &#39;[u]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1bb</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> formZl formZr mulrA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formN</span> <span class="nv">u</span> : &#39;[- u] = &#39;[u].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1a3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[- u] = &#39;[u]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1c1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> formNr formNl opprK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">form_sign</span> <span class="nv">m</span> <span class="nv">u</span> : &#39;[(-<span class="mi">1</span>) ^+ m *: u] = &#39;[u].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>a6</q><br><q>4a</q><br><q>f2</q><br><q>a7</q><br><q>a8</q><br><q>fe</q><br><q>ff</q><br><q>172</q><br><q>a9</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">&#39;[(-<span class="mi">1</span>) ^+ m *: u] = &#39;[u]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1c6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -signr_odd scaler_sign; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> <span class="nl">?formN</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formD</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">let</span> <span class="nv">d</span> := &#39;[u, v] <span class="kr">in</span>
  &#39;[u + v] = &#39;[u] + &#39;[v] + (d + (-<span class="mi">1</span>) ^+ eps * theta d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10e</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">d</span> := &#39;[u, v] <span class="kr">in</span>
&#39;[u + v] = &#39;[u] + &#39;[v] + (d + (-<span class="mi">1</span>) ^+ eps * theta d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1cc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> formDl !formDr [&#39;[v, _]]formC [_ + &#39;[v]]addrC addrACA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formB</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">let</span> <span class="nv">d</span> := &#39;[u, v] <span class="kr">in</span>
  &#39;[u - v] = &#39;[u] + &#39;[v] - (d + (-<span class="mi">1</span>) ^+ eps * theta d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10e</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">d</span> := &#39;[u, v] <span class="kr">in</span>
&#39;[u - v] = &#39;[u] + &#39;[v] - (d + (-<span class="mi">1</span>) ^+ eps * theta d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1d1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> formD formN !formNr rmorphN mulrN -opprD.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">formBd</span> <span class="nv">u</span> <span class="nv">v</span> : u _|_ v -&gt; &#39;[u - v] = &#39;[u] + &#39;[v].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">u _|_ v -&gt; &#39;[u - v] = &#39;[u] + &#39;[v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1d6</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; uTv; <span class="nb">rewrite</span> formDd <span class="nl">?formN</span> // normalE formNr oppr_eq0 -normalE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Lemma formJ u v : &#39;[u ^ theta, v ^ theta] = (-1) ^+ eps * theta &#39;[u, v]. *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* rewrite {1}/form -map_trmx -map_mx_comp (@eq_map_mx _ _ _ _ _ id) ?map_mx_id //. *)</span>
<span class="c">(* set x := (_ *m _); have -&gt; : x 0 0 = theta ((x^t theta) 0 0) by rewrite !mxE. *)</span>
<span class="c">(* rewrite !trmx_mul trmxK map_trmx mulmxA !map_mxM. *)</span>
<span class="c">(* rewrite maptrmx_sesqui -!scalemxAr -scalemxAl mxE rmorphM rmorph_sign. *)</span>

<span class="c">(* Lemma formJ u : &#39;[u ^ theta] = (-1) ^+ eps * &#39;[u]. *)</span>
<span class="c">(* Proof.  *)</span>
<span class="c">(* rewrite {1}/form -map_trmx -map_mx_comp (@eq_map_mx _ _ _ _ _ id) ?map_mx_id //. *)</span>
<span class="c">(* set x := (_ *m _); have -&gt; : x 0 0 = theta ((x^t theta) 0 0) by rewrite !mxE. *)</span>
<span class="c">(* rewrite !trmx_mul trmxK map_trmx mulmxA !map_mxM. *)</span>
<span class="c">(* rewrite maptrmx_sesqui -!scalemxAr -scalemxAl mxE rmorphM rmorph_sign. *)</span>
<span class="c">(* rewrite !map_mxM. *)</span>
<span class="c">(* rewrite -map_mx_comp eq_map_mx_id //. *)</span>
<span class="c">(*  !linearZr_LR /=. linearZ. *)</span>
<span class="c">(*  linearZl. *)</span>
<span class="c">(* rewrite trmx_sesqui. *)</span>


<span class="c">(* rewrite mapmx. *)</span>
<span class="c">(* rewrite map *)</span>
<span class="c">(* apply/matrixP.  *)</span>

<span class="c">(* rewrite formC. *)</span>
<span class="c">(* Proof. by rewrite cfdot_conjC geC0_conj // cfnorm_ge0. Qed. *)</span>

<span class="c">(* Lemma cfCauchySchwarz u v : *)</span>
<span class="c">(*   `|&#39;[u, v]| ^+ 2 &lt;= &#39;[u] * &#39;[v] ?= iff ~~ free (u :: v). *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* rewrite free_cons span_seq1 seq1_free -negb_or negbK orbC. *)</span>
<span class="c">(* have [-&gt; | nz_v] /= := altP (v =P 0). *)</span>
<span class="c">(*   by apply/lerifP; rewrite !cfdot0r normCK mul0r mulr0. *)</span>
<span class="c">(* without loss ou: u / &#39;[u, v] = 0. *)</span>
<span class="c">(*   move=&gt; IHo; pose a := &#39;[u, v] / &#39;[v]; pose u1 := u - a *: v. *)</span>
<span class="c">(*   have ou: &#39;[u1, v] = 0. *)</span>
<span class="c">(*     by rewrite cfdotBl cfdotZl divfK ?cfnorm_eq0 ?subrr. *)</span>
<span class="c">(*   rewrite (canRL (subrK _) (erefl u1)) rpredDr ?rpredZ ?memv_line //. *)</span>
<span class="c">(*   rewrite cfdotDl ou add0r cfdotZl normrM (ger0_norm (cfnorm_ge0 _)). *)</span>
<span class="c">(*   rewrite exprMn mulrA -cfnormZ cfnormDd; last by rewrite cfdotZr ou mulr0. *)</span>
<span class="c">(*   by have:= IHo _ ou; rewrite mulrDl -lerif_subLR subrr ou normCK mul0r. *)</span>
<span class="c">(* rewrite ou normCK mul0r; split; first by rewrite mulr_ge0 ?cfnorm_ge0. *)</span>
<span class="c">(* rewrite eq_sym mulf_eq0 orbC cfnorm_eq0 (negPf nz_v) /=. *)</span>
<span class="c">(* apply/idP/idP=&gt; [|/vlineP[a {2}-&gt;]]; last by rewrite cfdotZr ou mulr0. *)</span>
<span class="c">(* by rewrite cfnorm_eq0 =&gt; /eqP-&gt;; apply: rpred0. *)</span>
<span class="c">(* Qed. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Sesquilinear</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;eps_theta .-sesqui&quot;</span> := (sesqui _ eps_theta) : ring_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">symmetric_form</span> := (false, [rmorphism of idfun]).-sesqui.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">skew</span> := (true, [rmorphism of idfun]).-sesqui.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">hermitian</span> := (false, @conjC _).-sesqui.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Section ClassificationForm. *)</span>

<span class="c">(* Variables (F : fieldType) (L : fieldExtType) (theat : &#39;Aut()) *)</span>

<span class="c">(* Notation &quot;&#39;&#39;[&#39; u , v ]_ M&quot; := (form M%R u%R v%R) : ring_scope. *)</span>
<span class="c">(* Notation &quot;&#39;&#39;[&#39; u ]_ M&quot; := (form M%R u%R u%R) : ring_scope. *)</span>

<span class="c">(* Hypothesis (thetaK : involutive theta). *)</span>

<span class="c">(* Lemma sesqui_test M : (forall u v, &#39;[v, u]_M = 0 -&gt; &#39;[u, v]_M = 0) -&gt; *)</span>
<span class="c">(*                       {eps | eps^+2 = 1 &amp; M \is (eps,theta).-sesqui}. *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* pose  *)</span>


<span class="c">(*                       [/\ forall u, &#39;[u] = 0, theta =1 id &amp; eps = -1] *)</span>
<span class="c">(*                       \/ ((exists u, &#39;[u] != 0) /\ (eps = 1)). *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move=&gt; M_neq0 form_eq0. *)</span>
<span class="c">(* have [] := boolP [forall i : &#39;I_n, &#39;[&#39;e_i] == 0]; last first. *)</span>
<span class="c">(*   rewrite negb_forall =&gt; /existsP [i ei_neq0]. *)</span>
<span class="c">(*   right; split; first by exists (&#39;e_i). *)</span>
<span class="c">(*   apply/eqP; *)</span>

<span class="c">(*  contraT *)</span>


<span class="c">(* suff [f_eq0|] : (forall u, &#39;[u] = 0) \/ (exists u, &#39;[u] != 0). *)</span>
<span class="c">(*   left; split=&gt; //. *)</span>

<span class="c">(* have [] := boolP [forall i : &#39;I_n, &#39;[&#39;e_i] == 0]. *)</span>

<span class="c">(* suff /eqP : eps ^+ 2 = 1. *)</span>
<span class="c">(*   rewrite -subr_eq0 subr_sqr_1 mulf_eq0. *)</span>
<span class="c">(*   move =&gt; /orP[]; rewrite addr_eq0 ?opprK=&gt; /eqP eps_eq. *)</span>
<span class="c">(*     right; split=&gt; //. *)</span>

<span class="c">(* have [] := boolP [forall i : &#39;I_n, &#39;[&#39;e_i] == 0]. *)</span>

<span class="c">(* have := sesquiC u u. *)</span>


<span class="c">(* rewrite !linearZ /= -[eps *: _ *m _]/(mulmxr _ _) linearZ /= mxE; congr (_ * _). *)</span>
<span class="c">(* have : u = map_mx theta (map_mx theta u). *)</span>
<span class="c">(*   apply/rowP=&gt; i; rewrite !mxE. *)</span>
<span class="c">(* rewrite -[in LHS]mulmxA -map_mxM. *)</span>
<span class="c">(* rewrite  *)</span>
<span class="c">(*  !mxE rmorph_sum; apply: eq_bigr =&gt; /= i _; rewrite !mxE. *)</span>
<span class="c">(* rewrite !rmorphM thetaK rmorph_sum. *)</span>

<span class="c">(* Hypothesis (M_sesqui : M \is (eps, theta).-sesqui). *)</span>

<span class="c">(* rewrite -[a *: u *m _]/(mulmxr _ _). *)</span>
<span class="c">(* rewrite linearZ. *)</span>

<span class="c">(* Variables (R : fieldType) (n : nat). *)</span>

<span class="c">(* Local Notation &quot;A _|_ B&quot; := (A%MS &lt;= kermx B%MS^T)%MS. *)</span>

<span class="c">(* Lemma normal_sym k m (A : &#39;M[R]_(k,n)) (B : &#39;M[R]_(m,n)) : *)</span>
<span class="c">(*   A _|_ B = B _|_ A. *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* rewrite !(sameP sub_kermxP eqP) -{1}[A]trmxK -trmx_mul. *)</span>
<span class="c">(* by rewrite -{1}trmx0 (inj_eq (@trmx_inj _ _ _)). *)</span>
<span class="c">(* Qed. *)</span>

<span class="c">(* Lemma normalNm k m (A : &#39;M[R]_(k,n)) (B : &#39;M[R]_(m,n)) : (- A) _|_ B = A _|_ B. *)</span>
<span class="c">(* Proof. by rewrite eqmx_opp. Qed. *)</span>

<span class="c">(* Lemma normalmN k m (A : &#39;M[R]_(k,n)) (B : &#39;M[R]_(m,n)) : A _|_ (- B) = A _|_ B. *)</span>
<span class="c">(* Proof. by rewrite ![A _|_ _]normal_sym normalNm. Qed. *)</span>

<span class="c">(* Lemma normalDm k m p (A : &#39;M[R]_(k,n)) (B : &#39;M[R]_(m,n)) (C : &#39;M[R]_(p,n)) : *)</span>
<span class="c">(*   (A + B _|_ C) = (A _|_ C) &amp;&amp; (B _|_ C). *)</span>
<span class="c">(* Proof. by rewrite addsmxE !(sameP sub_kermxP eqP) mul_col_mx col_mx_eq0. Qed. *)</span>

<span class="c">(* Lemma normalmD  k m p (A : &#39;M[R]_(k,n)) (B : &#39;M[R]_(m,n)) (C : &#39;M[R]_(p,n)) : *)</span>
<span class="c">(*   (A _|_ B + C) = (A _|_ B) &amp;&amp; (A _|_ C). *)</span>
<span class="c">(* Proof. by rewrite ![A _|_ _]normal_sym normalDm. Qed. *)</span>

<span class="c">(* Definition dot (u v : &#39;rV[R]_n) : R := (u *m v^T) 0 0. *)</span>

<span class="c">(* Notation &quot;&#39;&#39;[&#39; u , v ]&quot; := (dot u v) : ring_scope. *)</span>
<span class="c">(* Notation &quot;&#39;&#39;[&#39; u ]&quot; := &#39;[u, u]%MS : ring_scope. *)</span>

<span class="c">(* Lemma dotmulE (u v : &#39;rV[R]_n) : &#39;[u, v] = \sum_k u``_k * v``_k. *)</span>
<span class="c">(* Proof. by rewrite [LHS]mxE; apply: eq_bigr=&gt; i; rewrite mxE. Qed. *)</span>

<span class="c">(* Lemma normalvv (u v : &#39;rV[R]_n) : (u _|_ v) = (&#39;[u, v] == 0). *)</span>
<span class="c">(* Proof. by rewrite (sameP sub_kermxP eqP) [_ *m _^T]mx11_scalar fmorph_eq0. Qed. *)</span>

<span class="c">(* End Normal. *)</span>

<span class="c">(* Local Notation &quot;&#39;&#39;[&#39; u , v ]&quot; := (form u v) : ring_scope. *)</span>
<span class="c">(* Local Notation &quot;&#39;&#39;[&#39; u ]&quot; := &#39;[u%R, u%R] : ring_scope. *)</span>
<span class="c">(* Local Notation &quot;A _|_ B&quot; := (A%MS &lt;= kermx B%MS^T)%MS. *)</span></span></pre></article></body></html>