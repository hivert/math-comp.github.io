<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>boolp.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
<span class="c">(* -------------------------------------------------------------------- *)</span>
<span class="c">(* Copyright (c) - 2015--2016 - IMDEA Software Institute                *)</span>
<span class="c">(* Copyright (c) - 2015--2018 - Inria                                   *)</span>
<span class="c">(* Copyright (c) - 2016--2018 - Polytechnique                           *)</span>
<span class="c">(* -------------------------------------------------------------------- *)</span>

</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predI _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predU _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predD _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predC _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ preim _ of _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(******************************************************************************)</span>
<span class="c">(*                              Classical Logic                               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* This file provides the axioms of classical logic and tools to perform      *)</span>
<span class="c">(* classical reasoning in the Mathematical Compnent framework. The three      *)</span>
<span class="c">(* axioms are taken from the standard library of Coq, more details can be     *)</span>
<span class="c">(* found in Section 5 of                                                      *)</span>
<span class="c">(*   Reynald AffeldtÔøº, Cyril Cohen, Damien Rouhling:                          *)</span>
<span class="c">(*   Formalization Techniques for Asymptotic Reasoning in Classical Analysis. *)</span>
<span class="c">(*   Journal of Formalized Reasoning, 2018                                    *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Axioms                                                                   *)</span>
<span class="c">(* functional_extensionality_dep == functional extensionality (on dependently *)</span>
<span class="c">(*                     typed functions), i.e., functions that are pointwise   *)</span>
<span class="c">(*                     equal are equal                                        *)</span>
<span class="c">(* propositional_extensionality == propositional extensionality, i.e., iff    *)</span>
<span class="c">(*                     and equality are the same on Prop                      *)</span>
<span class="c">(* constructive_indefinite_description == existential in Prop (ex) implies    *)</span>
<span class="c">(*                     existential in Type (sig)                              *)</span>
<span class="c">(*              cid := constructive_indefinite_description (shortcut)         *)</span>
<span class="c">(* --&gt; A number of properties are derived below from these axioms and are     *)</span>
<span class="c">(* often more pratical to use than directly using the axioms. For instance    *)</span>
<span class="c">(* propext, funext, the excluded middle (EM),...                              *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Boolean View of Prop                                                     *)</span>
<span class="c">(*         `[&lt; P &gt;] == boolean view of P : Prop, see all lemmas about asbool  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Mathematical Components Structures                                       *)</span>
<span class="c">(*  {classic T} == Endow T : Type with a canonical eqType/choiceType.         *)</span>
<span class="c">(*                 This is intended for local use.                            *)</span>
<span class="c">(*                 E.g., T : Type |- A : {fset {classic T}}                   *)</span>
<span class="c">(*                 Alternatively one may use elim/Pchoice: T =&gt; T in H *.     *)</span>
<span class="c">(*                 to substitute T with T : choiceType once and for all.      *)</span>
<span class="c">(* {eclassic T} == Endow T : eqType with a canonical choiceType.              *)</span>
<span class="c">(*                 On the model of {classic _}.                               *)</span>
<span class="c">(*                 See also the lemmas Peq and eqPchoice.                     *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* --&gt; Functions into a porderType (resp. latticeType) are equipped with      *)</span>
<span class="c">(* a porderType (resp. latticeType), (f &lt;= g)%O when f x &lt;= g x for all x,    *)</span>
<span class="c">(* see lemma lefP.                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kt">Set</span>   Implicit <span class="kn">Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Strict Implicit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Printing Implicit Defensive</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> box_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> quant_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">functional_extensionality_dep</span> :
       <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x),
       (<span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x) -&gt; f = g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">propositional_extensionality</span> :
       <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P &lt;-&gt; Q -&gt; P = Q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">constructive_indefinite_description</span> :
  <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>),
  (<span class="kr">exists</span> <span class="nv">x</span> : A, P x) -&gt; {x : A | P x}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">cid</span> := constructive_indefinite_description.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">cid2</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">exists2</span> x : A, P x &amp; Q x) -&gt; {x : A | P x &amp; Q x}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists2</span> x : A, P x &amp; Q x) -&gt; {x : A | P x &amp; Q x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; PQA; <span class="nb">suff</span>: {x | P x /\ Q x} <span class="bp">by</span> <span class="nb">move</span>=&gt; [a [*]]; <span class="kr">exists</span> <span class="nv">a</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5</q><br><q>6</q><br><span><var>PQA</var><span class="hyp-type"><b>: </b><span><span class="kr">exists2</span> x : A, P x &amp; Q x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A | P x /\ Q x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: cid; <span class="nb">case</span>: PQA =&gt; x; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">mextentionality</span> := {
  _ : <span class="kr">forall</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>), (P &lt;-&gt; Q) -&gt; (P = Q);
  _ : <span class="kr">forall</span> {<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U),
        (<span class="kr">forall</span> <span class="nv">x</span>, f x = g x) -&gt; f = g;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">extentionality</span> : mextentionality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">mextentionality</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P &lt;-&gt; Q -&gt; P = Q</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U),
(<span class="kr">forall</span> <span class="nv">x</span> : T, f x = g x) -&gt; f = g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>15</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">exact</span>: propositional_extensionality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><q>1a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>1d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; T U f g; <span class="nb">apply</span>: functional_extensionality_dep.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">propext</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (P &lt;-&gt; Q) -&gt; (P = Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P &lt;-&gt; Q -&gt; P = Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>21</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [propext _] := extentionality; <span class="nb">apply</span>: propext.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">funext</span> {<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U) : (f =<span class="mi">1</span> g) -&gt; f = g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>T -&gt; U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f =<span class="mi">1</span> g -&gt; f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>28</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: extentionality=&gt; _; <span class="nb">apply</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">propeqE</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (P = Q) = (P &lt;-&gt; Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(P = Q) = (P &lt;-&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>30</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: propext; <span class="nb">split</span>=&gt; [-&gt;|/propext].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">propeqP</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (P = Q) &lt;-&gt; (P &lt;-&gt; Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P = Q &lt;-&gt; (P &lt;-&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>35</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">funeqE</span> {<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U) : (f = g) = (f =<span class="mi">1</span> g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(f = g) = (f =<span class="mi">1</span> g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [-&gt;//|/funext].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">funeq2E</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U -&gt; V) : (f = g) = (f =<span class="mi">2</span> g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>T -&gt; U -&gt; V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f = g) = (f =<span class="mi">2</span> g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [-&gt;//|?]; <span class="nb">rewrite</span> funeqE=&gt; x; <span class="nb">rewrite</span> funeqE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">funeq3E</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> <span class="nv">W</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U -&gt; V -&gt; W) :
  (f = g) = (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, f x y z = g x y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, U, V, W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>T -&gt; U -&gt; V -&gt; W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f = g) =
(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : U) (<span class="nv">z</span> : V), f x y z = g x y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>47</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [-&gt;//|?]; <span class="nb">rewrite</span> funeq2E=&gt; x y; <span class="nb">rewrite</span> funeqE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">funeqP</span> {<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U) : (f = g) &lt;-&gt; (f =<span class="mi">1</span> g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;-&gt; f =<span class="mi">1</span> g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> funeqE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">funeq2P</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U -&gt; V) : (f = g) &lt;-&gt; (f =<span class="mi">2</span> g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>41</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;-&gt; f =<span class="mi">2</span> g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>54</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> funeq2E.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">funeq3P</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> <span class="nv">W</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; U -&gt; V -&gt; W) :
  (f = g) &lt;-&gt; (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, f x y z = g x y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>49</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : U) (<span class="nv">z</span> : V), f x y z = g x y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>59</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> funeq3E.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">predeqE</span> {<span class="nv">T</span>} (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; <span class="kt">Prop</span>) : (P = Q) = (<span class="kr">forall</span> <span class="nv">x</span>, P x &lt;-&gt; Q x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(P = Q) = (<span class="kr">forall</span> <span class="nv">x</span> : T, P x &lt;-&gt; Q x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [-&gt;//|?]; <span class="nb">rewrite</span> funeqE=&gt; x; <span class="nb">rewrite</span> propeqE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">predeq2E</span> {<span class="nv">T</span> <span class="nv">U</span>} (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; U -&gt; <span class="kt">Prop</span>) :
   (P = Q) = (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x y &lt;-&gt; Q x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2b</q><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>T -&gt; U -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(P = Q) = (<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : U), P x y &lt;-&gt; Q x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>66</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [-&gt;//|?]; <span class="nb">rewrite</span> funeq2E=&gt; ??; <span class="nb">rewrite</span> propeqE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">predeq3E</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span>} (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; U -&gt; V -&gt; <span class="kt">Prop</span>) :
   (P = Q) = (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, P x y z &lt;-&gt; Q x y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>42</q><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>T -&gt; U -&gt; V -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(P = Q) =
(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : U) (<span class="nv">z</span> : V), P x y z &lt;-&gt; Q x y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [-&gt;//|?]; <span class="nb">rewrite</span> funeq3E=&gt; ???; <span class="nb">rewrite</span> propeqE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">predeqP</span> {<span class="nv">T</span>} (<span class="nv">A</span> <span class="nv">B</span> : T -&gt; <span class="kt">Prop</span>) : (A = B) &lt;-&gt; (<span class="kr">forall</span> <span class="nv">x</span>, A x &lt;-&gt; B x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A = B &lt;-&gt; (<span class="kr">forall</span> <span class="nv">x</span> : T, A x &lt;-&gt; B x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>74</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeqE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">predeq2P</span> {<span class="nv">T</span> <span class="nv">U</span>} (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; U -&gt; <span class="kt">Prop</span>) :
   (P = Q) &lt;-&gt; (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x y &lt;-&gt; Q x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>68</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P = Q &lt;-&gt; (<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : U), P x y &lt;-&gt; Q x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeq2E.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">predeq3P</span> {<span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span>} (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; U -&gt; V -&gt; <span class="kt">Prop</span>) :
   (P = Q) &lt;-&gt; (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, P x y z &lt;-&gt; Q x y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P = Q &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : U) (<span class="nv">z</span> : V), P x y z &lt;-&gt; Q x y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>80</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> predeq3E.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">propT</span> {<span class="nv">P</span> : <span class="kt">Prop</span>} : P -&gt; P = <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P -&gt; P = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>85</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; p; <span class="nb">rewrite</span> propeqE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">Prop_irrelevance</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">x</span> <span class="nv">y</span> : P) : x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>88</q><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>8c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: x (x) y =&gt; /propT-&gt; [] [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> Prop_irrelevance : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">mclassic</span> := {
  _ : <span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>), {P} + {~P};
  _ : <span class="kr">forall</span> <span class="nv">T</span>, Choice.mixin_of T
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">choice</span> <span class="nv">X</span> <span class="nv">Y</span> (<span class="nv">P</span> : X -&gt; Y -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span>, <span class="kr">exists</span> <span class="nv">y</span>, P x y) -&gt; {f &amp; <span class="kr">forall</span> <span class="nv">x</span>, P x (f x)}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, <span class="kr">exists</span> <span class="nv">y</span> : Y, P x y) -&gt;
{f : X -&gt; Y &amp; <span class="kr">forall</span> <span class="nv">x</span> : X, P x (f x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>93</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /(_ _)/constructive_indefinite_description -/all_tag.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Diaconescu Theorem *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">EM</span> <span class="nv">P</span> : P \/ ~ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P \/ ~ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9b</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">pose</span> U val := <span class="kr">fun</span> <span class="nv">Q</span> : bool =&gt; Q = val \/ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>88</q><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">val</span> <span class="nv">Q</span> : bool =&gt; Q = val \/ P</span></span><span class="hyp-type"><b>: </b><span>bool -&gt; bool -&gt; <span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><q>9d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> Uex val : <span class="kr">exists</span> <span class="nv">b</span>, U val b <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">val</span>; <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>88</q><br><q>a3</q><br><span><var>Uex</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">val</span> : bool, <span class="kr">exists</span> <span class="nv">b</span> : bool, U val b</span></span></span><br></div><span class="goal-separator"><hr></span><q>9d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">pose</span> f val := projT1 (cid (Uex val)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>88</q><br><q>a3</q><br><q>a8</q><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">val</span> : bool =&gt; projT1 (cid (Uex val))</span></span><span class="hyp-type"><b>: </b><span>bool -&gt; bool</span></span></span></span><br></div><span class="goal-separator"><hr></span><q>9d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">pose</span> Uf val : U val (f val) := projT2 (cid (Uex val)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>88</q><br><q>a3</q><br><q>a8</q><br><q>ad</q><br><span><var>Uf</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">val</span> : bool =&gt; projT2 (cid (Uex val)))
  : (<span class="kr">forall</span> <span class="nv">val</span> : bool, U val (f val))</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">val</span> : bool, U val (f val)</span></span></span></span><br></div><span class="goal-separator"><hr></span><q>9d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> : f true != f false \/ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f true != f false \/ P</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>b1</q><label class="goal-separator"><hr></label><div class="goal-conclusion">f true != f false \/ P -&gt; P \/ ~ P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [] := (Uf true, Uf false); <span class="nb">rewrite</span> /U.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f true = true \/ P -&gt;
f false = false \/ P -&gt; f true != f false \/ P</div></blockquote><q>b7</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [-&gt;|?] [-&gt;|?] ; <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">right</span>]; <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b1</q><span class="goal-separator"><hr></span><q>b9</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; [/eqP fTFN|]; [<span class="nb">right</span>=&gt; p|<span class="bp">by</span> <span class="nb">left</span>]; <span class="nb">apply</span>: fTFN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>88</q><br><q>a3</q><br><q>a8</q><br><q>ad</q><br><q>b2</q><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f true = f false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> UTF : U true = U false <span class="bp">by</span> <span class="nb">rewrite</span> predeqE /U =&gt; b; <span class="nb">split</span>=&gt; _; <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>88</q><br><q>a3</q><br><q>a8</q><br><q>ad</q><br><q>b2</q><br><q>c5</q><br><span><var>UTF</var><span class="hyp-type"><b>: </b><span>U true = U false</span></span></span><br></div><span class="goal-separator"><hr></span><q>c6</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /f; <span class="nb">move</span>: (Uex true) (Uex false); <span class="nb">rewrite</span> UTF =&gt; p1 p2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>88</q><br><q>a3</q><br><q>a8</q><br><q>ad</q><br><q>b2</q><br><q>c5</q><br><q>cb</q><br><span><var>p1, p2</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">b</span> : bool, U false b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projT1 (cid p1) = projT1 (cid p2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">congr</span> (projT1 (cid _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">pselect</span> (<span class="nv">P</span> : <span class="kt">Prop</span>): {P} + {~P}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{P} + {~ P}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>d3</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> : <span class="kr">exists</span> <span class="nv">b</span>, <span class="kr">if</span> b <span class="kr">then</span> P <span class="kr">else</span> ~ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">b</span> : bool, <span class="kr">if</span> b <span class="kr">then</span> P <span class="kr">else</span> ~ P</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>87</q><label class="goal-separator"><hr></label><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">b</span> : bool, <span class="kr">if</span> b <span class="kr">then</span> P <span class="kr">else</span> ~ P) -&gt; {P} + {~ P}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: (EM P); [<span class="kr">exists</span> <span class="nv">true</span>|<span class="kr">exists</span> <span class="nv">false</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><q>dd</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /cid [[]]; [<span class="nb">left</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">pselectT</span> <span class="nv">T</span> : (T -&gt; <span class="kt">False</span>) + T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((T -&gt; <span class="kt">False</span>) + T)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>e2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [/cid[]//|NT] := pselect (<span class="kr">exists</span> <span class="nv">t</span> : T, <span class="kt">True</span>); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><span><var>NT</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists</span> <span class="nv">_</span> : T, <span class="kt">True</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><q>e5</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>=&gt; t; <span class="nb">case</span>: NT; <span class="kr">exists</span> <span class="nv">t</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">classic</span> : mclassic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">mclassic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ed</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [|T]; <span class="kp">first</span> <span class="bp">exact</span>: pselect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">choiceMixin T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> (<span class="nv">fun</span> (P : pred T) (n : nat) =&gt;
  <span class="kr">if</span> pselect (<span class="kr">exists</span> <span class="nv">x</span>, P x) <span class="kr">isn&#39;t</span> <span class="nb">left</span> ex <span class="kr">then</span> None
  <span class="kr">else</span> Some (projT1 (cid ex)))
  =&gt; [P n x|P [x Px]|P Q /funext -&gt; //].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pred T</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> pselect (<span class="kr">exists</span> <span class="nv">x</span> : T, P x) <span class="kr">with</span>
| <span class="nb">left</span> ex =&gt; Some (projT1 (cid ex))
| <span class="nb">right</span> _ =&gt; None
<span class="kr">end</span> = Some x -&gt; P x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>f9</q><br><q>fb</q><br><span><var>Px</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">_</span> : nat,
  <span class="kr">match</span> pselect (<span class="kr">exists</span> <span class="nv">x</span> : T, P x) <span class="kr">with</span>
  | <span class="nb">left</span> ex =&gt; Some (projT1 (cid ex))
  | <span class="nb">right</span> _ =&gt; None
  <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: pselect =&gt; // ex [&lt;- ]; <span class="nb">case</span>: cid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ff</q><span class="goal-separator"><hr></span><q>101</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>; <span class="nb">case</span>: pselect =&gt; // -[]; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">gen_choiceMixin</span> {<span class="nv">T</span> : <span class="kt">Type</span>} : Choice.mixin_of T.</label><small class="alectryon-output"><div><q>f2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>f2</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: classic.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">pdegen</span> (<span class="nv">P</span> : <span class="kt">Prop</span>): P = <span class="kt">True</span> \/ P = <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P = <span class="kt">True</span> \/ P = <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>108</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [p|Np] := pselect P; [<span class="nb">left</span>|<span class="nb">right</span>]; <span class="nb">rewrite</span> propeqE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lem</span> (<span class="nv">P</span> : <span class="kt">Prop</span>): P \/ ~P.</label><small class="alectryon-output"><div><q>9b</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>9b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: (pselect P); <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trueE</span> : true = <span class="kt">True</span> :&gt; <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">true = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">falseE</span> : false = <span class="kt">False</span> :&gt; <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">false = <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>114</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">propF</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : ~ P -&gt; P = <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ P -&gt; P = <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>119</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; p; <span class="nb">rewrite</span> propeqE; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_fun</span> <span class="nv">T</span> <span class="nv">rT</span> (<span class="nv">U</span> <span class="nv">V</span> : T -&gt; rT) :
  (<span class="kr">forall</span> <span class="nv">x</span> : T, U x = V x) -&gt; (<span class="kr">fun</span> <span class="nv">x</span> =&gt; U x) = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; V x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, rT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>T -&gt; rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, U x = V x) -&gt; [eta U] = [eta V]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /funext-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_fun2</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">rT</span> (<span class="nv">U</span> <span class="nv">V</span> : T1 -&gt; T2 -&gt; rT) :
  (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, U x y = V x y) -&gt; (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; U x y) = (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; V x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T1, T2, rT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>T1 -&gt; T2 -&gt; rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2), U x y = V x y) -&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : T1 =&gt; [eta U x]) = (<span class="kr">fun</span> <span class="nv">x</span> : T1 =&gt; [eta V x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>126</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; UV; <span class="nb">rewrite</span> funeq2E =&gt; x y; <span class="nb">rewrite</span> UV.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_fun3</span>  <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">rT</span> (<span class="nv">U</span> <span class="nv">V</span> : T1 -&gt; T2 -&gt; T3 -&gt; rT) :
  (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, U x y z = V x y z) -&gt;
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> =&gt; U x y z) = (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> =&gt; V x y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T1, T2, T3, rT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>T1 -&gt; T2 -&gt; T3 -&gt; rT</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2) (<span class="nv">z</span> : T3), U x y z = V x y z) -&gt;
(<span class="kr">fun</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2) =&gt; [eta U x y]) =
(<span class="kr">fun</span> (<span class="nv">x</span> : T1) (<span class="nv">y</span> : T2) =&gt; [eta V x y])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>12e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; UV; <span class="nb">rewrite</span> funeq3E =&gt; x y z; <span class="nb">rewrite</span> UV.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_forall</span> <span class="nv">T</span> (<span class="nv">U</span> <span class="nv">V</span> : T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span> : T, U x = V x) -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, U x) = (<span class="kr">forall</span> <span class="nv">x</span>, V x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, U x = V x) -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : T, U x) = (<span class="kr">forall</span> <span class="nv">x</span> : T, V x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>136</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; e; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; ??; <span class="nb">rewrite</span> (e,=^~e).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_forall2</span> <span class="nv">T</span> <span class="nv">S</span> (<span class="nv">U</span> <span class="nv">V</span> : <span class="kr">forall</span> <span class="nv">x</span> : T, S x -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, U x y = V x y) -&gt; (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, U x y) = (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, V x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><span><var>S</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Type</span></span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : T, S x -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x), U x y = V x y) -&gt;
(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x), U x y) =
(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x), V x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>13d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; UV; <span class="nb">apply</span>/eq_forall =&gt; x; <span class="nb">apply</span>/eq_forall.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_forall3</span> <span class="nv">T</span> <span class="nv">S</span> <span class="nv">R</span> (<span class="nv">U</span> <span class="nv">V</span> : <span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x), R x y -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, U x y z = V x y z) -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, U x y z) = (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, V x y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>140</q><br><span><var>R</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : T, S x -&gt; <span class="kt">Type</span></span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x), R x y -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x) (<span class="nv">z</span> : R x y),
 U x y z = V x y z) -&gt;
(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x) (<span class="nv">z</span> : R x y), U x y z) =
(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x) (<span class="nv">z</span> : R x y), V x y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>145</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; UV; <span class="nb">apply</span>/eq_forall2 =&gt; x y; <span class="nb">apply</span>/eq_forall.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_exists</span> <span class="nv">T</span> (<span class="nv">U</span> <span class="nv">V</span> : T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span> : T, U x = V x) -&gt; (<span class="kr">exists</span> <span class="nv">x</span>, U x) = (<span class="kr">exists</span> <span class="nv">x</span>, V x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>138</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, U x = V x) -&gt;
(<span class="kr">exists</span> <span class="nv">x</span> : T, U x) = (<span class="kr">exists</span> <span class="nv">x</span> : T, V x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>14d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; e; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; - [] x ?; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">rewrite</span> (e,=^~e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_exists2</span> <span class="nv">T</span> <span class="nv">S</span> (<span class="nv">U</span> <span class="nv">V</span> : <span class="kr">forall</span> <span class="nv">x</span> : T, S x -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, U x y = V x y) -&gt; (<span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span>, U x y) = (<span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span>, V x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>13f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x), U x y = V x y) -&gt;
(<span class="kr">exists</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x), U x y) =
(<span class="kr">exists</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x), V x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>152</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; UV; <span class="nb">apply</span>/eq_exists =&gt; x; <span class="nb">apply</span>/eq_exists.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_exists3</span> <span class="nv">T</span> <span class="nv">S</span> <span class="nv">R</span> (<span class="nv">U</span> <span class="nv">V</span> : <span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x), R x y -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, U x y z = V x y z) -&gt;
  (<span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, U x y z) = (<span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, V x y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>147</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x) (<span class="nv">z</span> : R x y),
 U x y z = V x y z) -&gt;
(<span class="kr">exists</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x) (<span class="nv">z</span> : R x y), U x y z) =
(<span class="kr">exists</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S x) (<span class="nv">z</span> : R x y), V x y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>157</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; UV; <span class="nb">apply</span>/eq_exists2 =&gt; x y; <span class="nb">apply</span>/eq_exists.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_exist</span> <span class="nv">T</span> (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) (<span class="nv">s</span> <span class="nv">t</span> : T) (<span class="nv">p</span> : P s) (<span class="nv">q</span> : P t) :
  s = t -&gt; exist P s p = exist P t q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>s, t</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P s</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>P t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s = t -&gt; exist P s p = exist P t q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>15c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; st; <span class="nb">case</span>: _ / st <span class="kr">in</span> q *; <span class="nb">apply</span>/congr1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forall_swap</span> <span class="nv">T</span> <span class="nv">S</span> (<span class="nv">U</span> : <span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S), <span class="kt">Prop</span>) :
   (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, U x y) = (<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">x</span>, U x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>T -&gt; S -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S), U x y) =
(<span class="kr">forall</span> (<span class="nv">y</span> : S) (<span class="nv">x</span> : T), U x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>166</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">exists_swap</span> <span class="nv">T</span> <span class="nv">S</span> (<span class="nv">U</span> : <span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S), <span class="kt">Prop</span>) :
   (<span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span>, U x y) = (<span class="kr">exists</span> <span class="nv">y</span> <span class="nv">x</span>, U x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>168</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S), U x y) =
(<span class="kr">exists</span> (<span class="nv">y</span> : S) (<span class="nv">x</span> : T), U x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>16e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; -[x [y]]; <span class="kr">exists</span> <span class="nv">y</span>, x.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">reflect_eq</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool) : reflect P b -&gt; P = b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>88</q><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect P b -&gt; P = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>173</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="bp">exact</span>: rwP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">asbool</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) :=
  <span class="kr">if</span> pselect P <span class="kr">then</span> true <span class="kr">else</span> false.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`[&lt; P &gt;]&quot;</span> := (asbool P) : bool_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asboolE</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : `[&lt;P&gt;] = P :&gt; <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; P &gt;] = P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>17a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE /asbool; <span class="nb">case</span>: pselect; <span class="nb">split</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asboolP</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : reflect P `[&lt;P&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect P `[&lt; P &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>17f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (equivP idP); <span class="nb">rewrite</span> asboolE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asboolb</span> (<span class="nv">b</span> : bool) : `[&lt; b &gt;] = b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>176</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; b &gt;] = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>184</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/asboolP/idP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asboolPn</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : reflect (~ P) (~~ `[&lt;P&gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (~ P) (~~ `[&lt; P &gt;])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>18a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> /asbool; <span class="nb">case</span>: pselect=&gt; h; <span class="nb">constructor</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asboolW</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : `[&lt;P&gt;] -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; P &gt;] -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>18f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: asboolP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Shall this be a coercion ?*)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asboolT</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : P -&gt; `[&lt;P&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P -&gt; `[&lt; P &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>194</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: asboolP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asboolF</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : ~ P -&gt; `[&lt;P&gt;] = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ P -&gt; `[&lt; P &gt;] = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>199</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/introF/asboolP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_opE</span> (<span class="nv">T</span> : eqType) (<span class="nv">x</span> <span class="nv">y</span> : T) : (x == y : <span class="kt">Prop</span>) = (x = y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span>eqType</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x == y : <span class="kt">Prop</span>) = (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>19e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/propext; <span class="nb">split</span>=&gt; /eqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">is_true_inj</span> : injective is_true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">injective is_true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1a6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [] []; <span class="nb">rewrite</span> ?(trueE, falseE) <span class="nl">?propeqE</span>; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">gen_eq</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">u</span> <span class="nv">v</span> : T) := `[&lt;u = v&gt;].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">gen_eqP</span> (<span class="nv">T</span> : <span class="kt">Type</span>) : Equality.axiom (@gen_eq T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Equality.axiom (gen_eq (T:=T))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1ab</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x y; <span class="nb">apply</span>: (iffP (asboolP _)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">gen_eqMixin</span> {<span class="nv">T</span> : <span class="kt">Type</span>} := EqMixin (@gen_eqP T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">arrow_eqType</span> (T : <span class="kt">Type</span>) (T&#39; : eqType) :=
  EqType (T -&gt; T&#39;) gen_eqMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">arrow_choiceType</span> (T : <span class="kt">Type</span>) (T&#39; : choiceType) :=
  ChoiceType (T -&gt; T&#39;) gen_choiceMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">dep_arrow_eqType</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">T&#39;</span> : T -&gt; eqType) :=
  EqType (<span class="kr">forall</span> <span class="nv">x</span> : T, T&#39; x) gen_eqMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">dep_arrow_choiceClass</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">T&#39;</span> : T -&gt; choiceType) :=
  Choice.<span class="kn">Class</span> (Equality.class (dep_arrow_eqType T&#39;)) gen_choiceMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">dep_arrow_choiceType</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">T&#39;</span> : T -&gt; choiceType) :=
  Choice.Pack (dep_arrow_choiceClass T&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Prop_eqType</span> := EqType <span class="kt">Prop</span> gen_eqMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">Prop_choiceType</span> := ChoiceType <span class="kt">Prop</span> gen_choiceMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">classicType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">T</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">classicType</span> := T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">classicType_eqType</span> := EqType classicType gen_eqMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">classicType_choiceType</span> := ChoiceType classicType gen_choiceMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">classicType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;{classic&#39; T }&quot;</span> := (classicType T)
 (<span class="kn">format</span> <span class="s2">&quot;&#39;{classic&#39;  T }&quot;</span>) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">eclassicType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">T</span> : eqType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eclassicType</span> : <span class="kt">Type</span> := T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">eclassicType_eqType</span> := EqType eclassicType (Equality.class T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">eclassicType_choiceType</span> := ChoiceType eclassicType gen_choiceMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">eclassicType</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;{eclassic&#39; T }&quot;</span> := (eclassicType T)
 (<span class="kn">format</span> <span class="s2">&quot;&#39;{eclassic&#39;  T }&quot;</span>) : type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">canonical_of</span> <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">sort</span> : U -&gt; T) := <span class="kr">forall</span> (<span class="nv">G</span> : T -&gt; <span class="kt">Type</span>),
  (<span class="kr">forall</span> <span class="nv">x&#39;</span>, G (sort x&#39;)) -&gt; <span class="kr">forall</span> <span class="nv">x</span>, G x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">canonical_</span> sort := (@canonical_of _ _ sort).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">canonical</span> T E := (@canonical_of T E id).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">canon</span> <span class="nv">T</span> <span class="nv">U</span> (<span class="nv">sort</span> : U -&gt; T) : (<span class="kr">forall</span> <span class="nv">x</span>, <span class="kr">exists</span> <span class="nv">y</span>, sort y = x) -&gt; canonical_ sort.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2b</q><br><span><var>sort</var><span class="hyp-type"><b>: </b><span>U -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, <span class="kr">exists</span> <span class="nv">y</span> : U, sort y = x) -&gt;
canonical_ sort</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1b0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; + G Gs x =&gt; /(_ x)/cid[x&#39; &lt;-].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> canon {T U sort} x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">Peq</span> : canonical <span class="kt">Type</span> eqType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">canonical_ [eta Equality.sort]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1b7</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: canon =&gt; T; <span class="kr">exists</span>  [eqType of {classic T}].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">Pchoice</span> : canonical <span class="kt">Type</span> choiceType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">canonical_ [eta Choice.sort]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1bc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: canon =&gt; T; <span class="kr">exists</span> [choiceType of {classic T}].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eqPchoice</span> : canonical eqType choiceType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">canonical_ [eta Choice.eqType]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1c1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: canon=&gt; T; <span class="kr">exists</span> [choiceType of {eclassic T}]; <span class="nb">case</span>: T.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_True</span> : (~ <span class="kt">True</span>) = <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ <span class="kt">True</span>) = <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1c6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>/propext.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_False</span> : (~ <span class="kt">False</span>) = <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ <span class="kt">False</span>) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1cb</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/propext; <span class="nb">split</span>=&gt; _.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_equiv_eq</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>} : (P &lt;-&gt; Q) -&gt; `[&lt;P&gt;] = `[&lt;Q&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P &lt;-&gt; Q -&gt; `[&lt; P &gt;] = `[&lt; Q &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1d0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -propeqE =&gt; -&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_equiv_eqP</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>} <span class="nv">b</span> : reflect Q b -&gt; (P &lt;-&gt; Q) -&gt; `[&lt;P&gt;] = b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>24</q><br><q>176</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect Q b -&gt; P &lt;-&gt; Q -&gt; `[&lt; P &gt;] = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1d5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Q_b [PQ QP]; <span class="nb">apply</span>/asboolP/Q_b.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_equiv</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>} : (P &lt;-&gt; Q) -&gt; (`[&lt;P&gt;] &lt;-&gt; `[&lt;Q&gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P &lt;-&gt; Q -&gt; `[&lt; P &gt;] &lt;-&gt; `[&lt; Q &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1db</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/asbool_equiv_eq-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_eq_equiv</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>} : `[&lt;P&gt;] = `[&lt;Q&gt;] -&gt; (P &lt;-&gt; Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; P &gt;] = `[&lt; Q &gt;] -&gt; P &lt;-&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1e0</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; eq; <span class="nb">split</span>=&gt; /asboolP; <span class="nb">rewrite</span> (eq, =^~ eq) =&gt; /asboolP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">and_asboolP</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : reflect (P /\ Q) (`[&lt; P &gt;] &amp;&amp; `[&lt; Q &gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (P /\ Q) (`[&lt; P &gt;] &amp;&amp; `[&lt; Q &gt;])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1e5</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>/andP =&gt; /asboolP p /asboolP q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ Q -&gt; `[&lt; P &gt;] &amp;&amp; `[&lt; Q &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; /asboolP-&gt; /asboolP-&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">and3_asboolP</span> (<span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>) :
  reflect [/\ P, Q &amp; R] [&amp;&amp; `[&lt; P &gt;], `[&lt; Q &gt;] &amp; `[&lt; R &gt;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q, R</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect [/\ P, Q &amp; R]
  [&amp;&amp; `[&lt; P &gt;], `[&lt; Q &gt;] &amp; `[&lt; R &gt;]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1ee</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>/and3P =&gt; /asboolP p /asboolP q /asboolP r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1f0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[/\ P, Q &amp; R] -&gt; [&amp;&amp; `[&lt; P &gt;], `[&lt; Q &gt;] &amp; `[&lt; R &gt;]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span> =&gt; /asboolP -&gt; /asboolP -&gt; /asboolP -&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">or_asboolP</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : reflect (P \/ Q) (`[&lt; P &gt;] || `[&lt; Q &gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (P \/ Q) (`[&lt; P &gt;] || `[&lt; Q &gt;])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1f9</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>/orP=&gt; /asboolP; [<span class="nb">left</span> | <span class="nb">right</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P \/ Q -&gt; `[&lt; P &gt;] || `[&lt; Q &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; /asboolP-&gt; //=; <span class="nb">rewrite</span> orbT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">or3_asboolP</span> (<span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>) :
  reflect [\/ P, Q | R] [|| `[&lt; P &gt;], `[&lt; Q &gt;] | `[&lt; R &gt;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1f0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect [\/ P, Q | R]
  [|| `[&lt; P &gt;], `[&lt; Q &gt;] | `[&lt; R &gt;]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>202</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>=&gt; [| |] /asboolP -&gt; //=; <span class="nb">rewrite</span> !orbT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1f0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[|| `[&lt; P &gt;], `[&lt; Q &gt;] | `[&lt; R &gt;]] -&gt; [\/ P, Q | R]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>/orP=&gt; [/asboolP p|/orP[]/asboolP]; [<span class="bp">exact</span>:Or31|<span class="bp">exact</span>:Or32|<span class="bp">exact</span>:Or33].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_neg</span> {<span class="nv">P</span> : <span class="kt">Prop</span>} : `[&lt;~ P&gt;] = ~~ `[&lt;P&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; ~ P &gt;] = ~~ `[&lt; P &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>20b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP/asboolPn=&gt; [/asboolP|/asboolT].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_or</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>} : `[&lt;P \/ Q&gt;] = `[&lt;P&gt;] || `[&lt;Q&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; P \/ Q &gt;] = `[&lt; P &gt;] || `[&lt; Q &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>210</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (asbool_equiv_eqP (or_asboolP _ _)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_and</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>} : `[&lt;P /\ Q&gt;] = `[&lt;P&gt;] &amp;&amp; `[&lt;Q&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; P /\ Q &gt;] = `[&lt; P &gt;] &amp;&amp; `[&lt; Q &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>215</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (asbool_equiv_eqP (and_asboolP _ _)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">imply_asboolP</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>} : reflect (P -&gt; Q) (`[&lt;P&gt;] ==&gt; `[&lt;Q&gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (P -&gt; Q) (`[&lt; P &gt;] ==&gt; `[&lt; Q &gt;])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>21a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP implyP)=&gt; [PQb /asboolP/PQb/asboolW //|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(P -&gt; Q) -&gt; `[&lt; P &gt;] -&gt; `[&lt; Q &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; PQ /asboolP/PQ/asboolT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_imply</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>} : `[&lt;P -&gt; Q&gt;] = `[&lt;P&gt;] ==&gt; `[&lt;Q&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; P -&gt; Q &gt;] = `[&lt; P &gt;] ==&gt; `[&lt; Q &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>223</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (asbool_equiv_eqP imply_asboolP).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">imply_asboolPn</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : reflect (P /\ ~ Q) (~~ `[&lt;P -&gt; Q&gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (P /\ ~ Q) (~~ `[&lt; P -&gt; Q &gt;])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>228</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ `[&lt; P -&gt; Q &gt;] -&gt; P /\ ~ Q</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>23</q><label class="goal-separator"><hr></label><div class="goal-conclusion">P /\ ~ Q -&gt; ~~ `[&lt; P -&gt; Q &gt;]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> asbool_imply negb_imply -asbool_neg =&gt; /and_asboolP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><q>232</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/and_asboolP; <span class="nb">rewrite</span> asbool_neg -negb_imply asbool_imply.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forall_asboolP</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) :
  reflect (<span class="kr">forall</span> <span class="nv">x</span>, `[&lt;P x&gt;]) (`[&lt;<span class="kr">forall</span> <span class="nv">x</span>, P x&gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>15f</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (<span class="kr">forall</span> <span class="nv">x</span> : T, `[&lt; P x &gt;])
  `[&lt; <span class="kr">forall</span> <span class="nv">x</span> : T, P x &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>237</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>/asboolP=&gt; Px x; <span class="nb">apply</span>/asboolP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, `[&lt; P x &gt;]) -&gt; `[&lt; <span class="kr">forall</span> <span class="nv">x</span> : T, P x &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Px; <span class="nb">apply</span>/asboolP=&gt; x; <span class="nb">apply</span>/asboolP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">exists_asboolP</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) :
  reflect (<span class="kr">exists</span> <span class="nv">x</span>, `[&lt;P x&gt;]) (`[&lt;<span class="kr">exists</span> <span class="nv">x</span>, P x&gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (<span class="kr">exists</span> <span class="nv">x</span> : T, `[&lt; P x &gt;])
  `[&lt; <span class="kr">exists</span> <span class="nv">x</span> : T, P x &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>241</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>/asboolP=&gt; x Px; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">apply</span>/asboolP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">x</span> : T, `[&lt; P x &gt;]) -&gt; `[&lt; <span class="kr">exists</span> <span class="nv">x</span> : T, P x &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; x bPx; <span class="nb">apply</span>/asboolP; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">apply</span>/asboolP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>

</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notT</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : P = <span class="kt">False</span> -&gt; ~ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P = <span class="kt">False</span> -&gt; ~ P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>24a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>-&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">contrapT</span> <span class="nv">P</span> : ~ ~ P -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ ~ P -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>24f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/asboolPn=&gt; nnb; <span class="nb">apply</span>/asboolP; <span class="nb">apply</span>: contraR nnb =&gt; /asboolPn /asboolP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notTE</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : (~ P) -&gt; P = <span class="kt">False</span>.</label><small class="alectryon-output"><div><q>119</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><q>11c</q><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: (pdegen P)=&gt; -&gt;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notFE</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : (~ P) = <span class="kt">False</span> -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ P) = <span class="kt">False</span> -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>255</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>/notT; <span class="bp">exact</span>: contrapT.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notK</span> : involutive not.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">involutive not</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>25a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; P; <span class="nb">case</span>: (pdegen P)=&gt; -&gt;; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: notTE; <span class="nb">intuition</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ ~ <span class="kt">True</span>) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> [~ <span class="kt">True</span>]notTE //; <span class="nb">case</span>: (pdegen (~ <span class="kt">False</span>)) =&gt; // /notFE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">contra_notP</span> (<span class="nv">Q</span> <span class="nv">P</span> : <span class="kt">Prop</span>) : (~ Q -&gt; P) -&gt; ~ P -&gt; Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ Q -&gt; P) -&gt; ~ P -&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>263</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; cb /asboolPn nb; <span class="nb">apply</span>/asboolP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>266</q><br><span><var>cb</var><span class="hyp-type"><b>: </b><span>~ Q -&gt; P</span></span></span><br><span><var>nb</var><span class="hyp-type"><b>: </b><span>~~ `[&lt; P &gt;]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; Q &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: contraR nb =&gt; /asboolP /cb /asboolP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">contraPP</span> (<span class="nv">Q</span> <span class="nv">P</span> : <span class="kt">Prop</span>) : (~ Q -&gt; ~ P) -&gt; P -&gt; Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>265</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ Q -&gt; ~ P) -&gt; P -&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>271</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; cb /asboolP hb; <span class="nb">apply</span>/asboolP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>266</q><br><span><var>cb</var><span class="hyp-type"><b>: </b><span>~ Q -&gt; ~ P</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>`[&lt; P &gt;]</span></span></span><br></div><span class="goal-separator"><hr></span><q>26f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: contraLR hb =&gt; /asboolP /cb /asboolPn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">contra_notT</span> <span class="nv">b</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : (~~ b -&gt; P) -&gt; ~ P -&gt; b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>176</q><br><q>88</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(~~ b -&gt; P) -&gt; ~ P -&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>27c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; bP; <span class="nb">apply</span>: contra_notP =&gt; /negP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">contraPT</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) <span class="nv">b</span> : (~~ b -&gt; ~ P) -&gt; P -&gt; b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>175</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~~ b -&gt; ~ P) -&gt; P -&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>282</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /contra_notT; <span class="nb">rewrite</span> notK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">contraTP</span> <span class="nv">b</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) : (~ Q -&gt; ~~ b) -&gt; b -&gt; Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>176</q><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ Q -&gt; ~~ b) -&gt; b -&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>287</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; QB; <span class="nb">apply</span>: contraPP =&gt; /QB/negP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">contraNP</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool) : (~ P -&gt; b) -&gt; ~~ b -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>175</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ P -&gt; b) -&gt; ~~ b -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>28e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; /contra_notP + /negP =&gt; /[<span class="nb">apply</span>].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">contra_neqP</span> (<span class="nv">T</span> : eqType) (<span class="nv">x</span> <span class="nv">y</span> : T) <span class="nv">P</span> : (~ P -&gt; x = y) -&gt; x != y -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a1</q><br><q>1a2</q><br><q>88</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ P -&gt; x = y) -&gt; x != y -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>293</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Pxy; <span class="nb">apply</span>: contraNP =&gt; /Pxy/eqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">contra_eqP</span> (<span class="nv">T</span> : eqType) (<span class="nv">x</span> <span class="nv">y</span> : T) (<span class="nv">Q</span> : <span class="kt">Prop</span>) : (~ Q -&gt; x != y) -&gt; x = y -&gt; Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1a1</q><br><q>1a2</q><br><q>28a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ Q -&gt; x != y) -&gt; x = y -&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>299</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Qxy /eqP; <span class="nb">apply</span>: contraTP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">wlog_neg</span> <span class="nv">P</span> : (~ P -&gt; P) -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>87</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ P -&gt; P) -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>29f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">case</span>: (pselect P).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_inj</span> : injective not.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">injective not</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2a4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: can_inj notK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notLR</span> <span class="nv">P</span> <span class="nv">Q</span> : (P = ~ Q) -&gt; (~ P) = Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P = (~ Q) -&gt; (~ P) = Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2a9</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: canLR notK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">notRL</span> <span class="nv">P</span> <span class="nv">Q</span> : (~ P) = Q -&gt; P = ~ Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ P) = Q -&gt; P = (~ Q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2ae</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: canRL notK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">iff_notr</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (P &lt;-&gt; ~ Q) &lt;-&gt; (~ P &lt;-&gt; Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(P &lt;-&gt; ~ Q) &lt;-&gt; (~ P &lt;-&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2b3</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; [/propext -&gt;|/propext &lt;-]; <span class="nb">rewrite</span> notK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">iff_not2</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (~ P &lt;-&gt; ~ Q) &lt;-&gt; (P &lt;-&gt; Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ P &lt;-&gt; ~ Q) &lt;-&gt; (P &lt;-&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2b8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; [/iff_notr|PQ]; [|<span class="nb">apply</span>/iff_notr]; <span class="nb">rewrite</span> notK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
<span class="c">(* assia : let&#39;s see if we need the simplpred machinery. In any case, we sould</span>
<span class="c">   first try definitions + appropriate Arguments setting to see whether these</span>
<span class="c">   can replace the canonical structures machinery. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">predp</span> <span class="nv">T</span> := T -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Identity Coercion</span> <span class="nf">fun_of_pred</span> : predp &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">relp</span> <span class="nv">T</span> := T -&gt; predp T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Identity Coercion</span> <span class="nf">fun_of_rel</span> : rel &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">xpredp0</span> := (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kt">False</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">xpredpT</span> := (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kt">True</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">xpredpI</span> := (<span class="kr">fun</span> (<span class="nv">p1</span> <span class="nv">p2</span> : predp _) <span class="nv">x</span> =&gt; p1 x /\ p2 x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">xpredpU</span> := (<span class="kr">fun</span> (<span class="nv">p1</span> <span class="nv">p2</span> : predp _) <span class="nv">x</span> =&gt; p1 x \/ p2 x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">xpredpC</span> := (<span class="kr">fun</span> (<span class="nv">p</span> : predp _) <span class="nv">x</span> =&gt; ~ p x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">xpredpD</span> := (<span class="kr">fun</span> (<span class="nv">p1</span> <span class="nv">p2</span> : predp _) <span class="nv">x</span> =&gt; ~ p2 x /\ p1 x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">xpreimp</span> := (<span class="kr">fun</span> <span class="nv">f</span> (<span class="nv">p</span> : predp _) <span class="nv">x</span> =&gt; p (f x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">xrelpU</span> := (<span class="kr">fun</span> (<span class="nv">r1</span> <span class="nv">r2</span> : relp _) <span class="nv">x</span> <span class="nv">y</span> =&gt; r1 x y \/ r2 x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pred0p</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : predp T) : bool := `[&lt;P =<span class="mi">1</span> xpredp0&gt;].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Prenex Implicits</span> <span class="nf">pred0p</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">pred0pP</span>  (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : predp T) : reflect (P =<span class="mi">1</span> xpredp0) (pred0p P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><span><var>P</var><span class="hyp-type"><b>: </b><span>predp T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (P =<span class="mi">1</span> xpredp0) (pred0p P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2bd</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (iffP (asboolP _)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* -------------------------------------------------------------------- *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forallp_asboolPn</span> {<span class="nv">T</span>} {<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>} :
  reflect (<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x) (~~ `[&lt;<span class="kr">exists</span> <span class="nv">x</span> : T, P x&gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x)
  (~~ `[&lt; <span class="kr">exists</span> <span class="nv">x</span> : T, P x &gt;])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2c4</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP)=&gt; [/asboolPn NP x Px|NP].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>15f</q><br><span><var>NP</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists</span> <span class="nv">x</span> : T, P x)</span></span></span><br><q>fb</q><br><q>100</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>15f</q><br><span><var>NP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">~~ `[&lt; <span class="kr">exists</span> <span class="nv">x</span> : T, P x &gt;]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/NP; <span class="kr">exists</span> <span class="nv">x</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2d0</q><span class="goal-separator"><hr></span><q>2d2</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/asboolP=&gt; -[x]; <span class="nb">apply</span>/NP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">existsp_asboolPn</span> {<span class="nv">T</span>} {<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>} :
  reflect (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x) (~~ `[&lt;<span class="kr">forall</span> <span class="nv">x</span> : T, P x&gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)
  (~~ `[&lt; <span class="kr">forall</span> <span class="nv">x</span> : T, P x &gt;])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2d7</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>=&gt; x NPx; <span class="nb">apply</span>/asboolPn=&gt; /(_ x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ `[&lt; <span class="kr">forall</span> <span class="nv">x</span> : T, P x &gt;] -&gt; <span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>/asboolPn=&gt; NP; <span class="nb">apply</span>/asboolP/negbNE/asboolPn=&gt; h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>15f</q><br><span><var>NP</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)</span></span></span><br></div><span class="goal-separator"><hr></span><q>2cd</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/NP=&gt; x; <span class="nb">apply</span>/asboolP/negbNE/asboolPn=&gt; NPx; <span class="nb">apply</span>/h; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_forallNb</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : pred T) :
  `[&lt; <span class="kr">forall</span> <span class="nv">x</span> : T, ~~ (P x) &gt;] = ~~ `[&lt; <span class="kr">exists</span> <span class="nv">x</span> : T, P x &gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>f9</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; <span class="kr">forall</span> <span class="nv">x</span> : T, ~~ P x &gt;] =
~~ `[&lt; <span class="kr">exists</span> <span class="nv">x</span> : T, P x &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2e6</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span>: (asbool_equiv_eqP forallp_asboolPn);
  <span class="bp">by</span> <span class="nb">split</span>=&gt; h x; <span class="nb">apply</span>/negP/h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">asbool_existsNb</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : pred T) :
  `[&lt; <span class="kr">exists</span> <span class="nv">x</span> : T, ~~ (P x) &gt;] = ~~ `[&lt; <span class="kr">forall</span> <span class="nv">x</span> : T, P x &gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2e8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; <span class="kr">exists</span> <span class="nv">x</span> : T, ~~ P x &gt;] =
~~ `[&lt; <span class="kr">forall</span> <span class="nv">x</span> : T, P x &gt;]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2ec</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span>: (asbool_equiv_eqP existsp_asboolPn);
  <span class="bp">by</span> <span class="nb">split</span>=&gt; -[x h]; <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">apply</span>/negP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_implyP</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : ~ (P -&gt; Q) &lt;-&gt; P /\ ~ Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (P -&gt; Q) &lt;-&gt; P /\ ~ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2f1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [/asboolP|[p nq pq]]; [|<span class="bp">exact</span>/nq/pq].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">`[&lt; ~ (P -&gt; Q) &gt;] -&gt; P /\ ~ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> asbool_neg =&gt; /imply_asboolPn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_andP</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : ~ (P /\ Q) &lt;-&gt; ~ P \/ ~ Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (P /\ Q) &lt;-&gt; ~ P \/ ~ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2fa</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span> =&gt; [/asboolPn|[|]]; <span class="kp">try</span> <span class="bp">by</span> <span class="nb">apply</span>: contra_not =&gt; -[].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ `[&lt; P /\ Q &gt;] -&gt; ~ P \/ ~ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> asbool_and negb_and =&gt; /orP[]/asboolPn; [<span class="nb">left</span>|<span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_and3P</span> (<span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>) : ~ [/\ P, Q &amp; R] &lt;-&gt; [\/ ~ P, ~ Q | ~ R].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1f0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ [/\ P, Q &amp; R] &lt;-&gt; [\/ ~ P, ~ Q | ~ R]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>303</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [/and3_asboolP|/or3_asboolP].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1f0</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ [&amp;&amp; `[&lt; P &gt;], `[&lt; Q &gt;] &amp; `[&lt; R &gt;]] -&gt;
[\/ ~ P, ~ Q | ~ R]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>1f0</q><label class="goal-separator"><hr></label><div class="goal-conclusion">[|| `[&lt; ~ P &gt;], `[&lt; ~ Q &gt;] | `[&lt; ~ R &gt;]] -&gt;
~ [/\ P, Q &amp; R]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span>!negb_and -<span class="mi">3</span>!asbool_neg =&gt; /or3_asboolP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1f0</q><span class="goal-separator"><hr></span><q>30d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">3</span>!asbool_neg -<span class="mi">2</span>!negb_and =&gt; /and3_asboolP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_orP</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : ~ (P \/ Q) &lt;-&gt; ~ P /\ ~ Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (P \/ Q) &lt;-&gt; ~ P /\ ~ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>312</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; [<span class="nb">apply</span>: contra_notP =&gt; /not_andP|<span class="nb">apply</span>: contraPnot =&gt; AB; <span class="nb">apply</span>/not_andP];
  <span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span>!notK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_implyE</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (~ (P -&gt; Q)) = (P /\ ~ Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ (P -&gt; Q)) = (P /\ ~ Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>317</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE not_implyP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">orC</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (P \/ Q) = (Q \/ P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(P \/ Q) = (Q \/ P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>31c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [[]|[]]; [<span class="nb">right</span>|<span class="nb">left</span>|<span class="nb">right</span>|<span class="nb">left</span>].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">orA</span> : associative or.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">associative or</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>321</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; P Q R; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [|]; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">andC</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : (P /\ Q) = (Q /\ P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(P /\ Q) = (Q /\ P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>326</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [[]|[]].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">andA</span> : associative <span class="kn">and</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">associative <span class="kn">and</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>32b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; P Q R; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [|]; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forallNE</span> {<span class="nv">T</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) : (<span class="kr">forall</span> <span class="nv">x</span>, ~ P x) = ~ <span class="kr">exists</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x) = (~ (<span class="kr">exists</span> <span class="nv">x</span> : T, P x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>330</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [fP [x /fP]//|nexP x Px]; <span class="nb">apply</span>: nexP; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">existsNE</span> {<span class="nv">T</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) : (<span class="kr">exists</span> <span class="nv">x</span>, ~ P x) = ~ <span class="kr">forall</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x) = (~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>335</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; [[x Px] aP //|NaP].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>15f</q><br><span><var>NaP</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: contrapT; <span class="nb">rewrite</span> -forallNE =&gt; aP; <span class="nb">apply</span>: NaP =&gt; x; <span class="nb">apply</span>: contrapT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">existsNP</span> <span class="nv">T</span> (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) : (<span class="kr">exists</span> <span class="nv">x</span>, ~ P x) &lt;-&gt; ~ <span class="kr">forall</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x) &lt;-&gt; ~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>340</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> existsNE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_existsP</span> <span class="nv">T</span> (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) : (<span class="kr">exists</span> <span class="nv">x</span>, P x) &lt;-&gt; ~ <span class="kr">forall</span> <span class="nv">x</span>, ~ P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">x</span> : T, P x) &lt;-&gt; ~ (<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>345</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> forallNE notK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forallNP</span> <span class="nv">T</span> (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) : (<span class="kr">forall</span> <span class="nv">x</span>, ~ P x) &lt;-&gt; ~ <span class="kr">exists</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x) &lt;-&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span> : T, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>34a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> forallNE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_forallP</span> <span class="nv">T</span> (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) : (<span class="kr">forall</span> <span class="nv">x</span>, P x) &lt;-&gt; ~ <span class="kr">exists</span> <span class="nv">x</span>, ~ P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>239</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, P x) &lt;-&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>34f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> existsNE notK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">exists2P</span> <span class="nv">T</span> (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">exists2</span> x, P x &amp; Q x) &lt;-&gt; <span class="kr">exists</span> <span class="nv">x</span>, P x /\ Q x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>60</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists2</span> x : T, P x &amp; Q x) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">x</span> : T, P x /\ Q x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>354</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>=&gt; [[x ? ?] | [x []]]; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">not_exists2P</span> <span class="nv">T</span> (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">exists2</span> x, P x &amp; Q x) &lt;-&gt; ~ <span class="kr">forall</span> <span class="nv">x</span>, ~ P x \/ ~ Q x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>60</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists2</span> x : T, P x &amp; Q x) &lt;-&gt;
~ (<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x \/ ~ Q x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>359</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> exists2P not_existsP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>60</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (<span class="kr">forall</span> <span class="nv">x</span> : T, ~ (P x /\ Q x)) &lt;-&gt;
~ (<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x \/ ~ Q x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; <span class="nb">apply</span>: contra_not =&gt; PQx x;  <span class="nb">apply</span>/not_andP; <span class="nb">apply</span>: PQx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forall2NP</span> <span class="nv">T</span> (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span>, ~ P x \/ ~ Q x) &lt;-&gt; ~ (<span class="kr">exists2</span> x, P x &amp; Q x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>60</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x \/ ~ Q x) &lt;-&gt;
~ (<span class="kr">exists2</span> x : T, P x &amp; Q x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>362</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [PQ [t Pt Qt]|PQ t]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">have</span> [] := PQ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>62</q><br><span><var>PQ</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists2</span> x : T, P x &amp; Q x)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ P t \/ ~ Q t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -not_andP =&gt; -[Pt Qt]; <span class="nb">apply</span> PQ; <span class="kr">exists</span> <span class="nv">t</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forallPNP</span> <span class="nv">T</span> (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; ~ Q x) &lt;-&gt; ~ (<span class="kr">exists2</span> x, P x &amp; Q x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>60</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : T, P x -&gt; ~ Q x) &lt;-&gt;
~ (<span class="kr">exists2</span> x : T, P x &amp; Q x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>36e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [PQ [t Pt Qt]|PQ t]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">have</span> [] := PQ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>369</q><span class="goal-separator"><hr></span><div class="goal-conclusion">P t -&gt; ~ Q t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; Pt Qt; <span class="nb">apply</span>: PQ; <span class="kr">exists</span> <span class="nv">t</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">existsPNP</span> <span class="nv">T</span> (<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; <span class="kt">Prop</span>) :
  (<span class="kr">exists2</span> x, P x &amp; ~ Q x) &lt;-&gt; ~ (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; Q x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>60</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists2</span> x : T, P x &amp; ~ Q x) &lt;-&gt;
~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x -&gt; Q x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>377</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>=&gt; [[x Px NQx] /(_ x Px)//|]; <span class="nb">apply</span>: contra_notP =&gt; + x Px.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>62</q><br><q>fb</q><br><q>100</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (<span class="kr">exists2</span> x : T, P x &amp; ~ Q x) -&gt; Q x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: contra_notP =&gt; NQx; <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forallp_asboolPn2</span> {<span class="nv">T</span>} {<span class="nv">P</span> <span class="nv">Q</span> : T -&gt; <span class="kt">Prop</span>} :
  reflect (<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x \/ ~ Q x) (~~ `[&lt;<span class="kr">exists2</span> x : T, P x &amp; Q x&gt;]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>60</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (<span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x \/ ~ Q x)
  (~~ `[&lt; <span class="kr">exists2</span> x : T, P x &amp; Q x &gt;])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>381</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP)=&gt; [/asboolPn NP x|NP].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>62</q><br><span><var>NP</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists2</span> x : T, P x &amp; Q x)</span></span></span><br><q>fb</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ P x \/ ~ Q x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>62</q><br><span><var>NP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : T, ~ P x \/ ~ Q x</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">~~ `[&lt; <span class="kr">exists2</span> x : T, P x &amp; Q x &gt;]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/forallPNP : NP =&gt; /(_ x)/and_rec/not_andP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>38d</q><span class="goal-separator"><hr></span><q>38f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/asboolP=&gt; -[x Px Qx]; <span class="nb">have</span> /not_andP := NP x; <span class="bp">exact</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">FunOrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">FunOrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Order.TTheory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">aT</span> : <span class="kt">Type</span>) (<span class="nv">d</span> : unit) (<span class="nv">T</span> : porderType d).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : aT -&gt; T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fun_display</span> : unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>aT</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>unit</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>porderType d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>394</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: tt.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lef</span> <span class="nv">f</span> <span class="nv">g</span> := `[&lt; <span class="kr">forall</span> <span class="nv">x</span>, (f x &lt;= g x)%O &gt;].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;f &lt;= g&quot;</span> := (lef f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ltf</span> <span class="nv">f</span> <span class="nv">g</span> := `[&lt; (<span class="kr">forall</span> <span class="nv">x</span>, (f x &lt;= g x)%O) /\ <span class="kr">exists</span> <span class="nv">x</span>, f x != g x &gt;].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;f &lt; g&quot;</span> := (ltf f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ltf_def</span> <span class="nv">f</span> <span class="nv">g</span> : (f &lt; g) = (g != f) &amp;&amp; (f &lt;= g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>399</q><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>aT -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f &lt; g) = (g != f) &amp;&amp; (f &lt;= g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>39d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/idP/andP =&gt; [fg|[gf fg]]; [<span class="nb">split</span>|<span class="nb">apply</span>/asboolP; <span class="nb">split</span>; [<span class="bp">exact</span>/asboolP|]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>399</q><br><q>3a0</q><br><span><var>fg</var><span class="hyp-type"><b>: </b><span>f &lt; g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g != f</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>3a6</q><label class="goal-separator"><hr></label><div class="goal-conclusion">f &lt;= g</div></blockquote><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>399</q><br><q>3a0</q><br><span><var>gf</var><span class="hyp-type"><b>: </b><span>g != f</span></span></span><br><span><var>fg</var><span class="hyp-type"><b>: </b><span>f &lt;= g</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">x</span> : aT, f x != g x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>3a4</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/eqP =&gt; gf; <span class="nb">move</span>: fg =&gt; /asboolP[fg] [x /eqP]; <span class="nb">apply</span>; <span class="nb">rewrite</span> gf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3a6</q><span class="goal-separator"><hr></span><q>3ab</q></blockquote><div class="alectryon-extra-goals"><q>3ac</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>3b3</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/asboolP =&gt; x; <span class="nb">rewrite</span> le_eqVlt; <span class="nb">move</span>/asboolP : fg =&gt; [fg [y gfy]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>399</q><br><q>3a0</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>aT</span></span></span><br><span><var>fg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : aT, (f x &lt;= g x)%O</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>aT</span></span></span><br><span><var>gfy</var><span class="hyp-type"><b>: </b><span>f y != g y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f x == g x) || (f x &lt; g x)%O</div></blockquote><q>3b5</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">have</span> [//|gfx /=] := boolP (f x == g x); <span class="nb">rewrite</span> lt_neqAle gfx /= fg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ad</q><span class="goal-separator"><hr></span><q>3b0</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>3c1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/not_existsP =&gt; h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>399</q><br><q>3a0</q><br><q>3ae</q><br><q>3af</q><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : aT, ~ f x != g x</span></span></span><br></div><span class="goal-separator"><hr></span><q>2cd</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> : f =<span class="mi">1</span> g <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">have</span> /negP/negPn/eqP := h x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3c7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f =<span class="mi">1</span> g -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -funeqE; <span class="nb">apply</span>/nesym/eqP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">lef_refl</span> : reflexive lef.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>396</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflexive lef</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3ce</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; f; <span class="nb">apply</span>/asboolP =&gt; x.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">lef_anti</span> : antisymmetric lef.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>396</q><span class="goal-separator"><hr></span><div class="goal-conclusion">antisymmetric lef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3d3</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; f g =&gt; /andP[/asboolP fg /asboolP gf]; <span class="nb">rewrite</span> funeqE =&gt; x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>399</q><br><q>3a0</q><br><q>3bc</q><br><span><var>gf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : aT, (g x &lt;= f x)%O</span></span></span><br><q>3bb</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le fg gf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">lef_trans</span> : transitive lef.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>396</q><span class="goal-separator"><hr></span><div class="goal-conclusion">transitive lef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3de</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; g f h /asboolP fg /asboolP gh; <span class="nb">apply</span>/asboolP =&gt; x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>399</q><br><span><var>g, f, h</var><span class="hyp-type"><b>: </b><span>aT -&gt; T</span></span></span><br><q>3bc</q><br><span><var>gh</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : aT, (g x &lt;= h x)%O</span></span></span><br><q>3bb</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f x &lt;= h x)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (le_trans (fg x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">porderMixin</span> :=
  @LePOrderMixin _ lef ltf ltf_def lef_refl lef_anti lef_trans.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">porderType</span> := POrderType fun_display (aT -&gt; T) porderMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">FunOrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">FunLattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Order.TTheory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">aT</span> : <span class="kt">Type</span>) (<span class="nv">d</span> : unit) (<span class="nv">T</span> : latticeType d).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : aT -&gt; T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">meetf</span> <span class="nv">f</span> <span class="nv">g</span> := <span class="kr">fun</span> <span class="nv">x</span> =&gt; Order.meet (f x) (g x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">joinf</span> <span class="nv">f</span> <span class="nv">g</span> := <span class="kr">fun</span> <span class="nv">x</span> =&gt; Order.join (f x) (g x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">meetfC</span> : commutative meetf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><span><var>T</var><span class="hyp-type"><b>: </b><span>latticeType d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">commutative meetf</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3ea</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; f g; <span class="nb">apply</span>/funext =&gt; x; <span class="bp">exact</span>: meetC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">joinfC</span> : commutative joinf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ec</q><span class="goal-separator"><hr></span><div class="goal-conclusion">commutative joinf</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3f1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; f g; <span class="nb">apply</span>/funext =&gt; x; <span class="bp">exact</span>: joinC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">meetfA</span> : associative meetf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ec</q><span class="goal-separator"><hr></span><div class="goal-conclusion">associative meetf</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3f6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; f g h; <span class="nb">apply</span>/funext =&gt; x; <span class="bp">exact</span>: meetA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">joinfA</span> : associative joinf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ec</q><span class="goal-separator"><hr></span><div class="goal-conclusion">associative joinf</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3fb</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; f g h; <span class="nb">apply</span>/funext =&gt; x; <span class="bp">exact</span>: joinA.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">joinfKI</span> <span class="nv">g</span> <span class="nv">f</span> : meetf f (joinf f g) = f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>3ed</q><br><span><var>g, f</var><span class="hyp-type"><b>: </b><span>aT -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">meetf f (joinf f g) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>400</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span>/funext =&gt; x; <span class="bp">exact</span>: joinKI.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">meetfKU</span> <span class="nv">g</span> <span class="nv">f</span> : joinf f (meetf f g) = f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>402</q><span class="goal-separator"><hr></span><div class="goal-conclusion">joinf f (meetf f g) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>407</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span>/funext =&gt; x; <span class="bp">exact</span>: meetKU.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lef_meet</span> <span class="nv">f</span> <span class="nv">g</span> : (f &lt;= g)%O = (meetf f g == f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>3ed</q><br><q>3a0</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f &lt;= g)%O = (meetf f g == f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>40c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/idP/idP =&gt; [/asboolP f_le_g|/eqP &lt;-].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>3ed</q><br><q>3a0</q><br><span><var>f_le_g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : aT, (f x &lt;= g x)%O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">meetf f g == f</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>40e</q><label class="goal-separator"><hr></label><div class="goal-conclusion">(meetf f g &lt;= g)%O</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>412</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/eqP/funext =&gt; x; <span class="bp">exact</span>/meet_l/f_le_g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>40e</q><span class="goal-separator"><hr></span><q>419</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>41c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span>/asboolP =&gt; x; <span class="bp">exact</span>: leIr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">latticeMixin</span> :=
  LatticeMixin meetfC joinfC meetfA joinfA joinfKI meetfKU lef_meet.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">latticeType</span> := LatticeType (aT -&gt; T) latticeMixin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">FunLattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">porderType</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Ignoring canonical projection to <span class="kr">forall</span> <span class="nv">_</span>, _ <span class="bp">by</span>
Order.POrder.sort <span class="kr">in</span> porderType: redundant <span class="kr">with</span>
porderType
[redundant-canonical-projection,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Canonical</span> <span class="nf">latticeType</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Ignoring canonical projection to <span class="kr">forall</span> <span class="nv">_</span>, _ <span class="bp">by</span>
Order.Lattice.sort <span class="kr">in</span> latticeType: redundant <span class="kr">with</span>
latticeType
[redundant-canonical-projection,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Exports</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">FunOrder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> FunOrder.Exports.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">lefP</span> (<span class="nv">aT</span> : <span class="kt">Type</span>) <span class="nv">d</span> (<span class="nv">T</span> : porderType d) (<span class="nv">f</span> <span class="nv">g</span> : aT -&gt; T) :
  reflect (<span class="kr">forall</span> <span class="nv">x</span>, (f x &lt;= g x)%O) (f &lt;= g)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>39f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (<span class="kr">forall</span> <span class="nv">x</span> : aT, (f x &lt;= g x)%O) (f &lt;= g)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>422</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (iffP idP) =&gt; [fg|fg]; [<span class="bp">exact</span>/asboolP | <span class="nb">apply</span>/asboolP].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">meetfE</span> (<span class="nv">aT</span> : <span class="kt">Type</span>) <span class="nv">d</span> (<span class="nv">T</span> : latticeType d) (<span class="nv">f</span> <span class="nv">g</span> : aT -&gt; T) <span class="nv">x</span> :
  ((f `&amp;` g) x = f x `&amp;` g x)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>397</q><br><q>398</q><br><q>3ed</q><br><q>3a0</q><br><q>3bb</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f `&amp;` g)%O x = (f x `&amp;` g x)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>427</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">joinfE</span> (<span class="nv">aT</span> : <span class="kt">Type</span>) <span class="nv">d</span> (<span class="nv">T</span> : latticeType d) (<span class="nv">f</span> <span class="nv">g</span> : aT -&gt; T) <span class="nv">x</span> :
  ((f `|` g) x = f x `|` g x)%O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>429</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(f `|` g)%O x = (f x `|` g x)%O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>42d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">iterfS</span> {<span class="nv">T</span>} (<span class="nv">f</span> : T -&gt; T) (<span class="nv">n</span> : nat) : iter n.+<span class="mi">1</span> f = f \o iter n f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T -&gt; T</span></span></span><br><q>fa</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">iter n.+<span class="mi">1</span> f = f \o iter n f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>432</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">iterfSr</span> {<span class="nv">T</span>} (<span class="nv">f</span> : T -&gt; T) (<span class="nv">n</span> : nat) : iter n.+<span class="mi">1</span> f = iter n f \o f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>434</q><span class="goal-separator"><hr></span><div class="goal-conclusion">iter n.+<span class="mi">1</span> f = iter n f \o f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>439</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/funeqP =&gt; ?; <span class="nb">rewrite</span> iterSr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">iter0</span> {<span class="nv">T</span>} (<span class="nv">f</span> : T -&gt; T) : iter <span class="mi">0</span> f = id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>61</q><br><q>435</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">iter <span class="mi">0</span> f = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>43e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></article></body></html>