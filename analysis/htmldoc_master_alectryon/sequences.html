<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>sequences.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect ssralg ssrint ssrnum matrix.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predI _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predU _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predD _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predC _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ preim _ of _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closedM;
                   GRing.smulr_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedM; GRing.smulr_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed.
New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.sdivr_closed_div;
                   GRing.divr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.sdivr_closedM; GRing.smulr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subalg_closedBM;
                   GRing.subring_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subalg_closedZ; GRing.submod_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divring_closed_div;
                   GRing.sdivr_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divring_closedBM; GRing.subring_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divalg_closedBdiv;
                   GRing.divring_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divalg_closedZ; GRing.subalg_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.Pred.subring_smul;
                   GRing.Pred.smul_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.Pred.subring_semi; GRing.Pred.semiring_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> interval rat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> boolp classical_sets.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Empty.mixin; Empty.eqMixin] : Empty.class_of &gt;-&gt; Equality.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[Empty.base; Finite.base; Choice.base] : Empty.class_of &gt;-&gt; Equality.mixin_of.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Empty.mixin; Empty.choiceMixin] : Empty.class_of &gt;-&gt; Choice.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[Empty.base; Finite.base; Choice.mixin] : Empty.class_of &gt;-&gt; Choice.mixin_of.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Empty.mixin; Empty.countMixin] : Empty.class_of &gt;-&gt; Countable.mixin_of <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[Empty.base; Finite.mixin; Finite.mixin_base] : Empty.class_of &gt;-&gt; Countable.mixin_of.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> functions set_interval mathcomp_extra.
<span class="kn">Require Import</span> reals ereal signed topology normedtype landau.

<span class="sd">(******************************************************************************)</span>
<span class="c">(*                Definitions and lemmas about sequences                      *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* The purpose of this file is to gather generic definitions and lemmas about *)</span>
<span class="c">(* sequences.                                                                 *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * About sequences of real numbers:                                         *)</span>
<span class="c">(*        [sequence u_n]_n == the sequence of general element u_n             *)</span>
<span class="c">(*                  R ^nat == notation for the type of sequences, i.e.,       *)</span>
<span class="c">(*                            functions of type nat -&gt; R                      *)</span>
<span class="c">(*                 seqDU F == sequence F_0, F_1 \ F_0, F_2 \ (F_0 U F_1),...  *)</span>
<span class="c">(*                  seqD F == the sequence F_0, F_1 \ F_0, F_2 \ F_1,...      *)</span>
<span class="c">(*               series u_ == the sequence of partial sums of u_              *)</span>
<span class="c">(*            telescope u_ := [sequence u_ n.+1 - u_ n]_n                     *)</span>
<span class="c">(*                harmonic == harmonic sequence                               *)</span>
<span class="c">(*              arithmetic == arithmetic sequence                             *)</span>
<span class="c">(*               geometric == geometric sequence                              *)</span>
<span class="c">(*                            also arithmetic_mean, harmonic_mean,            *)</span>
<span class="c">(*                            root_mean_square                                *)</span>
<span class="c">(*          [series u_n]_n == the series of general element u_n               *)</span>
<span class="c">(*              [normed S] == transforms a series S = [series u_n]_n in its   *)</span>
<span class="c">(*                            normed series [series `|u_n|]_n] (useful to     *)</span>
<span class="c">(*                            represent absolute and normed convergence:      *)</span>
<span class="c">(*                            cvg [norm S_n])                                 *)</span>
<span class="c">(*             exp_coeff n == the sequence of coefficients of the real        *)</span>
<span class="c">(*                            exponential                                     *)</span>
<span class="c">(*                  expR x == the exponential function defined on a realType  *)</span>
<span class="c">(* is_cvg_series_exp_coeff == convergence of \sum_n^+oo x^n / n!              *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*        \sum_&lt;range&gt; F i == lim (fun n =&gt; (\sum_&lt;range&gt;) F i)) where        *)</span>
<span class="c">(*                            &lt;range&gt; can be (i &lt;oo), (i &lt;oo | P i),          *)</span>
<span class="c">(*                            (m &lt;= i &lt;oo), or (m &lt;= i &lt;oo | P i)             *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* Sections sequences_R_* contain properties of sequences of real numbers.    *)</span>
<span class="c">(* For example:                                                               *)</span>
<span class="c">(* nonincreasing_cvg_ge u_ == if u_ is nonincreasing and convergent then      *)</span>
<span class="c">(*                            forall n, lim u_ &lt;= u_ n                        *)</span>
<span class="c">(* nondecreasing_cvg_le u_ == if u_ is nondecreasing and convergent then      *)</span>
<span class="c">(*                            forall n, lim u_ &gt;= u_ n                        *)</span>
<span class="c">(*    nondecreasing_cvg u_ == if u_ is nondecreasing and bounded then u_      *)</span>
<span class="c">(*                            is convergent and its limit is sup u_n          *)</span>
<span class="c">(*    nonincreasing_cvg u_ == if u_ is nonincreasing u_ and bound by below    *)</span>
<span class="c">(*                            then u_ is convergent                           *)</span>
<span class="c">(*                adjacent == adjacent sequences lemma                        *)</span>
<span class="c">(*                  cesaro == Cesaro&#39;s lemma                                  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * About sequences of natural numbers:                                      *)</span>
<span class="c">(*   nseries                                                                  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * About sequences of extended real numbers:                                *)</span>
<span class="c">(*   eseries, etelescope, etc.                                                *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* Section sequences_ereal contain properties of sequences of extended real   *)</span>
<span class="c">(* numbers.                                                                   *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*   Naming convention: lemmas about series of non-negative (resp. non-       *)</span>
<span class="c">(*   positive) extended numbers use the string &quot;nneseries&quot; (resp. &quot;npeseries&quot;)*)</span>
<span class="c">(*   as part of their identifier                                              *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Limit superior and inferior:                                             *)</span>
<span class="c">(*             sdrop u n := {u_k | k &gt;= n}                                    *)</span>
<span class="c">(*                sups u := [sequence sup (sdrop u n)]_n                      *)</span>
<span class="c">(*                infs u := [sequence inf (sdrop u n)]_n                      *)</span>
<span class="c">(*         lim_{inf,sup} == limit inferior/superior for realType              *)</span>
<span class="c">(*               esups u := [sequence ereal_sup (sdrop u n)]_n                *)</span>
<span class="c">(*               einfs u := [sequence ereal_inf (sdrop u n)]_n                *)</span>
<span class="c">(*        lim_e{inf,sup} == limit inferior/superior for \bar R                *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="kn">Set Implicit Arguments</span>.
<span class="kn">Unset Strict Implicit</span>.
<span class="kn">Unset Printing Implicit Defensive</span>.
<span class="kn">Import</span> Order.TTheory GRing.Theory Num.Def Num.Theory.
<span class="kn">Import</span> numFieldNormedType.Exports.

<span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.

<span class="kn">Reserved Notation</span> <span class="s2">&quot;R ^nat&quot;</span> (<span class="kn">at level</span> <span class="mi">0</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;a `^ x&quot;</span> (<span class="kn">at level</span> <span class="mi">11</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;sequence&#39; E ]_ n&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, E <span class="kn">at level</span> <span class="mi">200</span>, n name, <span class="kn">format</span> <span class="s2">&quot;[ &#39;sequence&#39;  E ]_ n&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;series&#39; E ]_ n&quot;</span>
  (<span class="kn">at level</span> <span class="mi">0</span>, E <span class="kn">at level</span> <span class="mi">0</span>, n name, <span class="kn">format</span> <span class="s2">&quot;[ &#39;series&#39;  E ]_ n&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;[ &#39;normed&#39; E ]&quot;</span>  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;normed&#39;  E ]&quot;</span>).

<span class="kn">Reserved Notation</span> <span class="s2">&quot;\big [ op / idx ]_ ( m &lt;= i &lt;oo | P ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">36</span>, F <span class="kn">at level</span> <span class="mi">36</span>, op, idx <span class="kn">at level</span> <span class="mi">10</span>, m, i <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \big [ op / idx ]_ ( m  &lt;=  i  &lt;oo  |  P )  F &#39;]&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;\big [ op / idx ]_ ( m &lt;= i &lt;oo ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">36</span>, F <span class="kn">at level</span> <span class="mi">36</span>, op, idx <span class="kn">at level</span> <span class="mi">10</span>, i, m <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \big [ op / idx ]_ ( m  &lt;=  i  &lt;oo ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;\big [ op / idx ]_ ( i &lt;oo | P ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">36</span>, F <span class="kn">at level</span> <span class="mi">36</span>, op, idx <span class="kn">at level</span> <span class="mi">10</span>, i <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \big [ op / idx ]_ ( i  &lt;oo |  P ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;\big [ op / idx ]_ ( i &lt;oo ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">36</span>, F <span class="kn">at level</span> <span class="mi">36</span>, op, idx <span class="kn">at level</span> <span class="mi">10</span>, i <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \big [ op / idx ]_ ( i  &lt;oo )  F &#39;]&#39;&quot;</span>).

<span class="kn">Reserved Notation</span> <span class="s2">&quot;\sum_ ( m &lt;= i &#39;&lt;oo&#39; | P ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i, m <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \sum_ ( m  &lt;=  i  &lt;oo  |  P ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;\sum_ ( m &lt;= i &#39;&lt;oo&#39; ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i, m <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \sum_ ( m  &lt;=  i  &lt;oo ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;\sum_ ( i &#39;&lt;oo&#39; | P ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \sum_ ( i  &lt;oo  |  P ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;\sum_ ( i &#39;&lt;oo&#39; ) F&quot;</span>
  (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i <span class="kn">at level</span> <span class="mi">50</span>,
           <span class="kn">format</span> <span class="s2">&quot;&#39;[&#39; \sum_ ( i  &lt;oo ) &#39;/  &#39;  F &#39;]&#39;&quot;</span>).

<span class="kn">Definition</span> <span class="nf">sequence</span> <span class="nv">R</span> := nat -&gt; R.
<span class="kn">Definition</span> <span class="nf">mk_sequence</span> <span class="nv">R</span> <span class="nv">f</span> : sequence R := f.
<span class="kn">Arguments</span> mk_sequence R f /.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;sequence&#39; E ]_ n&quot;</span> := (mk_sequence (<span class="kr">fun</span> <span class="nv">n</span> =&gt; E%E)) : ereal_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;sequence&#39; E ]_ n&quot;</span> := (mk_sequence (<span class="kr">fun</span> <span class="nv">n</span> =&gt; E)) : ring_scope.
<span class="kn">Notation</span> <span class="s2">&quot;R ^nat&quot;</span> := (sequence R) : type_scope.

<span class="kn">Notation</span> <span class="s2">&quot;&#39;nondecreasing_seq&#39; f&quot;</span> := ({homo f : n m / (n &lt;= m)%nat &gt;-&gt; (n &lt;= m)%O})
  (<span class="kn">at level</span> <span class="mi">10</span>).
<span class="kn">Notation</span> <span class="s2">&quot;&#39;nonincreasing_seq&#39; f&quot;</span> := ({homo f : n m / (n &lt;= m)%nat &gt;-&gt; (n &gt;= m)%O})
  (<span class="kn">at level</span> <span class="mi">10</span>).
<span class="kn">Notation</span> <span class="s2">&quot;&#39;increasing_seq&#39; f&quot;</span> := ({mono f : n m / (n &lt;= m)%nat &gt;-&gt; (n &lt;= m)%O})
  (<span class="kn">at level</span> <span class="mi">10</span>).
<span class="kn">Notation</span> <span class="s2">&quot;&#39;decreasing_seq&#39; f&quot;</span> := ({mono f : n m / (n &lt;= m)%nat &gt;-&gt; (n &gt;= m)%O})
  (<span class="kn">at level</span> <span class="mi">10</span>).
<span class="c">(* TODO:  the &quot;strict&quot; versions with mono instead of homo should also have notations*)</span>

<span class="kn">Lemma</span> <span class="nf">nondecreasing_opp</span> (<span class="nv">T</span> : numDomainType) (<span class="nv">u_</span> : T ^nat) :
  nondecreasing_seq (- u_) = nonincreasing_seq u_.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; du x y /du; <span class="nb">rewrite</span> ler_opp2. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nonincreasing_opp</span> (<span class="nv">T</span> : numDomainType) (<span class="nv">u_</span> : T ^nat) :
  nonincreasing_seq (- u_) = nondecreasing_seq u_.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; du x y /du; <span class="nb">rewrite</span> ler_opp2. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">decreasing_opp</span> (<span class="nv">T</span> : numDomainType) (<span class="nv">u_</span> : T ^nat) :
  decreasing_seq (- u_) = increasing_seq u_.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; du x y; <span class="nb">rewrite</span> -du ler_opp2. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">increasing_opp</span> (<span class="nv">T</span> : numDomainType) (<span class="nv">u_</span> : T ^nat) :
  increasing_seq (- u_) = decreasing_seq u_.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; du x y; <span class="nb">rewrite</span> -du ler_opp2. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_seqP</span> (<span class="nv">d</span> : unit) (<span class="nv">T</span> : porderType d) (<span class="nv">u_</span> : T ^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, u_ n &lt;= u_ n.+<span class="mi">1</span>)%O &lt;-&gt; nondecreasing_seq u_.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; [|h n]; [<span class="bp">exact</span>: homo_leq le_trans | <span class="bp">exact</span>: h]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nonincreasing_seqP</span> (<span class="nv">d</span> : unit) (<span class="nv">T</span> : porderType d) (<span class="nv">u_</span> : T ^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, u_ n &gt;= u_ n.+<span class="mi">1</span>)%O &lt;-&gt; nonincreasing_seq u_.
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: homo_leq (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">u</span> <span class="nv">v</span> =&gt; le_trans v u).
<span class="bp">by</span> <span class="nb">move</span>=&gt; u_nincr n; <span class="bp">exact</span>: u_nincr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">increasing_seqP</span> (<span class="nv">d</span> : unit) (<span class="nv">T</span> : porderType d) (<span class="nv">u_</span> : T ^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, u_ n &lt; u_ n.+<span class="mi">1</span>)%O &lt;-&gt; increasing_seq u_.
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; u_nondec; <span class="nb">apply</span>: le_mono; <span class="nb">apply</span>: homo_ltn lt_trans _.
<span class="bp">by</span> <span class="nb">move</span>=&gt; u_incr n; <span class="nb">rewrite</span> lt_neqAle eq_le !u_incr leqnSn ltnn.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">decreasing_seqP</span> (<span class="nv">d</span> : unit) (<span class="nv">T</span> : porderType d) (<span class="nv">u_</span> : T ^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, u_ n &gt; u_ n.+<span class="mi">1</span>)%O &lt;-&gt; decreasing_seq u_.
<span class="kn">Proof</span>.
<span class="nb">split</span>.
  <span class="nb">move</span>=&gt; u_noninc.
  <span class="c">(* FIXME: add shortcut to order.v *)</span>
  <span class="nb">apply</span>: (@total_homo_mono _ T u_ leq ltn _ _ leqnn _ ltn_neqAle
    _ (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; esym (le_anti _)) leq_total
    (homo_ltn (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">u</span> <span class="nv">v</span> =&gt; lt_trans v u) u_noninc)) =&gt; //.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x y; <span class="nb">rewrite</span> eq_sym -lt_neqAle.
<span class="bp">by</span> <span class="nb">move</span>=&gt; u_decr n; <span class="nb">rewrite</span> lt_neqAle eq_le !u_decr !leqnSn ltnn.
<span class="kn">Qed</span>.
<span class="c">(* TODO (maybe): variants for near \oo ?? *)</span>

<span class="kn">Lemma</span> <span class="nf">lef_at</span> (<span class="nv">aT</span> : <span class="kt">Type</span>) <span class="nv">d</span> (<span class="nv">T</span> : porderType d) (<span class="nv">f</span> : (aT -&gt; T)^nat) <span class="nv">x</span> :
  nondecreasing_seq f -&gt; {homo (f^~ x) : n m / (n &lt;= m)%N &gt;-&gt; (n &lt;= m)%O}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; nf m n mn; <span class="nb">have</span> /asboolP := nf _ _ mn; <span class="bp">exact</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_seqD</span> <span class="nv">T</span> (<span class="nv">d</span> : unit) (<span class="nv">R</span> : numDomainType) (<span class="nv">f</span> <span class="nv">g</span> : (T -&gt; R)^nat) :
  (<span class="kr">forall</span> <span class="nv">x</span>, nondecreasing_seq (f ^~ x)) -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, nondecreasing_seq (g ^~ x)) -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, nondecreasing_seq ((f \+ g) ^~ x)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ndf ndg t m n mn; <span class="nb">apply</span>: ler_add; [<span class="bp">exact</span>/ndf|<span class="bp">exact</span>/ndg]. <span class="kn">Qed</span>.

<span class="kn">Local Notation</span> <span class="nf">eqolimn</span> := (@eqolim _ _ _ eventually_filter).
<span class="kn">Local Notation</span> <span class="nf">eqolimPn</span> := (@eqolimP _ _ _ eventually_filter).

<span class="sd">(*********************)</span>
<span class="c">(* Sequences of sets *)</span>
<span class="sd">(*********************)</span>

<span class="kn">Section</span> <span class="nf">seqDU</span>.
<span class="kn">Variables</span> (<span class="nv">T</span> : <span class="kt">Type</span>).
<span class="kn">Implicit Types</span> <span class="nv">F</span> : (<span class="nb">set</span> T)^nat.

<span class="kn">Definition</span> <span class="nf">seqDU</span> <span class="nv">F</span> <span class="nv">n</span> := F n `\` \big[setU/set0]_(k &lt; n) F k.

<span class="kn">Lemma</span> <span class="nf">trivIset_seqDU</span> <span class="nv">F</span> : trivIset setT (seqDU F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; i j _ _; <span class="nb">wlog</span> ij : i j / (i &lt; j)%N =&gt; [/(_ _ _ _) tB|].
  <span class="bp">by</span> <span class="nb">have</span> [ij /tB-&gt;|ij|] := ltngtP i j; <span class="nb">rewrite</span> //setIC =&gt; /tB -&gt;.
<span class="nb">move</span>=&gt; /set0P; <span class="nb">apply</span>: contraNeq =&gt; _; <span class="nb">apply</span>/eqP.
<span class="nb">rewrite</span> /seqDU <span class="mi">2</span>!setDE !setIA setIC (bigD1 (Ordinal ij)) //=.
<span class="bp">by</span> <span class="nb">rewrite</span> setCU setIAC !setIA setICl !set0I.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigsetU_seqDU</span> <span class="nv">F</span> <span class="nv">n</span> :
  \big[setU/set0]_(k &lt; n) F k = \big[setU/set0]_(k &lt; n) seqDU F k.
<span class="kn">Proof</span>.
<span class="nb">elim</span>: n =&gt; [|n ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span>!big_ord0.
<span class="nb">rewrite</span> !big_ord_recr /= predeqE =&gt; t; <span class="nb">split</span>=&gt; [[Ft|Fnt]|[Ft|[Fnt Ft]]].
- <span class="bp">by</span> <span class="nb">left</span>; <span class="nb">rewrite</span> -ih.
- <span class="nb">have</span> [?|?] := pselect ((\big[setU/set0]_(i &lt; n) seqDU F i) t); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">left</span>.
  <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> ih.
- <span class="bp">by</span> <span class="nb">left</span>; <span class="nb">rewrite</span> ih.
- <span class="bp">by</span> <span class="nb">right</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">seqDU_bigcup_eq</span> <span class="nv">F</span> : \bigcup_k F k = \bigcup_k seqDU F k.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /seqDU predeqE =&gt; t; <span class="nb">split</span>=&gt; [[n _ Fnt]|[n _]]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> setDE =&gt; -[? _]; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="nb">have</span> [UFnt|UFnt] := pselect ((\big[setU/set0]_(k &lt; n) F k) t); <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.
<span class="nb">suff</span> [m [Fmt FNmt]] : <span class="kr">exists</span> <span class="nv">m</span>, F m t /\ <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; m)%N -&gt; ~ F k t.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">m</span> =&gt; //; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> -bigcup_mkord =&gt; -[k kj]; <span class="bp">exact</span>: FNmt.
<span class="nb">move</span>: UFnt; <span class="nb">rewrite</span> -bigcup_mkord =&gt; -[/= k _ Fkt] {Fnt n}.
<span class="nb">have</span> [n kn] := ubnP k; <span class="nb">elim</span>: n =&gt; // n ih <span class="kr">in</span> t k Fkt kn *.
<span class="nb">case</span>: k =&gt; [|k] <span class="kr">in</span> Fkt kn *; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">O</span>.
<span class="nb">have</span> [?|] := pselect (<span class="kr">forall</span> <span class="nv">m</span>, (m &lt;= k)%N -&gt; ~ F m t); <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span>.+<span class="mi">1</span>.
<span class="nb">move</span>=&gt; /existsNP[i] /not_implyP[ik] /contrapT Fit; <span class="nb">apply</span> (ih t i) =&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> (leq_ltn_trans ik).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">seqDU</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> trivIset_seqDU : core.

<span class="kn">Section</span> <span class="nf">seqD</span>.
<span class="kn">Variable</span> <span class="nv">T</span> : <span class="kt">Type</span>.
<span class="kn">Implicit Types</span> <span class="nv">F</span> : (<span class="nb">set</span> T) ^nat.

<span class="kn">Definition</span> <span class="nf">seqD</span> <span class="nv">F</span> := <span class="kr">fun</span> <span class="nv">n</span> =&gt; <span class="kr">if</span> n <span class="kr">isn&#39;t</span> n&#39;.+<span class="mi">1</span> <span class="kr">then</span> F O <span class="kr">else</span> F n `\` F n&#39;.

<span class="kn">Lemma</span> <span class="nf">seqDU_seqD</span> <span class="nv">F</span> : nondecreasing_seq F -&gt; seqDU F = seqD F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ndF; <span class="nb">rewrite</span> funeqE =&gt; -[|n] /=; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /seqDU big_ord0 setD0.
<span class="nb">rewrite</span> /seqDU big_ord_recr /= setUC; <span class="nb">congr</span> (_ `\` _); <span class="nb">apply</span>/setUidPl.
<span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_mkord =&gt; + [k /= kn]; <span class="bp">exact</span>/subsetPset/ndF/ltnW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">trivIset_seqD</span> <span class="nv">F</span> : nondecreasing_seq F -&gt; trivIset setT (seqD F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ndF; <span class="nb">rewrite</span> -seqDU_seqD //; <span class="bp">exact</span>: trivIset_seqDU. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigsetU_seqD</span> <span class="nv">F</span> <span class="nv">n</span> :
  \big[setU/set0]_(i &lt; n) F i = \big[setU/set0]_(i &lt; n) seqD F i.
<span class="kn">Proof</span>.
<span class="nb">case</span>: n =&gt; [|n]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span>!big_ord0.
<span class="nb">elim</span>: n =&gt; [|n ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> !big_ord_recl !big_ord0.
<span class="nb">rewrite</span> big_ord_recr [<span class="kr">in</span> RHS]big_ord_recr /= -{}ih predeqE =&gt; x; <span class="nb">split</span>.
  <span class="nb">move</span>=&gt; [?|?]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">left</span>.
  <span class="nb">have</span> [?|?] := pselect (F n x); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">right</span>.
  <span class="bp">by</span> <span class="nb">left</span>; <span class="nb">rewrite</span> big_ord_recr /=; <span class="nb">right</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [?|[? ?]]; [<span class="nb">left</span> | <span class="nb">right</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">setU_seqD</span> <span class="nv">F</span> : nondecreasing_seq F -&gt;
  <span class="kr">forall</span> <span class="nv">n</span>, F n.+<span class="mi">1</span> = F n `|` seqD F n.+<span class="mi">1</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ndF n; <span class="nb">rewrite</span> /seqD funeqE =&gt; x; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">have</span> [?|?] := pselect (F n x); [<span class="nb">left</span> | <span class="nb">right</span>].
<span class="bp">by</span> <span class="nb">move</span>=&gt; -[|[]//]; <span class="nb">move</span>: x; <span class="bp">exact</span>/subsetPset/ndF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_bigsetU_seqD</span> <span class="nv">F</span> <span class="nv">n</span> : nondecreasing_seq F -&gt;
  F n = \big[setU/set0]_(i &lt; n.+<span class="mi">1</span>) seqD F i.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ndF; <span class="nb">elim</span>: n =&gt; [|n ih]; <span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> big_ord_recl big_ord0; <span class="nb">left</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recl big_ord0 setU0.
- <span class="nb">rewrite</span> (setU_seqD ndF) =&gt; -[|/=].
  <span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr /= -ih =&gt; Fnx; <span class="nb">left</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; -[Fn1x Fnx]; <span class="nb">rewrite</span> big_ord_recr /=; <span class="nb">right</span>.
- <span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr /= -ih =&gt; -[|[]//]; <span class="nb">move</span>: x; <span class="bp">exact</span>/subsetPset/ndF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_bigcup_seqD</span> <span class="nv">F</span> : \bigcup_n F n = \bigcup_n seqD F n.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; x; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>.
  <span class="nb">case</span>; <span class="nb">elim</span>=&gt; [_ F0x|n ih _ Fn1x]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">O</span>.
  <span class="nb">have</span> [|Fnx] := pselect (F n x); <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.+<span class="mi">1</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /(ih I)[m _ Fmx]; <span class="kr">exists</span> <span class="nv">m</span>.
<span class="nb">case</span>; <span class="nb">elim</span>=&gt; [_ /= F0x|n ih _ /= [Fn1x Fnx]]; <span class="bp">by</span> [<span class="kr">exists</span> <span class="nv">O</span> | <span class="kr">exists</span> <span class="nv">n</span>.+<span class="mi">1</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_bigcup_seqD_bigsetU</span> <span class="nv">F</span> :
  \bigcup_n (seqD (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \big[setU/set0]_(i &lt; n.+<span class="mi">1</span>) F i) n) = \bigcup_n F n.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -(@eq_bigcup_seqD (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \big[setU/set0]_(i &lt; n.+<span class="mi">1</span>) F i)).
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; [t [i _]|t [i _ Fit]].
  <span class="bp">by</span> <span class="nb">rewrite</span> -bigcup_set_cond =&gt; -[/= j _ Fjt]; <span class="kr">exists</span> <span class="nv">j</span>.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">rewrite</span> big_ord_recr /=; <span class="nb">right</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">seqD</span>.

<span class="sd">(************************************)</span>
<span class="c">(* Convergence of patched sequences *)</span>
<span class="sd">(************************************)</span>

<span class="kn">Section</span> <span class="nf">sequences_patched</span>.
<span class="c">(* TODO: generalizations to numDomainType *)</span>

<span class="kn">Section</span> <span class="nf">NatShift</span>.

<span class="kn">Variables</span> (<span class="nv">N</span> : nat) (<span class="nv">V</span> : topologicalType).
<span class="kn">Implicit Types</span> (<span class="nv">f</span> : nat -&gt; V) (<span class="nv">u</span> : V ^nat)  (<span class="nv">l</span> : V).

<span class="kn">Lemma</span> <span class="nf">cvg_restrict</span> <span class="nv">f</span> <span class="nv">u_</span> <span class="nv">l</span> :
  ([sequence <span class="kr">if</span> (n &lt;= N)%N <span class="kr">then</span> f n <span class="kr">else</span> u_ n]_n @ \oo --&gt; l) =
  (u_ @ \oo --&gt; l).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>; <span class="nb">apply</span>: cvg_trans; <span class="nb">apply</span>: near_eq_cvg;
<span class="bp">by</span> near <span class="kp">do</span> [<span class="nb">move</span>=&gt; /=; <span class="nb">case</span>: ifP =&gt; //; <span class="nb">rewrite</span> ltn_geF//].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_restrict</span> <span class="nv">f</span> <span class="nv">u_</span> :
  cvg ([sequence <span class="kr">if</span> (n &lt;= N)%nat <span class="kr">then</span> f n <span class="kr">else</span> u_ n]_n @ \oo) =
  cvg (u_ @ \oo).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>;
  [<span class="nb">rewrite</span> cvg_restrict|<span class="nb">rewrite</span> -(cvg_restrict f)] =&gt; /cvgP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_centern</span> <span class="nv">u_</span> <span class="nv">l</span> : ([sequence u_ (n - N)%N]_n --&gt; l) = (u_ --&gt; l).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: cvg_comp; <span class="nb">apply</span>: cvg_subnr.
<span class="nb">gen have</span> cD : u_ l / u_ --&gt; l -&gt; (<span class="kr">fun</span> <span class="nv">n</span> =&gt; u_ (n + N)%N) --&gt; l.
   <span class="bp">by</span> <span class="nb">apply</span>: cvg_comp; <span class="nb">apply</span>: cvg_addnr.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /cD /=; <span class="nb">under</span> [X <span class="kr">in</span> X --&gt; l]funext =&gt; n <span class="kp">do</span> <span class="nb">rewrite</span> addnK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_shiftn</span> <span class="nv">u_</span> <span class="nv">l</span> : ([sequence u_ (n + N)%N]_n --&gt; l) = (u_ --&gt; l).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: cvg_comp; <span class="nb">apply</span>: cvg_addnr.
<span class="nb">rewrite</span> -[X <span class="kr">in</span> X -&gt; _]cvg_centern; <span class="nb">apply</span>: cvg_trans =&gt; /=.
<span class="bp">by</span> <span class="nb">apply</span>: near_eq_cvg; near <span class="kp">do</span> <span class="nb">rewrite</span> subnK; <span class="kr">exists</span> <span class="nv">N</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">NatShift</span>.

<span class="kn">Variables</span> (<span class="nv">V</span> : topologicalType).

<span class="kn">Lemma</span> <span class="nf">cvg_shiftS</span> <span class="nv">u_</span> (<span class="nv">l</span> : V) : ([sequence u_ n.+<span class="mi">1</span>]_n --&gt; l) = (u_ --&gt; l).
<span class="kn">Proof</span>.
<span class="nb">suff</span> -&gt; : [sequence u_ n.+<span class="mi">1</span>]_n = [sequence u_(n + <span class="mi">1</span>)%N]_n <span class="bp">by</span> <span class="nb">rewrite</span> cvg_shiftn.
<span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n/=; <span class="nb">rewrite</span> addn1.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sequences_patched</span>.

<span class="kn">Section</span> <span class="nf">sequences_R_lemmas_realFieldType</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realFieldType.
<span class="kn">Implicit Types</span> <span class="nv">u</span> <span class="nv">v</span> : R ^nat.

<span class="kn">Lemma</span> <span class="nf">__deprecated__squeeze</span> <span class="nv">T</span> (<span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : T -&gt; R) (<span class="nv">a</span> : filter_on T) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near a, f x &lt;= g x &lt;= h x) -&gt; <span class="kr">forall</span> (<span class="nv">l</span> : R),
  f @ a --&gt; l -&gt; h @ a --&gt; l -&gt; g @ a --&gt; l.
<span class="kn">Proof</span>. <span class="bp">exact</span>: squeeze_cvgr. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `squeeze_cvgr`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">squeeze</span> := __deprecated__squeeze.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgPpinfty</span> (<span class="nv">u_</span> : R ^nat) :
  u_ --&gt; +oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, A &lt;= u_ n.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgryPge. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgryPge`, and generalized to any filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgPpinfty</span> := __deprecated__cvgPpinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgNpinfty</span> <span class="nv">u_</span> : (- u_ --&gt; +oo) = (u_ --&gt; -oo).
<span class="kn">Proof</span>. <span class="bp">exact</span>/propeqP/cvgNry. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use `cvgNry` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgNpinfty</span> := __deprecated__cvgNpinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgNninfty</span> <span class="nv">u_</span> : (- u_ --&gt; -oo) = (u_ --&gt; +oo).
<span class="kn">Proof</span>. <span class="bp">exact</span>/propeqP/cvgNrNy. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use `cvgNrNy` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgNninfty</span> := __deprecated__cvgNninfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgPninfty</span> (<span class="nv">u_</span> : R ^nat) :
  u_ --&gt; -oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, A &gt;= u_ n.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgrNyPle. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgrNyPle`, and generalized to any filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgPninfty</span> := __deprecated__cvgPninfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ger_cvg_pinfty</span> <span class="nv">u_</span> <span class="nv">v_</span> : (\<span class="kr">forall</span> <span class="nv">n</span> \near \oo, u_ n &lt;= v_ n) -&gt;
  u_ --&gt; +oo -&gt; v_ --&gt; +oo.
<span class="kn">Proof</span>. <span class="bp">exact</span>: ger_cvgy. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `ger_cvgy`, and generalized to any filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ger_cvg_pinfty</span> := __deprecated__ger_cvg_pinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ler_cvg_ninfty</span> <span class="nv">v_</span> <span class="nv">u_</span> : (\<span class="kr">forall</span> <span class="nv">n</span> \near \oo, u_ n &lt;= v_ n) -&gt;
  v_ --&gt; -oo -&gt; u_ --&gt; -oo.
<span class="kn">Proof</span>. <span class="bp">exact</span>: ler_cvgNy. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `ler_cvgNy`, and generalized to any filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ler_cvg_ninfty</span> := __deprecated__ler_cvg_ninfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__lim_ge</span> <span class="nv">x</span> <span class="nv">u</span> : cvg u -&gt; (\<span class="kr">forall</span> <span class="nv">n</span> \near \oo, x &lt;= u n) -&gt; x &lt;= lim u.
<span class="kn">Proof</span>. <span class="bp">exact</span>: limr_ge. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `limr_ge`, and generalized to any proper filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">lim_ge</span> := __deprecated__lim_ge.

<span class="kn">Lemma</span> <span class="nf">__deprecated__lim_le</span> <span class="nv">x</span> <span class="nv">u</span> : cvg u -&gt; (\<span class="kr">forall</span> <span class="nv">n</span> \near \oo, x &gt;= u n) -&gt; x &gt;= lim u.
<span class="kn">Proof</span>. <span class="bp">exact</span>: limr_le. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `limr_le`, and generalized to any proper filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">lim_le</span> := __deprecated__lim_le.

<span class="kn">Lemma</span> <span class="nf">lt_lim</span> <span class="nv">u</span> (<span class="nv">M</span> : R) : nondecreasing_seq u -&gt; cvg u -&gt; M &lt; lim u -&gt;
  \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, M &lt;= u n.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ndu cu Ml; <span class="nb">have</span> [[n Mun]|/forallNP Mu] := pselect (<span class="kr">exists</span> <span class="nv">n</span>, M &lt;= u n).
  near=&gt; m; <span class="nb">suff</span> : u n &lt;= u m <span class="bp">by</span> <span class="bp">exact</span>: le_trans.
  <span class="bp">by</span> near: m; <span class="kr">exists</span> <span class="nv">n</span>.+<span class="mi">1</span> =&gt; // p q; <span class="nb">apply</span>/ndu/ltnW.
<span class="nb">have</span> {}Mu : <span class="kr">forall</span> <span class="nv">x</span>, M &gt; u x <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> ltNge; <span class="nb">apply</span>/negP.
<span class="nb">have</span> : lim u &lt;= M <span class="bp">by</span> <span class="nb">apply</span>: limr_le =&gt; //; near=&gt; m; <span class="nb">apply</span>/ltW/Mu.
<span class="bp">by</span> <span class="nb">move</span>/(lt_le_trans Ml); <span class="nb">rewrite</span> ltxx.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nonincreasing_cvg_ge</span> <span class="nv">u_</span> : nonincreasing_seq u_ -&gt; cvg u_ -&gt;
  <span class="kr">forall</span> <span class="nv">n</span>, lim u_ &lt;= u_ n.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; du ul p; <span class="nb">rewrite</span> leNgt; <span class="nb">apply</span>/negP =&gt; up0.
<span class="nb">move</span>/cvgrPdist_lt : ul =&gt; /(_ `|u_ p - lim u_|%R).
<span class="nb">rewrite</span> {<span class="mi">1</span>}ltr0_norm <span class="nl">?subr_lt0</span> // opprB subr_gt0 =&gt; /(_ up0) ul.
near \oo =&gt; N.
<span class="nb">have</span> /du uNp : (p &lt;= N)%nat <span class="bp">by</span> near: N; <span class="nb">rewrite</span> nearE; <span class="kr">exists</span> <span class="nv">p</span>.
<span class="nb">have</span> : `|lim u_ - u_ N| &gt;= `|u_ p - lim u_|%R.
 <span class="nb">rewrite</span> ltr0_norm // <span class="nl">?subr_lt0</span> // opprB distrC.
 <span class="nb">rewrite</span> (@le_trans _ _ (lim u_ - u_ N)) // <span class="nl">?ler_sub</span> //.
 <span class="nb">rewrite</span> (_ : `| _ | = `|u_ N - lim u_|%R) // ler0_norm // <span class="nl">?opprB</span> //.
 <span class="bp">by</span> <span class="nb">rewrite</span> subr_le0 (le_trans _ (ltW up0)).
<span class="nb">rewrite</span> leNgt =&gt; /negP; <span class="nb">apply</span>; <span class="bp">by</span> near: N.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_cvg_le</span> <span class="nv">u_</span> : nondecreasing_seq u_ -&gt; cvg u_ -&gt;
  <span class="kr">forall</span> <span class="nv">n</span>, u_ n &lt;= lim u_.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; iu cu n; <span class="nb">move</span>: (@nonincreasing_cvg_ge (- u_)).
<span class="nb">rewrite</span> -nondecreasing_opp opprK =&gt; /(_ iu); <span class="nb">rewrite</span> is_cvgNE =&gt; /(_ cu n).
<span class="bp">by</span> <span class="nb">rewrite</span> limN // ler_oppl opprK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_has_ub</span> <span class="nv">u_</span> : cvg u_ -&gt; has_ubound [<span class="nb">set</span> `|u_ n| | n <span class="kr">in</span> setT].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvg_seq_bounded/pinfty_ex_gt0[M M_gt0 /= uM].
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">M</span>; <span class="nb">apply</span>/ubP =&gt; x -[n _ &lt;-{x}]; <span class="bp">exact</span>: uM.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_has_sup</span> <span class="nv">u_</span> : cvg u_ -&gt; has_sup (u_ @` setT).
<span class="kn">Proof</span>.
<span class="nb">move</span>/cvg_has_ub; <span class="nb">rewrite</span> -/(_ @` _) -(image_comp u_ normr setT).
<span class="bp">by</span> <span class="nb">move</span>=&gt; /has_ub_image_norm uM; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> (<span class="nv">u_</span> <span class="mi">0</span>%N), <span class="mi">0</span>%N.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_has_inf</span> <span class="nv">u_</span> : cvg u_ -&gt; has_inf (u_ @` setT).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/is_cvgN/cvg_has_sup; <span class="nb">rewrite</span> -has_inf_supN image_comp. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgPpinfty_lt</span> (<span class="nv">u_</span> : R ^nat) :
  u_ --&gt; +oo%R &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, (A &lt; u_ n)%R.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgryPgt. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgryPgt`, and generalized to any proper filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgPpinfty_lt</span> := __deprecated__cvgPpinfty_lt.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgPninfty_lt</span> (<span class="nv">u_</span> : R ^nat) :
  u_ --&gt; -oo%R &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, (A &gt; u_ n)%R.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgrNyPlt. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgrNyPlt`, and generalized to any proper filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgPninfty_lt</span> := __deprecated__cvgPninfty_lt.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgPpinfty_near</span> (<span class="nv">u_</span> : R ^nat) :
  u_ --&gt; +oo%R &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near +oo, \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, (A &lt;= u_ n)%R.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgryPgey. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgryPgey`, and generalized to any proper filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgPpinfty_near</span> := __deprecated__cvgPpinfty_near.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgPninfty_near</span> (<span class="nv">u_</span> : R ^nat) :
  u_ --&gt; -oo%R &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near -oo, \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, (A &gt;= u_ n)%R.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgrNyPleNy. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgrNyPleNy`, and generalized to any proper filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgPninfty_near</span> := __deprecated__cvgPninfty_near.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgPpinfty_lt_near</span> (<span class="nv">u_</span> : R ^nat) :
  u_ --&gt; +oo%R &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near +oo, \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, (A &lt; u_ n)%R.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgryPgty. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgryPgty`, and generalized to any proper filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgPpinfty_lt_near</span> := __deprecated__cvgPpinfty_lt_near.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvgPninfty_lt_near</span> (<span class="nv">u_</span> : R ^nat) :
  u_ --&gt; -oo%R &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near -oo, \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, (A &gt; u_ n)%R.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgrNyPltNy. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgrNyPltNy`, and generalized to any proper filter&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvgPninfty_lt_near</span> := __deprecated__cvgPninfty_lt_near.

<span class="kn">End</span> <span class="nf">sequences_R_lemmas_realFieldType</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__invr_cvg0</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">u</span> : R^nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, <span class="mi">0</span> &lt; u i) -&gt; ((u i)^-<span class="mi">1</span> @[i --&gt; \oo] --&gt; <span class="mi">0</span>) &lt;-&gt; (u --&gt; +oo).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> gtr0_cvgV0//; <span class="nb">apply</span>: nearW. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `gtr0_cvgV0` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">invr_cvg0</span> := __deprecated__invr_cvg0.

<span class="kn">Lemma</span> <span class="nf">__deprecated__invr_cvg_pinfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">u</span> : R^nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, <span class="mi">0</span> &lt; u i) -&gt; ((u i)^-<span class="mi">1</span> @[i --&gt; \oo] --&gt; +oo) &lt;-&gt; (u --&gt; <span class="mi">0</span>).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> cvgrVy//; <span class="nb">apply</span>: nearW. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgrVy` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">invr_cvg_pinfty</span> := __deprecated__invr_cvg_pinfty.

<span class="kn">Section</span> <span class="nf">partial_sum</span>.
<span class="kn">Variables</span> (<span class="nv">V</span> : zmodType) (<span class="nv">u_</span> : V ^nat).

<span class="kn">Definition</span> <span class="nf">series</span> : V ^nat := [sequence \sum_(<span class="mi">0</span> &lt;= k &lt; n) u_ k]_n.
<span class="kn">Definition</span> <span class="nf">telescope</span> : V ^nat := [sequence u_ n.+<span class="mi">1</span> - u_ n]_n.

<span class="kn">Lemma</span> <span class="nf">seriesEnat</span> : series = [sequence \sum_(<span class="mi">0</span> &lt;= k &lt; n) u_ k]_n.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">seriesEord</span> : series = [sequence \sum_(k &lt; n) u_ k]_n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> /series/= big_mkord. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">seriesSr</span> <span class="nv">n</span> : series n.+<span class="mi">1</span> = series n + u_ n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> !seriesEord/= big_ord_recr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">seriesS</span> <span class="nv">n</span> : series n.+<span class="mi">1</span> = u_ n + series n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> addrC seriesSr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">seriesSB</span> (<span class="nv">n</span> : nat) : series n.+<span class="mi">1</span> - series n = u_ n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> seriesS addrK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">series_addn</span> <span class="nv">m</span> <span class="nv">n</span> : series (n + m)%N = series m + \sum_(m &lt;= k &lt; n + m) u_ k.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> seriesEnat/= -big_cat_nat// leq_addl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_series_geq</span> <span class="nv">m</span> <span class="nv">n</span> : (m &lt;= n)%N -&gt;
  series n - series m = \sum_(m &lt;= k &lt; n) u_ k.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /subnK&lt;-; <span class="nb">rewrite</span> series_addn addrAC subrr add0r. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_series</span> <span class="nv">m</span> <span class="nv">n</span> :
  series n - series m = <span class="kr">if</span> (m &lt;= n)%N <span class="kr">then</span> \sum_(m &lt;= k &lt; n) u_ k
                        <span class="kr">else</span> - \sum_(n &lt;= k &lt; m) u_ k.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> [mn|/ltnW mn] := leqP m n; <span class="nb">rewrite</span> -sub_series_geq// opprB. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_double_series</span> <span class="nv">n</span> : series n.*<span class="mi">2</span> - series n = \sum_(n &lt;= k &lt; n.*<span class="mi">2</span>) u_ k.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> sub_series_geq// -addnn leq_addl. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">partial_sum</span>.

<span class="kn">Arguments</span> series {V} u_ n : <span class="nb">simpl</span> never.
<span class="kn">Arguments</span> telescope {V} u_ n : <span class="nb">simpl</span> never.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;series&#39; E ]_ n&quot;</span> := (series [sequence E]_n) : ring_scope.

<span class="kn">Lemma</span> <span class="nf">seriesN</span> (<span class="nv">V</span> : zmodType) (<span class="nv">f</span> : V ^nat) : series (- f) = - series f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> /series /= sumrN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">seriesD</span> (<span class="nv">V</span> : zmodType) (<span class="nv">f</span> <span class="nv">g</span> : V ^nat) : series (f + g) = series f + series g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /series /= funeqE =&gt; n; <span class="nb">rewrite</span> big_split. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">seriesZ</span> (<span class="nv">R</span> : ringType) (<span class="nv">V</span> : lmodType R) (<span class="nv">f</span> : V ^nat) <span class="nv">k</span> :
  series (k *: f) = k *: series f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> /series /= -scaler_sumr. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">partial_sum_numFieldType</span>.
<span class="kn">Variables</span> <span class="nv">V</span> : numFieldType.
<span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> : V ^nat.

<span class="kn">Lemma</span> <span class="nf">is_cvg_seriesN</span> <span class="nv">f</span> : cvg (series (- f)) = cvg (series f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> seriesN is_cvgNE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_seriesN</span> <span class="nv">f</span> : cvg (series f) -&gt; lim (series (- f)) = - lim (series f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf; <span class="nb">rewrite</span> seriesN limN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_seriesZ</span> <span class="nv">f</span> <span class="nv">k</span> : cvg (series f) -&gt; cvg (series (k *: f)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf; <span class="nb">rewrite</span> seriesZ; <span class="bp">exact</span>: is_cvgZr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_seriesZ</span> <span class="nv">f</span> <span class="nv">k</span> : cvg (series f) -&gt;
  lim (series (k *: f)) = k *: lim (series f).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf; <span class="nb">rewrite</span> seriesZ limZr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_seriesD</span> <span class="nv">f</span> <span class="nv">g</span> :
  cvg (series f) -&gt; cvg (series g) -&gt; cvg (series (f + g)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf cg; <span class="nb">rewrite</span> seriesD; <span class="bp">exact</span>: is_cvgD. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_seriesD</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (series f) -&gt; cvg (series g) -&gt;
  lim (series (f + g)) = lim (series f) + lim (series g).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf cg; <span class="nb">rewrite</span> seriesD limD. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_seriesB</span> <span class="nv">f</span> <span class="nv">g</span> :
  cvg (series f) -&gt; cvg (series g) -&gt; cvg (series (f - g)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf cg; <span class="nb">apply</span>: is_cvg_seriesD; <span class="nb">rewrite</span> <span class="nl">?is_cvg_seriesN</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_seriesB</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (series f) -&gt; cvg (series g) -&gt;
  lim (series (f - g)) = lim (series f) - lim (series g).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Cf Cg; <span class="nb">rewrite</span> lim_seriesD <span class="nl">?is_cvg_seriesN</span>// lim_seriesN. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">partial_sum_numFieldType</span>.

<span class="kn">Lemma</span> <span class="nf">lim_series_le</span> (<span class="nv">V</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : V ^nat) :
  cvg (series f) -&gt; cvg (series g) -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, f n &lt;= g n) -&gt;
  lim (series f) &lt;= lim (series g).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; cf cg fg; <span class="nb">apply</span> (ler_lim cf cg); near=&gt; x; <span class="nb">rewrite</span> ler_sum.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">telescopeK</span> (<span class="nv">V</span> : zmodType) (<span class="nv">u_</span> : V ^nat) :
  series (telescope u_) = [sequence u_ n - u_ <span class="mi">0</span>%N]_n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> seriesEnat/= telescope_sumr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">seriesK</span> (<span class="nv">V</span> : zmodType) : cancel (@series V) telescope.
<span class="kn">Proof</span>. <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>/funext/seriesSB. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_sum_telescope</span> (<span class="nv">V</span> : zmodType) (<span class="nv">u_</span> : V ^nat) <span class="nv">n</span> :
  u_ n = u_ <span class="mi">0</span>%N + series (telescope u_) n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> telescopeK/= addrC addrNK. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">series_patched</span>.
<span class="kn">Variables</span> (<span class="nv">N</span> : nat) (<span class="nv">K</span> : numFieldType) (<span class="nv">V</span> : normedModType K).
<span class="kn">Implicit Types</span> (<span class="nv">f</span> : nat -&gt; V) (<span class="nv">u</span> : V ^nat)  (<span class="nv">l</span> : V).

<span class="kn">Lemma</span> <span class="nf">is_cvg_series_restrict</span> <span class="nv">u_</span> :
  cvg [sequence \sum_(N &lt;= k &lt; n) u_ k]_n = cvg (series u_).
<span class="kn">Proof</span>.
<span class="nb">suff</span> -&gt; : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(N &lt;= k &lt; n) u_ k) =
          <span class="kr">fun</span> <span class="nv">n</span> =&gt; <span class="kr">if</span> (n &lt;= N)%N <span class="kr">then</span> \sum_(N &lt;= k &lt; n) u_ k
                   <span class="kr">else</span> series u_ n - \sum_(<span class="mi">0</span> &lt;= k &lt; N) u_ k.
  <span class="bp">by</span> <span class="nb">rewrite</span> is_cvg_restrict/= is_cvgDlE//; <span class="nb">apply</span>: is_cvg_cst.
<span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">case</span>: leqP =&gt; // ltNn; <span class="nb">apply</span>: (canRL (addrK _)).
<span class="bp">by</span> <span class="nb">rewrite</span> seriesEnat addrC -big_cat_nat// ltnW.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">series_patched</span>.

<span class="kn">Section</span> <span class="nf">sequences_R_lemmas</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_cvg</span> (<span class="nv">u_</span> : R ^nat) :
    nondecreasing_seq u_ -&gt; has_ubound (range u_) -&gt;
  u_ --&gt; sup (range u_).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; leu u_ub; <span class="nb">set</span> M := sup (range u_).
<span class="nb">have</span> su_ : has_sup (range u_) <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> (<span class="nv">u_</span> <span class="mi">0</span>%N), <span class="mi">0</span>%N.
<span class="nb">apply</span>/cvgrPdist_le =&gt; _/posnumP[e].
<span class="nb">have</span> [p /andP[Mu_p u_pM]] : <span class="kr">exists</span> <span class="nv">p</span>, M - e%:num &lt;= u_ p &lt;= M.
  <span class="nb">have</span> [_ -[p _] &lt;- /ltW Mu_p] := sup_adherent (gt0 e) su_.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">p</span>; <span class="nb">rewrite</span> Mu_p; <span class="nb">have</span> /ubP := sup_upper_bound su_; <span class="nb">apply</span>; <span class="kr">exists</span> <span class="nv">p</span>.
near=&gt; n; <span class="nb">have</span> pn : (p &lt;= n)%N <span class="bp">by</span> near: n; <span class="bp">exact</span>: nbhs_infty_ge.
<span class="nb">rewrite</span> ler_distlC (le_trans Mu_p (leu _ _ _))//= (@le_trans _ _ M) <span class="nl">?ler_addl</span>//.
<span class="bp">by</span> <span class="nb">have</span> /ubP := sup_upper_bound su_; <span class="nb">apply</span>; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_is_cvg</span> (<span class="nv">u_</span> : R ^nat) :
  nondecreasing_seq u_ -&gt; has_ubound (range u_) -&gt; cvg u_.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; u_nd u_ub; <span class="nb">apply</span>: cvgP; <span class="nb">apply</span>: nondecreasing_cvg. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_dvg_lt</span> (<span class="nv">u_</span> : R ^nat) :
  nondecreasing_seq u_ -&gt; ~ cvg u_ -&gt; u_ --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; nu du; <span class="nb">apply</span>: contrapT =&gt; /cvgryPge/existsNP[l lu]; <span class="nb">apply</span>: du.
<span class="nb">apply</span>: nondecreasing_is_cvg =&gt; //; <span class="kr">exists</span> <span class="nv">l</span> =&gt; _ [n _ &lt;-].
<span class="nb">rewrite</span> leNgt; <span class="nb">apply</span>/negP =&gt; lun; <span class="nb">apply</span>: lu; near=&gt; m.
<span class="bp">by</span> <span class="nb">rewrite</span> (le_trans (ltW lun)) //; <span class="nb">apply</span>: nu; near: m; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_nondecreasing_is_cvg</span> (<span class="nv">u_</span> : R ^nat) (<span class="nv">M</span> : R) :
    {near \oo, nondecreasing_seq u_} -&gt; (\<span class="kr">forall</span> <span class="nv">n</span> \near \oo, u_ n &lt;= M) -&gt;
  cvg u_.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [k _ u_nd] [k&#39; _ u_M]; <span class="nb">suff</span> : cvg [sequence u_ (n + maxn k k&#39;)%N]_n.
  <span class="bp">by</span> <span class="nb">case</span>/cvg_ex =&gt; /= l; <span class="nb">rewrite</span> cvg_shiftn =&gt; ul; <span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> <span class="nv">l</span>.
<span class="nb">apply</span>: nondecreasing_is_cvg; [<span class="nb">move</span>=&gt; /= m n mn|<span class="kr">exists</span> <span class="nv">M</span> =&gt; _ [n _ &lt;-]].
  <span class="bp">by</span> <span class="nb">rewrite</span> u_nd <span class="nl">?leq_add2r</span>//= (leq_trans (leq_maxl _ _) (leq_addl _ _)).
<span class="bp">by</span> <span class="nb">rewrite</span> u_M //= (leq_trans (leq_maxr _ _) (leq_addl _ _)).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nonincreasing_cvg</span> (<span class="nv">u_</span> : R ^nat) :
    nonincreasing_seq u_ -&gt; has_lbound (range u_) -&gt;
  u_ --&gt; inf (u_ @` setT).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -nondecreasing_opp =&gt; u_nd u_lb; <span class="nb">rewrite</span> -[X <span class="kr">in</span> X --&gt; _](opprK u_).
<span class="nb">apply</span>: cvgN; <span class="nb">rewrite</span> image_comp; <span class="nb">apply</span>: nondecreasing_cvg =&gt; //.
<span class="bp">by</span> <span class="nb">move</span>/has_lb_ubN : u_lb; <span class="nb">rewrite</span> image_comp.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nonincreasing_is_cvg</span> (<span class="nv">u_</span> : R ^nat) :
  nonincreasing_seq u_ -&gt; has_lbound (range u_) -&gt; cvg u_.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; u_decr u_bnd; <span class="nb">apply</span>: cvgP; <span class="nb">apply</span>: nonincreasing_cvg. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_nonincreasing_is_cvg</span> (<span class="nv">u_</span> : R ^nat) (<span class="nv">m</span> : R) :
    {near \oo, nonincreasing_seq u_} -&gt; (\<span class="kr">forall</span> <span class="nv">n</span> \near \oo, m &lt;= u_ n) -&gt;
  cvg u_.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_ni u_m.
<span class="nb">rewrite</span> -(opprK u_); <span class="nb">apply</span>: is_cvgN; <span class="nb">apply</span>/(@near_nondecreasing_is_cvg _ (- m)).
- <span class="bp">by</span> <span class="nb">apply</span>: filterS u_ni =&gt; x u_x y xy; <span class="nb">rewrite</span> ler_oppl opprK u_x.
- <span class="bp">by</span> <span class="nb">apply</span>: filterS u_m =&gt; x u_x; <span class="nb">rewrite</span> ler_oppl opprK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">adjacent</span> (<span class="nv">u_</span> <span class="nv">v_</span> : R ^nat) : nondecreasing_seq u_ -&gt; nonincreasing_seq v_ -&gt;
  (v_ - u_) --&gt; (<span class="mi">0</span> : R) -&gt; [/\ lim v_ = lim u_, cvg u_ &amp; cvg v_].
<span class="kn">Proof</span>.
<span class="nb">set</span> w_ := v_ - u_ =&gt; iu dv w0; <span class="nb">have</span> vu n : v_ n &gt;= u_ n.
  <span class="nb">suff</span> : lim w_ &lt;= w_ n <span class="bp">by</span> <span class="nb">rewrite</span> (cvg_lim _ w0)// subr_ge0.
  <span class="nb">apply</span>: (nonincreasing_cvg_ge _ (cvgP _ w0)) =&gt; m p mp.
  <span class="bp">by</span> <span class="nb">rewrite</span> ler_sub; <span class="nb">rewrite</span> <span class="nl">?iu</span> <span class="nl">?dv</span>.
<span class="nb">have</span> cu : cvg u_.
  <span class="nb">apply</span>: nondecreasing_is_cvg =&gt; //; <span class="kr">exists</span> (<span class="nv">v_</span> <span class="mi">0</span>%N) =&gt; _ [n _ &lt;-].
  <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans (vu _)) // dv.
<span class="nb">have</span> cv : cvg v_.
  <span class="nb">apply</span>: nonincreasing_is_cvg =&gt; //; <span class="kr">exists</span> (<span class="nv">u_</span> <span class="mi">0</span>%N) =&gt; _ [n _ &lt;-].
  <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans _ (vu _)) // iu.
<span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> -subr_eq0 -limB //; <span class="bp">exact</span>/eqP/cvg_lim.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sequences_R_lemmas</span>.

<span class="kn">Definition</span> <span class="nf">harmonic</span> {<span class="nv">R</span> : fieldType} : R ^nat := [sequence n.+<span class="mi">1</span>%:R^-<span class="mi">1</span>]_n.
<span class="kn">Arguments</span> harmonic {R} n /.

<span class="kn">Lemma</span> <span class="nf">harmonic_gt0</span> {<span class="nv">R</span> : numFieldType} <span class="nv">i</span> : <span class="mi">0</span> &lt; harmonic i :&gt; R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /=. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">harmonic_ge0</span> {<span class="nv">R</span> : numFieldType} <span class="nv">i</span> : <span class="mi">0</span> &lt;= harmonic i :&gt; R.
<span class="kn">Proof</span>. <span class="bp">exact</span>/ltW/harmonic_gt0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_harmonic</span> {<span class="nv">R</span> : archiFieldType} : harmonic --&gt; (<span class="mi">0</span> : R).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/cvgrPdist_le =&gt; _/posnumP[e]; near=&gt; i.
<span class="nb">rewrite</span> distrC subr0 ger0_norm//= -lef_pinv <span class="nl">?qualifE</span>// invrK.
<span class="nb">rewrite</span> (le_trans (ltW (archi_boundP _)))// ler_nat -add1n -leq_subLR.
<span class="bp">by</span> near: i; <span class="nb">apply</span>: nbhs_infty_ge.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dvg_harmonic</span> (<span class="nv">R</span> : numFieldType) : ~ cvg (series (@harmonic R)).
<span class="kn">Proof</span>.
<span class="nb">have</span> ge_half n : (<span class="mi">0</span> &lt; n)%N -&gt; <span class="mi">2</span>^-<span class="mi">1</span> &lt;= \sum_(n &lt;= i &lt; n.*<span class="mi">2</span>) harmonic i.
  <span class="nb">case</span>: n =&gt; // n _.
  <span class="nb">rewrite</span> (@le_trans _ _ (\sum_(n.+<span class="mi">1</span> &lt;= i &lt; n.+<span class="mi">1</span>.*<span class="mi">2</span>) n.+<span class="mi">1</span>.*<span class="mi">2</span>%:R^-<span class="mi">1</span>)) //=.
    <span class="nb">rewrite</span> sumr_const_nat -addnn addnK addnn -mul2n natrM invfM.
    <span class="bp">by</span> <span class="nb">rewrite</span> -[_ *+ n.+<span class="mi">1</span>]mulr_natr divfK.
  <span class="bp">by</span> <span class="nb">apply</span>: ler_sum_nat =&gt; i /andP[? ?]; <span class="nb">rewrite</span> lef_pinv <span class="nl">?qualifE</span> <span class="nl">?ler_nat</span>.
<span class="nb">move</span>/cvg_cauchy/cauchy_ballP =&gt; /(_ _ [gt0 of <span class="mi">2</span>^-<span class="mi">1</span> : R]); <span class="nb">rewrite</span> !near_map2.
<span class="nb">rewrite</span> -ball_normE =&gt; /nearP_dep hcvg; near \oo =&gt; n; near \oo =&gt; m.
<span class="nb">have</span>: `|series harmonic n - series harmonic m| &lt; <span class="mi">2</span>^-<span class="mi">1</span> :&gt; R <span class="bp">by</span> near: m; near: n.
<span class="nb">rewrite</span> le_gtF// distrC -[X <span class="kr">in</span> X - _](addrNK (series harmonic n.*<span class="mi">2</span>)).
<span class="nb">rewrite</span> sub_series_geq; <span class="nb">last</span> <span class="bp">by</span> near: m; <span class="nb">apply</span>: nbhs_infty_ge.
<span class="nb">rewrite</span> -addrA sub_series_geq -addnn <span class="nl">?leq_addr</span>// addnn.
<span class="nb">have</span> sh_ge0 i j : <span class="mi">0</span> &lt;= \sum_(i &lt;= k &lt; j) harmonic k :&gt; R.
  <span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?sumr_ge0</span>//; <span class="nb">move</span>=&gt; k _; <span class="nb">apply</span>: harmonic_ge0.
<span class="bp">by</span> <span class="nb">rewrite</span> ger0_norm// ler_paddl// ge_half//; near: n.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">arithmetic_mean</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">u_</span> : R ^nat) : R ^nat :=
  [sequence n.+<span class="mi">1</span>%:R^-<span class="mi">1</span> * (series u_ n.+<span class="mi">1</span>)]_n.

<span class="kn">Definition</span> <span class="nf">harmonic_mean</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">u_</span> : R ^nat) : R ^nat :=
  <span class="kr">let</span> <span class="nv">v</span> := [sequence (u_ n)^-<span class="mi">1</span>]_n <span class="kr">in</span>
  [sequence (n.+<span class="mi">1</span>%:R / series v n.+<span class="mi">1</span>)]_n.

<span class="kn">Definition</span> <span class="nf">root_mean_square</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> : R ^nat) : R ^nat :=
  <span class="kr">let</span> <span class="nv">v_</span> := [sequence (u_ k)^+<span class="mi">2</span>]_k <span class="kr">in</span>
  [sequence Num.sqrt (n.+<span class="mi">1</span>%:R^-<span class="mi">1</span> * series v_ n.+<span class="mi">1</span>)]_n.

<span class="kn">Section</span> <span class="nf">cesaro</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : archiFieldType.

<span class="kn">Theorem</span> <span class="nf">cesaro</span> (<span class="nv">u_</span> : R ^nat) (<span class="nv">l</span> : R) : u_ --&gt; l -&gt; arithmetic_mean u_ --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u0_cvg; <span class="nb">have</span> ssplit v_ m n : (m &lt;= n)%N -&gt; `|n%:R^-<span class="mi">1</span> * series v_ n| &lt;=
    n%:R^-<span class="mi">1</span> * `|series v_ m| + n%:R^-<span class="mi">1</span> * `|\sum_(m &lt;= i &lt; n) v_ i|.
  <span class="nb">move</span>=&gt; /subnK&lt;-; <span class="nb">rewrite</span> series_addn mulrDr (le_trans (ler_norm_add _ _))//.
  <span class="bp">by</span> <span class="nb">rewrite</span> !normrM ger0_norm.
<span class="nb">apply</span>/cvgrPdist_lt=&gt; _/posnumP[e]; near \oo =&gt; m; near=&gt; n.
<span class="nb">have</span> {}/ssplit -/(_ _ [sequence l - u_ n]_n) : (m.+<span class="mi">1</span> &lt;= n.+<span class="mi">1</span>)%nat.
  <span class="bp">by</span> near: n; <span class="kr">exists</span> <span class="nv">m</span>.
<span class="nb">rewrite</span> !seriesEnat /= big_split/=.
<span class="nb">rewrite</span> sumrN mulrBr sumr_const_nat -(mulr_natl l) mulKf//.
<span class="nb">move</span>=&gt; /le_lt_trans-&gt;//; <span class="nb">rewrite</span> [e%:num]splitr ltr_add//.
  <span class="nb">have</span> [-&gt;|neq0] := eqVneq (\sum_(<span class="mi">0</span> &lt;= k &lt; m.+<span class="mi">1</span>) (l - u_ k)) <span class="mi">0</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> normr0 mulr0.
  <span class="nb">rewrite</span> -ltr_pdivl_mulr <span class="nl">?normr_gt0</span>//.
  <span class="nb">rewrite</span> -ltf_pinv <span class="nl">?qualifE</span>// <span class="nl">?mulr_gt0</span> <span class="nl">?invr_gt0</span> <span class="nl">?normr_gt0</span>// invrK.
  <span class="nb">rewrite</span> (lt_le_trans (archi_boundP _))// ler_nat leqW//.
  <span class="bp">by</span> near: n; <span class="nb">apply</span>: nbhs_infty_ge.
<span class="nb">rewrite</span> ltr_pdivr_mull <span class="nl">?ltr0n</span> // (le_lt_trans (ler_norm_sum _ _ _)) //.
<span class="nb">rewrite</span> (le_lt_trans (@ler_sum_nat _ _ _ _ (<span class="kr">fun</span> <span class="nv">i</span> =&gt; e%:num / <span class="mi">2</span>) _))//; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> sumr_const_nat mulr_natl ltr_pmuln2l// ltn_subrL.
<span class="nb">move</span>=&gt; i /andP[mi _]; <span class="nb">move</span>: i mi; near: m.
<span class="nb">have</span> : \<span class="kr">forall</span> <span class="nv">x</span> \near \oo, `|l - u_ x| &lt; e%:num / <span class="mi">2</span>.
  <span class="bp">by</span> <span class="nb">move</span>/cvgrPdist_lt : u0_cvg; <span class="nb">apply</span>.
<span class="nb">move</span>=&gt; -[N _ Nu]; <span class="kr">exists</span> <span class="nv">N</span> =&gt; // k Nk i ki.
<span class="bp">by</span> <span class="nb">rewrite</span> ltW// Nu//= (leq_trans Nk)// ltnW.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cesaro</span>.

<span class="kn">Section</span> <span class="nf">cesaro_converse</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : archiFieldType.

<span class="kn">Let</span> <span class="nf">cesaro_converse_off_by_one</span> (<span class="nv">u_</span> : R ^nat) :
  [sequence n.+<span class="mi">1</span>%:R^-<span class="mi">1</span> * series u_ n.+<span class="mi">1</span>]_ n --&gt; (<span class="mi">0</span> : R) -&gt;
  [sequence n.+<span class="mi">1</span>%:R^-<span class="mi">1</span> * series u_ n]_ n --&gt; (<span class="mi">0</span> : R).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; H; <span class="nb">apply</span>/cvgrPdist_lt =&gt; _/posnumP[e].
<span class="nb">move</span>/cvgrPdist_lt : H =&gt; /(_ _ (gt0 e)) -[m _ mu].
near=&gt; n; <span class="nb">rewrite</span> sub0r normrN /=.
<span class="nb">have</span> /andP[n0] : ((<span class="mi">0</span> &lt; n) &amp;&amp; (m &lt;= n.-<span class="mi">1</span>))%N.
  near: n; <span class="kr">exists</span> <span class="nv">m</span>.+<span class="mi">1</span> =&gt; // k mk; <span class="nb">rewrite</span> (leq_trans _ mk) //=.
  <span class="bp">by</span> <span class="nb">rewrite</span> -(leq_add2r <span class="mi">1</span>%N) !addn1 prednK // (leq_trans _ mk).
<span class="nb">move</span>/mu =&gt; {mu}; <span class="nb">rewrite</span> sub0r normrN /= prednK //; <span class="nb">apply</span>: le_lt_trans.
<span class="nb">rewrite</span> !normrM ler_wpmul2r // ger0_norm // ger0_norm //.
<span class="bp">by</span> <span class="nb">rewrite</span> lef_pinv // <span class="nl">?ler_nat</span> // posrE // ltr0n.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cesaro_converse</span> (<span class="nv">u_</span> : R ^nat) (<span class="nv">l</span> : R) :
  telescope u_ =o_\oo harmonic -&gt; arithmetic_mean u_ --&gt; l -&gt; u_ --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">pose</span> a_ := telescope u_ =&gt; a_o u_l.
<span class="nb">suff</span> abel : <span class="kr">forall</span> <span class="nv">n</span>,
    u_ n - arithmetic_mean u_ n = \sum_(<span class="mi">1</span> &lt;= k &lt; n.+<span class="mi">1</span>) k%:R / n.+<span class="mi">1</span>%:R * a_ k.-<span class="mi">1</span>.
  <span class="nb">suff</span> K : u_ - arithmetic_mean u_ --&gt; (<span class="mi">0</span> : R).
    <span class="nb">rewrite</span> -(add0r l).
    <span class="nb">rewrite</span> (_ : u_ = u_ - arithmetic_mean u_ + arithmetic_mean u_); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> subrK.
    <span class="bp">exact</span>: cvgD.
  <span class="nb">rewrite</span> (_ : _ - arithmetic_mean u_ =
      (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">1</span> &lt;= k &lt; n.+<span class="mi">1</span>) k%:R / n.+<span class="mi">1</span>%:R * a_ k.-<span class="mi">1</span>)); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> funeqE.
  <span class="nb">rewrite</span> {abel} /= (_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) =
      <span class="kr">fun</span> <span class="nv">n</span> =&gt; n.+<span class="mi">1</span>%:R^-<span class="mi">1</span> * \sum_(<span class="mi">0</span> &lt;= k &lt; n) k.+<span class="mi">1</span>%:R * a_ k); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> big_add1 /= /= big_distrr /=.
    <span class="bp">by</span> <span class="nb">apply</span> eq_bigr =&gt; i _; <span class="nb">rewrite</span> mulrCA mulrA.
  <span class="nb">have</span> {}a_o : [sequence n.+<span class="mi">1</span>%:R * telescope u_ n]_n --&gt; (<span class="mi">0</span> : R).
    <span class="nb">apply</span>: (@eqolim0 _ _ _ eventually_filterType).
    <span class="nb">rewrite</span> a_o.
    <span class="nb">set</span> h := &#39;o_[filter of \oo] harmonic.
    <span class="nb">apply</span>/eqoP =&gt; _/posnumP[e] /=.
    near=&gt; n; <span class="nb">rewrite</span> normr1 mulr1 normrM -ler_pdivl_mull// <span class="nl">?normr_gt0</span>//.
    <span class="nb">rewrite</span> mulrC -normrV <span class="nl">?unitfE</span> //.
    near: n.
    <span class="bp">by</span> <span class="nb">case</span>: (eqoP eventually_filterType harmonic h) =&gt; Hh _; <span class="nb">apply</span> Hh.
  <span class="nb">move</span>: (cesaro a_o); <span class="nb">rewrite</span> /arithmetic_mean /series /= -/a_.
  <span class="bp">exact</span>: (@cesaro_converse_off_by_one (<span class="kr">fun</span> <span class="nv">k</span> =&gt; k.+<span class="mi">1</span>%:R * a_ k)).
<span class="nb">case</span> =&gt; [|n].
  <span class="nb">rewrite</span> /arithmetic_mean/= invr1 mul1r !seriesEnat/=.
  <span class="bp">by</span> <span class="nb">rewrite</span> big_nat1 subrr big_geq.
<span class="nb">rewrite</span> /arithmetic_mean /= seriesEnat /= big_nat_recl //=.
<span class="nb">under</span> eq_bigr <span class="kp">do</span> <span class="nb">rewrite</span> eq_sum_telescope.
<span class="nb">rewrite</span> big_split /= big_const_nat iter_addr addr0 addrA -mulrS mulrDr.
<span class="nb">rewrite</span> -(mulr_natl (u_ O)) mulrA mulVr <span class="nl">?unitfE</span> <span class="nl">?pnatr_eq0</span> // mul1r opprD addrA.
<span class="nb">rewrite</span> eq_sum_telescope (addrC (u_ O)) addrK.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ - _ * X](_ : _ =
    \sum_(<span class="mi">0</span> &lt;= i &lt; n.+<span class="mi">1</span>) \sum_(<span class="mi">0</span> &lt;= k &lt; n.+<span class="mi">1</span> | (k &lt; i.+<span class="mi">1</span>)%N) a_ k); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> !big_mkord; <span class="nb">apply</span> eq_bigr =&gt; i _.
  <span class="bp">by</span> <span class="nb">rewrite</span> seriesEord/= big_mkord -big_ord_widen//.
<span class="nb">rewrite</span> (exchange_big_dep_nat xpredT) //=.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ - _ * X](_ : _ =
    \sum_(<span class="mi">0</span> &lt;= i &lt; n.+<span class="mi">1</span>) \sum_(i &lt;= j &lt; n.+<span class="mi">1</span>) a_ i ); <span class="nb">last first</span>.
  <span class="nb">apply</span> congr_big_nat =&gt; //= i ni.
  <span class="nb">rewrite</span> big_const_nat iter_addr addr0 -big_filter.
  <span class="nb">rewrite</span> big_const_seq iter_addr addr0; <span class="nb">congr</span> (_ *+ _).
  <span class="nb">rewrite</span> /index_iota subn0 -[<span class="kr">in</span> LHS](subnKC (ltnW ni)) iotaD filter_cat.
  <span class="nb">rewrite</span> count_cat (_ : [seq _ &lt;- _ | _] = [::]); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> -(filter_pred0 (iota <span class="mi">0</span> i)); <span class="nb">apply</span> eq_in_filter =&gt; j.
    <span class="bp">by</span> <span class="nb">rewrite</span> mem_iota leq0n andTb add0n =&gt; ji; <span class="nb">rewrite</span> ltnNge ji.
  <span class="nb">rewrite</span> <span class="mi">2</span>!add0n (_ : [seq _ &lt;- _ | _] = iota i (n.+<span class="mi">1</span> - i)); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> -[RHS]filter_predT; <span class="nb">apply</span> eq_in_filter =&gt; j.
    <span class="nb">rewrite</span> mem_iota =&gt; /andP[ij]; <span class="nb">rewrite</span> subnKC; <span class="nb">last</span> <span class="bp">exact</span>/ltnW.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; jn; <span class="nb">rewrite</span> ltnS ij.
  <span class="bp">by</span> <span class="nb">rewrite</span> count_predT size_iota.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ - _ * X](_ : _ =
    \sum_(<span class="mi">0</span> &lt;= i &lt; n.+<span class="mi">1</span>) a_ i * (n.+<span class="mi">1</span> - i)%:R); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span> eq_bigr =&gt; i _; <span class="nb">rewrite</span> big_const_nat iter_addr addr0 mulr_natr.
<span class="nb">rewrite</span> big_distrr /= big_mkord (big_morph _ (@opprD _) (@oppr0 _)).
<span class="nb">rewrite</span> seriesEord -big_split /= big_add1 /= big_mkord; <span class="nb">apply</span> eq_bigr =&gt; i _.
<span class="nb">rewrite</span> mulrCA -[X <span class="kr">in</span> X - _]mulr1 -mulrBr [RHS]mulrC; <span class="nb">congr</span> (_ * _).
<span class="nb">rewrite</span> -[X <span class="kr">in</span> X - _](@divrr _ (n.+<span class="mi">2</span>)%:R) <span class="nl">?unitfE</span> <span class="nl">?pnatr_eq0</span> //.
<span class="nb">rewrite</span> [<span class="kr">in</span> X <span class="kr">in</span> _ - X]mulrC -mulrBl; <span class="nb">congr</span> (_ / _).
<span class="nb">rewrite</span> -natrB; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> (@leq_trans n.+<span class="mi">1</span>) // leq_subr.
<span class="nb">rewrite</span> subnBA; <span class="bp">by</span> [<span class="nb">rewrite</span> addSnnS addnC addnK | <span class="nb">rewrite</span> ltnW].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cesaro_converse</span>.

<span class="kn">Section</span> <span class="nf">series_convergence</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_series_cvg_0</span> (<span class="nv">K</span> : numFieldType) (<span class="nv">V</span> : normedModType K) (<span class="nv">u_</span> : V ^nat) :
  cvg (series u_) -&gt; u_ --&gt; (<span class="mi">0</span> : V).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cvg_series.
<span class="nb">rewrite</span> (_ : u_ = <span class="kr">fun</span> <span class="nv">n</span> =&gt; series u_ n.+<span class="mi">1</span> - series u_ n); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; i; <span class="nb">rewrite</span> seriesSB.
<span class="bp">by</span> <span class="nb">rewrite</span> -(subrr (lim (series u_))); <span class="nb">apply</span>: cvgB =&gt; //; <span class="nb">rewrite</span> <span class="nl">?cvg_shiftS</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_series</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">u_</span> : R ^nat) (<span class="nv">P</span> : pred nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; <span class="mi">0</span> &lt;= u_ n)%R -&gt;
  nondecreasing_seq (<span class="kr">fun</span> <span class="nv">n</span>=&gt; \sum_(<span class="mi">0</span> &lt;= k &lt; n | P k) u_ k)%R.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_ge0; <span class="nb">apply</span>/nondecreasing_seqP =&gt; n.
<span class="nb">rewrite</span> [<span class="kr">in</span> leRHS]big_mkcond [<span class="kr">in</span> leRHS]big_nat_recr//=.
<span class="bp">by</span> <span class="nb">rewrite</span> -[<span class="kr">in</span> leRHS]big_mkcond/= ler_addl; <span class="nb">case</span>: ifPn =&gt; //; <span class="bp">exact</span>: u_ge0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">increasing_series</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">u_</span> : R ^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, <span class="mi">0</span> &lt; u_ n) -&gt; increasing_seq (series u_).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_ge0; <span class="nb">apply</span>/increasing_seqP =&gt; n.
<span class="bp">by</span> <span class="nb">rewrite</span> !seriesEord/= big_ord_recr ltr_addl.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">series_convergence</span>.

<span class="kn">Definition</span> <span class="nf">arithmetic</span> (<span class="nv">R</span> : zmodType) <span class="nv">a</span> <span class="nv">z</span> : R ^nat := [sequence a + z *+ n]_n.
<span class="kn">Arguments</span> arithmetic {R} a z n /.

<span class="kn">Lemma</span> <span class="nf">mulrn_arithmetic</span> (<span class="nv">R</span> : zmodType) : @GRing.natmul R = arithmetic <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeq2E =&gt; z n /=; <span class="nb">rewrite</span> add0r. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">geometric</span> (<span class="nv">R</span> : fieldType) <span class="nv">a</span> <span class="nv">z</span> : R ^nat := [sequence a * z ^+ n]_n.
<span class="kn">Arguments</span> geometric {R} a z n /.

<span class="kn">Lemma</span> <span class="nf">exprn_geometric</span> (<span class="nv">R</span> : fieldType) : (@GRing.exp R) = geometric <span class="mi">1</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeq2E =&gt; z n /=; <span class="nb">rewrite</span> mul1r. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_arithmetic</span> (<span class="nv">R</span> : archiFieldType) <span class="nv">a</span> (<span class="nv">z</span> : R) :
  z &gt; <span class="mi">0</span> -&gt; arithmetic a z --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; z_gt0; <span class="nb">apply</span>/cvgryPge =&gt; A; near=&gt; n =&gt; /=.
<span class="nb">rewrite</span> -ler_subl_addl -mulr_natl -ler_pdivr_mulr//.
<span class="nb">rewrite</span> ler_normlW// ltW// (lt_le_trans (archi_boundP _))// ler_nat.
<span class="bp">by</span> near: n; <span class="nb">apply</span>: nbhs_infty_ge.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_expr</span> (<span class="nv">R</span> : archiFieldType) (<span class="nv">z</span> : R) :
  `|z| &lt; <span class="mi">1</span> -&gt; (GRing.exp z : R ^nat) --&gt; (<span class="mi">0</span> : R).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Nz_lt1; <span class="nb">apply</span>/norm_cvg0P; <span class="nb">pose</span> t := (<span class="mi">1</span> - `|z|).
<span class="nb">apply</span>: (@squeeze_cvgr _ _ _ _ (cst <span class="mi">0</span>) _ (t^-<span class="mi">1</span> *: @harmonic R)); <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
- <span class="bp">exact</span>: cvg_cst.
- <span class="bp">by</span> <span class="nb">rewrite</span> -(scaler0 _ t^-<span class="mi">1</span>); <span class="bp">exact</span>: (cvgZr cvg_harmonic).
near=&gt; n; <span class="nb">rewrite</span> normr_ge0 normrX/= ler_pdivl_mull <span class="nl">?subr_gt0</span>//.
<span class="nb">rewrite</span> -(@ler_pmul2l _ n.+<span class="mi">1</span>%:R)// mulfV// [t * _]mulrC mulr_natl.
<span class="nb">have</span> -&gt; : <span class="mi">1</span> = (`|z| + t) ^+ n.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> addrC addrNK expr1n.
<span class="nb">rewrite</span> exprDn (bigD1 (inord <span class="mi">1</span>)) <span class="nl">?inordK</span>// subn1 expr1 bin1 ler_addl sumr_ge0//.
<span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">rewrite</span> ?(mulrn_wge0, mulr_ge0, exprn_ge0, subr_ge0)// ltW.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">geometric_seriesE</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">a</span> <span class="nv">z</span> : R) : z != <span class="mi">1</span> -&gt;
  series (geometric a z) = [sequence a * (<span class="mi">1</span> - z ^+ n) / (<span class="mi">1</span> - z)]_n.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; z_neq1 n.
<span class="nb">apply</span>: (@mulIf _ (<span class="mi">1</span> - z)); <span class="nb">rewrite</span> <span class="nl">?mulfVK</span> <span class="nl">?subr_eq0</span> <span class="mi">1</span><span class="nl">?eq_sym</span>//.
<span class="nb">rewrite</span> seriesEnat !mulrBr [<span class="kr">in</span> LHS]mulr1 mulr_suml -opprB -sumrB.
<span class="bp">by</span> <span class="nb">under</span> eq_bigr <span class="kp">do</span> <span class="nb">rewrite</span> -mulrA -exprSr; <span class="nb">rewrite</span> telescope_sumr// opprB.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_geometric_series</span> (<span class="nv">R</span> : archiFieldType) (<span class="nv">a</span> <span class="nv">z</span> : R) : `|z| &lt; <span class="mi">1</span> -&gt;
  series (geometric a z) --&gt; (a * (<span class="mi">1</span> - z)^-<span class="mi">1</span>).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Nz_lt1; <span class="nb">rewrite</span> geometric_seriesE <span class="nl">?lt_eqF</span> <span class="mi">1</span><span class="nl">?ltr_normlW</span>//.
<span class="nb">have</span> -&gt; : a / (<span class="mi">1</span> - z) = (a * (<span class="mi">1</span> - <span class="mi">0</span>)) / (<span class="mi">1</span> - z) <span class="bp">by</span> <span class="nb">rewrite</span> subr0 mulr1.
<span class="bp">by</span> <span class="nb">apply</span>: cvgMl; <span class="nb">apply</span>: cvgMr; <span class="nb">apply</span>: cvgB; [<span class="nb">apply</span>: cvg_cst|<span class="nb">apply</span>: cvg_expr].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_geometric_series_half</span> (<span class="nv">R</span> : archiFieldType) (<span class="nv">r</span> : R) <span class="nv">n</span> :
  series (<span class="kr">fun</span> <span class="nv">k</span> =&gt; r / (<span class="mi">2</span> ^ (k + n.+<span class="mi">1</span>))%:R : R^o) --&gt; (r / <span class="mi">2</span> ^+ n : R^o).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (_ : series _ = series (geometric (r / (<span class="mi">2</span> ^ n.+<span class="mi">1</span>)%:R) <span class="mi">2</span>^-<span class="mi">1</span>%R)); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> funeqE =&gt; m; <span class="nb">rewrite</span> /series /=; <span class="nb">apply</span> eq_bigr =&gt; k _.
  <span class="bp">by</span> <span class="nb">rewrite</span> expnD natrM (mulrC (<span class="mi">2</span> ^ k)%:R) invfM exprVn (natrX _ <span class="mi">2</span> k) mulrA.
<span class="nb">apply</span>: cvg_trans.
  <span class="nb">apply</span>: cvg_geometric_series.
  <span class="bp">by</span> <span class="nb">rewrite</span> ger0_norm // invr_lt1 // <span class="nl">?ltr1n</span> // unitfE.
<span class="nb">rewrite</span> [X <span class="kr">in</span> (X - _)%R](splitr <span class="mi">1</span>) div1r addrK.
<span class="bp">by</span> <span class="nb">rewrite</span> -mulrA -invfM expnSr natrM -mulrA divff// mulr1 natrX.
<span class="kn">Qed</span>.
<span class="kn">Arguments</span> cvg_geometric_series_half {R} _ _.

<span class="kn">Lemma</span> <span class="nf">cvg_geometric</span> (<span class="nv">R</span> : archiFieldType) (<span class="nv">a</span> <span class="nv">z</span> : R) : `|z| &lt; <span class="mi">1</span> -&gt;
  geometric a z --&gt; (<span class="mi">0</span> : R).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvg_geometric_series/cvgP/cvg_series_cvg_0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_geometric_series</span> (<span class="nv">R</span> : archiFieldType) (<span class="nv">a</span> <span class="nv">z</span> : R) : `|z| &lt; <span class="mi">1</span> -&gt;
 cvg (series (geometric a z)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvg_geometric_series/cvgP; <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">normed_series_of</span> (<span class="nv">K</span> : numDomainType) (<span class="nv">V</span> : normedModType K)
    (<span class="nv">u_</span> : V ^nat) <span class="nv">of</span> <span class="nv">phantom</span> <span class="nv">V</span>^nat (series u_) : K ^nat :=
  [series `|u_ n|]_n.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;normed&#39; s_ ]&quot;</span> := (@normed_series_of _ _ _ (Phantom _ s_)) : ring_scope.
<span class="kn">Arguments</span> normed_series_of {K V} u_ _ n /.

<span class="kn">Lemma</span> <span class="nf">ger0_normed</span> {<span class="nv">K</span> : numFieldType} (<span class="nv">u_</span> : K ^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, <span class="mi">0</span> &lt;= u_ n) -&gt; [normed series u_] = series u_.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; u_gt0; <span class="nb">rewrite</span> funeqE =&gt; n /=; <span class="nb">apply</span>: eq_bigr =&gt; k; <span class="nb">rewrite</span> ger0_norm.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cauchy_seriesP</span> {<span class="nv">R</span> : numFieldType} (<span class="nv">V</span> : normedModType R) (<span class="nv">u_</span> : V ^nat) :
  cauchy (series u_ @ \oo) &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">e</span> : R, e &gt; <span class="mi">0</span> -&gt;
    \<span class="kr">forall</span> <span class="nv">n</span> \near (\oo, \oo), `|\sum_(n.<span class="mi">1</span> &lt;= k &lt; n.<span class="mi">2</span>) u_ k| &lt; e.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> -cauchy_ballP; <span class="nb">split</span>=&gt; su_cv _/posnumP[e];
<span class="nb">have</span> {}su_cv := !! su_cv _ (gt0 e);
<span class="nb">rewrite</span> -near2_pair -ball_normE !near_simpl/= <span class="kr">in</span> su_cv *.
  <span class="nb">apply</span>: filterS su_cv =&gt; -[/= m n]; <span class="nb">rewrite</span> distrC sub_series.
  <span class="bp">by</span> <span class="nb">have</span> [|/ltnW]:= leqP m n =&gt; mn//; <span class="nb">rewrite</span> (big_geq mn) <span class="nl">?normr0</span>.
<span class="nb">have</span> := su_cv; <span class="nb">rewrite</span> near_swap =&gt; su_cvC; near=&gt; m =&gt; /=; <span class="nb">rewrite</span> sub_series.
<span class="bp">by</span> <span class="nb">have</span> [|/ltnW]:= leqP m.<span class="mi">2</span> m.<span class="mi">1</span> =&gt; m12; <span class="nb">rewrite</span> <span class="nl">?normrN</span>; near: m.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">series_le_cvg</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> <span class="nv">v_</span> : R ^nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, <span class="mi">0</span> &lt;= u_ n) -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, <span class="mi">0</span> &lt;= v_ n) -&gt;
  (<span class="kr">forall</span> <span class="nv">n</span>, u_ n &lt;= v_ n) -&gt;
  cvg (series v_) -&gt; cvg (series u_).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_ge0 v_ge0 le_uv /cvg_seq_bounded/bounded_fun_has_ubound[M v_M].
<span class="nb">apply</span>: nondecreasing_is_cvg; <span class="kp">first</span> <span class="bp">exact</span>: nondecreasing_series.
<span class="kr">exists</span> <span class="nv">M</span> =&gt; _ [n _ &lt;-].
<span class="bp">by</span> <span class="nb">apply</span>: le_trans (v_M (series v_ n) _); [<span class="nb">apply</span>: ler_sum | <span class="kr">exists</span> <span class="nv">n</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">normed_cvg</span> {<span class="nv">R</span> : realType} (<span class="nv">V</span> : completeNormedModType R) (<span class="nv">u_</span> : V ^nat) :
  cvg [normed series u_] -&gt; cvg (series u_).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cauchy_cvgP/cauchy_seriesP u_ncvg.
<span class="nb">apply</span>/cauchy_cvgP/cauchy_seriesP =&gt; e /u_ncvg.
<span class="nb">apply</span>: filterS =&gt; n /=; <span class="nb">rewrite</span> ger0_norm <span class="nl">?sumr_ge0</span>//.
<span class="bp">by</span> <span class="nb">apply</span>: le_lt_trans; <span class="nb">apply</span>: ler_norm_sum.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_series_norm</span> {<span class="nv">R</span> : realType} (<span class="nv">V</span> : completeNormedModType R) (<span class="nv">f</span> : V ^nat) :
  cvg [normed series f] -&gt; `|lim (series f)| &lt;= lim [normed series f].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cnf; <span class="nb">have</span> cf := normed_cvg cnf.
<span class="nb">rewrite</span> -lim_norm // (ler_lim (is_cvg_norm cf) cnf) //.
<span class="bp">by</span> near=&gt; x; <span class="nb">rewrite</span> ler_norm_sum.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">series_linear</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_series_bounded</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> : R ^nat) :
  cvg (series f) -&gt; bounded_fun f.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>/cvg_series_cvg_0 =&gt; f0; <span class="nb">apply</span>/cvg_seq_bounded/cvg_ex; <span class="kr">exists</span> <span class="mi">0</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_to_0_linear</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> : R -&gt; R) <span class="nv">K</span> <span class="nv">k</span> :
  <span class="mi">0</span> &lt; k -&gt; (<span class="kr">forall</span> <span class="nv">r</span>, <span class="mi">0</span> &lt; `| r | &lt; k -&gt; `|f r| &lt;= K * `| r |) -&gt;
    f x @[x --&gt; <span class="mi">0</span>^&#39;] --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; k0 kfK; <span class="nb">have</span> [K0|K0] := lerP K <span class="mi">0</span>.
- <span class="nb">apply</span>/cvgrPdist_lt =&gt; _/posnumP[e]; near=&gt; x.
  <span class="nb">rewrite</span> distrC subr0 (le_lt_trans (kfK _ _)) //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> (@le_lt_trans _ _ <span class="mi">0</span>)// mulr_le0_ge0.
  near: x; <span class="kr">exists</span> (<span class="nv">k</span> / <span class="mi">2</span>); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /mkset divr_gt0.
  <span class="nb">move</span>=&gt; t /=; <span class="nb">rewrite</span> distrC subr0 =&gt; tk2 t0.
  <span class="bp">by</span> <span class="nb">rewrite</span> normr_gt0 t0 (lt_trans tk2) // -[<span class="kr">in</span> ltLHS](add0r k) midf_lt.
- <span class="nb">apply</span>/eqolim0/eqoP =&gt; _/posnumP[e]; near=&gt; x.
  <span class="nb">rewrite</span> (le_trans (kfK _ _)) //=.
  + near: x; <span class="kr">exists</span> (<span class="nv">k</span> / <span class="mi">2</span>); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /mkset divr_gt0.
    <span class="nb">move</span>=&gt; t /=; <span class="nb">rewrite</span> distrC subr0 =&gt; tk2 t0.
    <span class="bp">by</span> <span class="nb">rewrite</span> normr_gt0 t0 (lt_trans tk2) // -[<span class="kr">in</span> ltLHS](add0r k) midf_lt.
  + <span class="nb">rewrite</span> normr1 mulr1 mulrC -ler_pdivl_mulr //.
    near: x; <span class="kr">exists</span> (<span class="nv">e</span>%:num / K); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /mkset divr_gt0.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; t /=; <span class="nb">rewrite</span> distrC subr0 =&gt; /ltW.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_cvg_to_0_linear</span> (<span class="nv">R</span> : realType) (<span class="nv">f</span> : nat -&gt; R) (<span class="nv">g</span> : R -&gt; nat -&gt; R) <span class="nv">k</span> :
  <span class="mi">0</span> &lt; k -&gt; cvg (series f) -&gt;
  (<span class="kr">forall</span> <span class="nv">r</span>, <span class="mi">0</span> &lt; `|r| &lt; k -&gt; <span class="kr">forall</span> <span class="nv">n</span>, `|g r n| &lt;= f n * `| r |) -&gt;
  lim (series (g x)) @[x --&gt; <span class="mi">0</span>^&#39;] --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; k_gt0 Cf Hg.
<span class="nb">apply</span>: (@cvg_to_0_linear _ _ (lim (series f)) k) =&gt; // h hLk; <span class="nb">rewrite</span> mulrC.
<span class="nb">have</span> Ckf := @is_cvg_seriesZ _ _ `|h| Cf.
<span class="nb">have</span> Cng : cvg [normed series (g h)].
  <span class="nb">apply</span>: series_le_cvg (Hg _ hLk) _ =&gt; [//|?|].
    <span class="bp">exact</span>: le_trans (Hg _ hLk _).
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> mulrC.
<span class="nb">apply</span>: (le_trans (lim_series_norm Cng)).
<span class="nb">rewrite</span> -[_ * _](lim_seriesZ _ Cf) (lim_series_le Cng Ckf) // =&gt; n.
<span class="bp">by</span> <span class="nb">rewrite</span> [leRHS]mulrC; <span class="nb">apply</span>: Hg.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">series_linear</span>.

<span class="kn">Section</span> <span class="nf">exponential_series</span>.

<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> <span class="nv">x</span> : R.

<span class="kn">Definition</span> <span class="nf">exp_coeff</span> <span class="nv">x</span> := [sequence x ^+ n / n`!%:R]_n.

<span class="kn">Local Notation</span> <span class="nf">exp</span> := exp_coeff.

<span class="kn">Lemma</span> <span class="nf">exp_coeff_ge0</span> <span class="nv">x</span> <span class="nv">n</span> : <span class="mi">0</span> &lt;= x -&gt; <span class="mi">0</span> &lt;= exp x n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; x0; <span class="nb">rewrite</span> /exp divr_ge0 // exprn_ge0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">series_exp_coeff0</span> <span class="nv">n</span> : series (exp <span class="mi">0</span>) n.+<span class="mi">1</span> = <span class="mi">1</span>.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /series /= big_mkord big_ord_recl /= /exp /= expr0n divr1.
<span class="bp">by</span> <span class="nb">rewrite</span> big1 <span class="nl">?addr0</span> // =&gt; i _; <span class="nb">rewrite</span> expr0n mul0r.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">exponential_series_cvg</span>.

<span class="kn">Variable</span> <span class="nv">x</span> : R.
<span class="kn">Hypothesis</span> <span class="nv">x0</span> : <span class="mi">0</span> &lt; x.

<span class="kn">Let</span> <span class="nf">S0</span> <span class="nv">N</span> <span class="nv">n</span> := (N ^ N)%:R * \sum_(N.+<span class="mi">1</span> &lt;= i &lt; n) (x / N%:R) ^+ i.

<span class="kn">Let</span> <span class="nf">is_cvg_S0</span> <span class="nv">N</span> : x &lt; N%:R -&gt; cvg (S0 N).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; xN; <span class="nb">apply</span>: is_cvgZr; <span class="nb">rewrite</span> is_cvg_series_restrict exprn_geometric.
<span class="nb">apply</span>/is_cvg_geometric_series; <span class="nb">rewrite</span> normrM normfV.
<span class="bp">by</span> <span class="nb">rewrite</span> ltr_pdivr_mulr <span class="nl">?mul1r</span> !ger0_norm // <span class="mi">1</span><span class="nl">?ltW</span> // (lt_trans x0).
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">S0_ge0</span> <span class="nv">N</span> <span class="nv">n</span> : <span class="mi">0</span> &lt;= S0 N n.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> mulr_ge0 // <span class="nl">?ler0n</span> //; <span class="nb">apply</span> sumr_ge0 =&gt; i _.
<span class="bp">by</span> <span class="nb">rewrite</span> exprn_ge0 // divr_ge0 // ltW.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">S0_sup</span> <span class="nv">N</span> <span class="nv">n</span> : x &lt; N%:R -&gt; S0 N n &lt;= sup (range (S0 N)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; xN; <span class="nb">apply</span>/sup_upper_bound; [<span class="nb">split</span>; [<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">S0</span> <span class="nv">N</span> <span class="nv">n</span>), n|]|<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>].
<span class="nb">rewrite</span> (_ : (range _) = [<span class="nb">set</span> `|S0 N n0| | n0 <span class="kr">in</span> setT]).
  <span class="bp">by</span> <span class="nb">apply</span>: cvg_has_ub (is_cvg_S0 xN).
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE=&gt; y; <span class="nb">split</span>=&gt; -[z _ &lt;-]; <span class="kr">exists</span> <span class="nv">z</span>; <span class="nb">rewrite</span> <span class="nl">?ger0_norm</span> <span class="nl">?S0_ge0</span>.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">S1</span> <span class="nv">N</span> <span class="nv">n</span> := \sum_(N.+<span class="mi">1</span> &lt;= i &lt; n) exp x i.

<span class="kn">Lemma</span> <span class="nf">incr_S1</span> <span class="nv">N</span> : nondecreasing_seq (S1 N).
<span class="kn">Proof</span>.
<span class="nb">apply</span>/nondecreasing_seqP =&gt; n; <span class="nb">rewrite</span> /S1.
<span class="nb">have</span> [nN|Nn] := leqP n N; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> !big_geq // (leq_trans nN).
<span class="bp">by</span> <span class="nb">rewrite</span> big_nat_recr//= ler_addl exp_coeff_ge0 // ltW.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">S1_sup</span> <span class="nv">N</span> : x &lt; N%:R -&gt; ubound (range (S1 N)) (sup (range (S0 N))).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; xN _ [n _ &lt;-]; <span class="nb">rewrite</span> (le_trans _ (S0_sup n xN)) // /S0 big_distrr /=.
<span class="nb">have</span> N_gt0 := lt_trans x0 xN; <span class="nb">apply</span> ler_sum =&gt; i _.
<span class="nb">have</span> [Ni|iN] := ltnP N i; <span class="nb">last first</span>.
  <span class="nb">rewrite</span> expr_div_n mulrCA ler_pmul2l <span class="nl">?exprn_gt0</span>// (@le_trans _ _ <span class="mi">1</span>) //.
    <span class="bp">by</span> <span class="nb">rewrite</span> invf_le1// <span class="nl">?ler1n</span> <span class="nl">?ltr0n</span> // fact_gt0.
  <span class="nb">rewrite</span> natrX -expfB_cond ?(negPf (lt0r_neq0 N_gt0))//.
  <span class="bp">by</span> <span class="nb">rewrite</span> exprn_ege1 // ler1n; <span class="nb">case</span>: (N) xN x0; <span class="nb">case</span>: ltrgt0P.
<span class="nb">rewrite</span> /exp expr_div_n /= (fact_split Ni) mulrCA ler_pmul2l <span class="nl">?exprn_gt0</span>// natrX.
<span class="nb">rewrite</span> -invf_div -expfB // lef_pinv <span class="nl">?qualifE</span> <span class="nl">?exprn_gt0</span>//; <span class="nb">last first</span>.
  <span class="nb">rewrite</span> ltr0n muln_gt0 fact_gt0/= big_seq big_mkcond/= prodn_gt0// =&gt; j.
  <span class="bp">by</span> <span class="nb">case</span>: ifPn=&gt;//; <span class="nb">rewrite</span> mem_index_iota =&gt; /andP[+ _]; <span class="bp">exact</span>: leq_ltn_trans.
<span class="nb">rewrite</span> big_nat_rev/= -natrX ler_nat -prod_nat_const_nat big_add1 /= big_ltn //.
<span class="nb">rewrite</span> leq_mul//; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (fact_geq _))// leq_pmull.
<span class="nb">under</span> [<span class="kr">in</span> X <span class="kr">in</span> (_ &lt;= X)%N]eq_bigr <span class="kp">do</span> <span class="nb">rewrite</span> <span class="mi">2</span>!addSn <span class="mi">2</span>!subSS.
<span class="nb">rewrite</span> !big_seq/=; <span class="nb">elim</span>/big_ind2 : _ =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="bp">exact</span>: leq_mul.
<span class="nb">move</span>=&gt; j; <span class="nb">rewrite</span> mem_index_iota =&gt; /andP[_ ji].
<span class="bp">by</span> <span class="nb">rewrite</span> -addnBA// <span class="nl">?leq_addr</span>// ltnW// ltnW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_series_exp_coeff_pos</span> : cvg (series (exp x)).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /series; near \oo =&gt; N; <span class="nb">have</span> xN : x &lt; N%:R; <span class="nb">last first</span>.
  <span class="nb">rewrite</span> -(@is_cvg_series_restrict N.+<span class="mi">1</span>).
  <span class="bp">by</span> <span class="nb">apply</span>: (nondecreasing_is_cvg (incr_S1 N)); <span class="nb">eexists</span>; <span class="nb">apply</span>: S1_sup.
near: N; <span class="kr">exists</span> (<span class="nv">absz</span> (floor x)).+<span class="mi">1</span> =&gt; // m; <span class="nb">rewrite</span> /mkset -(@ler_nat R).
<span class="nb">move</span>/lt_le_trans =&gt; -&gt; //; <span class="nb">rewrite</span> (lt_le_trans (lt_succ_floor x)) // -addn1.
<span class="bp">by</span> <span class="nb">rewrite</span> natrD ler_add2r -(@gez0_abs (floor x)) <span class="nl">?floor_ge0</span>// ltW.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">exponential_series_cvg</span>.

<span class="kn">Lemma</span> <span class="nf">normed_series_exp_coeff</span> <span class="nv">x</span> : [normed series (exp x)] = series (exp `|x|).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; n /=; <span class="nb">apply</span>: eq_bigr =&gt; k _.
<span class="bp">by</span> <span class="nb">rewrite</span> /exp normrM normfV normrX [`|_%:R|]@ger0_norm.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_series_exp_coeff</span> <span class="nv">x</span> : cvg (series (exp x)).
<span class="kn">Proof</span>.
<span class="nb">have</span> [-&gt;|x0] := eqVneq x <span class="mi">0</span>.
  <span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> <span class="mi">1</span>; <span class="nb">apply</span>/cvgrPdist_lt =&gt; // =&gt; _/posnumP[e].
  near=&gt; n; <span class="nb">have</span> [m -&gt;] : <span class="kr">exists</span> <span class="nv">m</span>, n = m.+<span class="mi">1</span>.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.-<span class="mi">1</span>; <span class="nb">rewrite</span> prednK //; near: n; <span class="kr">exists</span> <span class="mi">1</span>%N.
  <span class="bp">by</span> <span class="nb">rewrite</span> series_exp_coeff0 subrr normr0.
<span class="nb">apply</span>: normed_cvg; <span class="nb">rewrite</span> normed_series_exp_coeff.
<span class="bp">by</span> <span class="nb">apply</span>: is_cvg_series_exp_coeff_pos; <span class="nb">rewrite</span> normr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_exp_coeff</span> <span class="nv">x</span> : exp x --&gt; (<span class="mi">0</span> : R).
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvg_series_cvg_0 (@is_cvg_series_exp_coeff x)). <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">exponential_series</span>.

<span class="c">(* TODO: generalize *)</span>
<span class="kn">Definition</span> <span class="nf">expR</span> {<span class="nv">R</span> : realType} (<span class="nv">x</span> : R) : R := lim (series (exp_coeff x)).

<span class="sd">(********************************)</span>
<span class="c">(* Sequences of natural numbers *)</span>
<span class="sd">(********************************)</span>

<span class="kn">Lemma</span> <span class="nf">__deprecated__nat_dvg_real</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> : nat ^nat) : u_ --&gt; \oo -&gt;
  ([sequence (u_ n)%:R : R^o]_n --&gt; +oo)%R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>/cvgrnyP. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgrnyP` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">nat_dvg_real</span> := __deprecated__nat_dvg_real.

<span class="kn">Lemma</span> <span class="nf">__deprecated__nat_cvgPpinfty</span> (<span class="nv">u</span> : nat^nat) :
  u --&gt; \oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, (A &lt;= u n)%N.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgnyPge. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
      note=<span class="s2">&quot;renamed to `cvgnyPge` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">nat_cvgPpinfty</span>:= __deprecated__nat_cvgPpinfty.

<span class="kn">Lemma</span> <span class="nf">nat_nondecreasing_is_cvg</span> (<span class="nv">u_</span> : nat^nat) :
  nondecreasing_seq u_ -&gt; has_ubound (range u_) -&gt; cvg u_.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_nd [l ul].
<span class="nb">suff</span> [N Nu] : <span class="kr">exists</span> <span class="nv">N</span>, <span class="kr">forall</span> <span class="nv">n</span>, (n &gt;= N)%N -&gt; u_ n = u_ N.
  <span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> (<span class="nv">u_</span> <span class="nv">N</span>); <span class="nb">rewrite</span> -(cvg_shiftn N).
  <span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ = cst (u_ N))//; <span class="kp">first</span> <span class="bp">exact</span>: cvg_cst.
  <span class="bp">by</span> <span class="nb">apply</span>/funext =&gt; n /=; <span class="nb">rewrite</span> Nu// leq_addl.
<span class="nb">apply</span>/not_existsP =&gt; hu.
<span class="nb">have</span> {hu}/choice[f Hf] : <span class="kr">forall</span> <span class="nv">x</span>, (<span class="kr">exists</span> <span class="nv">n</span>, x &lt;= n /\ u_ n &gt; u_ x)%N.
  <span class="nb">move</span>=&gt; x; <span class="nb">have</span> /existsNP[N /not_implyP[xN Nx]] := hu x.
  <span class="kr">exists</span> <span class="nv">N</span>; <span class="nb">split</span> =&gt; //; <span class="nb">move</span>/eqP : Nx; <span class="nb">rewrite</span> neq_lt =&gt; /orP[|//].
  <span class="bp">by</span> <span class="nb">move</span>/u_nd : xN; <span class="nb">rewrite</span> le_eqVlt =&gt; /predU1P[-&gt;|//].
<span class="nb">have</span> uf : <span class="kr">forall</span> <span class="nv">x</span>, (x &lt; u_ (iter x.+<span class="mi">1</span> f O))%N.
  <span class="nb">elim</span>=&gt; /= [|i ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">have</span> := Hf O =&gt; -[_]; <span class="bp">exact</span>: leq_trans.
  <span class="bp">by</span> <span class="nb">have</span> := Hf (f (iter i f O)) =&gt; -[_]; <span class="bp">exact</span>: leq_trans.
<span class="nb">have</span> /ul : range u_ (u_ (iter l.+<span class="mi">1</span> f O)) <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">iter</span> <span class="nv">l</span>.+<span class="mi">1</span> f O).
<span class="bp">by</span> <span class="nb">rewrite</span> leNgt =&gt; /negP; <span class="nb">apply</span>; <span class="nb">rewrite</span> ltEnat //=; <span class="bp">exact</span>: uf.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">nseries</span> (<span class="nv">u</span> : nat^nat) := (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= k &lt; n) u k)%N.

<span class="kn">Lemma</span> <span class="nf">le_nseries</span> (<span class="nv">u</span> : nat^nat) : {homo nseries u : a b / a &lt;= b}%N.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; a b ab; <span class="nb">rewrite</span> /nseries [<span class="kr">in</span> X <span class="kr">in</span> (_ &lt;= X)%N]/index_iota subn0.
<span class="nb">rewrite</span> -[<span class="kr">in</span> X <span class="kr">in</span> (_ &lt;= X)%N](subnKC ab) iotaD big_cat/= add0n.
<span class="bp">by</span> <span class="nb">rewrite</span> /index_iota subn0 leq_addr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_nseries_near</span> (<span class="nv">u</span> : nat^nat) : cvg (nseries u) -&gt;
  \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, u n = <span class="mi">0</span>%N.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvg_ex[l ul]; <span class="nb">have</span> /ul[a _ aul] : nbhs l [<span class="nb">set</span> l].
  <span class="bp">by</span> <span class="kr">exists</span> [<span class="nb">set</span> l]; <span class="nb">split</span>=&gt; //; <span class="kr">exists</span> [<span class="nb">set</span> l] =&gt; //; <span class="nb">rewrite</span> bigcup_set1.
<span class="nb">have</span> /ul[b _ bul] : nbhs l [<span class="nb">set</span> l.-<span class="mi">1</span>; l].
  <span class="bp">by</span> <span class="kr">exists</span> [<span class="nb">set</span> l]; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> [<span class="nb">set</span> l] =&gt; //; <span class="nb">rewrite</span> bigcup_set1.
<span class="kr">exists</span> (<span class="nv">maxn</span> <span class="nv">a</span> <span class="nv">b</span>) =&gt; // n /= abn.
<span class="nb">rewrite</span> (_ : u = <span class="kr">fun</span> <span class="nv">n</span> =&gt; nseries u n.+<span class="mi">1</span> - nseries u n)%N; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; i; <span class="nb">rewrite</span> /nseries big_nat_recr//= addnC addnK.
<span class="nb">have</span> /aul -&gt; : (a &lt;= n)%N <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans _ abn) // leq_max leqnn.
<span class="nb">have</span> /bul[-&gt;|-&gt;] : (b &lt;= n.+<span class="mi">1</span>)%N <span class="bp">by</span> <span class="nb">rewrite</span> leqW// (leq_trans _ abn)// leq_maxr.
- <span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> subn_eq0// leq_pred.
- <span class="bp">by</span> <span class="nb">rewrite</span> subnn.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dvg_nseries</span> (<span class="nv">u</span> : nat^nat) : ~ cvg (nseries u) -&gt; nseries u --&gt; \oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; du; <span class="nb">apply</span>: contrapT =&gt; /cvgnyPgt/existsNP[l lu]; <span class="nb">apply</span>: du.
<span class="nb">apply</span>: nat_nondecreasing_is_cvg =&gt; //; <span class="kp">first</span> <span class="bp">exact</span>: le_nseries.
<span class="kr">exists</span> <span class="nv">l</span> =&gt; _ [n _ &lt;-]; <span class="nb">rewrite</span> leNgt; <span class="nb">apply</span>/negP =&gt; lun; <span class="nb">apply</span>: lu.
<span class="bp">by</span> near <span class="kp">do</span> <span class="nb">rewrite</span> (leq_trans lun) <span class="nl">?le_nseries</span>//; <span class="nb">apply</span>: nbhs_infty_ge.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="sd">(**************************************)</span>
<span class="c">(* Sequences of extended real numbers *)</span>
<span class="sd">(**************************************)</span>

<span class="kn">Notation</span> <span class="s2">&quot;\big [ op / idx ]_ ( m &lt;= i &lt;oo | P ) F&quot;</span> :=
  (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (\big[ op / idx ]_(m &lt;= i &lt; n | P) F))) : big_scope.
<span class="kn">Notation</span> <span class="s2">&quot;\big [ op / idx ]_ ( m &lt;= i &lt;oo ) F&quot;</span> :=
  (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (\big[ op / idx ]_(m &lt;= i &lt; n) F))) : big_scope.
<span class="kn">Notation</span> <span class="s2">&quot;\big [ op / idx ]_ ( i &lt;oo | P ) F&quot;</span> :=
  (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (\big[ op / idx ]_(i &lt; n | P) F))) : big_scope.
<span class="kn">Notation</span> <span class="s2">&quot;\big [ op / idx ]_ ( i &lt;oo ) F&quot;</span> :=
  (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (\big[ op / idx ]_(i &lt; n) F))) : big_scope.

<span class="kn">Notation</span> <span class="s2">&quot;\sum_ ( m &lt;= i &lt;oo | P ) F&quot;</span> :=
  (\big[+%E/<span class="mi">0</span>%E]_(m &lt;= i &lt;oo | P%B) F%E) : ereal_scope.
<span class="kn">Notation</span> <span class="s2">&quot;\sum_ ( m &lt;= i &lt;oo ) F&quot;</span> :=
  (\big[+%E/<span class="mi">0</span>%E]_(m &lt;= i &lt;oo) F%E) : ereal_scope.
<span class="kn">Notation</span> <span class="s2">&quot;\sum_ ( i &lt;oo | P ) F&quot;</span> :=
  (\big[+%E/<span class="mi">0</span>%E]_(<span class="mi">0</span> &lt;= i &lt;oo | P%B) F%E) : ereal_scope.
<span class="kn">Notation</span> <span class="s2">&quot;\sum_ ( i &lt;oo ) F&quot;</span> :=
  (\big[+%E/<span class="mi">0</span>%E]_(<span class="mi">0</span> &lt;= i &lt;oo) F%E) : ereal_scope.

<span class="kn">Section</span> <span class="nf">partial_esum</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Variables</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">u_</span> : (\bar R)^nat).

<span class="kn">Definition</span> <span class="nf">eseries</span> : (\bar R)^nat := [sequence \sum_(<span class="mi">0</span> &lt;= k &lt; n) u_ k]_n.
<span class="kn">Definition</span> <span class="nf">etelescope</span> : (\bar R)^nat := [sequence u_ n.+<span class="mi">1</span> - u_ n]_n.

<span class="kn">Lemma</span> <span class="nf">eseriesEnat</span> : eseries = [sequence \sum_(<span class="mi">0</span> &lt;= k &lt; n) u_ k]_n.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eseriesEord</span> : eseries = [sequence \sum_(k &lt; n) u_ k]_n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> /eseries/= big_mkord. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eseriesSr</span> <span class="nv">n</span> : eseries n.+<span class="mi">1</span> = eseries n + u_ n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> !eseriesEord/= big_ord_recr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eseriesS</span> <span class="nv">n</span> : eseries n.+<span class="mi">1</span> = u_ n + eseries n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> addeC eseriesSr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eseriesSB</span> (<span class="nv">n</span> : nat) :
  eseries n \<span class="kr">is</span> a fin_num -&gt; eseries n.+<span class="mi">1</span> - eseries n = u_ n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; enfin; <span class="nb">rewrite</span> eseriesS addeK//=. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eseries_addn</span> <span class="nv">m</span> <span class="nv">n</span> : eseries (n + m)%N = eseries m + \sum_(m &lt;= k &lt; n + m) u_ k.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> eseriesEnat/= -big_cat_nat// leq_addl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_eseries_geq</span> <span class="nv">m</span> <span class="nv">n</span> : (m &lt;= n)%N -&gt; eseries m \<span class="kr">is</span> a fin_num -&gt;
  eseries n - eseries m = \sum_(m &lt;= k &lt; n) u_ k.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /subnK&lt;- emfin; <span class="nb">rewrite</span> eseries_addn addeAC subee// add0e. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_eseries</span> <span class="nv">m</span> <span class="nv">n</span> : eseries m \<span class="kr">is</span> a fin_num -&gt; eseries n \<span class="kr">is</span> a fin_num -&gt;
  eseries n - eseries m = <span class="kr">if</span> (m &lt;= n)%N <span class="kr">then</span> \sum_(m &lt;= k &lt; n) u_ k
                        <span class="kr">else</span> - \sum_(n &lt;= k &lt; m) u_ k.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ? ?; <span class="nb">have</span> [mn|/ltnW mn] := leqP m n; <span class="nb">rewrite</span> -sub_eseries_geq//.
<span class="bp">by</span> <span class="nb">rewrite</span> fin_num_oppeD <span class="nl">?fin_numN</span>// oppeK addeC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_double_eseries</span> <span class="nv">n</span> : eseries n \<span class="kr">is</span> a fin_num -&gt;
  eseries n.*<span class="mi">2</span> - eseries n = \sum_(n &lt;= k &lt; n.*<span class="mi">2</span>) u_ k.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; enfin; <span class="nb">rewrite</span> sub_eseries_geq// -addnn leq_addl. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">partial_esum</span>.

<span class="kn">Arguments</span> eseries {R} u_ n : <span class="nb">simpl</span> never.
<span class="kn">Arguments</span> etelescope {R} u_ n : <span class="nb">simpl</span> never.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;series&#39; E ]_ n&quot;</span> := (eseries [sequence E%E]_n) : ereal_scope.

<span class="kn">Section</span> <span class="nf">eseries_ops</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : numDomainType).
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">eseriesD</span> (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) : eseries (f \+ g) = eseries f \+ eseries g.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /eseries /= funeqE =&gt; n; <span class="nb">rewrite</span> big_split. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">eseries_ops</span>.

<span class="kn">Section</span> <span class="nf">sequences_ereal_realDomainType</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Variable</span> <span class="nv">T</span> : realDomainType.
<span class="kn">Implicit Types</span> <span class="nv">u</span> : (\bar T)^nat.

<span class="kn">Lemma</span> <span class="nf">ereal_nondecreasing_opp</span> <span class="nv">u_</span> :
  nondecreasing_seq (-%E \o u_) = nonincreasing_seq u_.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; ni_u m n mn; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> lee_oppr oppeK ni_u.
<span class="bp">by</span> <span class="nb">rewrite</span> -(oppeK (u_ m)) -lee_oppr ni_u.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sequences_ereal_realDomainType</span>.

<span class="kn">Section</span> <span class="nf">sequences_ereal</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvg_abs0</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> : (\bar R)^nat) :
  abse \o f --&gt; nbhs <span class="mi">0</span> -&gt; f --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/cvg_abse0P. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvg_abse0P` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvg_abs0</span> := __deprecated__ereal_cvg_abs0.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvg_ge0</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> : (\bar R)^nat) (<span class="nv">a</span> : \bar R) :
  (<span class="kr">forall</span> <span class="nv">n</span>, <span class="mi">0</span> &lt;= f n) -&gt; f --&gt; a -&gt; <span class="mi">0</span> &lt;= a.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f_ge0; <span class="nb">apply</span>: cvge_ge; <span class="nb">apply</span>: nearW. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;use `cvge_ge` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvg_ge0</span> := __deprecated__ereal_cvg_ge0.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_lim_ge</span> (<span class="nv">R</span> : realFieldType) <span class="nv">x</span> (<span class="nv">u_</span> : (\bar R)^nat) : cvg u_ -&gt;
  (\<span class="kr">forall</span> <span class="nv">n</span> \near \oo, x &lt;= u_ n) -&gt; x &lt;= lim u_.
<span class="kn">Proof</span>. <span class="bp">exact</span>: lime_ge. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `lime_ge` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_lim_ge</span> := __deprecated__ereal_lim_ge.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_lim_le</span> (<span class="nv">R</span> : realFieldType) <span class="nv">x</span> (<span class="nv">u_</span> : (\bar R)^nat) : cvg u_ -&gt;
  (\<span class="kr">forall</span> <span class="nv">n</span> \near \oo, u_ n &lt;= x) -&gt; lim u_ &lt;= x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: lime_le. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `lime_le` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_lim_le</span> := __deprecated__ereal_lim_le.

<span class="kn">Lemma</span> <span class="nf">__deprecated__dvg_ereal_cvg</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">u_</span> : R ^nat) :
  u_ --&gt; +oo%R -&gt; [sequence (u_ n)%:E]_n --&gt; +oo.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeryP. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgeryP` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">dvg_ereal_cvg</span> := __deprecated__dvg_ereal_cvg.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvg_real</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> : (\bar R)^nat) <span class="nv">a</span> :
  {near \oo, <span class="kr">forall</span> <span class="nv">x</span>, f x \<span class="kr">is</span> a fin_num} /\
  (fine \o f --&gt; a) &lt;-&gt; f --&gt; a%:E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> fine_cvgP. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `fine_cvgP` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvg_real</span> := __deprecated__ereal_cvg_real.

<span class="kn">Lemma</span> <span class="nf">ereal_nondecreasing_cvg</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> : (\bar R)^nat) :
  nondecreasing_seq u_ -&gt; u_ --&gt; ereal_sup (u_ @` setT).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; nd_u_; <span class="nb">set</span> S := u_ @` setT; <span class="nb">set</span> l := ereal_sup S.
<span class="nb">have</span> [Spoo|Spoo] := pselect (S +oo).
  <span class="nb">have</span> [N Nu] : <span class="kr">exists</span> <span class="nv">N</span>, <span class="kr">forall</span> <span class="nv">n</span>, (n &gt;= N)%nat -&gt; u_ n = +oo.
    <span class="nb">case</span>: Spoo =&gt; N _ uNoo; <span class="kr">exists</span> <span class="nv">N</span> =&gt; n Nn.
    <span class="bp">by</span> <span class="nb">move</span>: (nd_u_ _ _ Nn); <span class="nb">rewrite</span> uNoo leye_eq =&gt; /eqP.
  <span class="nb">have</span> -&gt; : l = +oo <span class="bp">by</span> <span class="nb">rewrite</span> /l /ereal_sup; <span class="bp">exact</span>: supremum_pinfty.
  <span class="nb">rewrite</span> -(cvg_shiftn N); <span class="nb">set</span> f := (X <span class="kr">in</span> X --&gt; _).
  <span class="nb">rewrite</span> (_ : f = (<span class="kr">fun</span>=&gt; +oo)); <span class="kp">first</span> <span class="bp">exact</span>: cvg_cst.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> /f /= Nu // leq_addl.
<span class="nb">have</span> [Snoo|Snoo] := pselect (u_ = <span class="kr">fun</span>=&gt; -oo).
  <span class="nb">rewrite</span> /l (_ : S = [<span class="nb">set</span> -oo]); <span class="nb">last first</span>.
    <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; [-[n _ &lt;-]|-&gt;]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> Snoo.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">O</span> =&gt; //; <span class="nb">rewrite</span> Snoo.
  <span class="bp">by</span> <span class="nb">rewrite</span> ereal_sup1 Snoo; <span class="bp">exact</span>: cvg_cst.
<span class="nb">have</span> [/ereal_sup_ninfty loo|lnoo] := eqVneq l -oo.
  <span class="nb">suff</span> : u_ = (<span class="kr">fun</span>=&gt; -oo) <span class="bp">by</span> [].
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; m; <span class="nb">apply</span> (loo (u_ m)); <span class="kr">exists</span> <span class="nv">m</span>.
<span class="nb">apply</span>/cvg_ballP =&gt; _/posnumP[e].
<span class="nb">have</span> [{lnoo}loo|lpoo] := eqVneq l +oo.
  near=&gt; n; <span class="nb">rewrite</span> /ball /= /ereal_ball.
  <span class="nb">have</span> unoo : u_ n != -oo.
    near: n; <span class="nb">have</span> [m /eqP umoo] : <span class="kr">exists</span> <span class="nv">m</span>, u_ m &lt;&gt; -oo.
      <span class="nb">apply</span>/existsNP =&gt; uoo.
      <span class="bp">by</span> <span class="nb">apply</span>/Snoo; <span class="nb">rewrite</span> funeqE =&gt; ?; <span class="nb">rewrite</span> uoo.
    <span class="kr">exists</span> <span class="nv">m</span> =&gt; // k mk; <span class="nb">apply</span>: contra umoo =&gt; /eqP ukoo.
    <span class="bp">by</span> <span class="nb">move</span>/nd_u_ : mk; <span class="nb">rewrite</span> ukoo leeNy_eq.
  <span class="nb">rewrite</span> loo ger0_norm <span class="nl">?subr_ge0</span>; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">case</span>/ler_normlP : (contract_le1 (u_ n)).
  <span class="nb">have</span> [e2|e2] := lerP <span class="mi">2</span> e%:num.
    <span class="nb">rewrite</span> /= ltr_subl_addr addrC -ltr_subl_addr.
    <span class="nb">case</span>/ler_normlP : (contract_le1 (u_ n)); <span class="nb">rewrite</span> ler_oppl =&gt; un1 _.
    <span class="nb">rewrite</span> (@le_lt_trans _ _ (-<span class="mi">1</span>)) //.
      <span class="bp">by</span> <span class="nb">rewrite</span> ler_subl_addr addrC -ler_subl_addr opprK (le_trans e2).
    <span class="bp">by</span> <span class="nb">move</span>: un1; <span class="nb">rewrite</span> le_eqVlt eq_sym contract_eqN1 (negbTE unoo).
  <span class="nb">rewrite</span> ltr_subl_addr addrC -ltr_subl_addr -lt_expandLR <span class="nl">?inE</span>//=.
    near: n.
    <span class="nb">suff</span> [n Hn] : <span class="kr">exists</span> <span class="nv">n</span>, expand (contract +oo - e%:num)%R &lt; u_ n.
      <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; // m nm; <span class="nb">rewrite</span> (lt_le_trans Hn) //; <span class="nb">apply</span> nd_u_.
    <span class="nb">apply</span>/not_existsP =&gt; abs.
    <span class="nb">have</span> : l &lt;= expand (contract +oo - e%:num)%R.
      <span class="nb">apply</span>: ub_ereal_sup =&gt; x [n _ &lt;-{x}].
      <span class="nb">rewrite</span> leNgt; <span class="nb">apply</span>/negP/abs.
      <span class="nb">rewrite</span> loo leye_eq expand_eqoo ler_sub_addr addrC -ler_sub_addr subrr.
      <span class="bp">by</span> <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -ltNge.
    <span class="nb">have</span> [e1|e1] := ltrP <span class="mi">1</span> e%:num.
      <span class="bp">by</span> <span class="nb">rewrite</span> ler_subl_addr (le_trans (ltW e2)).
    <span class="bp">by</span> <span class="nb">rewrite</span> ler_subl_addr ler_addl.
<span class="nb">have</span> l_fin_num : l \<span class="kr">is</span> a fin_num <span class="bp">by</span> <span class="nb">rewrite</span> fin_numE lpoo lnoo.
<span class="nb">have</span> [le1|le1] := (ltrP (`|contract l - e%:num|) <span class="mi">1</span>)%R; <span class="nb">last first</span>.
  near=&gt; n; <span class="nb">rewrite</span> /ball /= /ereal_ball /=.
  <span class="nb">have</span> unoo : u_ n != -oo.
    near: n.
    <span class="nb">have</span> [m /eqP umoo] : <span class="kr">exists</span> <span class="nv">m</span>, u_ m &lt;&gt; -oo.
      <span class="nb">apply</span>/existsNP =&gt; uoo.
      <span class="bp">by</span> <span class="nb">apply</span>/Snoo; <span class="nb">rewrite</span> funeqE =&gt; ?; <span class="nb">rewrite</span> uoo.
    <span class="kr">exists</span> <span class="nv">m</span> =&gt; // k mk; <span class="nb">apply</span>: contra umoo =&gt; /eqP ukoo.
    <span class="bp">by</span> <span class="nb">move</span>/nd_u_ : mk; <span class="nb">rewrite</span> ukoo leeNy_eq.
  <span class="nb">rewrite</span> ger0_norm <span class="nl">?subr_ge0</span> <span class="nl">?le_contract</span> <span class="nl">?ereal_sup_ub</span>//; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.
  <span class="nb">have</span> [l0|l0] := ger0P (contract l).
    <span class="nb">have</span> el : (e%:num &gt; contract l)%R.
      <span class="nb">rewrite</span> ltNge; <span class="nb">apply</span>/negP =&gt; er.
      <span class="nb">rewrite</span> ger0_norm <span class="nl">?subr_ge0</span>// -ler_subl_addr opprK <span class="kr">in</span> le1.
      <span class="nb">case</span>/ler_normlP : (contract_le1 l) =&gt; _ /(le_trans le1); <span class="nb">apply</span>/negP.
      <span class="bp">by</span> <span class="nb">rewrite</span> -ltNge ltr_addl.
    <span class="nb">rewrite</span> ltr0_norm <span class="nl">?subr_lt0</span>// opprB <span class="kr">in</span> le1.
    <span class="nb">rewrite</span> ltr_subl_addr addrC -ltr_subl_addr -opprB ltr_oppl.
    <span class="nb">rewrite</span> (lt_le_trans _ le1) // lt_neqAle eqr_oppLR contract_eqN1 unoo /=.
    <span class="bp">by</span> <span class="nb">case</span>/ler_normlP : (contract_le1 (u_ n)).
  <span class="nb">rewrite</span> ler0_norm <span class="kr">in</span> le1; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> subr_le0 (le_trans (ltW l0)).
  <span class="nb">rewrite</span> opprB ler_subr_addr addrC -ler_subr_addr <span class="kr">in</span> le1.
  <span class="nb">rewrite</span> ltr_subl_addr (le_lt_trans le1) // -ltr_subl_addl addrAC subrr add0r.
  <span class="nb">rewrite</span> lt_neqAle eq_sym contract_eqN1 unoo /=.
  <span class="bp">by</span> <span class="nb">case</span>/ler_normlP : (contract_le1 (u_ n)); <span class="nb">rewrite</span> ler_oppl.
<span class="nb">pose</span> e&#39; :=
  (fine l - fine (expand (contract l - e%:num)))%R.
<span class="nb">have</span> e&#39;0 : (<span class="mi">0</span> &lt; e&#39;)%R.
  <span class="nb">rewrite</span> /e&#39; subr_gt0 -lte_fin fine_expand //.
  <span class="nb">rewrite</span> lt_expandLR <span class="nl">?inE</span> <span class="nl">?ltW</span>// ltr_subl_addr fineK //.
  <span class="bp">by</span> <span class="nb">rewrite</span> ltr_addl.
<span class="nb">have</span> [y [m _ umx] Se&#39;y] := ub_ereal_sup_adherent e&#39;0 l_fin_num.
near=&gt; n; <span class="nb">rewrite</span> /ball /= /ereal_ball /=.
<span class="nb">rewrite</span> ger0_norm <span class="nl">?subr_ge0</span> <span class="nl">?le_contract</span> <span class="nl">?ereal_sup_ub</span>//; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span>.
<span class="nb">move</span>: Se&#39;y; <span class="nb">rewrite</span> -{}umx {y} /= =&gt; le&#39;um.
<span class="nb">have</span> leum : (contract l - e%:num &lt; contract (u_ m))%R.
  <span class="nb">rewrite</span> -lt_expandLR <span class="nl">?inE</span> <span class="nl">?ltW</span>//.
  <span class="nb">move</span>: le&#39;um; <span class="nb">rewrite</span> /e&#39; EFinN /= opprB EFinB.
  <span class="nb">rewrite</span> (fineK l_fin_num) fine_expand //.
  <span class="bp">by</span> <span class="nb">rewrite</span> addeCA subee // adde0.
<span class="nb">rewrite</span> ltr_subl_addr addrC -ltr_subl_addr (lt_le_trans leum) //.
<span class="bp">by</span> <span class="nb">rewrite</span> le_contract nd_u_//; near: n; <span class="kr">exists</span> <span class="nv">m</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ereal_nondecreasing_is_cvg</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> : (\bar R) ^nat) :
  nondecreasing_seq u_ -&gt; cvg u_.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: ereal_nondecreasing_cvg. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ereal_nonincreasing_cvg</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> : (\bar R)^nat) :
  nonincreasing_seq u_ -&gt; u_ --&gt; ereal_inf (u_ @` setT).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ni_u; <span class="nb">rewrite</span> [X <span class="kr">in</span> X --&gt; _](_ : _ = -%E \o -%E \o u_); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> /= oppeK.
<span class="nb">apply</span>: cvgeN.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ --&gt; X](_ : _ = ereal_sup (range (-%E \o u_))); <span class="nb">last first</span>.
  <span class="nb">congr</span> ereal_sup; <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [[_ [n _ &lt;-]] &lt;-|[n _] &lt;-];
    <span class="bp">by</span> [<span class="kr">exists</span> <span class="nv">n</span> | <span class="kr">exists</span> (<span class="nv">u_</span> <span class="nv">n</span>) =&gt; //; <span class="kr">exists</span> <span class="nv">n</span>].
<span class="bp">by</span> <span class="nb">apply</span>: ereal_nondecreasing_cvg; <span class="nb">rewrite</span> ereal_nondecreasing_opp.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ereal_nonincreasing_is_cvg</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> : (\bar R) ^nat) :
  nonincreasing_seq u_ -&gt; cvg u_.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="nb">apply</span>: ereal_nonincreasing_cvg. <span class="kn">Qed</span>.

<span class="c">(* NB: see also nondecreasing_series *)</span>
<span class="kn">Lemma</span> <span class="nf">ereal_nondecreasing_series</span> (<span class="nv">R</span> : realDomainType) (<span class="nv">u_</span> : (\bar R)^nat)
  (<span class="nv">P</span> : pred nat) : (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; <span class="mi">0</span> &lt;= u_ n) -&gt;
  nondecreasing_seq (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n | P i) u_ i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; u_ge0 n m nm; <span class="nb">rewrite</span> lee_sum_nneg_natr// =&gt; k _ /u_ge0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_eseries</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) (<span class="nv">P</span> : pred nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; f i = g i) -&gt; \sum_(i &lt;oo | P i) f i = \sum_(i &lt;oo | P i) g i.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; efg; <span class="nb">congr</span> (lim _); <span class="nb">apply</span>/funext =&gt; n; <span class="bp">exact</span>: eq_bigr. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">ereal_series</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> : (\bar R)^nat).
<span class="kn">Implicit Types</span> <span class="nv">P</span> : pred nat.

<span class="kn">Lemma</span> <span class="nf">ereal_series_cond</span> <span class="nv">k</span> <span class="nv">P</span> :
  \sum_(k &lt;= i &lt;oo | P i) f i = \sum_(i &lt;oo | (k &lt;= i)%N &amp;&amp; P i) f i.
<span class="kn">Proof</span>.
<span class="nb">congr</span> (lim _); <span class="nb">apply</span>/funext =&gt; n.
<span class="nb">rewrite</span> big_nat_cond (big_nat_widenl k <span class="mi">0</span>%N)//= <span class="mi">2</span>!big_mkord.
<span class="bp">by</span> <span class="nb">apply</span>: eq_big =&gt; //= i; <span class="nb">rewrite</span> andbAC ltn_ord andbT andbb.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ereal_series</span> <span class="nv">k</span> : \sum_(k &lt;= i &lt;oo) f i = \sum_(i &lt;oo | (k &lt;= i)%N) f i.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> ereal_series_cond; <span class="nb">congr</span> (lim _); <span class="nb">apply</span>/funext =&gt; n.
<span class="bp">by</span> <span class="nb">apply</span>: eq_big =&gt; // i; <span class="nb">rewrite</span> andbT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eseries0</span> <span class="nv">P</span> : (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; f i = <span class="mi">0</span>) -&gt; \sum_(i &lt;oo | P i) f i = <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f0; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> big1//; <span class="nb">rewrite</span> lim_cst. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eseries_pred0</span> <span class="nv">P</span> : P =<span class="mi">1</span> xpred0 -&gt; \sum_(i &lt;oo | P i) f i = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; P0; <span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _) = <span class="kr">fun</span>=&gt; <span class="mi">0</span>) <span class="nl">?lim_cst</span>// funeqE =&gt; n.
<span class="bp">by</span> <span class="nb">rewrite</span> big1 // =&gt; i; <span class="nb">rewrite</span> P0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ereal_series</span>.

<span class="kn">Lemma</span> <span class="nf">nneseries_lim_ge</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> : (\bar R)^nat) (<span class="nv">P</span> : pred nat) <span class="nv">k</span> :
  (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; <span class="mi">0</span> &lt;= u_ n) -&gt;
  \sum_(<span class="mi">0</span> &lt;= i &lt; k | P i) u_ i &lt;= \sum_(i &lt;oo | P i) u_ i.
<span class="kn">Proof</span>.
<span class="nb">move</span>/ereal_nondecreasing_series/ereal_nondecreasing_cvg/cvg_lim =&gt; -&gt; //.
<span class="bp">by</span> <span class="nb">apply</span>: ereal_sup_ub; <span class="kr">exists</span> <span class="nv">k</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eseries_pinfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">u_</span> : (\bar R)^nat)
    (<span class="nv">P</span> : pred nat) <span class="nv">k</span> : (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; u_ n != -oo) -&gt; P k -&gt;
  u_ k = +oo -&gt; \sum_(i &lt;oo | P i) u_ i = +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; uNy Pk uky; <span class="nb">apply</span>: lim_near_cst =&gt; //; near=&gt; n.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> big_mkord esum_eqy; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /= i Pi; <span class="nb">rewrite</span> uNy.
<span class="nb">apply</span>/existsP.
<span class="nb">have</span> kn : (k &lt; n)%N <span class="bp">by</span> near: n; <span class="kr">exists</span> <span class="nv">k</span>.+<span class="mi">1</span>.
<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">Ordinal</span> <span class="nv">kn</span>) =&gt; /=; <span class="nb">rewrite</span> uky eqxx andbT.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">cvg_eseries</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> : (\bar R)^nat).
<span class="kn">Implicit Type</span> <span class="nf">P</span> : pred nat.

<span class="kn">Lemma</span> <span class="nf">is_cvg_ereal_nneg_natsum_cond</span> <span class="nv">m</span> <span class="nv">P</span> :
  (<span class="kr">forall</span> <span class="nv">n</span>, (m &lt;= n)%N -&gt; P n -&gt; <span class="mi">0</span> &lt;= u_ n) -&gt;
cvg (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(m &lt;= i &lt; n | P i) u_ i).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>/lee_sum_nneg_natr/ereal_nondecreasing_cvg =&gt; cu; <span class="nb">apply</span>: cvgP; <span class="bp">exact</span>: cu.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_ereal_npos_natsum_cond</span> <span class="nv">m</span> <span class="nv">P</span> :
  (<span class="kr">forall</span> <span class="nv">n</span>, (m &lt;= n)%N -&gt; P n -&gt; u_ n &lt;= <span class="mi">0</span>) -&gt;
  cvg (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(m &lt;= i &lt; n | P i) u_ i).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>/lee_sum_npos_natr/ereal_nonincreasing_cvg =&gt; cu; <span class="nb">apply</span>: cvgP; <span class="bp">exact</span>: cu.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_ereal_nneg_natsum</span> <span class="nv">m</span> : (<span class="kr">forall</span> <span class="nv">n</span>, (m &lt;= n)%N -&gt; <span class="mi">0</span> &lt;= u_ n) -&gt;
  cvg (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(m &lt;= i &lt; n) u_ i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; u_ge0; <span class="nb">apply</span>: is_cvg_ereal_nneg_natsum_cond =&gt; n /u_ge0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_ereal_npos_natsum</span> <span class="nv">m</span> : (<span class="kr">forall</span> <span class="nv">n</span>, (m &lt;= n)%N -&gt; u_ n &lt;= <span class="mi">0</span>) -&gt;
  cvg (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(m &lt;= i &lt; n) u_ i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; u_le0; <span class="nb">apply</span>: is_cvg_ereal_npos_natsum_cond =&gt; n /u_le0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_nneseries_cond</span> <span class="nv">P</span> : (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; <span class="mi">0</span> &lt;= u_ n) -&gt;
  cvg (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n | P i) u_ i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; u_ge0; <span class="nb">apply</span>: is_cvg_ereal_nneg_natsum_cond =&gt; n _ /u_ge0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_npeseries_cond</span> <span class="nv">P</span> : (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; u_ n &lt;= <span class="mi">0</span>) -&gt;
  cvg (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n | P i) u_ i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; u_le0; <span class="nb">apply</span>: is_cvg_ereal_npos_natsum_cond =&gt; n _ /u_le0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_nneseries</span> <span class="nv">P</span> : (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; <span class="mi">0</span> &lt;= u_ n) -&gt;
  cvg (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n | P i) u_ i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: is_cvg_nneseries_cond. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_npeseries</span> <span class="nv">P</span> : (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; u_ n &lt;= <span class="mi">0</span>) -&gt;
  cvg (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n | P i) u_ i).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: is_cvg_npeseries_cond. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nneseries_ge0</span> <span class="nv">P</span> : (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; <span class="mi">0</span> &lt;= u_ n) -&gt;
  <span class="mi">0</span> &lt;= \sum_(i &lt;oo | P i) u_ i.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u0; <span class="nb">apply</span>: (lime_ge (is_cvg_nneseries u0)).
<span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; k; <span class="nb">rewrite</span> sume_ge0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">npeseries_le0</span> <span class="nv">P</span> : (<span class="kr">forall</span> <span class="nv">n</span> : nat, P n -&gt; u_ n &lt;= <span class="mi">0</span>) -&gt;
  \sum_(i &lt;oo | P i) u_ i &lt;= <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u0; <span class="nb">apply</span>: (lime_le (is_cvg_npeseries u0)).
<span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; k; <span class="nb">rewrite</span> sume_le0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvg_eseries</span>.
<span class="kn">Arguments</span> is_cvg_nneseries {R}.

<span class="kn">Lemma</span> <span class="nf">nnseries_is_cvg</span> {<span class="nv">R</span> : realType} (<span class="nv">u</span> : nat -&gt; R) :
  (<span class="kr">forall</span> <span class="nv">i</span>, <span class="mi">0</span> &lt;= u i)%R -&gt; \sum_(k &lt;oo) (u k)%:E &lt; +oo -&gt; cvg (series u).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: nondecreasing_is_cvg.
  <span class="nb">move</span>=&gt; m n mn; <span class="nb">rewrite</span> /series/=.
  <span class="nb">rewrite</span> -(subnKC mn) {<span class="mi">2</span>}/index_iota subn0 iotaD big_cat/=.
  <span class="bp">by</span> <span class="nb">rewrite</span> add0n -{<span class="mi">2</span>}(subn0 m) -/(index_iota _ _) ler_addl sumr_ge0.
<span class="kr">exists</span> (<span class="nv">fine</span> (\sum_(k &lt;oo) (u k)%:E)).
<span class="nb">rewrite</span> /ubound/= =&gt; _ [n _ &lt;-]; <span class="nb">rewrite</span> -lee_fin fineK//; <span class="nb">last first</span>.
  <span class="nb">rewrite</span> fin_num_abs gee0_abs//; <span class="nb">apply</span>: nneseries_ge0 =&gt; // i _.
  <span class="bp">by</span> <span class="nb">rewrite</span> lee_fin.
<span class="bp">by</span> <span class="nb">rewrite</span> -sumEFin; <span class="nb">apply</span>: nneseries_lim_ge =&gt; i _; <span class="nb">rewrite</span> lee_fin.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nneseriesrM</span> (<span class="nv">R</span> : realType) (<span class="nv">f</span> : nat -&gt; \bar R) (<span class="nv">P</span> : pred nat) <span class="nv">x</span> :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; <span class="mi">0</span> &lt;= f i) -&gt;
  (\sum_(i &lt;oo | P i) (x%:E * f i) = x%:E * \sum_(i &lt;oo | P i) f i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0; <span class="nb">rewrite</span> -limeMl//; <span class="nb">last</span> <span class="bp">exact</span>: is_cvg_nneseries.
<span class="bp">by</span> <span class="nb">congr</span> (lim _); <span class="nb">apply</span>/funext =&gt; /= n; <span class="nb">rewrite</span> ge0_sume_distrr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">adde_def_nneseries</span> (<span class="nv">R</span> : realType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat)
    (<span class="nv">P</span> <span class="nv">Q</span> : pred nat) :
  (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; <span class="mi">0</span> &lt;= f n) -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, Q n -&gt; <span class="mi">0</span> &lt;= g n) -&gt;
  (\sum_(i &lt;oo | P i) f i) +? (\sum_(i &lt;oo | Q i) g i).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0 g0; <span class="nb">rewrite</span> /adde_def !negb_and; <span class="nb">apply</span>/andP; <span class="nb">split</span>; <span class="nb">apply</span>/orP.
- <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">apply</span>/eqP =&gt; Qg; <span class="nb">have</span> := nneseries_ge0 g0; <span class="nb">rewrite</span> Qg.
- <span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span>/eqP =&gt; Pf; <span class="nb">have</span> := nneseries_ge0 f0; <span class="nb">rewrite</span> Pf.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgPpinfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">u_</span> : (\bar R)^nat) :
  u_ --&gt; +oo &lt;-&gt; (<span class="kr">forall</span> <span class="nv">A</span>, (<span class="mi">0</span> &lt; A)%R -&gt; \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, A%:E &lt;= u_ n).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>=&gt; [/cvgeyPge//|u_ge]; <span class="nb">apply</span>/cvgeyPgey; near=&gt; x; <span class="nb">apply</span> u_ge.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use `cvgeyPge` or a variant instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgPpinfty</span> := __deprecated__ereal_cvgPpinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgPninfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">u_</span> : (\bar R)^nat) :
  u_ --&gt; -oo &lt;-&gt; (<span class="kr">forall</span> <span class="nv">A</span>, (A &lt; <span class="mi">0</span>)%R -&gt; \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, u_ n &lt;= A%:E).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>=&gt; [/cvgeNyPle//|u_ge]; <span class="nb">apply</span>/cvgeNyPleNy; near=&gt; x; <span class="nb">apply</span> u_ge.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use `cvgeNyPle` or a variant instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgPninfty</span> := __deprecated__ereal_cvgPninfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_squeeze</span> (<span class="nv">R</span> : realType) (<span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : (\bar R)^nat) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near \oo, f x &lt;= g x &lt;= h x) -&gt; <span class="kr">forall</span> (<span class="nv">l</span> : \bar R),
  f --&gt; l -&gt; h --&gt; l -&gt; g --&gt; l.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: squeeze_cvge. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `squeeze_cvge` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_squeeze</span> := __deprecated__ereal_squeeze.

<span class="kn">Lemma</span> <span class="nf">nneseries_pinfty</span> (<span class="nv">R</span> : realType) (<span class="nv">u_</span> : (\bar R)^nat)
  (<span class="nv">P</span> : pred nat) <span class="nv">k</span> : (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; <span class="mi">0</span> &lt;= u_ n) -&gt; P k -&gt;
  u_ k = +oo -&gt; \sum_(i &lt;oo | P i) u_ i = +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_ge0 Pk ukoo; <span class="nb">apply</span>: (eseries_pinfty _ Pk ukoo) =&gt; // n Pn.
<span class="bp">by</span> <span class="nb">rewrite</span> gt_eqF// (lt_le_trans _ (u_ge0 _ Pn)).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lee_nneseries</span> (<span class="nv">R</span> : realType) (<span class="nv">u</span> <span class="nv">v</span> : (\bar R)^nat) (<span class="nv">P</span> : pred nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; <span class="mi">0</span> &lt;= u i) -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; u n &lt;= v n) -&gt;
  \sum_(i &lt;oo | P i) u i &lt;= \sum_(i &lt;oo | P i) v i.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u0 Puv; <span class="nb">apply</span>: lee_lim.
- <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_ereal_nneg_natsum_cond =&gt; n _ /u0.
- <span class="nb">apply</span>: is_cvg_ereal_nneg_natsum_cond =&gt; n _ Pn.
  <span class="bp">by</span> <span class="nb">rewrite</span> (le_trans _ (Puv _ Pn))// u0.
- <span class="bp">by</span> near=&gt; n; <span class="bp">exact</span>: lee_sum.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lee_npeseries</span> (<span class="nv">R</span> : realType) (<span class="nv">u</span> <span class="nv">v</span> : (\bar R)^nat) (<span class="nv">P</span> : pred nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; u i &lt;= <span class="mi">0</span>) -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; v n &lt;= u n) -&gt;
  \sum_(i &lt;oo | P i) v i &lt;= \sum_(i &lt;oo | P i) u i.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u0 Puv; <span class="nb">apply</span>: lee_lim.
- <span class="nb">apply</span>: is_cvg_ereal_npos_natsum_cond =&gt; n _ /[dup] Pn /Puv/le_trans; <span class="nb">apply</span>.
  <span class="bp">exact</span>/u0.
- <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_ereal_npos_natsum_cond =&gt; n _ Pn; <span class="bp">exact</span>/u0.
- <span class="bp">by</span> near=&gt; n; <span class="bp">exact</span>: lee_sum.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgD_pinfty_fin</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) <span class="nv">b</span> :
  f --&gt; +oo -&gt; g --&gt; b%:E -&gt; f \+ g --&gt; +oo.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgeD. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;use `cvgeD` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgD_pinfty_fin</span> := __deprecated__ereal_cvgD_pinfty_fin.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgD_ninfty_fin</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) <span class="nv">b</span> :
  f --&gt; -oo -&gt; g --&gt; b%:E -&gt; f \+ g --&gt; -oo.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgeD. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;use `cvgeD` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgD_ninfty_fin</span> := __deprecated__ereal_cvgD_ninfty_fin.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgD_pinfty_pinfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) :
  f --&gt; +oo -&gt; g --&gt; +oo -&gt; f \+ g --&gt; +oo.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgeD. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;use `cvgeD` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgD_pinfty_pinfty</span> := __deprecated__ereal_cvgD_pinfty_pinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgD_ninfty_ninfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) :
  f --&gt; -oo -&gt; g --&gt; -oo -&gt; f \+ g --&gt; -oo.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgeD. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;use `cvgeD` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgD_ninfty_ninfty</span> := __deprecated__ereal_cvgD_ninfty_ninfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgD</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) <span class="nv">a</span> <span class="nv">b</span> :
  a +? b -&gt; f --&gt; a -&gt; g --&gt; b -&gt; f \+ g --&gt; a + b.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgeD. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgeD` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgD</span> := __deprecated__ereal_cvgD.

<span class="kn">Section</span> <span class="nf">nneseries_split</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgB</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) <span class="nv">a</span> <span class="nv">b</span> :
  a +? - b -&gt; f --&gt; a -&gt; g --&gt; b -&gt; f \- g --&gt; a - b.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgeB. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgeB` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgB</span> := __deprecated__ereal_cvgB.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_is_cvgD</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">u</span> <span class="nv">v</span> : (\bar R)^nat) :
  lim u +? lim v -&gt; cvg u -&gt; cvg v -&gt; cvg (u \+ v).
<span class="kn">Proof</span>. <span class="bp">exact</span>: is_cvgeD. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `is_cvgeD` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_is_cvgD</span> := __deprecated__ereal_is_cvgD.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvg_sub0</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> : (\bar R)^nat) (<span class="nv">k</span> : \bar R) :
  k \<span class="kr">is</span> a fin_num -&gt; (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x - k) --&gt; <span class="mi">0</span> &lt;-&gt; f --&gt; k.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvge_sub0. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvge_sub0` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvg_sub0</span> := __deprecated__ereal_cvg_sub0.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_limD</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) :
  cvg f -&gt; cvg g -&gt; lim f +? lim g -&gt;
  lim (f \+ g) = lim f + lim g.
<span class="kn">Proof</span>. <span class="bp">exact</span>: limeD. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `limeD` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_limD</span> := __deprecated__ereal_limD.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgM_gt0_pinfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) <span class="nv">b</span> :
  (<span class="mi">0</span> &lt; b)%R -&gt; f --&gt; +oo -&gt; g --&gt; b%:E -&gt; f \* g --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; b_lt0 fl gl; <span class="nb">have</span> /= := cvgeM _ fl gl; <span class="nb">rewrite</span> gt0_mulye//; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> mule_def_infty_neq0// gt_eqF.
<span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;use `cvgeM` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgM_gt0_pinfty</span> := __deprecated__ereal_cvgM_gt0_pinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgM_lt0_pinfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) <span class="nv">b</span> :
  (b &lt; <span class="mi">0</span>)%R -&gt; f --&gt; +oo -&gt; g --&gt; b%:E -&gt; f \* g --&gt; -oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; b_lt0 fl gl; <span class="nb">have</span> /= := cvgeM _ fl gl; <span class="nb">rewrite</span> lt0_mulye//; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> mule_def_infty_neq0// lt_eqF.
<span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;use `cvgeM` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgM_lt0_pinfty</span> := __deprecated__ereal_cvgM_lt0_pinfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgM_gt0_ninfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) <span class="nv">b</span> :
  (<span class="mi">0</span> &lt; b)%R -&gt; f --&gt; -oo -&gt; g --&gt; b%:E -&gt; f \* g --&gt; -oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; b_lt0 fl gl; <span class="nb">have</span> /= := cvgeM _ fl gl; <span class="nb">rewrite</span> gt0_mulNye//; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> mule_def_infty_neq0// gt_eqF.
<span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;use `cvgeM` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgM_gt0_ninfty</span> := __deprecated__ereal_cvgM_gt0_ninfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgM_lt0_ninfty</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R)^nat) <span class="nv">b</span> :
  (b &lt; <span class="mi">0</span>)%R -&gt; f --&gt; -oo -&gt; g --&gt; b%:E -&gt; f \* g --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; b_lt0 fl gl; <span class="nb">have</span> /= := cvgeM _ fl gl; <span class="nb">rewrite</span> lt0_mulNye//; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> mule_def_infty_neq0// lt_eqF.
<span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;use `cvgeM` instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgM_lt0_ninfty</span> := __deprecated__ereal_cvgM_lt0_ninfty.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_cvgM</span> (<span class="nv">R</span> : realType) (<span class="nv">f</span> <span class="nv">g</span> : (\bar R) ^nat) (<span class="nv">a</span> <span class="nv">b</span> : \bar R) :
 a *? b -&gt; f --&gt; a -&gt; g --&gt; b -&gt; f \* g --&gt; a * b.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgeM. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgeM` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgM</span> := __deprecated__ereal_cvgM.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ereal_lim_sum</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">r</span> : seq I)
    (<span class="nv">f</span> : I -&gt; (\bar R)^nat) (<span class="nv">l</span> : I -&gt; \bar R) (<span class="nv">P</span> : pred I) :
  (<span class="kr">forall</span> <span class="nv">k</span> <span class="nv">n</span>, P k -&gt; <span class="mi">0</span> &lt;= f k n) -&gt;
  (<span class="kr">forall</span> <span class="nv">k</span>, P k -&gt; f k --&gt; l k) -&gt;
  (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(k &lt;- r | P k) f k n) --&gt; \sum_(k &lt;- r | P k) l k.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; f0 ?; <span class="nb">apply</span>: cvg_nnesum =&gt; // ? ?; <span class="nb">apply</span>: nearW =&gt; ?; <span class="nb">apply</span>: f0.
<span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvg_nnesum` and generalized&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_lim_sum</span> := __deprecated__ereal_lim_sum.

<span class="kn">Let</span> <span class="nf">lim_shift_cst</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">u</span> : (\bar R) ^nat) (<span class="nv">l</span> : \bar R) :
  cvg u -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, <span class="mi">0</span> &lt;= u n) -&gt; -oo &lt; l -&gt; lim (<span class="kr">fun</span> <span class="nv">x</span> =&gt; l + u x) = l + lim u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cu u0 hl; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>: cvgeD (cu); <span class="nb">last first</span>.
  <span class="bp">exact</span>: cvg_cst.
<span class="nb">rewrite</span> ltninfty_adde_def// inE (@lt_le_trans _ _ <span class="mi">0</span>)//.
<span class="bp">by</span> <span class="nb">apply</span>: lime_ge =&gt; //; <span class="bp">exact</span>: nearW.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">near_eq_lim</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> <span class="nv">g</span> : nat -&gt; \bar R) :
  cvg g -&gt; {near \oo, f =<span class="mi">1</span> g} -&gt; lim f = lim g.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cg fg; <span class="nb">suff</span>: f --&gt; lim g <span class="bp">by</span> <span class="bp">exact</span>/cvg_lim.
<span class="bp">by</span> <span class="nb">apply</span>: cvg_trans cg; <span class="nb">apply</span>: near_eq_cvg; near <span class="kp">do</span> <span class="nb">apply</span>/esym.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nneseries_split</span> (<span class="nv">R</span> : realType) (<span class="nv">f</span> : nat -&gt; \bar R) <span class="nv">n</span> :
  (<span class="kr">forall</span> <span class="nv">k</span>, <span class="mi">0</span> &lt;= f k) -&gt;
  \sum_(k &lt;oo) f k = \sum_(k &lt; n) f k + \sum_(n &lt;= k &lt;oo) f k.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0; <span class="nb">elim</span>: n =&gt; [|n ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> big_ord0 add0e.
<span class="nb">rewrite</span> big_ord_recr/= -addeA [f n + _](_ : _ = \sum_(n &lt;= k &lt;oo) f k)//.
<span class="nb">rewrite</span> -lim_shift_cst; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> (@lt_le_trans _ _ <span class="mi">0</span>).
- <span class="nb">apply</span>: (@near_eq_lim _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f n + _)).
    <span class="bp">exact</span>: is_cvg_ereal_nneg_natsum.
  <span class="bp">by</span> near <span class="kp">do</span> <span class="nb">rewrite</span> -big_ltn//; <span class="bp">exact</span>: nbhs_infty_gt.
- <span class="bp">exact</span>: is_cvg_ereal_nneg_natsum.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; m; <span class="bp">exact</span>: sume_ge0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">nneseries_split</span>.

<span class="kn">Lemma</span> <span class="nf">nneseriesD</span> (<span class="nv">R</span> : realType) (<span class="nv">f</span> <span class="nv">g</span> : nat -&gt; \bar R) (<span class="nv">P</span> : pred nat) :
  (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; <span class="mi">0</span> &lt;= f i) -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, P i -&gt; <span class="mi">0</span> &lt;= g i) -&gt;
  \sum_(i &lt;oo | P i) (f i + g i) =
  \sum_(i &lt;oo | P i) f i + \sum_(i &lt;oo | P i) g i.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_eq0 g_eq0.
<span class="nb">transitivity</span> (lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= i &lt; n | P i) f i +
                         \sum_(<span class="mi">0</span> &lt;= i &lt; n | P i) g i)).
  <span class="bp">by</span> <span class="nb">congr</span> (lim _); <span class="nb">apply</span>/funext =&gt; n; <span class="nb">rewrite</span> big_split.
<span class="nb">rewrite</span> limeD /adde_def //=; <span class="kp">do</span> ? <span class="bp">exact</span>: is_cvg_nneseries.
<span class="bp">by</span> <span class="nb">rewrite</span> ![_ == -oo]gt_eqF <span class="nl">?andbF</span>// (@lt_le_trans _ _ <span class="mi">0</span>)
           ?[_ &lt; _]real0// nneseries_ge0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nneseries_sum_nat</span> (<span class="nv">R</span> : realType) <span class="nv">n</span> (<span class="nv">f</span> : nat -&gt; nat -&gt; \bar R) :
  (<span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, <span class="mi">0</span> &lt;= f i j) -&gt;
  \sum_(j &lt;oo) (\sum_(<span class="mi">0</span> &lt;= i &lt; n) f i j) =
  \sum_(<span class="mi">0</span> &lt;= i &lt; n) (\sum_(j &lt;oo) (f i j)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f0; <span class="nb">elim</span>: n =&gt; [|n IHn].
  <span class="bp">by</span> <span class="nb">rewrite</span> big_geq// eseries0// =&gt; i; <span class="nb">rewrite</span> big_geq.
<span class="nb">rewrite</span> big_nat_recr// -IHn/= -nneseriesD//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">rewrite</span> sume_ge0.
<span class="bp">by</span> <span class="nb">congr</span> (lim _); <span class="nb">apply</span>/funext =&gt; m; <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> big_nat_recr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nneseries_sum</span> <span class="nv">I</span> (<span class="nv">r</span> : seq I) (<span class="nv">P</span> : {pred I})
    [R : realType] [f : I -&gt; nat -&gt; \bar R] :
    (<span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, P i -&gt; <span class="mi">0</span> &lt;= f i j) -&gt;
  \sum_(j &lt;oo) \sum_(i &lt;- r | P i) f i j = \sum_(i &lt;- r | P i) \sum_(j &lt;oo) f i j.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_ge0; <span class="nb">case</span> Dr : r =&gt; [|i r&#39;]; <span class="nb">rewrite</span> -?{}[_ :: _]Dr.
  <span class="bp">by</span> <span class="nb">rewrite</span> big_nil eseries0// =&gt; i; <span class="nb">rewrite</span> big_nil.
<span class="nb">rewrite</span> {r&#39;}(big_nth i) big_mkcond.
<span class="nb">rewrite</span> (eq_eseries (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; big_nth i _ _)).
<span class="nb">rewrite</span> (eq_eseries (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; big_mkcond _ _))/=.
<span class="nb">rewrite</span> nneseries_sum_nat; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">case</span>: ifP =&gt; // /f_ge0.
<span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; j _; <span class="nb">case</span>: ifP =&gt; //; <span class="nb">rewrite</span> eseries0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lte_lim</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">u</span> : (\bar R)^nat) (<span class="nv">M</span> : R) :
  nondecreasing_seq u -&gt; cvg u -&gt; M%:E &lt; lim u -&gt;
  \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, M%:E &lt;= u n.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ndu cu Ml; <span class="nb">have</span> [[n Mun]|] := pselect (<span class="kr">exists</span> <span class="nv">n</span>, M%:E &lt;= u n).
  near=&gt; m; <span class="nb">suff</span> : u n &lt;= u m <span class="bp">by</span> <span class="bp">exact</span>: le_trans.
  <span class="bp">by</span> near: m; <span class="kr">exists</span> <span class="nv">n</span>.+<span class="mi">1</span> =&gt; // p q; <span class="nb">apply</span>/ndu/ltnW.
<span class="nb">move</span>/forallNP =&gt; Mu.
<span class="nb">have</span> {}Mu : <span class="kr">forall</span> <span class="nv">x</span>, M%:E &gt; u x <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> ltNge; <span class="nb">apply</span>/negP.
<span class="nb">have</span> : lim u &lt;= M%:E <span class="bp">by</span> <span class="nb">apply</span> lime_le =&gt; //; near=&gt; m; <span class="nb">apply</span>/ltW/Mu.
<span class="bp">by</span> <span class="nb">move</span>/(lt_le_trans Ml); <span class="nb">rewrite</span> ltxx.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_mkord</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">P</span> : {pred nat}) (<span class="nv">f</span> : (\bar R)^nat) :
  lim (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(k &lt; n | P k) f k)%E = \sum_(k &lt;oo | P k) f k.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (_ : (<span class="kr">fun</span> <span class="nv">n</span> =&gt; _) = (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(<span class="mi">0</span> &lt;= k &lt; n | P k) f k)%E) //.
<span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; k; <span class="nb">rewrite</span> big_mkord.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eseries_mkcond</span> [R : realFieldType] [P : pred nat] (f : nat -&gt; \bar R) :
  \sum_(i &lt;oo | P i) f i = \sum_(i &lt;oo) <span class="kr">if</span> P i <span class="kr">then</span> f i <span class="kr">else</span> <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">congr</span> (lim _); <span class="nb">apply</span>: eq_fun =&gt; n /=; <span class="nb">apply</span>: big_mkcond. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sequences_ereal</span>.
#[deprecated(since=<span class="s2">&quot;analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;Use eseries0 instead.&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">nneseries0</span> := eseries0.
#[deprecated(since=<span class="s2">&quot;analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;Use eq_eseries instead.&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">eq_nneseries</span> := eq_eseries.
#[deprecated(since=<span class="s2">&quot;analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;Use eseries_pred0 instead.&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">nneseries_pred0</span> := eseries_pred0.
#[deprecated(since=<span class="s2">&quot;analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;Use eseries_mkcond instead.&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">nneseries_mkcond</span> := eseries_mkcond.

<span class="kn">Definition</span> <span class="nf">sdrop</span> <span class="nv">T</span> (<span class="nv">u</span> : T^nat) <span class="nv">n</span> := [<span class="nb">set</span> u k | k <span class="kr">in</span> [<span class="nb">set</span> k | k &gt;= n]]%N.

<span class="kn">Section</span> <span class="nf">sdrop</span>.
<span class="kn">Variables</span> (<span class="nv">d</span> : unit) (<span class="nv">R</span> : porderType d).
<span class="kn">Implicit Types</span> (<span class="nv">u</span> : R^o^nat).

<span class="kn">Lemma</span> <span class="nf">has_lbound_sdrop</span> <span class="nv">u</span> : has_lbound (range u) -&gt;
  <span class="kr">forall</span> <span class="nv">m</span>, has_lbound (sdrop u m).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [M uM] n; <span class="kr">exists</span> <span class="nv">M</span> =&gt; _ [m /= nm] &lt;-; <span class="nb">rewrite</span> uM //; <span class="kr">exists</span> <span class="nv">m</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">has_ubound_sdrop</span> <span class="nv">u</span> : has_ubound (range u) -&gt;
  <span class="kr">forall</span> <span class="nv">m</span>, has_ubound (sdrop u m).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [M uM] n; <span class="kr">exists</span> <span class="nv">M</span> =&gt; _ [m /= nm] &lt;-; <span class="nb">rewrite</span> uM //; <span class="kr">exists</span> <span class="nv">m</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sdrop</span>.

<span class="kn">Section</span> <span class="nf">sups_infs</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> (<span class="nv">r</span> : R) (<span class="nv">u</span> : R^o^nat).

<span class="kn">Definition</span> <span class="nf">sups</span> <span class="nv">u</span> := [sequence sup (sdrop u n)]_n.

<span class="kn">Definition</span> <span class="nf">infs</span> <span class="nv">u</span> := [sequence inf (sdrop u n)]_n.

<span class="kn">Lemma</span> <span class="nf">supsN</span> <span class="nv">u</span> : sups (-%R \o u) = - infs u.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> /sups /infs /inf /= opprK; <span class="nb">congr</span> (sup _).
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; [[m /= nm &lt;-]|[_ [m /= nm] &lt;-] &lt;-];
  [<span class="kr">exists</span> (<span class="nv">u</span> <span class="nv">m</span>) =&gt; //; <span class="kr">exists</span> <span class="nv">m</span> | <span class="kr">exists</span> <span class="nv">m</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">infsN</span> <span class="nv">u</span> : infs (-%R \o u) = - sups u.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> -eqr_oppLR -supsN; <span class="nb">apply</span>/eqP; <span class="nb">congr</span> (sups _).
<span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; ? /=; <span class="nb">rewrite</span> opprK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nonincreasing_sups</span> <span class="nv">u</span> : has_ubound (range u) -&gt;
  nonincreasing_seq (sups u).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_ub m n mn; <span class="nb">apply</span>: le_sup =&gt; [_ /= [p np] &lt;-| |].
- <span class="bp">by</span> <span class="nb">apply</span>/downP; <span class="kr">exists</span> (<span class="nv">u</span> <span class="nv">p</span>) =&gt; //=; <span class="kr">exists</span> <span class="nv">p</span> =&gt; //; <span class="bp">exact</span>: leq_trans np.
- <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">u</span> <span class="nv">n</span>) =&gt; /=; <span class="kr">exists</span> <span class="nv">n</span> =&gt; /=.
- <span class="bp">by</span> <span class="nb">split</span>; [<span class="kr">exists</span> (<span class="nv">u</span> <span class="nv">m</span>); <span class="kr">exists</span> <span class="nv">m</span> =&gt; //=|<span class="bp">exact</span>/has_ubound_sdrop].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_infs</span> <span class="nv">u</span> : has_lbound (range u) -&gt;
  nondecreasing_seq (infs u).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_lb; <span class="nb">rewrite</span> -nonincreasing_opp -supsN; <span class="nb">apply</span>/nonincreasing_sups.
<span class="bp">by</span> <span class="nb">move</span>: u_lb =&gt; /has_lb_ubN; <span class="nb">rewrite</span> /comp /= image_comp.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_sups</span> <span class="nv">u</span> : cvg u -&gt; cvg (sups u).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cf; <span class="nb">have</span> [M [Mreal Mu]] := cvg_seq_bounded cf.
<span class="nb">apply</span>: nonincreasing_is_cvg.
  <span class="bp">exact</span>/nonincreasing_sups/bounded_fun_has_ubound/cvg_seq_bounded.
<span class="kr">exists</span> (- (M + <span class="mi">1</span>)) =&gt; _ [n _ &lt;-]; <span class="nb">rewrite</span> (@le_trans _ _ (u n)) //.
  <span class="bp">by</span> <span class="nb">apply</span>/lerNnormlW/Mu =&gt; //; <span class="nb">rewrite</span> ltr_addl.
<span class="nb">apply</span>: sup_ub; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; /=.
<span class="bp">exact</span>/has_ubound_sdrop/bounded_fun_has_ubound/cvg_seq_bounded.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_infs</span> <span class="nv">u</span> : cvg u -&gt; cvg (infs u).
<span class="kn">Proof</span>.
<span class="nb">move</span>/is_cvgN/is_cvg_sups; <span class="nb">rewrite</span> supsN.
<span class="bp">by</span> <span class="nb">move</span>/(@is_cvgN _ [normedModType R of R^o]); <span class="nb">rewrite</span> opprK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">infs_le_sups</span> <span class="nv">u</span> <span class="nv">n</span> : cvg u -&gt; infs u n &lt;= sups u n.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cu; <span class="nb">rewrite</span> /infs /sups /=; <span class="nb">set</span> A := sdrop _ _.
<span class="nb">have</span> [a Aa] : A !=set0 <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">u</span> <span class="nv">n</span>); <span class="nb">rewrite</span> /A /=; <span class="kr">exists</span> <span class="nv">n</span> =&gt; //=.
<span class="nb">rewrite</span> (@le_trans _ _ a) //; [<span class="nb">apply</span>/inf_lb|<span class="nb">apply</span>/sup_ub] =&gt; //.
- <span class="bp">exact</span>/has_lbound_sdrop/bounded_fun_has_lbound/cvg_seq_bounded.
- <span class="bp">exact</span>/has_ubound_sdrop/bounded_fun_has_ubound/cvg_seq_bounded.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_sups_inf</span> <span class="nv">u</span> : has_ubound (range u) -&gt; has_lbound (range u) -&gt;
  sups u --&gt; inf (range (sups u)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_ub u_lb.
<span class="nb">apply</span>: nonincreasing_cvg; <span class="kp">first</span> <span class="bp">exact</span>: nonincreasing_sups.
<span class="nb">case</span>: u_lb =&gt; M uM; <span class="kr">exists</span> <span class="nv">M</span> =&gt; _ [n _ &lt;-].
<span class="nb">rewrite</span> (@le_trans _ _ (u n)) //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span> uM; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="bp">by</span> <span class="nb">apply</span>: sup_ub; [<span class="bp">exact</span>/has_ubound_sdrop|<span class="kr">exists</span> <span class="nv">n</span> =&gt; /=].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_infs_sup</span> <span class="nv">u</span> : has_ubound (range u) -&gt; has_lbound (range u) -&gt;
  infs u --&gt; sup (range (infs u)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; u_ub u_lb; <span class="nb">have</span> : sups (- u) --&gt; inf (range (sups (- u))).
  <span class="nb">apply</span>: cvg_sups_inf.
  - <span class="bp">by</span> <span class="nb">move</span>: u_lb =&gt; /has_lb_ubN; <span class="nb">rewrite</span> image_comp.
  - <span class="bp">by</span> <span class="nb">move</span>: u_ub =&gt; /has_ub_lbN; <span class="nb">rewrite</span> image_comp.
<span class="nb">rewrite</span> /inf =&gt; /(@cvg_comp _ _ _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; - x)).
<span class="nb">rewrite</span> supsN /comp /= -[<span class="kr">in</span> X <span class="kr">in</span> _ -&gt; X --&gt; _](opprK (infs u)); <span class="nb">apply</span>.
<span class="nb">rewrite</span> image_comp /comp /= -(opprK (sup (range (infs u)))).
<span class="nb">apply</span>: (@cvgN _ [normedModType R of R^o]).
<span class="bp">by</span> <span class="nb">rewrite</span> (_ : [<span class="nb">set</span> _ | _ <span class="kr">in</span> setT] = (range (infs u))) // opprK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sups_preimage</span> <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> T) <span class="nv">r</span> (<span class="nv">f</span> : (T -&gt; R)^nat) <span class="nv">n</span> :
  (<span class="kr">forall</span> <span class="nv">t</span>, D t -&gt; has_ubound (range (f ^~ t))) -&gt;
  D `&amp;` (<span class="kr">fun</span> <span class="nv">x</span> =&gt; sups (f ^~x) n) @^-<span class="mi">1</span>` `]r, +oo[%classic =
  D `&amp;` \bigcup_(k <span class="kr">in</span> [<span class="nb">set</span> k | n &lt;= k]%N) f k @^-<span class="mi">1</span>` `]r, +oo[.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_ub; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>.
- <span class="nb">have</span> [|/set0P h] := eqVneq (sdrop (f ^~ t) n) set0.
    <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; /(_ (f n t))[+ _] =&gt; /forall2NP/(_ n)/= [].
  <span class="nb">rewrite</span> /= in_itv /= andbT =&gt; -[Dt].
  <span class="nb">move</span>=&gt; /(sup_gt h)[_ [m /= nm &lt;-]] rfmt. <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">m</span> =&gt; //.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= in_itv /= rfmt.
- <span class="nb">move</span>=&gt; [Dt [k /= nk]]; <span class="nb">rewrite</span> in_itv /= andbT =&gt; rfkt.
  <span class="nb">split</span>=&gt; //; <span class="nb">rewrite</span> /= in_itv /= andbT; <span class="nb">apply</span>: (lt_le_trans rfkt).
  <span class="bp">by</span> <span class="nb">apply</span>: sup_ub; [<span class="bp">exact</span>/has_ubound_sdrop/f_ub|<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">infs_preimage</span> <span class="nv">T</span> (<span class="nv">D</span> : <span class="nb">set</span> T) <span class="nv">r</span> (<span class="nv">f</span> : (T -&gt; R)^nat) <span class="nv">n</span> :
  (<span class="kr">forall</span> <span class="nv">t</span>, D t -&gt; has_lbound (range (f ^~ t))) -&gt;
  D `&amp;` (<span class="kr">fun</span> <span class="nv">x</span> =&gt; infs (f ^~ x) n) @^-<span class="mi">1</span>` `]-oo, r[ =
  D `&amp;` \bigcup_(k <span class="kr">in</span> [<span class="nb">set</span> k | n &lt;= k]%N) f k @^-<span class="mi">1</span>` `]-oo, r[.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; lb_f; <span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span>.
- <span class="nb">have</span> [|/set0P h] := eqVneq (sdrop (f ^~ t) n) set0.
    <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; /(_ (f n t))[+ _] =&gt; /forall2NP/(_ n)/= [].
  <span class="nb">rewrite</span> /= in_itv /= =&gt; -[Dt].
  <span class="bp">by</span> <span class="nb">move</span>=&gt;  /(inf_lt h)[_ [m /= nm &lt;-]] fmtr; <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">m</span>.
- <span class="nb">move</span>=&gt; [Dt [k /= nk]]; <span class="nb">rewrite</span> /= in_itv /= =&gt; fktr.
  <span class="nb">rewrite</span> in_itv /=; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: le_lt_trans fktr.
  <span class="bp">by</span> <span class="nb">apply</span>/inf_lb =&gt; //; [<span class="bp">exact</span>/has_lbound_sdrop/lb_f|<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bounded_fun_has_lbound_sups</span> <span class="nv">u</span> :
  bounded_fun u -&gt; has_lbound (range (sups u)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /[dup] ba /bounded_fun_has_lbound/has_lbound_sdrop h.
<span class="nb">have</span> [M hM] := h O; <span class="kr">exists</span> <span class="nv">M</span> =&gt; y [n _ &lt;-].
<span class="nb">rewrite</span> (@le_trans _ _ (u n)) //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span> hM; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="nb">apply</span>: sup_ub; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; /=.
<span class="bp">by</span> <span class="nb">move</span>: ba =&gt; /bounded_fun_has_ubound/has_ubound_sdrop; <span class="bp">exact</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bounded_fun_has_ubound_infs</span> <span class="nv">u</span> :
  bounded_fun u -&gt; has_ubound (range (infs u)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /[dup] ba /bounded_fun_has_ubound/has_ubound_sdrop h.
<span class="nb">have</span> [M hM] := h O; <span class="kr">exists</span> <span class="nv">M</span> =&gt; y [n _ &lt;-].
<span class="nb">rewrite</span> (@le_trans _ _ (u n)) //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span> hM; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="nb">apply</span>: inf_lb; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n</span> =&gt; /=.
<span class="bp">by</span> <span class="nb">move</span>: ba =&gt; /bounded_fun_has_lbound/has_lbound_sdrop; <span class="bp">exact</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sups_infs</span>.

<span class="kn">Section</span> <span class="nf">lim_sup_lim_inf</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> (<span class="nv">r</span> : R) (<span class="nv">u</span> <span class="nv">v</span> : R^o^nat).

<span class="kn">Definition</span> <span class="nf">lim_sup</span> <span class="nv">u</span> := lim (sups u).

<span class="kn">Definition</span> <span class="nf">lim_inf</span> <span class="nv">u</span> := lim (infs u).

<span class="kn">Lemma</span> <span class="nf">lim_infN</span> <span class="nv">u</span> : cvg u -&gt; lim_inf (-%R \o u) = - lim_sup u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cu_; <span class="nb">rewrite</span> /lim_inf infsN.
<span class="nb">rewrite</span> (@limN _ [normedModType R of R^o] _ _ _ (sups u)) //.
<span class="bp">exact</span>: is_cvg_sups.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_supE</span> <span class="nv">u</span> : bounded_fun u -&gt; lim_sup u = inf (range (sups u)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ba; <span class="nb">apply</span>/cvg_lim; <span class="kp">first</span> <span class="bp">exact</span>: Rhausdorff.
<span class="bp">by</span> <span class="nb">apply</span>/cvg_sups_inf; [<span class="bp">exact</span>/bounded_fun_has_ubound|
                        <span class="bp">exact</span>/bounded_fun_has_lbound].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_infE</span> <span class="nv">u</span> : bounded_fun u -&gt; lim_inf u = sup (range (infs u)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ba; <span class="nb">apply</span>/cvg_lim; <span class="kp">first</span> <span class="bp">exact</span>: Rhausdorff.
<span class="nb">apply</span>/cvg_infs_sup; [<span class="bp">exact</span>/bounded_fun_has_ubound|
                     <span class="bp">exact</span>/bounded_fun_has_lbound].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_inf_le_lim_sup</span> <span class="nv">u</span> : cvg u -&gt; lim_inf u &lt;= lim_sup u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cf_; <span class="nb">apply</span>: ler_lim; [<span class="bp">exact</span>: is_cvg_infs|<span class="bp">exact</span>: is_cvg_sups|].
<span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; n; <span class="nb">apply</span>: infs_le_sups.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_lim_inf_sup</span> <span class="nv">u</span> <span class="nv">l</span> : u --&gt; l -&gt; (lim_inf u = l) * (lim_sup u = l).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ul.
<span class="nb">have</span> /cvg_seq_bounded [M [Mr Mu]] : cvg u <span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: ul.
<span class="nb">suff</span>: lim_sup u &lt;= l &lt;= lim_inf u.
  <span class="nb">move</span>=&gt; /andP[sul liu].
  <span class="nb">have</span> /lim_inf_le_lim_sup iusu : cvg u <span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>: ul.
  <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le liu andbT (le_trans iusu).
  <span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le sul /= (le_trans _ iusu).
<span class="nb">apply</span>/andP; <span class="nb">split</span>.
- <span class="nb">apply</span>/ler_addgt0Pr =&gt; e e0.
  <span class="nb">apply</span>: limr_le; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_sups; <span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> <span class="nv">l</span>.
  <span class="nb">move</span>/cvgrPdist_lt : (ul) =&gt; /(_ _ e0) -[k _ klu].
  near=&gt; n; <span class="nb">have</span> kn : (k &lt;= n)%N <span class="bp">by</span> near: n; <span class="kr">exists</span> <span class="nv">k</span>.
  <span class="nb">apply</span>: sup_le_ub; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">u</span> <span class="nv">n</span>) =&gt; /=; <span class="kr">exists</span> <span class="nv">n</span> =&gt; //=.
  <span class="nb">move</span>=&gt; _ /= [m nm] &lt;-; <span class="nb">apply</span>/ltW/ltr_distl_addr; <span class="nb">rewrite</span> distrC.
  <span class="bp">by</span> <span class="nb">apply</span>: (klu m) =&gt; /=; <span class="nb">rewrite</span> (leq_trans kn).
- <span class="nb">apply</span>/ler_addgt0Pr =&gt; e e0; <span class="nb">rewrite</span> -ler_subl_addr.
  <span class="nb">apply</span>: limr_ge; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: is_cvg_infs; <span class="nb">apply</span>/cvg_ex; <span class="kr">exists</span> <span class="nv">l</span>.
  <span class="nb">move</span>/cvgrPdist_lt : (ul) =&gt; /(_ _ e0) -[k _ klu].
  near=&gt; n; <span class="nb">have</span> kn: (k &lt;= n)%N <span class="bp">by</span> near: n; <span class="kr">exists</span> <span class="nv">k</span>.
  <span class="nb">apply</span>: lb_le_inf; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">u</span> <span class="nv">n</span>) =&gt; /=; <span class="kr">exists</span> <span class="nv">n</span> =&gt; //=.
  <span class="nb">move</span>=&gt; _ /= [m nm] &lt;-; <span class="nb">apply</span>/ltW/ltr_distl_subl.
  <span class="bp">by</span> <span class="nb">apply</span>: (klu m) =&gt; /=; <span class="nb">rewrite</span> (leq_trans kn).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_lim_infE</span> <span class="nv">u</span> : cvg u -&gt; lim_inf u = lim u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvg_ex[l ul]; <span class="nb">have</span> [-&gt; _] := cvg_lim_inf_sup ul.
<span class="bp">by</span> <span class="nb">move</span>/cvg_lim : ul =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_lim_supE</span> <span class="nv">u</span> : cvg u -&gt; lim_sup u = lim u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvg_ex[l ul]; <span class="nb">have</span> [_ -&gt;] := cvg_lim_inf_sup ul.
<span class="bp">by</span> <span class="nb">move</span>/cvg_lim : ul =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_sups</span> <span class="nv">u</span> <span class="nv">l</span> : u --&gt; l -&gt; (sups u) --&gt; (l : R^o).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ul; <span class="nb">have</span> [iul &lt;-] := cvg_lim_inf_sup ul.
<span class="nb">apply</span>/cvg_closeP; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: is_cvg_sups.
<span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="nb">apply</span>: ul.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_infs</span> <span class="nv">u</span> <span class="nv">l</span> : u --&gt; l -&gt; (infs u) --&gt; (l : R^o).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ul; <span class="nb">have</span> [&lt;- iul] := cvg_lim_inf_sup ul.
<span class="nb">apply</span>/cvg_closeP; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: is_cvg_infs.
<span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="nb">apply</span>: ul.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">le_lim_supD</span> <span class="nv">u</span> <span class="nv">v</span> :
  bounded_fun u -&gt; bounded_fun v -&gt; lim_sup (u \+ v) &lt;= lim_sup u + lim_sup v.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ba bb; <span class="nb">have</span> ab k : sups (u \+ v) k &lt;= sups u k + sups v k.
  <span class="nb">apply</span>: sup_le_ub; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> ((u \+ v) k); <span class="kr">exists</span> <span class="nv">k</span> =&gt; /=.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; M [n /= kn &lt;-]; <span class="nb">apply</span>: ler_add; <span class="nb">apply</span>: sup_ub; [
    <span class="bp">exact</span>/has_ubound_sdrop/bounded_fun_has_ubound; <span class="bp">exact</span> | <span class="kr">exists</span> <span class="nv">n</span> |
    <span class="bp">exact</span>/has_ubound_sdrop/bounded_fun_has_ubound; <span class="bp">exact</span> | <span class="kr">exists</span> <span class="nv">n</span> ].
<span class="nb">have</span> cu : cvg (sups u).
  <span class="nb">apply</span>: nonincreasing_is_cvg; <span class="nb">last</span> <span class="bp">exact</span>: bounded_fun_has_lbound_sups.
  <span class="bp">exact</span>/nonincreasing_sups/bounded_fun_has_ubound.
<span class="nb">have</span> cv : cvg (sups v).
  <span class="nb">apply</span>: nonincreasing_is_cvg; <span class="nb">last</span> <span class="bp">exact</span>: bounded_fun_has_lbound_sups.
  <span class="bp">exact</span>/nonincreasing_sups/bounded_fun_has_ubound.
<span class="nb">rewrite</span> -(@limD _ [normedModType R of R^o] _ _ _ _ _ cu cv); <span class="nb">apply</span>: ler_lim.
- <span class="nb">apply</span>: nonincreasing_is_cvg; <span class="nb">last first</span>.
    <span class="bp">exact</span>/bounded_fun_has_lbound_sups/bounded_funD.
  <span class="bp">exact</span>/nonincreasing_sups/bounded_fun_has_ubound/bounded_funD.
- <span class="bp">exact</span>: (@is_cvgD _ [normedModType R of R^o] _ _ _ _ _ cu cv).
- <span class="bp">exact</span>: nearW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">le_lim_infD</span> <span class="nv">u</span> <span class="nv">v</span> :
  bounded_fun u -&gt; bounded_fun v -&gt; lim_inf u + lim_inf v &lt;= lim_inf (u \+ v).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ba bb; <span class="nb">have</span> ab k : infs u k + infs v k &lt;= infs (u \+ v) k.
  <span class="nb">apply</span>: lb_le_inf; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> ((u \+ v) k); <span class="kr">exists</span> <span class="nv">k</span> =&gt; /=.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; M [n /= kn &lt;-]; <span class="nb">apply</span>: ler_add; <span class="nb">apply</span>: inf_lb; [
    <span class="bp">exact</span>/has_lbound_sdrop/bounded_fun_has_lbound; <span class="bp">exact</span> | <span class="kr">exists</span> <span class="nv">n</span> |
    <span class="bp">exact</span>/has_lbound_sdrop/bounded_fun_has_lbound; <span class="bp">exact</span> | <span class="kr">exists</span> <span class="nv">n</span> ].
<span class="nb">have</span> cu : cvg (infs u).
  <span class="nb">apply</span>: nondecreasing_is_cvg; <span class="nb">last</span> <span class="bp">exact</span>: bounded_fun_has_ubound_infs.
  <span class="bp">exact</span>/nondecreasing_infs/bounded_fun_has_lbound.
<span class="nb">have</span> cv : cvg (infs v).
  <span class="nb">apply</span>: nondecreasing_is_cvg; <span class="nb">last</span> <span class="bp">exact</span>: bounded_fun_has_ubound_infs.
  <span class="bp">exact</span>/nondecreasing_infs/bounded_fun_has_lbound.
<span class="nb">rewrite</span> -(@limD _ [normedModType R of R^o] _ _ _ _ _ cu cv); <span class="nb">apply</span>: ler_lim.
- <span class="bp">exact</span>: (@is_cvgD _ [normedModType R of R^o] _ _ _ _ _ cu cv).
- <span class="nb">apply</span>: nondecreasing_is_cvg; <span class="nb">last first</span>.
    <span class="bp">exact</span>/bounded_fun_has_ubound_infs/bounded_funD.
  <span class="bp">exact</span>/nondecreasing_infs/bounded_fun_has_lbound/bounded_funD.
- <span class="bp">exact</span>: nearW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_supD</span> <span class="nv">u</span> <span class="nv">v</span> : cvg u -&gt; cvg v -&gt; lim_sup (u \+ v) = lim_sup u + lim_sup v.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cu cv; <span class="nb">have</span> [ba bb] := (cvg_seq_bounded cu, cvg_seq_bounded cv).
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le le_lim_supD //=.
<span class="nb">have</span> := @le_lim_supD _ _ (bounded_funD ba bb) (bounded_funN bb).
<span class="nb">rewrite</span> -ler_subl_addr; <span class="nb">apply</span>: le_trans.
<span class="nb">rewrite</span> -[_ \+ _]/(u + v - v) addrK -lim_infN; <span class="nb">last</span> <span class="bp">exact</span>: is_cvgN.
<span class="nb">rewrite</span> /comp /=; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> opprK.
<span class="bp">by</span> <span class="nb">rewrite</span> ler_add// cvg_lim_infE// cvg_lim_supE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_infD</span> <span class="nv">u</span> <span class="nv">v</span> : cvg u -&gt; cvg v -&gt; lim_inf (u \+ v) = lim_inf u + lim_inf v.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cu cv; <span class="nb">rewrite</span> (cvg_lim_infE cu) -(cvg_lim_supE cu).
<span class="nb">rewrite</span> (cvg_lim_infE cv) -(cvg_lim_supE cv) -lim_supD//.
<span class="nb">rewrite</span> cvg_lim_supE; <span class="nb">last</span> <span class="bp">exact</span>: (@is_cvgD _ _ _ _ _ _ _ cu cv).
<span class="bp">by</span> <span class="nb">rewrite</span> cvg_lim_infE //; <span class="bp">exact</span>: (@is_cvgD _ _ _ _ _ _ _ cu cv).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">lim_sup_lim_inf</span>.

<span class="kn">Section</span> <span class="nf">esups_einfs</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> (<span class="nv">u</span> : (\bar R)^nat).
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Definition</span> <span class="nf">esups</span> <span class="nv">u</span> := [sequence ereal_sup (sdrop u n)]_n.

<span class="kn">Definition</span> <span class="nf">einfs</span> <span class="nv">u</span> := [sequence ereal_inf (sdrop u n)]_n.

<span class="kn">Lemma</span> <span class="nf">esupsN</span> <span class="nv">u</span> : esups (-%E \o u) = -%E \o einfs u.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; n; <span class="nb">rewrite</span> /esups /= oppeK; <span class="nb">congr</span> (ereal_sup _).
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; [[m /= nm &lt;-]|[_ [m /= nm] &lt;-] &lt;-];
  [<span class="kr">exists</span> (<span class="nv">u</span> <span class="nv">m</span>) =&gt; //; <span class="kr">exists</span> <span class="nv">m</span> | <span class="kr">exists</span> <span class="nv">m</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">einfsN</span> <span class="nv">u</span> : einfs (-%E \o u) = -%E \o esups u.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> RHS](_ : u = -%E \o -%E \o u);
  <span class="nb">rewrite</span> <span class="nl">?esupsN</span> funeqE =&gt; n /=; <span class="nb">rewrite</span> oppeK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nonincreasing_esups</span> <span class="nv">u</span> : nonincreasing_seq (esups u).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>: le_ereal_sup =&gt; _ /= [k nk &lt;-]; <span class="kr">exists</span> <span class="nv">k</span> =&gt; //=.
<span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans mn).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nondecreasing_einfs</span> <span class="nv">u</span> : nondecreasing_seq (einfs u).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; m n mn; <span class="nb">apply</span>: le_ereal_inf =&gt; _ /= [k nk &lt;-]; <span class="kr">exists</span> <span class="nv">k</span> =&gt; //=.
<span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans mn).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">einfs_le_esups</span> <span class="nv">u</span> <span class="nv">n</span> : einfs u n &lt;= esups u n.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /einfs /=; <span class="nb">set</span> A := sdrop _ _; <span class="nb">have</span> [a Aa] : A !=set0.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">u</span> <span class="nv">n</span>); <span class="nb">rewrite</span> /A /=; <span class="kr">exists</span> <span class="nv">n</span> =&gt; //=.
<span class="bp">by</span> <span class="nb">rewrite</span> (@le_trans _ _ a) //; [<span class="bp">exact</span>/ereal_inf_lb|<span class="bp">exact</span>/ereal_sup_ub].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_esups_inf</span> <span class="nv">u</span> : esups u --&gt; ereal_inf (range (esups u)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: ereal_nonincreasing_cvg =&gt; //; <span class="bp">exact</span>: nonincreasing_esups. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_esups</span> <span class="nv">u</span> : cvg (esups u).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>/cvg_esups_inf. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_einfs_sup</span> <span class="nv">u</span> : einfs u --&gt; ereal_sup (range (einfs u)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: ereal_nondecreasing_cvg =&gt; //; <span class="bp">exact</span>: nondecreasing_einfs. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_einfs</span> <span class="nv">u</span> : cvg (einfs u).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span>/cvg_einfs_sup. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">esups_preimage</span> <span class="nv">T</span> (<span class="nv">a</span> : \bar R) (<span class="nv">f</span> : (T -&gt; \bar R)^nat) <span class="nv">n</span> :
  (<span class="kr">fun</span> <span class="nv">x</span> =&gt; esups (f^~x) n) @^-<span class="mi">1</span>` `]a, +oo[ =
  \bigcup_(k <span class="kr">in</span> [<span class="nb">set</span> k | n &lt;= k]%N) f k @^-<span class="mi">1</span>` `]a, +oo[.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; /=.
  <span class="nb">rewrite</span> /= in_itv /= andbT=&gt; /ereal_sup_gt[_ [/= k nk &lt;-]] afnt.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span> =&gt; //=; <span class="nb">rewrite</span> in_itv /= afnt.
<span class="nb">move</span>=&gt; -[k /= nk] /=; <span class="nb">rewrite</span> in_itv /= andbT =&gt; /lt_le_trans afkt.
<span class="bp">by</span> <span class="nb">rewrite</span> in_itv andbT/=; <span class="nb">apply</span>/afkt/ereal_sup_ub; <span class="kr">exists</span> <span class="nv">k</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">einfs_preimage</span> <span class="nv">T</span> (<span class="nv">a</span> : \bar R) (<span class="nv">f</span> : (T -&gt; \bar R)^nat) <span class="nv">n</span> :
  (<span class="kr">fun</span> <span class="nv">x</span> =&gt; einfs (f^~x) n) @^-<span class="mi">1</span>` `[a, +oo[%classic =
  \bigcap_(k <span class="kr">in</span> [<span class="nb">set</span> k | n &lt;= k]%N) f k @^-<span class="mi">1</span>` `[a, +oo[%classic.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; t; <span class="nb">split</span> =&gt; /= [|h].
  <span class="nb">rewrite</span> in_itv andbT /= =&gt; h k nk /=.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= in_itv/= (le_trans h)//; <span class="nb">apply</span> ereal_inf_lb; <span class="kr">exists</span> <span class="nv">k</span>.
<span class="nb">rewrite</span> /= in_itv /= andbT leNgt; <span class="nb">apply</span>/negP.
<span class="nb">move</span>=&gt; /ereal_inf_lt[_ /= [k nk &lt;-]]; <span class="nb">apply</span>/negP.
<span class="bp">by</span> <span class="nb">have</span> := h _ nk; <span class="nb">rewrite</span> /= in_itv /= andbT -leNgt.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">esups_einfs</span>.

<span class="kn">Module</span> <span class="nf">LimSup</span>.
<span class="kn">Definition</span> <span class="nf">lim_esup</span> (<span class="nv">R</span> : realType) (<span class="nv">u</span> : (\bar R)^nat) := lim (esups u).
<span class="kn">Definition</span> <span class="nf">lim_einf</span> (<span class="nv">R</span> : realType) (<span class="nv">u</span> : (\bar R)^nat) := lim (einfs u).
<span class="kn">End</span> <span class="nf">LimSup</span>.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `lim_esup`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">elim_sup</span> := LimSup.lim_esup.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `lim_einf`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">elim_inf</span> := LimSup.lim_einf.

<span class="kn">Notation</span> <span class="nf">lim_esup</span> := LimSup.lim_esup.
<span class="kn">Notation</span> <span class="nf">lim_einf</span> := LimSup.lim_einf.

<span class="kn">Section</span> <span class="nf">lim_esup_inf</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> (<span class="nv">u</span> <span class="nv">v</span> : (\bar R)^nat) (<span class="nv">l</span> : \bar R).

<span class="kn">Lemma</span> <span class="nf">lim_einf_shift</span> <span class="nv">u</span> <span class="nv">l</span> : l \<span class="kr">is</span> a fin_num -&gt;
  lim_einf (<span class="kr">fun</span> <span class="nv">x</span> =&gt; l + u x) = l + lim_einf u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; lfin; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>: cvg_trans; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: (@cvgeD _ \oo _ _ (cst l) (einfs u) _ (lim (einfs u)));
    [<span class="bp">exact</span>: fin_num_adde_defr|<span class="bp">exact</span>: cvg_cst|<span class="bp">exact</span>: is_cvg_einfs].
<span class="nb">suff</span> : einfs (<span class="kr">fun</span> <span class="nv">n</span> =&gt; l + u n) = (<span class="kr">fun</span> <span class="nv">n</span> =&gt; l + einfs u n) <span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;.
<span class="nb">rewrite</span> funeqE =&gt; n.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
- <span class="nb">rewrite</span> addeC -lee_subl_addr//; <span class="nb">apply</span>: lb_ereal_inf =&gt; /= _ [m /= mn] &lt;-.
  <span class="nb">rewrite</span> lee_subl_addr//; <span class="nb">apply</span>: ereal_inf_lb.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">m</span> =&gt; //; <span class="nb">rewrite</span> addeC.
- <span class="nb">apply</span>: lb_ereal_inf =&gt; /= _ [m /= mn] &lt;-.
  <span class="bp">by</span> <span class="nb">rewrite</span> lee_add2l//; <span class="nb">apply</span>: ereal_inf_lb; <span class="kr">exists</span> <span class="nv">m</span> =&gt; /=.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_esup_le_cvg</span> <span class="nv">u</span> <span class="nv">l</span> : lim_esup u &lt;= l -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, l &lt;= u n) -&gt; u --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; supul ul; <span class="nb">have</span> usupu n : l &lt;= u n &lt;= esups u n.
  <span class="bp">by</span> <span class="nb">rewrite</span> ul /=; <span class="nb">apply</span>/ereal_sup_ub; <span class="kr">exists</span> <span class="nv">n</span> =&gt; /=.
<span class="nb">suff</span> : esups u --&gt; l.
  <span class="bp">by</span> <span class="nb">apply</span>: (@squeeze_cvge _ _ _ _ (cst l)) =&gt; //; [<span class="bp">exact</span>: nearW|<span class="bp">exact</span>: cvg_cst].
<span class="nb">apply</span>/cvg_closeP; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: is_cvg_esups.
<span class="nb">rewrite</span> closeE//; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le supul.
<span class="nb">apply</span>: (lime_ge (@is_cvg_esups _ _)); <span class="nb">apply</span>: nearW =&gt; m.
<span class="nb">have</span> /le_trans : l &lt;= einfs u m <span class="bp">by</span> <span class="nb">apply</span>: lb_ereal_inf =&gt; _ [p /= pm] &lt;-.
<span class="bp">by</span> <span class="nb">apply</span>; <span class="bp">exact</span>: einfs_le_esups.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_einfN</span> <span class="nv">u</span> : lim_einf (-%E \o u) = - lim_esup u.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> /lim_einf einfsN /lim_esup limeN //; <span class="bp">exact</span>/is_cvg_esups.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_esupN</span> <span class="nv">u</span> : lim_esup (-%E \o u) = - lim_einf u.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> -eqe_oppLR -lim_einfN /=.
<span class="bp">by</span> <span class="nb">rewrite</span> (_ : _ \o _ = u) // funeqE =&gt; n /=; <span class="nb">rewrite</span> oppeK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_einf_sup</span> <span class="nv">u</span> : lim_einf u &lt;= lim_esup u.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: lee_lim; [<span class="bp">exact</span>/is_cvg_einfs|<span class="bp">exact</span>/is_cvg_esups|].
<span class="bp">by</span> <span class="nb">apply</span>: nearW; <span class="bp">exact</span>: einfs_le_esups.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgNy_lim_einf_sup</span> <span class="nv">u</span> : u --&gt; -oo -&gt;
  (lim_einf u = -oo) * (lim_esup u = -oo).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; uoo; <span class="nb">suff</span>: lim_esup u = -oo.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; {}uoo; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> -leeNy_eq -uoo lim_einf_sup.
<span class="nb">apply</span>: cvg_lim =&gt; //=. <span class="nb">apply</span>/cvgeNyPle =&gt; M.
<span class="nb">have</span> /cvgeNyPle/(_ M)[m _ uM] := uoo.
near=&gt; n; <span class="nb">apply</span>: ub_ereal_sup =&gt; _ [k /= nk &lt;-].
<span class="bp">by</span> <span class="nb">apply</span>: uM =&gt; /=; <span class="nb">rewrite</span> (leq_trans _ nk)//; near: n; <span class="kr">exists</span> <span class="nv">m</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgNy_einfs</span> <span class="nv">u</span> : u --&gt; -oo -&gt; einfs u --&gt; -oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvgNy_lim_einf_sup[uoo _].
<span class="bp">by</span> <span class="nb">apply</span>/cvg_closeP; <span class="nb">split</span>; [<span class="bp">exact</span>: is_cvg_einfs|<span class="nb">rewrite</span> closeE].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgNy_esups</span> <span class="nv">u</span> : u --&gt; -oo -&gt; esups u --&gt; -oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvgNy_lim_einf_sup[_ uoo].
<span class="bp">by</span> <span class="nb">apply</span>/cvg_closeP; <span class="nb">split</span>; [<span class="bp">exact</span>: is_cvg_esups|<span class="nb">rewrite</span> closeE].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgy_einfs</span> <span class="nv">u</span> : u --&gt; +oo -&gt; einfs u --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvgeN/cvgNy_esups/cvgeN; <span class="nb">rewrite</span> esupsN.
<span class="bp">by</span> <span class="nb">under</span> eq_cvg <span class="kp">do</span> <span class="nb">rewrite</span> /= oppeK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgy_esups</span> <span class="nv">u</span> : u --&gt; +oo -&gt; esups u --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvgeN/cvgNy_einfs/cvgeN; <span class="nb">rewrite</span> einfsN.
<span class="bp">by</span> <span class="nb">under</span> eq_cvg <span class="kp">do</span> <span class="nb">rewrite</span> /= oppeK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_esups</span> <span class="nv">u</span> <span class="nv">l</span> : u --&gt; l -&gt; esups u --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">case</span>: l =&gt; [l /fine_cvgP[u_fin_num] ul| |]; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
  - <span class="bp">exact</span>: cvgy_esups.
  - <span class="bp">exact</span>: cvgNy_esups.
<span class="nb">have</span> [p _ pu] := u_fin_num; <span class="nb">apply</span>/cvg_ballP =&gt; _/posnumP[e].
<span class="nb">have</span> : EFin \o sups (fine \o u) --&gt; l%:E.
  <span class="bp">by</span> <span class="nb">apply</span>: continuous_cvg =&gt; //; <span class="nb">apply</span>: cvg_sups.
<span class="nb">move</span>=&gt; /cvg_ballP /(_ e%:num (gt0 _))[q _ qsupsu]; near=&gt; n.
<span class="nb">have</span> -&gt; : esups u n = (EFin \o sups (fine \o u)) n.
  <span class="nb">rewrite</span> /= -ereal_sup_EFin; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
    - <span class="nb">apply</span>/has_ubound_sdrop/bounded_fun_has_ubound.
      <span class="bp">by</span> <span class="nb">apply</span>/cvg_seq_bounded/cvg_ex; <span class="nb">eexists</span>; <span class="bp">exact</span> ul.
    - <span class="bp">by</span> <span class="nb">eexists</span>; <span class="nb">rewrite</span> /sdrop /=; <span class="kr">exists</span> <span class="nv">n</span>; [|<span class="bp">reflexivity</span>].
  <span class="nb">congr</span> (ereal_sup _).
  <span class="nb">rewrite</span> predeqE =&gt; y; <span class="nb">split</span>=&gt; [[m /= nm &lt;-{y}]|[r [m /= nm &lt;-{r} &lt;-{y}]]].
    <span class="nb">have</span> /pu : (p &lt;= m)%N <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans _ nm) //; near: n; <span class="kr">exists</span> <span class="nv">p</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; /fineK umE; <span class="nb">eexists</span>; [<span class="kr">exists</span> <span class="nv">m</span>|<span class="bp">exact</span>/umE].
  <span class="nb">have</span> /pu : (p &lt;= m)%N <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans _ nm) //; near: n; <span class="kr">exists</span> <span class="nv">p</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /fineK umE; <span class="kr">exists</span> <span class="nv">m</span> =&gt; //; <span class="bp">exact</span>/umE.
<span class="bp">by</span> <span class="nb">apply</span>: qsupsu =&gt; /=; near: n; <span class="kr">exists</span> <span class="nv">q</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_einfs</span> <span class="nv">u</span> <span class="nv">l</span> : u --&gt; l -&gt; einfs u --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvgeN/cvg_esups/cvgeN; <span class="nb">rewrite</span> oppeK esupsN.
<span class="bp">by</span> <span class="nb">under</span> eq_cvg <span class="kp">do</span> <span class="nb">rewrite</span> /= oppeK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_lim_einf_sup</span> <span class="nv">u</span> <span class="nv">l</span> : u --&gt; l -&gt; (lim_einf u = l) * (lim_esup u = l).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ul; <span class="nb">split</span>; <span class="nb">apply</span>/cvg_lim =&gt; //; [<span class="nb">apply</span>/cvg_einfs|<span class="nb">apply</span>/cvg_esups].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_lim_einfE</span> <span class="nv">u</span> : cvg u -&gt; lim_einf u = lim u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvg_ex[l ul]; <span class="nb">have</span> [-&gt; _] := cvg_lim_einf_sup ul.
<span class="bp">by</span> <span class="nb">move</span>/cvg_lim : ul =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_lim_esupE</span> <span class="nv">u</span> : cvg u -&gt; lim_esup u = lim u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvg_ex[l ul]; <span class="nb">have</span> [_ -&gt;] := cvg_lim_einf_sup ul.
<span class="bp">by</span> <span class="nb">move</span>/cvg_lim : ul =&gt; -&gt;.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">lim_esup_inf</span>.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `lim_einf_shift`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">elim_inf_shift</span> := lim_einf_shift.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `lim_esup_le_cvg`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">elim_sup_le_cvg</span> := lim_esup_le_cvg.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `lim_einfN`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">elim_infN</span> := lim_einfN.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `lim_esupN`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">elim_supN</span> := lim_esupN.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `lim_einf_sup`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">elim_inf_sup</span> := lim_einf_sup.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `cvgNy_lim_einf_sup`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_ninfty_elim_inf_sup</span> := cvgNy_lim_einf_sup.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `cvgNy_einfs`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_ninfty_einfs</span> := cvgNy_einfs.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `cvgNy_esups`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_ninfty_esups</span> := cvgNy_esups.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `cvgy_einfs`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_pinfty_einfs</span> := cvgy_einfs.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `cvgy_esups`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_pinfty_esups</span> := cvgy_esups.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `cvg_lim_einf_sup`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_elim_inf_sup</span> := cvg_lim_einf_sup.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `is_cvg_lim_einfE`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">is_cvg_elim_infE</span> := is_cvg_lim_einfE.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed to `is_cvg_lim_esupE`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">is_cvg_elim_supE</span> := is_cvg_lim_esupE.

<span class="kn">Section</span> <span class="nf">banach_contraction</span>.

<span class="kn">Context</span> {<span class="nv">R</span> : realType} {<span class="nv">X</span> : completeNormedModType R} (<span class="nv">U</span> : <span class="nb">set</span> X).
<span class="kn">Variables</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">U</span> &gt;-&gt; U}).

<span class="kn">Section</span> <span class="nf">contractions</span>.
<span class="kn">Variables</span> (<span class="nv">q</span> : {nonneg R}) (<span class="nv">ctrf</span> : contraction q f) (<span class="nv">base</span> : X) (<span class="nv">Ubase</span> : U base).
<span class="kn">Let</span> <span class="nf">C</span> := `|f base - base| / (<span class="mi">1</span> - q%:num).
<span class="kn">Let</span> <span class="nf">y</span> := <span class="kr">fun</span> <span class="nv">n</span> =&gt; iter n f base.
<span class="kn">Let</span> <span class="nf">q1</span> := ctrf.<span class="mi">1</span>.
<span class="kn">Let</span> <span class="nf">ctrfq</span> := ctrf.<span class="mi">2</span>.
<span class="kn">Let</span> <span class="nf">C_ge0</span> : <span class="mi">0</span> &lt;= C.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> ?(invr_ge0, mulr_ge0, subr_ge0, ltW q1). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">contraction_dist</span> <span class="nv">n</span> <span class="nv">m</span> : `|y n - y (n + m)| &lt;= C * q%:num ^+ n.
<span class="kn">Proof</span>.
<span class="nb">have</span> f1 k : `|y k.+<span class="mi">1</span> - y k| &lt;= q%:num ^+ k * `|f base - base|.
  <span class="nb">elim</span>: k =&gt; [|k /(ler_wpmul2l (ge0 q))]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> expr0 mul1r.
  <span class="nb">rewrite</span> mulrA -exprS; <span class="nb">apply</span>: le_trans.
  <span class="bp">by</span> <span class="nb">rewrite</span> (@ctrfq (y k.+<span class="mi">1</span>, y k)); <span class="nb">split</span>; <span class="bp">exact</span>: funS.
<span class="nb">have</span> /le_trans -&gt; // : `| y n - y (n + m)| &lt;=
    series (geometric (`|f base - base| * q%:num ^+ n) q%:num) m.
  <span class="nb">elim</span>: m =&gt; [|m ih].
    <span class="bp">by</span> <span class="nb">rewrite</span> geometric_seriesE <span class="nl">?lt_eqF</span>//= addn0 subrr normr0 subrr mulr0 mul0r.
  <span class="nb">rewrite</span> (le_trans (ler_dist_add (y (n + m)%N) _ _))//.
  <span class="nb">apply</span>: (le_trans (ler_add ih _)); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> distrC addnS; <span class="bp">exact</span>: f1.
  <span class="nb">rewrite</span> [_ * `|_|]mulrC exprD mulrA geometric_seriesE <span class="nl">?lt_eqF</span>//=.
  <span class="nb">rewrite</span> -!/(`<span class="mi">1</span>-_) (onem_PosNum ctrf.<span class="mi">1</span>) (onemX_NngNum (ltW ctrf.<span class="mi">1</span>)).
  <span class="nb">rewrite</span> -!mulrA -mulrDr ler_pmul// -mulrDr exprSr onemM -addrA.
  <span class="nb">rewrite</span> -[<span class="kr">in</span> leRHS](mulrC _ `<span class="mi">1</span>-(_ ^+ m)) -onemMr onemK.
  <span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> leRHS]mulrDl mulrAC mulrV <span class="nl">?mul1r</span>// unitf_gt0// onem_gt0.
<span class="nb">rewrite</span> geometric_seriesE <span class="nl">?lt_eqF</span>//= -[leRHS]mulr1 (ACl (<span class="mi">1</span>*<span class="mi">4</span>*<span class="mi">2</span>*<span class="mi">3</span>))/= -/C.
<span class="bp">by</span> <span class="nb">rewrite</span> ler_wpmul2l// <span class="mi">1</span><span class="nl">?mulr_ge0</span>// ler_subl_addr ler_addl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">contraction_cvg</span> : cvg y.
<span class="kn">Proof</span>.
<span class="nb">apply</span>/cauchy_cvgP; <span class="nb">apply</span>/cauchy_ballP =&gt; _/posnumP[e]; near_simpl.
<span class="nb">have</span> lt_min n m : `|y n - y m| &lt;= C * q%:num ^+ minn n m.
  <span class="nb">wlog</span> : n m / (n &lt;= m)%N =&gt; W.
    <span class="bp">by</span> <span class="nb">case</span>/orP: (leq_total n m) =&gt; /W //; <span class="nb">rewrite</span> distrC minnC.
  <span class="bp">by</span> <span class="nb">rewrite</span> (minn_idPl _)// (le_trans _ (contraction_dist _ (m - n)))// subnKC.
<span class="nb">case</span>: ltrgt0P C_ge0 =&gt; // [Cpos|C0] _; <span class="nb">last first</span>.
  near=&gt; n m =&gt; /=; <span class="nb">rewrite</span> -ball_normE.
  <span class="bp">by</span> <span class="nb">apply</span>: (le_lt_trans (lt_min _ _)); <span class="nb">rewrite</span> C0 mul0r.
near=&gt; n; <span class="nb">rewrite</span> -ball_normE /= (le_lt_trans (lt_min n.<span class="mi">1</span> n.<span class="mi">2</span>)) //.
<span class="nb">rewrite</span> // -ltr_pdivl_mull //.
<span class="nb">suff</span> : ball <span class="mi">0</span> (C^-<span class="mi">1</span> * e%:num) (q%:num ^+ minn n.<span class="mi">1</span> n.<span class="mi">2</span>).
  <span class="bp">by</span> <span class="nb">rewrite</span> /ball /= sub0r normrN ger0_norm.
near: n; <span class="nb">rewrite</span> nbhs_simpl.
<span class="nb">pose</span> g := <span class="kr">fun</span> <span class="nv">w</span> : nat * nat =&gt; q%:num ^+ minn w.<span class="mi">1</span> w.<span class="mi">2</span>.
<span class="nb">have</span> := @fcvg_ball _ _ (g @ filter_prod \oo \oo) _ <span class="mi">0</span> _ (C^-<span class="mi">1</span> * e%:num).
<span class="nb">move</span>: (@cvg_geometric _ <span class="mi">1</span> q%:num); <span class="nb">rewrite</span> ger0_norm // =&gt; /(_ q1) geo.
near_simpl; <span class="nb">apply</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> mulr_gt0 // invr_gt0.
<span class="nb">apply</span>/cvg_ballP =&gt; _/posnumP[delta]; near_simpl.
<span class="nb">have</span> [N _ Q] : \<span class="kr">forall</span> <span class="nv">N</span> \near \oo, ball <span class="mi">0</span> delta%:num (geometric <span class="mi">1</span> q%:num N).
  <span class="bp">exact</span>: (@fcvg_ball R R _ _ <span class="mi">0</span> geo).
<span class="kr">exists</span> ([<span class="nb">set</span> n | N &lt;= n], [<span class="nb">set</span> n | N &lt;= n])%N; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">split</span>; <span class="kr">exists</span> <span class="nv">N</span>.
<span class="nb">move</span>=&gt; [n m] [Nn Nm]; <span class="nb">rewrite</span> /ball /= sub0r normrN ger0_norm /g //.
<span class="nb">apply</span>: le_lt_trans; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: (Q N) =&gt; /=.
<span class="nb">rewrite</span> sub0r normrN ger0_norm /geometric //= mul1r.
<span class="bp">by</span> <span class="nb">rewrite</span> ler_wiexpn2l // <span class="nl">?ltW</span> // leq_min Nn.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">contraction_cvg_fixed</span> : closed U -&gt; lim y = f (lim y).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; clU; <span class="nb">apply</span>: cvg_lim =&gt; //.
<span class="nb">apply</span>/cvgrPdist_lt =&gt; _/posnumP[e]; near_simpl; <span class="nb">apply</span>: near_inftyS.
<span class="nb">have</span> [q_gt0 | | q0] := ltrgt0P q%:num.
- near=&gt; n =&gt; /=; <span class="nb">apply</span>: (le_lt_trans (@ctrfq (_, _) _)) =&gt; //=.
  + <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: funS.
    <span class="bp">by</span> <span class="nb">apply</span>: closed_cvg contraction_cvg =&gt; //; <span class="nb">apply</span>: nearW =&gt; ?; <span class="bp">exact</span>: funS.
  + <span class="nb">rewrite</span> -ltr_pdivl_mull //; near: n; <span class="nb">move</span>/cvgrPdist_lt: contraction_cvg; <span class="nb">apply</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> mulr_gt0 // invr_gt0.
- <span class="bp">by</span> <span class="nb">rewrite</span> ltNge//; <span class="bp">exact</span>: contraNP.
- <span class="nb">apply</span>: nearW =&gt; /= n; <span class="nb">apply</span>: (le_lt_trans (@ctrfq (_, _) _)).
  + <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span>: funS.
    <span class="bp">by</span> <span class="nb">apply</span>: closed_cvg contraction_cvg =&gt; //; <span class="nb">apply</span>: nearW =&gt; ?; <span class="bp">exact</span>: funS.
  + <span class="bp">by</span> <span class="nb">rewrite</span> q0 mul0r.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">contractions</span>.

<span class="kn">Variable</span> <span class="nv">ctrf</span> : is_contraction f.

<span class="kn">Theorem</span> <span class="nf">banach_fixed_point</span> : closed U -&gt; U !=set0 -&gt; <span class="kr">exists2</span> p, U p &amp; p = f p.
<span class="kn">Proof</span>.
<span class="nb">case</span>: ctrf =&gt; [q ctrq] ? [base Ubase]; <span class="kr">exists</span> (<span class="nv">lim</span> (iter n f base @[n --&gt;\oo])).
  <span class="nb">apply</span>: closed_cvg (contraction_cvg ctrq Ubase) =&gt; //.
  <span class="bp">by</span> <span class="nb">apply</span>: nearW =&gt; ?; <span class="bp">exact</span>: funS.
<span class="bp">exact</span>: (contraction_cvg_fixed ctrq).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">banach_contraction</span>.</span></pre></article></body></html>