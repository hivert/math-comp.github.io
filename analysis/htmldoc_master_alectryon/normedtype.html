<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>normedtype.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect ssralg ssrint ssrnum finmap matrix.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predI _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predU _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predD _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ predC _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ preim _ of _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closedM;
                   GRing.smulr_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedN] : GRing.subring_closed &gt;-&gt; GRing.oppr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedM; GRing.smulr_closedM] : GRing.subring_closed &gt;-&gt; GRing.mulr_closed.
New coercion path [GRing.subring_closed_semi;
                   GRing.semiring_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subring_closedB; GRing.zmod_closedD] : GRing.subring_closed &gt;-&gt; GRing.addr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.sdivr_closed_div;
                   GRing.divr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.sdivr_closedM; GRing.smulr_closedM] : GRing.sdivr_closed &gt;-&gt; GRing.mulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.subalg_closedBM;
                   GRing.subring_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.subalg_closedZ; GRing.submod_closedB] : GRing.subalg_closed &gt;-&gt; GRing.zmod_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divring_closed_div;
                   GRing.sdivr_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divring_closedBM; GRing.subring_closedM] : GRing.divring_closed &gt;-&gt; GRing.smulr_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.divalg_closedBdiv;
                   GRing.divring_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.divalg_closedZ; GRing.subalg_closedBM] : GRing.divalg_closed &gt;-&gt; GRing.subring_closed.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [GRing.Pred.subring_smul;
                   GRing.Pred.smul_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[GRing.Pred.subring_semi; GRing.Pred.semiring_mul] : GRing.Pred.subring &gt;-&gt; GRing.Pred.mul.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> rat interval zmodp vector fieldext falgebra.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> boolp classical_sets functions.
<span class="kn">From</span> mathcomp.classical <span class="kn">Require Import</span> cardinality set_interval mathcomp_extra.
<span class="kn">Require Import</span> ereal reals signed topology prodnormedzmodule.

<span class="sd">(******************************************************************************)</span>
<span class="c">(* This file extends the topological hierarchy with norm-related notions.     *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* Note that balls in topology.v are not necessarily open, here they are.     *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Normed Topological Abelian groups:                                       *)</span>
<span class="c">(*  pseudoMetricNormedZmodType R  == interface type for a normed topological  *)</span>
<span class="c">(*                                   Abelian group equipped with a norm       *)</span>
<span class="c">(*  PseudoMetricNormedZmodule.Mixin nb == builds the mixin for a normed       *)</span>
<span class="c">(*                                   topological Abelian group from the       *)</span>
<span class="c">(*                                   compatibility between the norm and       *)</span>
<span class="c">(*                                   balls; the carrier type must have a      *)</span>
<span class="c">(*                                   normed Zmodule over a numDomainType.     *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Normed modules :                                                         *)</span>
<span class="c">(*                normedModType K == interface type for a normed module       *)</span>
<span class="c">(*                                   structure over the numDomainType K.      *)</span>
<span class="c">(*           NormedModMixin normZ == builds the mixin for a normed module     *)</span>
<span class="c">(*                                   from the property of the linearity of    *)</span>
<span class="c">(*                                   the norm; the carrier type must have a   *)</span>
<span class="c">(*                                   pseudoMetricNormedZmodType structure     *)</span>
<span class="c">(*            NormedModType K T m == packs the mixin m to build a             *)</span>
<span class="c">(*                                   normedModType K; T must have canonical   *)</span>
<span class="c">(*                                   pseudoMetricNormedZmodType K and         *)</span>
<span class="c">(*                                   pseudoMetricType structures.             *)</span>
<span class="c">(*  [normedModType K of T for cT] == T-clone of the normedModType K structure *)</span>
<span class="c">(*                                   cT.                                      *)</span>
<span class="c">(*         [normedModType K of T] == clone of a canonical normedModType K     *)</span>
<span class="c">(*                                   structure on T.                          *)</span>
<span class="c">(*                           `|x| == the norm of x (notation from ssrnum).    *)</span>
<span class="c">(*                      ball_norm == balls defined by the norm.               *)</span>
<span class="c">(*                      nbhs_norm == neighborhoods defined by the norm.       *)</span>
<span class="c">(*                    closed_ball == closure of a ball.                       *)</span>
<span class="c">(*   f @`[ a , b ], f @`] a , b [ == notations for images of intervals,       *)</span>
<span class="c">(*                                   intended for continuous, monotonous      *)</span>
<span class="c">(*                                   functions, defined in ring_scope and     *)</span>
<span class="c">(*                                   classical_set_scope respectively as:     *)</span>
<span class="c">(*                  f @`[ a , b ] := `[minr (f a) (f b), maxr (f a) (f b)]%O  *)</span>
<span class="c">(*                  f @`] a , b [ := `]minr (f a) (f b), maxr (f a) (f b)[%O  *)</span>
<span class="c">(*                  f @`[ a , b ] := `[minr (f a) (f b),                      *)</span>
<span class="c">(*                                     maxr (f a) (f b)]%classic              *)</span>
<span class="c">(*                  f @`] a , b [ := `]minr (f a) (f b),                      *)</span>
<span class="c">(*                                     maxr (f a) (f b)[%classic              *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Domination notations:                                                    *)</span>
<span class="c">(*              dominated_by h k f F == `|f| &lt;= k * `|h|, near F              *)</span>
<span class="c">(*                  bounded_near f F == f is bounded near F                   *)</span>
<span class="c">(*            [bounded f x | x in A] == f is bounded on A, ie F := globally A *)</span>
<span class="c">(*   [locally [bounded f x | x in A] == f is locally bounded on A             *)</span>
<span class="c">(*                       bounded_set == set of bounded sets.                  *)</span>
<span class="c">(*                                   := [set A | [bounded x | x in A]]        *)</span>
<span class="c">(*                       bounded_fun == set of functions bounded on their     *)</span>
<span class="c">(*                                      whole domain.                         *)</span>
<span class="c">(*                                   := [set f | [bounded f x | x in setT]]   *)</span>
<span class="c">(*                  lipschitz_on f F == f is lipschitz near F                 *)</span>
<span class="c">(*          [lipschitz f x | x in A] == f is lipschitz on A                   *)</span>
<span class="c">(* [locally [lipschitz f x | x in A] == f is locally lipschitz on A           *)</span>
<span class="c">(*               k.-lipschitz_on f F == f is k.-lipschitz near F              *)</span>
<span class="c">(*                  k.-lipschitz_A f == f is k.-lipschitz on A                *)</span>
<span class="c">(*        [locally k.-lipschitz_A f] == f is locally k.-lipschitz on A        *)</span>
<span class="c">(*                   contraction q f == f is q.-lipschitz and q &lt; 1           *)</span>
<span class="c">(*                  is_contraction f == exists q, f is q.-lipschitz and q &lt; 1 *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*                     is_interval E == the set E is an interval              *)</span>
<span class="c">(*                bigcup_ointsub U q == union of open real interval included  *)</span>
<span class="c">(*                                      in U and that contain the rational    *)</span>
<span class="c">(*                                      number q                              *)</span>
<span class="c">(*                           Rhull A == the real interval hull of a set A     *)</span>
<span class="c">(*                         shift x y == y + x                                 *)</span>
<span class="c">(*                          center c := shift (- c)                           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Complete normed modules :                                                *)</span>
<span class="c">(*        completeNormedModType K == interface type for a complete normed     *)</span>
<span class="c">(*                                   module structure over a realFieldType    *)</span>
<span class="c">(*                                   K.                                       *)</span>
<span class="c">(* [completeNormedModType K of T] == clone of a canonical complete normed     *)</span>
<span class="c">(*                                   module structure over K on T.            *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* * Filters :                                                                *)</span>
<span class="c">(*          at_left x, at_right x == filters on real numbers for predicates   *)</span>
<span class="c">(*                                   s.t. nbhs holds on the left/right of x   *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(* --&gt; We used these definitions to prove the intermediate value theorem and  *)</span>
<span class="c">(*     the Heine-Borel theorem, which states that the compact sets of R^n are *)</span>
<span class="c">(*     the closed and bounded sets.                                           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="kn">Reserved Notation</span> <span class="s2">&quot;f @`[ a , b ]&quot;</span> (<span class="kn">at level</span> <span class="mi">20</span>, b <span class="kn">at level</span> <span class="mi">9</span>,
  <span class="kn">format</span> <span class="s2">&quot;f  @`[ a ,  b ]&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;f @`] a , b [&quot;</span> (<span class="kn">at level</span> <span class="mi">20</span>, b <span class="kn">at level</span> <span class="mi">9</span>,
  <span class="kn">format</span> <span class="s2">&quot;f  @`] a ,  b [&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;x ^&#39;+&quot;</span> (<span class="kn">at level</span> <span class="mi">3</span>, <span class="kn">format</span> <span class="s2">&quot;x ^&#39;+&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;x ^&#39;-&quot;</span> (<span class="kn">at level</span> <span class="mi">3</span>, <span class="kn">format</span> <span class="s2">&quot;x ^&#39;-&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;+oo_ R&quot;</span> (<span class="kn">at level</span> <span class="mi">3</span>, <span class="kn">format</span> <span class="s2">&quot;+oo_ R&quot;</span>).
<span class="kn">Reserved Notation</span> <span class="s2">&quot;-oo_ R&quot;</span> (<span class="kn">at level</span> <span class="mi">3</span>, <span class="kn">format</span> <span class="s2">&quot;-oo_ R&quot;</span>).

<span class="kn">Set Implicit Arguments</span>.
<span class="kn">Unset Strict Implicit</span>.
<span class="kn">Unset Printing Implicit Defensive</span>.

<span class="kn">Import</span> Order.TTheory GRing.Theory Num.Def Num.Theory.
<span class="kn">Import</span> numFieldTopology.Exports.

<span class="kn">Local</span> <span class="kn">Open Scope</span> classical_set_scope.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ring_scope.

<span class="kn">Definition</span> <span class="nf">pointed_of_zmodule</span> (<span class="nv">R</span> : zmodType) : pointedType := PointedType R <span class="mi">0</span>.

<span class="kn">Definition</span> <span class="nf">filtered_of_normedZmod</span> (<span class="nv">K</span> : numDomainType) (<span class="nv">R</span> : normedZmodType K)
  : filteredType R := Filtered.Pack (Filtered.<span class="kn">Class</span>
    (@Pointed.class (pointed_of_zmodule R))
    (nbhs_ball_ (ball_ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|x|)))).

<span class="kn">Section</span> <span class="nf">pseudoMetric_of_normedDomain</span>.
<span class="kn">Variables</span> (<span class="nv">K</span> : numDomainType) (<span class="nv">R</span> : normedZmodType K).
<span class="kn">Lemma</span> <span class="nf">ball_norm_center</span> (<span class="nv">x</span> : R) (<span class="nv">e</span> : K) : <span class="mi">0</span> &lt; e -&gt; ball_ normr x e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? /=; <span class="nb">rewrite</span> subrr normr0. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">ball_norm_symmetric</span> (<span class="nv">x</span> <span class="nv">y</span> : R) (<span class="nv">e</span> : K) :
  ball_ normr x e y -&gt; ball_ normr y e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /= distrC. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">ball_norm_triangle</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : R) (<span class="nv">e1</span> <span class="nv">e2</span> : K) :
  ball_ normr x e1 y -&gt; ball_ normr y e2 z -&gt; ball_ normr x (e1 + e2) z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /= ? ?; <span class="nb">rewrite</span> -(subr0 x) -(subrr y) opprD opprK (addrA x _ y) -addrA.
<span class="bp">by</span> <span class="nb">rewrite</span> (le_lt_trans (ler_norm_add _ _)) // ltr_add.
<span class="kn">Qed</span>.
<span class="kn">Definition</span> <span class="nf">pseudoMetric_of_normedDomain</span>
  : PseudoMetric.mixin_of K (@entourage_ K R R (ball_ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|x|)))
  := PseudoMetricMixin ball_norm_center ball_norm_symmetric ball_norm_triangle erefl.

<span class="kn">Lemma</span> <span class="nf">nbhs_ball_normE</span> :
  @nbhs_ball_ K R R (ball_ normr) = nbhs_ (entourage_ (ball_ normr)).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /nbhs_ entourage_E predeq2E =&gt; x A; <span class="nb">split</span>.
  <span class="nb">move</span>=&gt; [e egt0 sbeA].
  <span class="bp">by</span> <span class="kr">exists</span> [<span class="nb">set</span> xy | ball_ normr xy.<span class="mi">1</span> e xy.<span class="mi">2</span>] =&gt; //; <span class="kr">exists</span> <span class="nv">e</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; [E [e egt0 sbeE] sEA]; <span class="kr">exists</span> <span class="nv">e</span> =&gt; // ??; <span class="nb">apply</span>/sEA/sbeE.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">pseudoMetric_of_normedDomain</span>.

<span class="kn">Lemma</span> <span class="nf">nbhsN</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">x</span> : R) : nbhs (- x) = -%R @ x.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> predeqE =&gt; A; <span class="nb">split</span>=&gt; //= -[] e e_gt0 xeA; <span class="kr">exists</span> <span class="nv">e</span> =&gt; //= y /=.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: xeA =&gt; //=; <span class="nb">rewrite</span> -opprD normrN.
<span class="bp">by</span> <span class="nb">rewrite</span> -opprD normrN =&gt; ?; <span class="nb">rewrite</span> -[y]opprK; <span class="nb">apply</span>: xeA; <span class="nb">rewrite</span> /= opprK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhsNimage</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">x</span> : R) :
  nbhs (- x) = [<span class="nb">set</span> -%R @` A | A <span class="kr">in</span> nbhs x].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> nbhsN /fmap/=; <span class="nb">under</span> eq_set =&gt; A <span class="kp">do</span> <span class="nb">rewrite</span> preimageEinv//= inv_oppr.
<span class="bp">by</span> <span class="nb">rewrite</span> (eq_imageK opprK opprK).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nearN</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">x</span> : R) (<span class="nv">P</span> : R -&gt; <span class="kt">Prop</span>) :
  (\<span class="kr">forall</span> <span class="nv">y</span> \near - x, P y) &lt;-&gt; \near x, P (- x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -near_simpl nbhsN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">openN</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">A</span> : <span class="nb">set</span> R) :
  open A -&gt; open [<span class="nb">set</span> - x | x <span class="kr">in</span> A].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Aop; <span class="nb">rewrite</span> openE =&gt; _ [x /Aop x_A &lt;-].
<span class="bp">by</span> <span class="nb">rewrite</span> /interior nbhsNimage; <span class="kr">exists</span> <span class="nv">A</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closedN</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">A</span> : <span class="nb">set</span> R) :
  closed A -&gt; closed [<span class="nb">set</span> - x | x <span class="kr">in</span> A].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Acl x clNAx.
<span class="nb">suff</span> /Acl : closure A (- x) <span class="bp">by</span> <span class="kr">exists</span> (- x)=&gt; //; <span class="nb">rewrite</span> opprK.
<span class="nb">move</span>=&gt; B oppx_B; <span class="nb">have</span> : [<span class="nb">set</span> - x | x <span class="kr">in</span> A] `&amp;` [<span class="nb">set</span> - x | x <span class="kr">in</span> B] !=set0.
  <span class="bp">by</span> <span class="nb">apply</span>: clNAx; <span class="nb">rewrite</span> -[x]opprK nbhsNimage; <span class="kr">exists</span> <span class="nv">B</span>.
<span class="nb">move</span>=&gt; [y [[z Az oppzey] [t Bt opptey]]]; <span class="kr">exists</span> (- y).
<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">rewrite</span> -oppzey opprK|<span class="nb">rewrite</span> -opptey opprK].
<span class="kn">Qed</span>.

<span class="kn">Module</span> <span class="nf">PseudoMetricNormedZmodule</span>.
<span class="kn">Section</span> <span class="nf">ClassDef</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : numDomainType.
<span class="kn">Record</span> <span class="nf">mixin_of</span> (<span class="nv">T</span> : normedZmodType R) (<span class="nv">ent</span> : <span class="nb">set</span> (<span class="nb">set</span> (T * T)))
    (<span class="nv">m</span> : PseudoMetric.mixin_of R ent) := Mixin {
  _ : PseudoMetric.ball m = ball_ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `| x |) }.

<span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">T</span> : <span class="kt">Type</span>) := <span class="kn">Class</span> {
  base : Num.NormedZmodule.class_of R T;
  pointed_mixin : Pointed.point_of T ;
  nbhs_mixin : Filtered.nbhs_of T T ;
  topological_mixin : @Topological.mixin_of T nbhs_mixin ;
  uniform_mixin : @Uniform.mixin_of T nbhs_mixin ;
  pseudoMetric_mixin :
    @PseudoMetric.mixin_of R T (Uniform.entourage uniform_mixin) ;
  mixin : @mixin_of (Num.NormedZmodule.Pack _ base) _ pseudoMetric_mixin
}.
<span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Num.NormedZmodule.class_of.
<span class="kn">Definition</span> <span class="nf">base2</span> <span class="nv">T</span> <span class="nv">c</span> := @PseudoMetric.<span class="kn">Class</span> <span class="nf">_</span> <span class="nv">_</span>
    (@Uniform.Class _
      (@Topological.Class _
        (Filtered.Class
         (Pointed.Class (@base T c) (pointed_mixin c))
         (nbhs_mixin c))
        (topological_mixin c))
      (uniform_mixin c))
    (<span class="nv">pseudoMetric_mixin</span> <span class="nv">c</span>).
<span class="kn">Local Coercion</span> <span class="nf">base2</span> : class_of &gt;-&gt; PseudoMetric.class_of.
<span class="c">(* TODO: base3? *)</span>

<span class="kn">Structure</span> <span class="nf">type</span> (<span class="nv">phR</span> : phant R) :=
  Pack { sort; _ : class_of sort }.
<span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.

<span class="kn">Variables</span> (<span class="nv">phR</span> : phant R) (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type phR).

<span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of cT <span class="kr">in</span> c.
<span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack phR T c.
<span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.
<span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of xT).
<span class="kn">Definition</span> <span class="nf">pack</span> (<span class="nv">b0</span> : Num.NormedZmodule.class_of R T) <span class="nv">lm0</span> <span class="nv">um0</span>
  (<span class="nv">m0</span> : @mixin_of (@Num.NormedZmodule.Pack R (Phant R) T b0) lm0 um0) :=
  <span class="kr">fun</span> <span class="nv">bT</span> (<span class="nv">b</span> : Num.NormedZmodule.class_of R T)
      &amp; phant_id (@Num.NormedZmodule.class R (Phant R) bT) b =&gt;
  <span class="kr">fun</span> <span class="nv">uT</span> (<span class="nv">u</span> : PseudoMetric.class_of R T) &amp; phant_id (@PseudoMetric.class R uT) u =&gt;
  <span class="kr">fun</span> (<span class="nv">m</span> : @mixin_of (Num.NormedZmodule.Pack _ b) _ u) &amp; phant_id m m0 =&gt;
  @Pack phR T (@<span class="kn">Class</span> <span class="nf">T</span> <span class="nv">b</span> <span class="nv">u</span> <span class="nv">u</span> <span class="nv">u</span> <span class="nv">u</span> <span class="nv">u</span> <span class="nv">m</span>).

<span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">zmodType</span> := @GRing.Zmodule.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">normedZmodType</span> := @Num.NormedZmodule.Pack R phR cT xclass.
<span class="kn">Definition</span> <span class="nf">pointedType</span> := @Pointed.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">filteredType</span> := @Filtered.Pack cT cT xclass.
<span class="kn">Definition</span> <span class="nf">topologicalType</span> := @Topological.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">uniformType</span> := @Uniform.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetricType</span> := @PseudoMetric.Pack R cT xclass.
<span class="kn">Definition</span> <span class="nf">pointed_zmodType</span> := @GRing.Zmodule.Pack pointedType xclass.
<span class="kn">Definition</span> <span class="nf">filtered_zmodType</span> := @GRing.Zmodule.Pack filteredType xclass.
<span class="kn">Definition</span> <span class="nf">topological_zmodType</span> := @GRing.Zmodule.Pack topologicalType xclass.
<span class="kn">Definition</span> <span class="nf">uniform_zmodType</span> := @GRing.Zmodule.Pack uniformType xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetric_zmodType</span> := @GRing.Zmodule.Pack pseudoMetricType xclass.
<span class="kn">Definition</span> <span class="nf">pointed_normedZmodType</span> := @Num.NormedZmodule.Pack R phR pointedType xclass.
<span class="kn">Definition</span> <span class="nf">filtered_normedZmodType</span> := @Num.NormedZmodule.Pack R phR filteredType xclass.
<span class="kn">Definition</span> <span class="nf">topological_normedZmodType</span> := @Num.NormedZmodule.Pack R phR topologicalType xclass.
<span class="kn">Definition</span> <span class="nf">uniform_normedZmodType</span> := @Num.NormedZmodule.Pack R phR uniformType xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetric_normedZmodType</span> := @Num.NormedZmodule.Pack R phR pseudoMetricType xclass.

<span class="kn">End</span> <span class="nf">ClassDef</span>.

<span class="c">(*Definition numDomain_normedDomainType (R : numDomainType) : type (Phant R) :=</span>
<span class="c">  Pack (Phant R) (@Class R _ _ (NumDomain.normed_mixin (NumDomain.class R))).*)</span>

<span class="kn">Module</span> <span class="nf">Exports</span>.
<span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; Num.NormedZmodule.class_of.
<span class="kn">Coercion</span> <span class="nf">base2</span> : class_of &gt;-&gt; PseudoMetric.class_of.
<span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.
<span class="kn">Canonical</span> <span class="nf">eqType</span>.
<span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.
<span class="kn">Canonical</span> <span class="nf">choiceType</span>.
<span class="kn">Coercion</span> <span class="nf">zmodType</span> : type &gt;-&gt; GRing.Zmodule.type.
<span class="kn">Canonical</span> <span class="nf">zmodType</span>.
<span class="kn">Coercion</span> <span class="nf">normedZmodType</span> : type &gt;-&gt; Num.NormedZmodule.type.
<span class="kn">Canonical</span> <span class="nf">normedZmodType</span>.
<span class="kn">Coercion</span> <span class="nf">pointedType</span> : type &gt;-&gt; Pointed.type.
<span class="kn">Canonical</span> <span class="nf">pointedType</span>.
<span class="kn">Coercion</span> <span class="nf">filteredType</span> : type &gt;-&gt; Filtered.type.
<span class="kn">Canonical</span> <span class="nf">filteredType</span>.
<span class="kn">Coercion</span> <span class="nf">topologicalType</span> : type &gt;-&gt; Topological.type.
<span class="kn">Canonical</span> <span class="nf">topologicalType</span>.
<span class="kn">Coercion</span> <span class="nf">uniformType</span> : type &gt;-&gt; Uniform.type.
<span class="kn">Canonical</span> <span class="nf">uniformType</span>.
<span class="kn">Coercion</span> <span class="nf">pseudoMetricType</span> : type &gt;-&gt; PseudoMetric.type.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_zmodType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_zmodType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_zmodType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_zmodType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_zmodType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_normedZmodType</span>.
<span class="kn">Notation</span> <span class="nf">pseudoMetricNormedZmodType</span> R := (type (Phant R)).
<span class="kn">Notation</span> <span class="nf">PseudoMetricNormedZmodType</span> R T m :=
  (@pack _ (Phant R) T _ _ _ m _ _ idfun _ _ idfun _ idfun).
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;pseudoMetricNormedZmodType&#39; R &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> :=
  (@clone _ (Phant R) T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;pseudoMetricNormedZmodType&#39;  R  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) :
  form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;pseudoMetricNormedZmodType&#39; R &#39;of&#39; T ]&quot;</span> :=
  (@clone _ (Phant R) T _ _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;pseudoMetricNormedZmodType&#39;  R  &#39;of&#39;  T ]&quot;</span>) : form_scope.
<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">PseudoMetricNormedZmodule</span>.
<span class="kn">Export</span> PseudoMetricNormedZmodule.Exports.

<span class="kn">Section</span> <span class="nf">pseudoMetricnormedzmodule_lemmas</span>.
<span class="kn">Context</span> {<span class="nv">K</span> : numDomainType} {<span class="nv">V</span> : pseudoMetricNormedZmodType K}.

<span class="kn">Local Notation</span> <span class="nf">ball_norm</span> := (ball_ (@normr K V)).

<span class="kn">Lemma</span> <span class="nf">ball_normE</span> : ball_norm = ball.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: V =&gt; ? [? ? ? ? ? ? []]. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">pseudoMetricnormedzmodule_lemmas</span>.</span></pre><div class="doc">
neighborhoods 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">Nbhs&#39;</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">T</span> : pseudoMetricType R}.

<span class="kn">Lemma</span> <span class="nf">ex_ball_sig</span> (<span class="nv">x</span> : T) (<span class="nv">P</span> : <span class="nb">set</span> T) :
  ~ (<span class="kr">forall</span> <span class="nv">eps</span> : {posnum R}, ~ (ball x eps%:num `&lt;=` ~` P)) -&gt;
    {d : {posnum R} | ball x d%:num `&lt;=` ~` P}.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> forallNE notK =&gt; exNP.
<span class="nb">pose</span> D := [<span class="nb">set</span> d : R^o | d &gt; <span class="mi">0</span> /\ ball x d `&lt;=` ~` P].
<span class="nb">have</span> [|d_gt0] := @getPex _ D; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">PosNum</span> <span class="nv">d_gt0</span>).
<span class="bp">by</span> <span class="nb">move</span>: exNP =&gt; [e eP]; <span class="kr">exists</span> <span class="nv">e</span>%:num.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhsC</span> (<span class="nv">x</span> : T) (<span class="nv">P</span> : <span class="nb">set</span> T) :
  ~ (<span class="kr">forall</span> <span class="nv">eps</span> : {posnum R}, ~ (ball x eps%:num `&lt;=` ~` P)) -&gt;
  nbhs x (~` P).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /ex_ball_sig [e] ?; <span class="nb">apply</span>/nbhs_ballP; <span class="kr">exists</span> <span class="nv">e</span>%:num =&gt; /=. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhsC_ball</span> (<span class="nv">x</span> : T) (<span class="nv">P</span> : <span class="nb">set</span> T) :
  nbhs x (~` P) -&gt; {d : {posnum R} | ball x d%:num `&lt;=` ~` P}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /nbhs_ballP xNP; <span class="nb">apply</span>: ex_ball_sig.
<span class="bp">by</span> <span class="nb">have</span> [_ /posnumP[e] eP /(_ _ eP)] := xNP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_ex</span> (<span class="nv">x</span> : T) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) : nbhs x P -&gt;
  {d : {posnum R} | <span class="kr">forall</span> <span class="nv">y</span>, ball x d%:num y -&gt; P y}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /nbhs_ballP xP.
<span class="nb">pose</span> D := [<span class="nb">set</span> d : R^o | d &gt; <span class="mi">0</span> /\ <span class="kr">forall</span> <span class="nv">y</span>, ball x d y -&gt; P y].
<span class="nb">have</span> [|d_gt0 dP] := @getPex _ D; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">PosNum</span> <span class="nv">d_gt0</span>).
<span class="bp">by</span> <span class="nb">move</span>: xP =&gt; [e bP]; <span class="kr">exists</span> (<span class="nv">e</span> : R).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Nbhs&#39;</span>.

<span class="kn">Lemma</span> <span class="nf">coord_continuous</span> {<span class="nv">K</span> : numFieldType} <span class="nv">m</span> <span class="nv">n</span> <span class="nv">i</span> <span class="nv">j</span> :
  continuous (<span class="kr">fun</span> <span class="nv">M</span> : &#39;M[K]_(m, n) =&gt; M i j).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /= M s /= /(nbhs_ballP (M i j)) [e e0 es].
<span class="nb">apply</span>/nbhs_ballP; <span class="kr">exists</span> <span class="nv">e</span> =&gt; //= N MN; <span class="bp">exact</span>/es/MN.
<span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">Proper_dnbhs_numFieldType</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">x</span> : R) :
  ProperFilter x^&#39;.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: Build_ProperFilter =&gt; A /nbhs_ballP[_/posnumP[e] Ae].
<span class="kr">exists</span> (<span class="nv">x</span> + e%:num / <span class="mi">2</span>); <span class="nb">apply</span>: Ae; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym addrC -subr_eq subrr eq_sym.
<span class="nb">rewrite</span> /ball /= opprD addrA subrr distrC subr0 ger0_norm //.
<span class="bp">by</span> <span class="nb">rewrite</span> {<span class="mi">2</span>}(splitr e%:num) ltr_spaddl.
<span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">Proper_dnbhs_realType</span> (<span class="nv">R</span> : realType) (<span class="nv">x</span> : R) :
  ProperFilter x^&#39;.
<span class="kn">Proof</span>. <span class="bp">exact</span>: Proper_dnbhs_numFieldType. <span class="kn">Qed</span>.</span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Some Topology on extended real numbers</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">pinfty_nbhs</span> (<span class="nv">R</span> : numFieldType) : <span class="nb">set</span> (<span class="nb">set</span> R) :=
  <span class="kr">fun</span> <span class="nv">P</span> =&gt; <span class="kr">exists</span> <span class="nv">M</span>, M \<span class="kr">is</span> Num.real /\ <span class="kr">forall</span> <span class="nv">x</span>, M &lt; x -&gt; P x.
<span class="kn">Arguments</span> pinfty_nbhs R : <span class="kn">clear implicits</span>.
<span class="kn">Definition</span> <span class="nf">ninfty_nbhs</span> (<span class="nv">R</span> : numFieldType) : <span class="nb">set</span> (<span class="nb">set</span> R) :=
  <span class="kr">fun</span> <span class="nv">P</span> =&gt; <span class="kr">exists</span> <span class="nv">M</span>, M \<span class="kr">is</span> Num.real /\ <span class="kr">forall</span> <span class="nv">x</span>, x &lt; M -&gt; P x.
<span class="kn">Arguments</span> ninfty_nbhs R : <span class="kn">clear implicits</span>.

<span class="kn">Notation</span> <span class="s2">&quot;+oo_ R&quot;</span> := (pinfty_nbhs [numFieldType of R])
  (<span class="kn">only parsing</span>) : ring_scope.
<span class="kn">Notation</span> <span class="s2">&quot;-oo_ R&quot;</span> := (ninfty_nbhs [numFieldType of R])
  (<span class="kn">only parsing</span>) : ring_scope.

<span class="kn">Notation</span> <span class="s2">&quot;+oo&quot;</span> := (pinfty_nbhs _) : ring_scope.
<span class="kn">Notation</span> <span class="s2">&quot;-oo&quot;</span> := (ninfty_nbhs _) : ring_scope.

<span class="kn">Section</span> <span class="nf">infty_nbhs_instances</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numFieldType}.
<span class="kn">Let</span> <span class="nf">R_topologicalType</span> := [topologicalType of R].
<span class="kn">Implicit Types</span> <span class="nv">r</span> : R.

<span class="kn">Global Instance</span> <span class="nf">proper_pinfty_nbhs</span> : ProperFilter (pinfty_nbhs R).
<span class="kn">Proof</span>.
<span class="nb">apply</span> Build_ProperFilter.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; P [M [Mreal MP]]; <span class="kr">exists</span> (<span class="nv">M</span> + <span class="mi">1</span>); <span class="nb">apply</span> MP; <span class="nb">rewrite</span> ltr_addl.
<span class="nb">split</span>=&gt; /= [|P Q [MP [MPr gtMP]] [MQ [MQr gtMQ]] |P Q sPQ [M [Mr gtM]]].
- <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>.
- <span class="kr">exists</span> (<span class="nv">maxr</span> <span class="nv">MP</span> <span class="nv">MQ</span>); <span class="nb">split</span>=&gt; [|x]; <span class="kp">first</span> <span class="bp">exact</span>: max_real.
  <span class="bp">by</span> <span class="nb">rewrite</span> comparable_lt_maxl <span class="nl">?real_comparable</span> // =&gt; /andP[/gtMP ? /gtMQ].
- <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">M</span>; <span class="nb">split</span> =&gt; // ? /gtM /sPQ.
<span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">proper_ninfty_nbhs</span> : ProperFilter (ninfty_nbhs R).
<span class="kn">Proof</span>.
<span class="nb">apply</span> Build_ProperFilter.
  <span class="nb">move</span>=&gt; P [M [Mr ltMP]]; <span class="kr">exists</span> (<span class="nv">M</span> - <span class="mi">1</span>).
  <span class="bp">by</span> <span class="nb">apply</span>: ltMP; <span class="nb">rewrite</span> gtr_addl oppr_lt0.
<span class="nb">split</span>=&gt; /= [|P Q [MP [MPr ltMP]] [MQ [MQr ltMQ]] |P Q sPQ [M [Mr ltM]]].
- <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>.
- <span class="kr">exists</span> (<span class="nv">Num</span>.min MP MQ); <span class="nb">split</span>=&gt; [|x]; <span class="kp">first</span> <span class="bp">exact</span>: min_real.
  <span class="bp">by</span> <span class="nb">rewrite</span> comparable_lt_minr <span class="nl">?real_comparable</span> // =&gt; /andP[/ltMP ? /ltMQ].
- <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">M</span>; <span class="nb">split</span> =&gt; // x /ltM /sPQ.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_pinfty_gt</span> <span class="nv">r</span> : r \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near +oo, r &lt; x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">r</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_pinfty_ge</span> <span class="nv">r</span> : r \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near +oo, r &lt;= x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">r</span>; <span class="nb">split</span> =&gt; //; <span class="nb">apply</span>: ltW. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_ninfty_lt</span> <span class="nv">r</span> : r \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near -oo, r &gt; x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">r</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_ninfty_le</span> <span class="nv">r</span> : r \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near -oo, r &gt;= x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">r</span>; <span class="nb">split</span> =&gt; // ?; <span class="nb">apply</span>: ltW. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_pinfty_real</span> : \<span class="kr">forall</span> <span class="nv">x</span> \near +oo, x \<span class="kr">is</span> @Num.real R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: filterS (nbhs_pinfty_gt (@real0 _)); <span class="nb">apply</span>: gtr0_real. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_ninfty_real</span> : \<span class="kr">forall</span> <span class="nv">x</span> \near -oo, x \<span class="kr">is</span> @Num.real R.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: filterS (nbhs_ninfty_lt (@real0 _)); <span class="nb">apply</span>: ltr0_real. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pinfty_ex_gt</span> (<span class="nv">m</span> : R) (<span class="nv">A</span> : <span class="nb">set</span> R) : m \<span class="kr">is</span> Num.real -&gt;
  (\<span class="kr">forall</span> <span class="nv">k</span> \near +oo, A k) -&gt; <span class="kr">exists2</span> M, m &lt; M &amp; A M.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; m_real Agt; near (pinfty_nbhs R) =&gt; M.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">M</span>; near: M =&gt; //; <span class="nb">apply</span>: nbhs_pinfty_gt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pinfty_ex_ge</span> (<span class="nv">m</span> : R) (<span class="nv">A</span> : <span class="nb">set</span> R) : m \<span class="kr">is</span> Num.real -&gt;
  (\<span class="kr">forall</span> <span class="nv">k</span> \near +oo, A k) -&gt; <span class="kr">exists2</span> M, m &lt;= M &amp; A M.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; m_real Agt; near (pinfty_nbhs R) =&gt; M.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">M</span>; near: M =&gt; //; <span class="nb">apply</span>: nbhs_pinfty_ge.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pinfty_ex_gt0</span> (<span class="nv">A</span> : <span class="nb">set</span> R) :
  (\<span class="kr">forall</span> <span class="nv">k</span> \near +oo, A k) -&gt; <span class="kr">exists2</span> M, M &gt; <span class="mi">0</span> &amp; A M.
<span class="kn">Proof</span>. <span class="bp">exact</span>: pinfty_ex_gt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_pinfty_div2</span> (<span class="nv">A</span> : <span class="nb">set</span> R) :
  (\<span class="kr">forall</span> <span class="nv">k</span> \near +oo, A k) -&gt; (\<span class="kr">forall</span> <span class="nv">k</span> \near +oo, A (k / <span class="mi">2</span>)).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [M [Mreal AM]]; <span class="kr">exists</span> (<span class="nv">M</span> * <span class="mi">2</span>); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> realM.
<span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> -ltr_pdivl_mulr //; <span class="bp">exact</span>: AM.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">infty_nbhs_instances</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt; <span class="nl">?x</span>)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_pinfty_gt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt;= <span class="nl">?x</span>)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_pinfty_ge <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &gt; <span class="nl">?x</span>)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_ninfty_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &gt;= <span class="nl">?x</span>)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_ninfty_le <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="nl">?x</span> \<span class="kr">is</span> Num.real)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_pinfty_real <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="nl">?x</span> \<span class="kr">is</span> Num.real)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_ninfty_real <span class="kr">end</span> : core.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt; <span class="nl">?x</span>)%E) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: ereal_nbhs_pinfty_gt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt;= <span class="nl">?x</span>)%E) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: ereal_nbhs_pinfty_ge <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &gt; <span class="nl">?x</span>)%E) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: ereal_nbhs_ninfty_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &gt;= <span class="nl">?x</span>)%E) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: ereal_nbhs_ninfty_le <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (fine <span class="nl">?x</span> \<span class="kr">is</span> Num.real)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: ereal_nbhs_pinfty_real <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (fine <span class="nl">?x</span> \<span class="kr">is</span> Num.real)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: ereal_nbhs_ninfty_real <span class="kr">end</span> : core.

<span class="kn">Section</span> <span class="nf">cvg_infty_numField</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numFieldType}.

<span class="kn">Let</span> <span class="nf">cvgryPnum</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> R)} {<span class="nv">FF</span> : Filter F} : [&lt;-&gt;
<span class="c">(* 0 *)</span> F --&gt; +oo;
<span class="c">(* 1 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= x;
<span class="c">(* 2 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; x;
<span class="c">(* 3 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near +oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; x;
<span class="c">(* 4 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near +oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= x ].
<span class="kn">Proof</span>.
tfae; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo A Areal; <span class="nb">apply</span>: Foo; <span class="nb">apply</span>: nbhs_pinfty_ge.
- <span class="nb">move</span>=&gt; AF A Areal; near +oo_R =&gt; B.
  <span class="bp">by</span> near <span class="kp">do</span> <span class="nb">apply</span>: (@lt_le_trans _ _ B) =&gt; //=; <span class="nb">apply</span>: AF.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo; near <span class="kp">do</span> <span class="nb">apply</span>: Foo =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: ltW.
<span class="nb">case</span>=&gt; [A [AR AF]] P [x [xR Px]]; near +oo_R =&gt; B.
<span class="bp">by</span> near <span class="kp">do</span> [<span class="nb">apply</span>: Px; <span class="nb">apply</span>: (@lt_le_trans _ _ B) =&gt; //]; <span class="nb">apply</span>: AF.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">cvgrNyPnum</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> R)} {<span class="nv">FF</span> : Filter F} : [&lt;-&gt;
<span class="c">(* 0 *)</span> F --&gt; -oo;
<span class="c">(* 1 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt;= x;
<span class="c">(* 2 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt; x;
<span class="c">(* 3 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near -oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt; x;
<span class="c">(* 4 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near -oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt;= x ].
<span class="kn">Proof</span>.
tfae; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo A Areal; <span class="nb">apply</span>: Foo; <span class="nb">apply</span>: nbhs_ninfty_le.
- <span class="nb">move</span>=&gt; AF A Areal; near -oo_R =&gt; B.
  <span class="bp">by</span> near <span class="kp">do</span> <span class="nb">apply</span>: (@le_lt_trans _ _ B) =&gt; //; <span class="nb">apply</span>: AF.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo; near <span class="kp">do</span> <span class="nb">apply</span>: Foo =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: ltW.
<span class="nb">case</span>=&gt; [A [AR AF]] P [x [xR Px]]; near -oo_R =&gt; B.
<span class="bp">by</span> near <span class="kp">do</span> [<span class="nb">apply</span>: Px; <span class="nb">apply</span>: (@le_lt_trans _ _ B) =&gt; //]; <span class="nb">apply</span>: AF.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Context</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F}.
<span class="kn">Implicit Types</span> <span class="nv">f</span> : T -&gt; R.

<span class="kn">Lemma</span> <span class="nf">cvgryPger</span> <span class="nv">f</span> :
  f @ F --&gt; +oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgryPnum <span class="mi">0</span>%N <span class="mi">1</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgryPgtr</span> <span class="nv">f</span> :
  f @ F --&gt; +oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgryPnum <span class="mi">0</span>%N <span class="mi">2</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgryPgty</span> <span class="nv">f</span> :
  f @ F --&gt; +oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near +oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgryPnum <span class="mi">0</span>%N <span class="mi">3</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgryPgey</span> <span class="nv">f</span> :
  f @ F --&gt; +oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near +oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgryPnum <span class="mi">0</span>%N <span class="mi">4</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNyPler</span> <span class="nv">f</span> :
  f @ F --&gt; -oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgrNyPnum <span class="mi">0</span>%N <span class="mi">1</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNyPltr</span> <span class="nv">f</span> :
  f @ F --&gt; -oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgrNyPnum <span class="mi">0</span>%N <span class="mi">2</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNyPltNy</span> <span class="nv">f</span> :
  f @ F --&gt; -oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near -oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgrNyPnum <span class="mi">0</span>%N <span class="mi">3</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNyPleNy</span> <span class="nv">f</span> :
  f @ F --&gt; -oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near -oo, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgrNyPnum <span class="mi">0</span>%N <span class="mi">4</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgry_ger</span> <span class="nv">f</span> :
  f @ F --&gt; +oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgryPger. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgry_gtr</span> <span class="nv">f</span> :
  f @ F --&gt; +oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgryPgtr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNy_ler</span> <span class="nv">f</span> :
  f @ F --&gt; -oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt;= f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgrNyPler. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNy_ltr</span> <span class="nv">f</span> :
  f @ F --&gt; -oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt; f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgrNyPltr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgNry</span> <span class="nv">f</span> : (- f @ F --&gt; +oo) &lt;-&gt; (f @ F --&gt; -oo).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> cvgrNyPler cvgryPger; <span class="nb">split</span>=&gt; Foo A Areal;
<span class="bp">by</span> near <span class="kp">do</span> <span class="nb">rewrite</span> -ler_opp2 <span class="nl">?opprK</span>; <span class="nb">apply</span>: Foo; <span class="nb">rewrite</span> rpredN.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgNrNy</span> <span class="nv">f</span> : (- f @ F --&gt; -oo) &lt;-&gt; (f @ F --&gt; +oo).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -cvgNry opprK. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvg_infty_numField</span>.

<span class="kn">Section</span> <span class="nf">cvg_infty_realField</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : realFieldType}.
<span class="kn">Context</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; R).

<span class="kn">Lemma</span> <span class="nf">cvgryPge</span> : f @ F --&gt; +oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= f x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgryPger; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> num_real; <span class="nb">split</span>=&gt; + *; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgryPgt</span> : f @ F --&gt; +oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; f x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgryPgtr; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> num_real; <span class="nb">split</span>=&gt; + *; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNyPle</span> : f @ F --&gt; -oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt;= f x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgrNyPler; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> num_real; <span class="nb">split</span>=&gt; + *; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNyPlt</span> : f @ F --&gt; -oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt; f x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgrNyPltr; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> num_real; <span class="nb">split</span>=&gt; + *; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgry_ge</span> : f @ F --&gt; +oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgryPge. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgry_gt</span> : f @ F --&gt; +oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &lt; f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgryPgt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNy_le</span> : f @ F --&gt; -oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt;= f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgrNyPle. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrNy_lt</span> : f @ F --&gt; -oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A &gt; f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgrNyPlt. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvg_infty_realField</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrnyP</span> {<span class="nv">R</span> : realType} {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; nat) :
   (((f n)%:R : R) @[n --&gt; F] --&gt; +oo) &lt;-&gt; (f @ F --&gt; \oo).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [/cvgryPge|/cvgnyPge] Foo.
  <span class="bp">by</span> <span class="nb">apply</span>/cvgnyPge =&gt; A; near <span class="kp">do</span> <span class="nb">rewrite</span> -(@ler_nat R); <span class="nb">apply</span>: Foo.
<span class="nb">apply</span>/cvgryPgey; near=&gt; A; near=&gt; n.
<span class="nb">rewrite</span> (le_trans (@ceil_ge R A))// (ler_int _ _ (f n)) [ceil _]intEsign.
<span class="bp">by</span> <span class="nb">rewrite</span> le_gtF <span class="nl">?expr0</span> <span class="nl">?mul1r</span> <span class="nl">?lez_nat</span> <span class="nl">?ceil_ge0</span>//; near: n; <span class="nb">apply</span>: Foo.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">ecvg_infty_numField</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Context</span> {<span class="nv">R</span> : numFieldType}.

<span class="kn">Let</span> <span class="nf">cvgeyPnum</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> \bar R)} {<span class="nv">FF</span> : Filter F} : [&lt;-&gt;
<span class="c">(* 0 *)</span> F --&gt; +oo;
<span class="c">(* 1 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt;= x;
<span class="c">(* 2 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt; x;
<span class="c">(* 3 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near +oo%R, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt; x;
<span class="c">(* 4 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near +oo%R, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt;= x ].
<span class="kn">Proof</span>.
tfae; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo A Areal; <span class="nb">apply</span>: Foo; <span class="nb">apply</span>: ereal_nbhs_pinfty_ge.
- <span class="nb">move</span>=&gt; AF A Areal; near +oo_R =&gt; B.
  <span class="bp">by</span> near <span class="kp">do</span> <span class="nb">rewrite</span> (@lt_le_trans _ _ B%:E) <span class="nl">?lte_fin</span>//; <span class="nb">apply</span>: AF.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo; near <span class="kp">do</span> <span class="nb">apply</span>: Foo =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: ltW.
<span class="nb">case</span>=&gt; [A [AR AF]] P [x [xR Px]]; near +oo_R =&gt; B.
<span class="bp">by</span> near <span class="kp">do</span> [<span class="nb">apply</span>: Px; <span class="nb">rewrite</span> (@lt_le_trans _ _ B%:E) <span class="nl">?lte_fin</span>//]; <span class="nb">apply</span>: AF.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">cvgeNyPnum</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> \bar R)} {<span class="nv">FF</span> : Filter F} : [&lt;-&gt;
<span class="c">(* 0 *)</span> F --&gt; -oo;
<span class="c">(* 1 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt;= x;
<span class="c">(* 2 *)</span> <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt; x;
<span class="c">(* 3 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near -oo%R, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt; x;
<span class="c">(* 4 *)</span> \<span class="kr">forall</span> <span class="nv">A</span> \near -oo%R, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt;= x ].
<span class="kn">Proof</span>.
tfae; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo A Areal; <span class="nb">apply</span>: Foo; <span class="nb">apply</span>: ereal_nbhs_ninfty_le.
- <span class="nb">move</span>=&gt; AF A Areal; near -oo_R =&gt; B.
  <span class="bp">by</span> near <span class="kp">do</span> <span class="nb">rewrite</span> (@le_lt_trans _ _ B%:E) <span class="nl">?lte_fin</span>//; <span class="nb">apply</span>: AF.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; Foo; near <span class="kp">do</span> <span class="nb">apply</span>: Foo =&gt; //.
- <span class="bp">by</span> <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>: ltW.
<span class="nb">case</span>=&gt; [A [AR AF]] P [x [xR Px]]; near -oo_R =&gt; B.
<span class="bp">by</span> near <span class="kp">do</span> [<span class="nb">apply</span>: Px; <span class="nb">rewrite</span> (@le_lt_trans _ _ B%:E) <span class="nl">?lte_fin</span>//]; <span class="nb">apply</span>: AF.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Context</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> : T -&gt; \bar R) (<span class="nv">u</span> : T -&gt; R).

<span class="kn">Lemma</span> <span class="nf">cvgeyPger</span> <span class="nv">f</span> :
  f @ F --&gt; +oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgeyPnum <span class="mi">0</span>%N <span class="mi">1</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeyPgtr</span> <span class="nv">f</span> :
  f @ F --&gt; +oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgeyPnum <span class="mi">0</span>%N <span class="mi">2</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeyPgty</span> <span class="nv">f</span> :
  f @ F --&gt; +oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near +oo%R, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgeyPnum <span class="mi">0</span>%N <span class="mi">3</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeyPgey</span> <span class="nv">f</span> :
  f @ F --&gt; +oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near +oo%R, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgeyPnum <span class="mi">0</span>%N <span class="mi">4</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNyPler</span> <span class="nv">f</span> :
  f @ F --&gt; -oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgeNyPnum <span class="mi">0</span>%N <span class="mi">1</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNyPltr</span> <span class="nv">f</span> :
  f @ F --&gt; -oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgeNyPnum <span class="mi">0</span>%N <span class="mi">2</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNyPltNy</span> <span class="nv">f</span> :
  f @ F --&gt; -oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near -oo%R, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt; f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgeNyPnum <span class="mi">0</span>%N <span class="mi">3</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNyPleNy</span> <span class="nv">f</span> :
  f @ F --&gt; -oo &lt;-&gt; \<span class="kr">forall</span> <span class="nv">A</span> \near -oo%R, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt;= f x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgeNyPnum <span class="mi">0</span>%N <span class="mi">4</span>%N). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgey_ger</span> <span class="nv">f</span> :
  f @ F --&gt; +oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeyPger. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgey_gtr</span> <span class="nv">f</span> :
  f @ F --&gt; +oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt; f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeyPgtr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNy_ler</span> <span class="nv">f</span> :
  f @ F --&gt; -oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt;= f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeNyPler. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNy_ltr</span> <span class="nv">f</span> :
  f @ F --&gt; -oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, A \<span class="kr">is</span> Num.real -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt; f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeNyPltr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgNey</span> <span class="nv">f</span> : (\- f @ F --&gt; +oo) &lt;-&gt; (f @ F --&gt; -oo).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> cvgeNyPler cvgeyPger; <span class="nb">split</span>=&gt; Foo A Areal;
<span class="bp">by</span> near <span class="kp">do</span> <span class="nb">rewrite</span> -lee_opp2 <span class="nl">?oppeK</span>; <span class="nb">apply</span>: Foo; <span class="nb">rewrite</span> rpredN.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgNeNy</span> <span class="nv">f</span> : (\- f @ F --&gt; -oo) &lt;-&gt; (f @ F --&gt; +oo).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> -cvgNey (_ : \- \- f = f)//; <span class="nb">apply</span>/funeqP =&gt; x /=; <span class="nb">rewrite</span> oppeK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeryP</span> <span class="nv">u</span> : ((u x)%:E @[x --&gt; F] --&gt; +oo) &lt;-&gt; (u @ F --&gt; +oo%R).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [/cvgeyPger|/cvgryPger] Foo.
  <span class="bp">by</span> <span class="nb">apply</span>/cvgryPger =&gt; A Ar; near <span class="kp">do</span> <span class="nb">rewrite</span> -lee_fin; <span class="nb">apply</span>: Foo.
<span class="bp">by</span> <span class="nb">apply</span>/cvgeyPger =&gt; A Ar; near <span class="kp">do</span> <span class="nb">rewrite</span> lee_fin; <span class="nb">apply</span>: Foo.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgerNyP</span> <span class="nv">u</span> : ((u x)%:E @[x --&gt; F] --&gt; -oo) &lt;-&gt; (u @ F --&gt; -oo%R).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [/cvgeNyPler|/cvgrNyPler] Foo.
  <span class="bp">by</span> <span class="nb">apply</span>/cvgrNyPler =&gt; A Ar; near <span class="kp">do</span> <span class="nb">rewrite</span> -lee_fin; <span class="nb">apply</span>: Foo.
<span class="bp">by</span> <span class="nb">apply</span>/cvgeNyPler =&gt; A Ar; near <span class="kp">do</span> <span class="nb">rewrite</span> lee_fin; <span class="nb">apply</span>: Foo.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ecvg_infty_numField</span>.

<span class="kn">Section</span> <span class="nf">ecvg_infty_realField</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Context</span> {<span class="nv">R</span> : realFieldType}.
<span class="kn">Context</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; \bar R).

<span class="kn">Lemma</span> <span class="nf">cvgeyPge</span> : f @ F --&gt; +oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt;= f x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgeyPger; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> num_real; <span class="nb">split</span>=&gt; + *; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeyPgt</span> : f @ F --&gt; +oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt; f x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgeyPgtr; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> num_real; <span class="nb">split</span>=&gt; + *; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNyPle</span> : f @ F --&gt; -oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt;= f x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgeNyPler; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> num_real; <span class="nb">split</span>=&gt; + *; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNyPlt</span> : f @ F --&gt; -oo &lt;-&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt; f x.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgeNyPltr; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">rewrite</span> num_real; <span class="nb">split</span>=&gt; + *; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgey_ge</span> : f @ F --&gt; +oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt;= f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeyPge. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgey_gt</span> : f @ F --&gt; +oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &lt; f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeyPgt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNy_le</span> : f @ F --&gt; -oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt;= f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeNyPle. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNy_lt</span> : f @ F --&gt; -oo -&gt; <span class="kr">forall</span> <span class="nv">A</span>, \<span class="kr">forall</span> <span class="nv">x</span> \near F, A%:E &gt; f x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeNyPlt. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ecvg_infty_realField</span>.

<span class="kn">Lemma</span> <span class="nf">cvgenyP</span> {<span class="nv">R</span> : realType} {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; nat) :
   (((f n)%:R : R)%:E @[n --&gt; F] --&gt; +oo%E) &lt;-&gt; (f @ F --&gt; \oo).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgeryP cvgrnyP. <span class="kn">Qed</span>.</span></pre><div class="doc">
<a id="lab2"></a><h2 class="section">Modules with a norm</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Module</span> <span class="nf">NormedModule</span>.

<span class="kn">Record</span> <span class="nf">mixin_of</span> (<span class="nv">K</span> : numDomainType)
  (<span class="nv">V</span> : pseudoMetricNormedZmodType K) (<span class="nv">scale</span> : K -&gt; V -&gt; V) := Mixin {
  _ : <span class="kr">forall</span> (<span class="nv">l</span> : K) (<span class="nv">x</span> : V), `| scale l x | = `| l | * `| x |;
}.

<span class="kn">Section</span> <span class="nf">ClassDef</span>.

<span class="kn">Variable</span> <span class="nv">K</span> : numDomainType.

<span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">T</span> : <span class="kt">Type</span>) := <span class="kn">Class</span> {
  base : PseudoMetricNormedZmodule.class_of K T ;
  lmodmixin : GRing.Lmodule.mixin_of K (GRing.Zmodule.Pack base) ;
  mixin : @mixin_of K (PseudoMetricNormedZmodule.Pack (Phant K) base)
                      (GRing.Lmodule.scale lmodmixin)
}.
<span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; PseudoMetricNormedZmodule.class_of.
<span class="kn">Local Coercion</span> <span class="nf">base2</span> T (c : class_of T) : GRing.Lmodule.class_of K T :=
  @GRing.Lmodule.<span class="kn">Class</span> <span class="nf">K</span> <span class="nv">T</span> (<span class="nv">base</span> <span class="nv">c</span>) (<span class="nv">lmodmixin</span> <span class="nv">c</span>).
<span class="kn">Local Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; mixin_of.

<span class="kn">Structure</span> <span class="nf">type</span> (<span class="nv">phK</span> : phant K) :=
  Pack { sort; _ : class_of sort }.
<span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.

<span class="kn">Variables</span> (<span class="nv">phK</span> : phant K) (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">cT</span> : type phK).

<span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of cT <span class="kr">in</span> c.
<span class="kn">Definition</span> <span class="nf">clone</span> <span class="nv">c</span> <span class="nv">of</span> <span class="nv">phant_id</span> <span class="nv">class</span> <span class="nv">c</span> := @Pack phK T c.
<span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.
<span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of xT).

<span class="kn">Definition</span> <span class="nf">pack</span> <span class="nv">b0</span> <span class="nv">l0</span>
                (<span class="nv">m0</span> : @mixin_of K (@PseudoMetricNormedZmodule.Pack K (Phant K) T b0)
                                (GRing.Lmodule.scale l0)) :=
  <span class="kr">fun</span> <span class="nv">bT</span> <span class="nv">b</span> &amp; phant_id (@PseudoMetricNormedZmodule.class K (Phant K) bT) b =&gt;
  <span class="kr">fun</span> <span class="nv">l</span> &amp; phant_id l0 l =&gt;
  <span class="kr">fun</span> <span class="nv">m</span> &amp; phant_id m0 m =&gt; Pack phK (@<span class="kn">Class</span> <span class="nf">T</span> <span class="nv">b</span> <span class="nv">l</span> <span class="nv">m</span>).

<span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">zmodType</span> := @GRing.Zmodule.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">normedZmodType</span> := @Num.NormedZmodule.Pack K phK cT xclass.
<span class="kn">Definition</span> <span class="nf">lmodType</span> := @GRing.Lmodule.Pack K phK cT xclass.
<span class="kn">Definition</span> <span class="nf">pointedType</span> := @Pointed.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">filteredType</span> := @Filtered.Pack cT cT xclass.
<span class="kn">Definition</span> <span class="nf">topologicalType</span> := @Topological.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">uniformType</span> := @Uniform.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetricType</span> := @PseudoMetric.Pack K cT xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmodType</span> := @PseudoMetricNormedZmodule.Pack K phK cT xclass.
<span class="kn">Definition</span> <span class="nf">pointed_lmodType</span> := @GRing.Lmodule.Pack K phK pointedType xclass.
<span class="kn">Definition</span> <span class="nf">filtered_lmodType</span> := @GRing.Lmodule.Pack K phK filteredType xclass.
<span class="kn">Definition</span> <span class="nf">topological_lmodType</span> := @GRing.Lmodule.Pack K phK topologicalType xclass.
<span class="kn">Definition</span> <span class="nf">uniform_lmodType</span> := @GRing.Lmodule.Pack K phK uniformType xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetric_lmodType</span> := @GRing.Lmodule.Pack K phK pseudoMetricType xclass.
<span class="kn">Definition</span> <span class="nf">normedZmod_lmodType</span> := @GRing.Lmodule.Pack K phK normedZmodType xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_lmodType</span> := @GRing.Lmodule.Pack K phK pseudoMetricNormedZmodType xclass.
<span class="kn">End</span> <span class="nf">ClassDef</span>.

<span class="kn">Module</span> <span class="nf">Exports</span>.

<span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; PseudoMetricNormedZmodule.class_of.
<span class="kn">Coercion</span> <span class="nf">base2</span> : class_of &gt;-&gt; GRing.Lmodule.class_of.
<span class="kn">Coercion</span> <span class="nf">mixin</span> : class_of &gt;-&gt; mixin_of.
<span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.
<span class="kn">Canonical</span> <span class="nf">eqType</span>.
<span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.
<span class="kn">Canonical</span> <span class="nf">choiceType</span>.
<span class="kn">Coercion</span> <span class="nf">zmodType</span> : type &gt;-&gt; GRing.Zmodule.type.
<span class="kn">Canonical</span> <span class="nf">zmodType</span>.
<span class="kn">Coercion</span> <span class="nf">normedZmodType</span> : type &gt;-&gt; Num.NormedZmodule.type.
<span class="kn">Canonical</span> <span class="nf">normedZmodType</span>.
<span class="kn">Coercion</span> <span class="nf">lmodType</span> : type &gt;-&gt; GRing.Lmodule.type.
<span class="kn">Canonical</span> <span class="nf">lmodType</span>.
<span class="kn">Coercion</span> <span class="nf">pointedType</span> : type &gt;-&gt; Pointed.type.
<span class="kn">Canonical</span> <span class="nf">pointedType</span>.
<span class="kn">Coercion</span> <span class="nf">filteredType</span> : type &gt;-&gt; Filtered.type.
<span class="kn">Canonical</span> <span class="nf">filteredType</span>.
<span class="kn">Coercion</span> <span class="nf">topologicalType</span> : type &gt;-&gt; Topological.type.
<span class="kn">Canonical</span> <span class="nf">topologicalType</span>.
<span class="kn">Coercion</span> <span class="nf">uniformType</span> : type &gt;-&gt; Uniform.type.
<span class="kn">Canonical</span> <span class="nf">uniformType</span>.
<span class="kn">Coercion</span> <span class="nf">pseudoMetricType</span> : type &gt;-&gt; PseudoMetric.type.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricType</span>.
<span class="kn">Coercion</span> <span class="nf">pseudoMetricNormedZmodType</span> : type &gt;-&gt; PseudoMetricNormedZmodule.type.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">pointed_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">filtered_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">topological_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">uniform_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetric_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">normedZmod_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_lmodType</span>.
<span class="kn">Notation</span> <span class="nf">normedModType</span> K := (type (Phant K)).
<span class="kn">Notation</span> <span class="nf">NormedModType</span> K T m := (@pack _ (Phant K) T _ _ m _ _ idfun _ idfun _ idfun).
<span class="kn">Notation</span> <span class="nf">NormedModMixin</span> := Mixin.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;normedModType&#39; K &#39;of&#39; T &#39;for&#39; cT ]&quot;</span> := (@clone _ (Phant K) T cT _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;normedModType&#39;  K  &#39;of&#39;  T  &#39;for&#39;  cT ]&quot;</span>) : form_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;normedModType&#39; K &#39;of&#39; T ]&quot;</span> := (@clone _ (Phant K) T _ _ id)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;normedModType&#39;  K  &#39;of&#39;  T ]&quot;</span>) : form_scope.
<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">NormedModule</span>.

<span class="kn">Export</span> NormedModule.Exports.

<span class="kn">Module</span> <span class="nf">regular_topology</span>.

<span class="kn">Section</span> <span class="nf">regular_topology</span>.
<span class="kn">Local Canonical</span> <span class="nf">pseudoMetricNormedZmodType</span> (R : numFieldType) :=
  @PseudoMetricNormedZmodType
    R R^o
    (PseudoMetricNormedZmodule.Mixin (erefl : @ball _ R = ball_ Num.norm)).
<span class="kn">Local Canonical</span> <span class="nf">normedModType</span> (R : numFieldType) :=
  NormedModType R R^o (@NormedModMixin _ _ ( *:%R : R -&gt; R^o -&gt; _) (@normrM _)).
<span class="kn">End</span> <span class="nf">regular_topology</span>.

<span class="kn">Module</span> <span class="nf">Exports</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">normedModType</span>.
<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">regular_topology</span>.
<span class="kn">Export</span> regular_topology.Exports.

<span class="kn">Module</span> <span class="nf">numFieldNormedType</span>.

<span class="kn">Section</span> <span class="nf">realType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : realType).
<span class="kn">Local Canonical</span> <span class="nf">real_lmodType</span> := [lmodType R of R <span class="kr">for</span> [lmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_lalgType</span> := [lalgType R of R <span class="kr">for</span> [lalgType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_algType</span> := [algType R of R <span class="kr">for</span> [algType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_comAlgType</span> := [comAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">real_unitAlgType</span> := [unitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">real_comUnitAlgType</span> := [comUnitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">real_vectType</span> := [vectType R of R <span class="kr">for</span> [vectType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_FalgType</span> := [FalgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">real_fieldExtType</span> :=
  [fieldExtType R of R <span class="kr">for</span> [fieldExtType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of R <span class="kr">for</span> [pseudoMetricNormedZmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">real_normedModType</span> :=
  [normedModType R of R <span class="kr">for</span> [normedModType R of R^o]].
<span class="kn">End</span> <span class="nf">realType</span>.

<span class="kn">Section</span> <span class="nf">rcfType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : rcfType).
<span class="kn">Local Canonical</span> <span class="nf">rcf_lmodType</span> := [lmodType R of R <span class="kr">for</span> [lmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_lalgType</span> := [lalgType R of R <span class="kr">for</span> [lalgType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_algType</span> := [algType R of R <span class="kr">for</span> [algType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_comAlgType</span> := [comAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">rcf_unitAlgType</span> := [unitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">rcf_comUnitAlgType</span> := [comUnitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">rcf_vectType</span> := [vectType R of R <span class="kr">for</span> [vectType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_FalgType</span> := [FalgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">rcf_fieldExtType</span> :=
  [fieldExtType R of R <span class="kr">for</span> [fieldExtType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of R <span class="kr">for</span> [pseudoMetricNormedZmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">rcf_normedModType</span> :=
  [normedModType R of R <span class="kr">for</span> [normedModType R of R^o]].
<span class="kn">End</span> <span class="nf">rcfType</span>.

<span class="kn">Section</span> <span class="nf">archiFieldType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : archiFieldType).
<span class="kn">Local Canonical</span> <span class="nf">archiField_lmodType</span> :=
  [lmodType R of R <span class="kr">for</span> [lmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_lalgType</span> :=
  [lalgType R of R <span class="kr">for</span> [lalgType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_algType</span> := [algType R of R <span class="kr">for</span> [algType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_comAlgType</span> := [comAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">archiField_unitAlgType</span> := [unitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">archiField_comUnitAlgType</span> := [comUnitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">archiField_vectType</span> :=
  [vectType R of R <span class="kr">for</span> [vectType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_FalgType</span> := [FalgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">archiField_fieldExtType</span> :=
  [fieldExtType R of R <span class="kr">for</span> [fieldExtType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of R <span class="kr">for</span> [pseudoMetricNormedZmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">archiField_normedModType</span> :=
  [normedModType R of R <span class="kr">for</span> [normedModType R of R^o]].
<span class="kn">End</span> <span class="nf">archiFieldType</span>.

<span class="kn">Section</span> <span class="nf">realFieldType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : realFieldType).
<span class="kn">Local Canonical</span> <span class="nf">realField_lmodType</span> := [lmodType R of R <span class="kr">for</span> [lmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_lalgType</span> := [lalgType R of R <span class="kr">for</span> [lalgType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_algType</span> := [algType R of R <span class="kr">for</span> [algType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_comAlgType</span> := [comAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">realField_unitAlgType</span> := [unitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">realField_comUnitAlgType</span> := [comUnitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">realField_vectType</span> := [vectType R of R <span class="kr">for</span> [vectType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_FalgType</span> := [FalgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">realField_fieldExtType</span> :=
  [fieldExtType R of R <span class="kr">for</span> [fieldExtType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of R <span class="kr">for</span> [pseudoMetricNormedZmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">realField_normedModType</span> :=
  [normedModType R of R <span class="kr">for</span> [normedModType R of R^o]].
<span class="kn">Definition</span> <span class="nf">lmod_latticeType</span> := [latticeType of realField_lmodType].
<span class="kn">Definition</span> <span class="nf">lmod_distrLatticeType</span> := [distrLatticeType of realField_lmodType].
<span class="kn">Definition</span> <span class="nf">lmod_orderType</span> := [orderType of realField_lmodType].
<span class="kn">Definition</span> <span class="nf">lmod_realDomainType</span> := [realDomainType of realField_lmodType].
<span class="kn">Definition</span> <span class="nf">lalg_latticeType</span> := [latticeType of realField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_distrLatticeType</span> := [distrLatticeType of realField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_orderType</span> := [orderType of realField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_realDomainType</span> := [realDomainType of realField_lalgType].
<span class="kn">Definition</span> <span class="nf">alg_latticeType</span> := [latticeType of realField_algType].
<span class="kn">Definition</span> <span class="nf">alg_distrLatticeType</span> := [distrLatticeType of realField_algType].
<span class="kn">Definition</span> <span class="nf">alg_orderType</span> := [orderType of realField_algType].
<span class="kn">Definition</span> <span class="nf">alg_realDomainType</span> := [realDomainType of realField_algType].
<span class="kn">Definition</span> <span class="nf">comAlg_latticeType</span> := [latticeType of realField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_distrLatticeType</span> :=
  [distrLatticeType of realField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_orderType</span> := [orderType of realField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_realDomainType</span> := [realDomainType of realField_comAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_latticeType</span> := [latticeType of realField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_distrLatticeType</span> :=
  [distrLatticeType of realField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_orderType</span> := [orderType of realField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_realDomainType</span> := [realDomainType of realField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_latticeType</span> := [latticeType of realField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_distrLatticeType</span> :=
  [distrLatticeType of realField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_orderType</span> := [orderType of realField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_realDomainType</span> :=
  [realDomainType of realField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">vect_latticeType</span> := [latticeType of realField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_distrLatticeType</span> := [distrLatticeType of realField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_orderType</span> := [orderType of realField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_realDomainType</span> := [realDomainType of realField_vectType].
<span class="kn">Definition</span> <span class="nf">Falg_latticeType</span> := [latticeType of realField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_distrLatticeType</span> := [distrLatticeType of realField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_orderType</span> := [orderType of realField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_realDomainType</span> := [realDomainType of realField_FalgType].
<span class="kn">Definition</span> <span class="nf">fieldExt_latticeType</span> := [latticeType of realField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_distrLatticeType</span> :=
  [distrLatticeType of realField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_orderType</span> := [orderType of realField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_realDomainType</span> :=
  [realDomainType of realField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_latticeType</span> :=
  [latticeType of realField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_distrLatticeType</span> :=
  [distrLatticeType of realField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_orderType</span> :=
  [orderType of realField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_realDomainType</span> :=
  [realDomainType of realField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">normedMod_latticeType</span> := [latticeType of realField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_distrLatticeType</span> :=
  [distrLatticeType of realField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_orderType</span> := [orderType of realField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_realDomainType</span> :=
  [realDomainType of realField_normedModType].
<span class="kn">End</span> <span class="nf">realFieldType</span>.

<span class="kn">Section</span> <span class="nf">numClosedFieldType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : numClosedFieldType).
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_lmodType</span> :=
  [lmodType R of R <span class="kr">for</span> [lmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_lalgType</span> :=
  [lalgType R of R <span class="kr">for</span> [lalgType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_algType</span> :=
  [algType R of R <span class="kr">for</span> [algType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_comAlgType</span> := [comAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_unitAlgType</span> := [unitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_comUnitAlgType</span> := [comUnitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_vectType</span> :=
  [vectType R of R <span class="kr">for</span> [vectType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_FalgType</span> := [FalgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_fieldExtType</span> :=
  [fieldExtType R of R <span class="kr">for</span> [fieldExtType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of R <span class="kr">for</span> [pseudoMetricNormedZmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numClosedField_normedModType</span> :=
  [normedModType R of R <span class="kr">for</span> [normedModType R of R^o]].
<span class="kn">Definition</span> <span class="nf">lmod_decFieldType</span> := [decFieldType of numClosedField_lmodType].
<span class="kn">Definition</span> <span class="nf">lmod_closedFieldType</span> := [closedFieldType of numClosedField_lmodType].
<span class="kn">Definition</span> <span class="nf">lalg_decFieldType</span> := [decFieldType of numClosedField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_closedFieldType</span> := [closedFieldType of numClosedField_lalgType].
<span class="kn">Definition</span> <span class="nf">alg_decFieldType</span> := [decFieldType of numClosedField_algType].
<span class="kn">Definition</span> <span class="nf">alg_closedFieldType</span> := [closedFieldType of numClosedField_algType].
<span class="kn">Definition</span> <span class="nf">comAlg_decFieldType</span> := [decFieldType of numClosedField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_closedFieldType</span> :=
  [closedFieldType of numClosedField_comAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_decFieldType</span> := [decFieldType of numClosedField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_closedFieldType</span> :=
  [closedFieldType of numClosedField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_decFieldType</span> :=
  [decFieldType of numClosedField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_closedFieldType</span> :=
  [closedFieldType of numClosedField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">vect_decFieldType</span> := [decFieldType of numClosedField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_closedFieldType</span> := [closedFieldType of numClosedField_vectType].
<span class="kn">Definition</span> <span class="nf">Falg_decFieldType</span> := [decFieldType of numClosedField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_closedFieldType</span> := [closedFieldType of numClosedField_FalgType].
<span class="kn">Definition</span> <span class="nf">fieldExt_decFieldType</span> :=
  [decFieldType of numClosedField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_closedFieldType</span> :=
  [closedFieldType of numClosedField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_decFieldType</span> :=
  [decFieldType of numClosedField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_closedFieldType</span> :=
  [closedFieldType of numClosedField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">normedMod_decFieldType</span> :=
  [decFieldType of numClosedField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_closedFieldType</span> :=
  [closedFieldType of numClosedField_normedModType].
<span class="kn">End</span> <span class="nf">numClosedFieldType</span>.

<span class="kn">Section</span> <span class="nf">numFieldType</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : numFieldType).
<span class="kn">Local Canonical</span> <span class="nf">numField_lmodType</span> := [lmodType R of R <span class="kr">for</span> [lmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_lalgType</span> := [lalgType R of R <span class="kr">for</span> [lalgType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_algType</span> := [algType R of R <span class="kr">for</span> [algType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_comAlgType</span> := [comAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">numField_unitAlgType</span> := [unitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">numField_comUnitAlgType</span> := [comUnitAlgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">numField_vectType</span> := [vectType R of R <span class="kr">for</span> [vectType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_FalgType</span> := [FalgType R of R].
<span class="kn">Local Canonical</span> <span class="nf">numField_fieldExtType</span> :=
  [fieldExtType R of R <span class="kr">for</span> [fieldExtType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of R <span class="kr">for</span> [pseudoMetricNormedZmodType R of R^o]].
<span class="kn">Local Canonical</span> <span class="nf">numField_normedModType</span> :=
  [normedModType R of R <span class="kr">for</span> [normedModType R of R^o]].
<span class="kn">Definition</span> <span class="nf">lmod_porderType</span> := [porderType of numField_lmodType].
<span class="kn">Definition</span> <span class="nf">lmod_numDomainType</span> := [numDomainType of numField_lmodType].
<span class="kn">Definition</span> <span class="nf">lalg_pointedType</span> := [pointedType of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_filteredType</span> := [filteredType R of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_topologicalType</span> := [topologicalType of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_uniformType</span> := [uniformType of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_pseudoMetricType</span> := [pseudoMetricType R of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_normedZmodType</span> := [normedZmodType R of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_normedModType</span> := [normedModType R of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_porderType</span> := [porderType of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">lalg_numDomainType</span> := [numDomainType of numField_lalgType].
<span class="kn">Definition</span> <span class="nf">alg_pointedType</span> := [pointedType of numField_algType].
<span class="kn">Definition</span> <span class="nf">alg_filteredType</span> := [filteredType R of numField_algType].
<span class="kn">Definition</span> <span class="nf">alg_topologicalType</span> := [topologicalType of numField_algType].
<span class="kn">Definition</span> <span class="nf">alg_uniformType</span> := [uniformType of numField_algType].
<span class="kn">Definition</span> <span class="nf">alg_pseudoMetricType</span> := [pseudoMetricType R of numField_algType].
<span class="kn">Definition</span> <span class="nf">alg_normedZmodType</span> := [normedZmodType R of numField_algType].
<span class="kn">Definition</span> <span class="nf">alg_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of numField_algType].
<span class="kn">Definition</span> <span class="nf">alg_normedModType</span> := [normedModType R of numField_algType].
<span class="kn">Definition</span> <span class="nf">alg_porderType</span> := [porderType of numField_algType].
<span class="kn">Definition</span> <span class="nf">alg_numDomainType</span> := [numDomainType of numField_algType].
<span class="kn">Definition</span> <span class="nf">comAlg_pointedType</span> := [pointedType of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_filteredType</span> := [filteredType R of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_topologicalType</span> := [topologicalType of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_uniformType</span> := [uniformType of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_pseudoMetricType</span> :=
  [pseudoMetricType R of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_normedZmodType</span> := [normedZmodType R of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_normedModType</span> := [normedModType R of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_porderType</span> := [porderType of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">comAlg_numDomainType</span> := [numDomainType of numField_comAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_pointedType</span> := [pointedType of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_filteredType</span> := [filteredType R of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_topologicalType</span> := [topologicalType of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_uniformType</span> := [uniformType of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_pseudoMetricType</span> :=
  [pseudoMetricType R of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_normedZmodType</span> := [normedZmodType R of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_normedModType</span> := [normedModType R of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_porderType</span> := [porderType of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">unitAlg_numDomainType</span> := [numDomainType of numField_unitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_pointedType</span> := [pointedType of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_filteredType</span> :=
  [filteredType R of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_topologicalType</span> :=
  [topologicalType of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_uniformType</span> := [uniformType of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_pseudoMetricType</span> :=
  [pseudoMetricType R of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_normedZmodType</span> :=
  [normedZmodType R of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_normedModType</span> :=
  [normedModType R of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_porderType</span> := [porderType of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">comUnitAlg_numDomainType</span> :=
  [numDomainType of numField_comUnitAlgType].
<span class="kn">Definition</span> <span class="nf">vect_pointedType</span> := [pointedType of numField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_filteredType</span> := [filteredType R of numField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_topologicalType</span> := [topologicalType of numField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_uniformType</span> := [uniformType of numField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_pseudoMetricType</span> := [pseudoMetricType R of numField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_normedZmodType</span> := [normedZmodType R of numField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of numField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_normedModType</span> := [normedModType R of numField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_porderType</span> := [porderType of numField_vectType].
<span class="kn">Definition</span> <span class="nf">vect_numDomainType</span> := [numDomainType of numField_vectType].
<span class="kn">Definition</span> <span class="nf">Falg_pointedType</span> := [pointedType of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_filteredType</span> := [filteredType R of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_topologicalType</span> := [topologicalType of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_uniformType</span> := [uniformType of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_pseudoMetricType</span> := [pseudoMetricType R of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_normedZmodType</span> := [normedZmodType R of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_normedModType</span> := [normedModType R of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_porderType</span> := [porderType of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">Falg_numDomainType</span> := [numDomainType of numField_FalgType].
<span class="kn">Definition</span> <span class="nf">fieldExt_pointedType</span> := [pointedType of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_filteredType</span> := [filteredType R of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_topologicalType</span> :=
  [topologicalType of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_uniformType</span> := [uniformType of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_pseudoMetricType</span> :=
  [pseudoMetricType R of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_normedZmodType</span> :=
  [normedZmodType R of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_pseudoMetricNormedZmodType</span> :=
  [pseudoMetricNormedZmodType R of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_normedModType</span> := [normedModType R of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_porderType</span> := [porderType of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">fieldExt_numDomainType</span> := [numDomainType of numField_fieldExtType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_ringType</span> :=
  [ringType of numField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_comRingType</span> :=
  [comRingType of numField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_unitRingType</span> :=
  [unitRingType of numField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_comUnitRingType</span> :=
  [comUnitRingType of numField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_idomainType</span> :=
  [idomainType of numField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_fieldType</span> :=
  [fieldType of numField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_porderType</span> :=
  [porderType of numField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmod_numDomainType</span> :=
  [numDomainType of numField_pseudoMetricNormedZmodType].
<span class="kn">Definition</span> <span class="nf">normedMod_ringType</span> := [ringType of numField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_comRingType</span> := [comRingType of numField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_unitRingType</span> := [unitRingType of numField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_comUnitRingType</span> :=
  [comUnitRingType of numField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_idomainType</span> := [idomainType of numField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_fieldType</span> := [fieldType of numField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_porderType</span> := [porderType of numField_normedModType].
<span class="kn">Definition</span> <span class="nf">normedMod_numDomainType</span> := [numDomainType of numField_normedModType].
<span class="kn">End</span> <span class="nf">numFieldType</span>.

<span class="kn">Module</span> <span class="nf">Exports</span>.
<span class="kn">Export</span> topology.numFieldTopology.Exports.
<span class="c">(* realType *)</span>
<span class="kn">Canonical</span> <span class="nf">real_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">real_lalgType</span>.
<span class="kn">Canonical</span> <span class="nf">real_algType</span>.
<span class="kn">Canonical</span> <span class="nf">real_comAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">real_unitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">real_comUnitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">real_vectType</span>.
<span class="kn">Canonical</span> <span class="nf">real_FalgType</span>.
<span class="kn">Canonical</span> <span class="nf">real_fieldExtType</span>.
<span class="kn">Canonical</span> <span class="nf">real_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">real_normedModType</span>.
<span class="kn">Coercion</span> <span class="nf">real_lmodType</span> : realType &gt;-&gt; lmodType.
<span class="kn">Coercion</span> <span class="nf">real_lalgType</span> : realType &gt;-&gt; lalgType.
<span class="kn">Coercion</span> <span class="nf">real_algType</span> : realType &gt;-&gt; algType.
<span class="kn">Coercion</span> <span class="nf">real_comAlgType</span> : realType &gt;-&gt; comAlgType.
<span class="kn">Coercion</span> <span class="nf">real_unitAlgType</span> : realType &gt;-&gt; unitAlgType.
<span class="kn">Coercion</span> <span class="nf">real_comUnitAlgType</span> : realType &gt;-&gt; comUnitAlgType.
<span class="kn">Coercion</span> <span class="nf">real_vectType</span> : realType &gt;-&gt; vectType.
<span class="kn">Coercion</span> <span class="nf">real_FalgType</span> : realType &gt;-&gt; FalgType.
<span class="kn">Coercion</span> <span class="nf">real_fieldExtType</span> : realType &gt;-&gt; fieldExtType.
<span class="kn">Coercion</span> <span class="nf">real_pseudoMetricNormedZmodType</span> :
  realType &gt;-&gt; pseudoMetricNormedZmodType.
<span class="kn">Coercion</span> <span class="nf">real_normedModType</span> : realType &gt;-&gt; normedModType.
<span class="c">(* rcfType *)</span>
<span class="kn">Canonical</span> <span class="nf">rcf_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_lalgType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_algType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_comAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_unitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_comUnitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_vectType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_FalgType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_fieldExtType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">rcf_normedModType</span>.
<span class="kn">Coercion</span> <span class="nf">rcf_lmodType</span> : rcfType &gt;-&gt; lmodType.
<span class="kn">Coercion</span> <span class="nf">rcf_lalgType</span> : rcfType &gt;-&gt; lalgType.
<span class="kn">Coercion</span> <span class="nf">rcf_algType</span> : rcfType &gt;-&gt; algType.
<span class="kn">Coercion</span> <span class="nf">rcf_comAlgType</span> : rcfType &gt;-&gt; comAlgType.
<span class="kn">Coercion</span> <span class="nf">rcf_unitAlgType</span> : rcfType &gt;-&gt; unitAlgType.
<span class="kn">Coercion</span> <span class="nf">rcf_comUnitAlgType</span> : rcfType &gt;-&gt; comUnitAlgType.
<span class="kn">Coercion</span> <span class="nf">rcf_vectType</span> : rcfType &gt;-&gt; vectType.
<span class="kn">Coercion</span> <span class="nf">rcf_FalgType</span> : rcfType &gt;-&gt; FalgType.
<span class="kn">Coercion</span> <span class="nf">rcf_fieldExtType</span> : rcfType &gt;-&gt; fieldExtType.
<span class="kn">Coercion</span> <span class="nf">rcf_pseudoMetricNormedZmodType</span> :
  rcfType &gt;-&gt; pseudoMetricNormedZmodType.
<span class="kn">Coercion</span> <span class="nf">rcf_normedModType</span> : rcfType &gt;-&gt; normedModType.
<span class="c">(* archiFieldType *)</span>
<span class="kn">Canonical</span> <span class="nf">archiField_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_lalgType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_algType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_comAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_unitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_comUnitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_vectType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_FalgType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_fieldExtType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">archiField_normedModType</span>.
<span class="kn">Coercion</span> <span class="nf">archiField_lmodType</span> : archiFieldType &gt;-&gt; lmodType.
<span class="kn">Coercion</span> <span class="nf">archiField_lalgType</span> : archiFieldType &gt;-&gt; lalgType.
<span class="kn">Coercion</span> <span class="nf">archiField_algType</span> : archiFieldType &gt;-&gt; algType.
<span class="kn">Coercion</span> <span class="nf">archiField_comAlgType</span> : archiFieldType &gt;-&gt; comAlgType.
<span class="kn">Coercion</span> <span class="nf">archiField_unitAlgType</span> : archiFieldType &gt;-&gt; unitAlgType.
<span class="kn">Coercion</span> <span class="nf">archiField_comUnitAlgType</span> : archiFieldType &gt;-&gt; comUnitAlgType.
<span class="kn">Coercion</span> <span class="nf">archiField_vectType</span> : archiFieldType &gt;-&gt; vectType.
<span class="kn">Coercion</span> <span class="nf">archiField_FalgType</span> : archiFieldType &gt;-&gt; FalgType.
<span class="kn">Coercion</span> <span class="nf">archiField_fieldExtType</span> : archiFieldType &gt;-&gt; fieldExtType.
<span class="kn">Coercion</span> <span class="nf">archiField_pseudoMetricNormedZmodType</span> :
  archiFieldType &gt;-&gt; pseudoMetricNormedZmodType.
<span class="kn">Coercion</span> <span class="nf">archiField_normedModType</span> : archiFieldType &gt;-&gt; normedModType.
<span class="c">(* realFieldType *)</span>
<span class="kn">Canonical</span> <span class="nf">realField_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_lalgType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_algType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_comAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_unitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_comUnitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_vectType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_FalgType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_fieldExtType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">realField_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">lmod_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">lmod_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">lmod_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">lmod_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_realDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_latticeType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_distrLatticeType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_orderType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_realDomainType</span>.
<span class="kn">Coercion</span> <span class="nf">realField_lmodType</span> : realFieldType &gt;-&gt; lmodType.
<span class="kn">Coercion</span> <span class="nf">realField_lalgType</span> : realFieldType &gt;-&gt; lalgType.
<span class="kn">Coercion</span> <span class="nf">realField_algType</span> : realFieldType &gt;-&gt; algType.
<span class="kn">Coercion</span> <span class="nf">realField_comAlgType</span> : realFieldType &gt;-&gt; comAlgType.
<span class="kn">Coercion</span> <span class="nf">realField_unitAlgType</span> : realFieldType &gt;-&gt; unitAlgType.
<span class="kn">Coercion</span> <span class="nf">realField_comUnitAlgType</span> : realFieldType &gt;-&gt; comUnitAlgType.
<span class="kn">Coercion</span> <span class="nf">realField_vectType</span> : realFieldType &gt;-&gt; vectType.
<span class="kn">Coercion</span> <span class="nf">realField_FalgType</span> : realFieldType &gt;-&gt; FalgType.
<span class="kn">Coercion</span> <span class="nf">realField_fieldExtType</span> : realFieldType &gt;-&gt; fieldExtType.
<span class="kn">Coercion</span> <span class="nf">realField_pseudoMetricNormedZmodType</span> :
  Num.RealField.type &gt;-&gt; PseudoMetricNormedZmodule.type.
<span class="kn">Coercion</span> <span class="nf">realField_normedModType</span> : Num.RealField.type &gt;-&gt; NormedModule.type.
<span class="c">(* numClosedFieldType *)</span>
<span class="kn">Canonical</span> <span class="nf">numClosedField_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_lalgType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_algType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_comAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_unitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_comUnitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_vectType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_FalgType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_fieldExtType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">numClosedField_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">lmod_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">lmod_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_closedFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_decFieldType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_closedFieldType</span>.
<span class="kn">Coercion</span> <span class="nf">numClosedField_lmodType</span> : numClosedFieldType &gt;-&gt; lmodType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_lalgType</span> : numClosedFieldType &gt;-&gt; lalgType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_algType</span> : numClosedFieldType &gt;-&gt; algType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_comAlgType</span> : numClosedFieldType &gt;-&gt; comAlgType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_unitAlgType</span> : numClosedFieldType &gt;-&gt; unitAlgType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_comUnitAlgType</span> : numClosedFieldType &gt;-&gt; comUnitAlgType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_vectType</span> : numClosedFieldType &gt;-&gt; vectType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_FalgType</span> : numClosedFieldType &gt;-&gt; FalgType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_fieldExtType</span> : numClosedFieldType &gt;-&gt; fieldExtType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_pseudoMetricNormedZmodType</span> :
  numClosedFieldType &gt;-&gt; pseudoMetricNormedZmodType.
<span class="kn">Coercion</span> <span class="nf">numClosedField_normedModType</span> : numClosedFieldType &gt;-&gt; normedModType.
<span class="c">(* numFieldType *)</span>
<span class="kn">Canonical</span> <span class="nf">numField_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_lalgType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_algType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_comAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_unitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_comUnitAlgType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_vectType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_FalgType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_fieldExtType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">numField_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">lmod_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">lmod_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">lalg_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">alg_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">comAlg_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">unitAlg_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">comUnitAlg_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">vect_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">Falg_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_pointedType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_filteredType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_topologicalType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_uniformType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_pseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">fieldExt_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_ringType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_comRingType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_unitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_comUnitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_idomainType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_fieldType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmod_numDomainType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_ringType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_comRingType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_unitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_comUnitRingType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_idomainType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_fieldType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_porderType</span>.
<span class="kn">Canonical</span> <span class="nf">normedMod_numDomainType</span>.
<span class="kn">Coercion</span> <span class="nf">numField_lmodType</span> : numFieldType &gt;-&gt; lmodType.
<span class="kn">Coercion</span> <span class="nf">numField_lalgType</span> : numFieldType &gt;-&gt; lalgType.
<span class="kn">Coercion</span> <span class="nf">numField_algType</span> : numFieldType &gt;-&gt; algType.
<span class="kn">Coercion</span> <span class="nf">numField_comAlgType</span> : numFieldType &gt;-&gt; comAlgType.
<span class="kn">Coercion</span> <span class="nf">numField_unitAlgType</span> : numFieldType &gt;-&gt; unitAlgType.
<span class="kn">Coercion</span> <span class="nf">numField_comUnitAlgType</span> : numFieldType &gt;-&gt; comUnitAlgType.
<span class="kn">Coercion</span> <span class="nf">numField_vectType</span> : numFieldType &gt;-&gt; vectType.
<span class="kn">Coercion</span> <span class="nf">numField_FalgType</span> : numFieldType &gt;-&gt; FalgType.
<span class="kn">Coercion</span> <span class="nf">numField_fieldExtType</span> : numFieldType &gt;-&gt; fieldExtType.
<span class="kn">Coercion</span> <span class="nf">numField_pseudoMetricNormedZmodType</span> :
  numFieldType &gt;-&gt; pseudoMetricNormedZmodType.
<span class="kn">Coercion</span> <span class="nf">numField_normedModType</span> : numFieldType &gt;-&gt; normedModType.
<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">numFieldNormedType</span>.
<span class="kn">Import</span> numFieldNormedType.Exports.

<span class="kn">Section</span> <span class="nf">NormedModule_numDomainType</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">V</span> : normedModType R).

<span class="kn">Lemma</span> <span class="nf">normrZ</span> <span class="nv">l</span> (<span class="nv">x</span> : V) : `| l *: x | = `| l | * `| x |.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: V x =&gt; V0 [a b [c]] //= v; <span class="nb">rewrite</span> c. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">normrZV</span> (<span class="nv">x</span> : V) : `|x| \<span class="kr">in</span> GRing.unit -&gt; `| `| x |^-<span class="mi">1</span> *: x | = <span class="mi">1</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; nxu; <span class="nb">rewrite</span> normrZ normrV// normr_id mulVr. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">NormedModule_numDomainType</span>.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;renamed `normrZ`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">normmZ</span> := normrZ.

<span class="kn">Section</span> <span class="nf">NormedModule_numFieldType</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">V</span> : normedModType R).

<span class="kn">Lemma</span> <span class="nf">normfZV</span> (<span class="nv">x</span> : V) : x != <span class="mi">0</span> -&gt; `| `|x|^-<span class="mi">1</span> *: x | = <span class="mi">1</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -normr_eq0 -unitfE =&gt; /normrZV-&gt;. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">NormedModule_numFieldType</span>.

<span class="kn">Section</span> <span class="nf">PseudoNormedZmod_numDomainType</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">V</span> : pseudoMetricNormedZmodType R).

<span class="kn">Local Notation</span> <span class="nf">ball_norm</span> := (ball_ (@normr R V)).

<span class="kn">Local Notation</span> <span class="nf">nbhs_ball</span> := (@nbhs_ball _ V).

<span class="kn">Local Notation</span> <span class="nf">nbhs_norm</span> := (nbhs_ball_ ball_norm).

<span class="c">(* if we do not give the V argument to nbhs, the universally quantified set that</span>
<span class="c">appears inside the notation for cvg_to has type</span>
<span class="c">set (let &#39;{| PseudoMetricNormedZmodule.sort := T |} := V in T) instead of set V,</span>
<span class="c">which causes an inference problem in derive.v *)</span>
<span class="kn">Lemma</span> <span class="nf">nbhs_nbhs_norm</span> : nbhs_norm = nbhs.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> ball_normE funeqE =&gt; x; <span class="nb">rewrite</span> -filter_from_ballE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_normP</span> <span class="nv">x</span> (<span class="nv">P</span> : V -&gt; <span class="kt">Prop</span>) : (\near x, P x) &lt;-&gt; nbhs_norm x P.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> nbhs_nbhs_norm. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_le_nbhs_norm</span> (<span class="nv">x</span> : V) : @nbhs V _ x `=&gt;` nbhs_norm x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; P [e e0 subP]; <span class="nb">apply</span>/nbhs_normP; <span class="kr">exists</span> <span class="nv">e</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_norm_le_nbhs</span> <span class="nv">x</span> : nbhs_norm x `=&gt;` nbhs x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; P /nbhs_normP [e e0 Pxe]; <span class="kr">exists</span> <span class="nv">e</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_from_norm_nbhs</span> <span class="nv">x</span> :
  @filter_from R _ [<span class="nb">set</span> x : R | <span class="mi">0</span> &lt; x] (ball_norm x) = nbhs x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -nbhs_nbhs_norm ball_normE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_normE</span> (<span class="nv">x</span> : V) (<span class="nv">P</span> : V -&gt; <span class="kt">Prop</span>) :
  nbhs_norm x P = \near x, P x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> nbhs_nbhs_norm near_simpl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">filter_from_normE</span> (<span class="nv">x</span> : V) (<span class="nv">P</span> : V -&gt; <span class="kt">Prop</span>) :
  @filter_from R _ [<span class="nb">set</span> x : R | <span class="mi">0</span> &lt; x] (ball_norm x) P = \near x, P x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> filter_from_norm_nbhs. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_nbhs_norm</span> (<span class="nv">x</span> : V) (<span class="nv">P</span> : V -&gt; <span class="kt">Prop</span>) :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near nbhs_norm x, P x) = \near x, P x.
<span class="kn">Proof</span>. <span class="bp">exact</span>: nbhs_normE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_norm_ball_norm</span> <span class="nv">x</span> (<span class="nv">e</span> : {posnum R}) :
  nbhs_norm x (ball_norm x e%:num).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> ball_normE; <span class="kr">exists</span> <span class="nv">e</span>%:num =&gt; /=. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_ball_norm</span> (<span class="nv">x</span> : V) (<span class="nv">eps</span> : {posnum R}) : nbhs x (ball_norm x eps%:num).
<span class="kn">Proof</span>. <span class="nb">rewrite</span> -nbhs_nbhs_norm; <span class="nb">apply</span>: nbhs_norm_ball_norm. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ball_norm_dec</span> <span class="nv">x</span> <span class="nv">y</span> (<span class="nv">e</span> : R) : {ball_norm x e y} + {~ ball_norm x e y}.
<span class="kn">Proof</span>. <span class="bp">exact</span>: pselect. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ball_norm_sym</span> <span class="nv">x</span> <span class="nv">y</span> (<span class="nv">e</span> : R) : ball_norm x e y -&gt; ball_norm y e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /ball_norm/= -opprB normrN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ball_norm_le</span> <span class="nv">x</span> (<span class="nv">e1</span> <span class="nv">e2</span> : R) :
  e1 &lt;= e2 -&gt; ball_norm x e1 `&lt;=` ball_norm x e2.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; e1e2 y /lt_le_trans; <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">nbhs_simpl</span> := (nbhs_simpl,@nbhs_nbhs_norm,@filter_from_norm_nbhs).

<span class="kn">Lemma</span> <span class="nf">fcvgrPdist_lt</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> V)} {<span class="nv">FF</span> : Filter F} (<span class="nv">y</span> : V) :
  F --&gt; y &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, `|y - y&#39;| &lt; eps.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -filter_fromP /= !nbhs_simpl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrPdist_lt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|y - f t| &lt; eps.
<span class="kn">Proof</span>. <span class="bp">exact</span>: fcvgrPdist_lt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrPdistC_lt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t - y| &lt; eps.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgrPdist_lt; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">rewrite</span> distrC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_dist_lt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">eps</span>, eps &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|y - f t| &lt; eps.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvgrPdist_lt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvg_dist</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> V)} {<span class="nv">FF</span> : Filter F} (<span class="nv">y</span> : V) :
  F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">eps</span>, eps &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, `|y - y&#39;| &lt; eps.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgr_dist_lt. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use `cvgr_dist_lt` or a variation instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_dist</span> := __deprecated__cvg_dist.

<span class="kn">Lemma</span> <span class="nf">cvgr_distC_lt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">eps</span>, eps &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t - y| &lt; eps.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvgrPdistC_lt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_dist_le</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">eps</span>, eps &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|y - f t| &lt;= eps.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; near <span class="kp">do</span> <span class="nb">rewrite</span> ltW//; <span class="nb">apply</span>: cvgr_dist_lt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_distC_le</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">eps</span>, eps &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t - y| &lt;= eps.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; near <span class="kp">do</span> <span class="nb">rewrite</span> ltW//; <span class="nb">apply</span>: cvgr_distC_lt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_norm0P</span> {<span class="nv">P</span> : V -&gt; <span class="kt">Prop</span>} :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near <span class="mi">0</span>, P x) &lt;-&gt;
  filter_from [<span class="nb">set</span> e | <span class="mi">0</span> &lt; e] (<span class="kr">fun</span> <span class="nv">e</span> =&gt; [<span class="nb">set</span> y | `|y| &lt; e]) P.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> nbhs_normP; <span class="nb">split</span>=&gt; -[/= e e0 Pe];
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">e</span> =&gt; // y /=; <span class="nb">have</span> /= := Pe y; <span class="nb">rewrite</span> distrC subr0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr0Pnorm_lt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) :
  f @ F --&gt; <span class="mi">0</span> &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &lt; eps.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgrPdistC_lt; <span class="nb">under</span> eq_forall <span class="kp">do</span> <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">rewrite</span> subr0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr0_norm_lt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) :
  f @ F --&gt; <span class="mi">0</span> -&gt; <span class="kr">forall</span> <span class="nv">eps</span>, eps &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &lt; eps.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvgr0Pnorm_lt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr0_norm_le</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) :
  f @ F --&gt; <span class="mi">0</span> -&gt; <span class="kr">forall</span> <span class="nv">eps</span>, eps &gt; <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &lt;= eps.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? ?; near <span class="kp">do</span> <span class="nb">rewrite</span> ltW//; <span class="nb">apply</span>: cvgr0_norm_lt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs0_lt</span> <span class="nv">e</span> : <span class="mi">0</span> &lt; e -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near (<span class="mi">0</span> : V), `|x| &lt; e.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgr0_norm_lt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dnbhs0_lt</span> <span class="nv">e</span> : <span class="mi">0</span> &lt; e -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near (<span class="mi">0</span> : V)^&#39;, `|x| &lt; e.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; e_gt0; <span class="nb">apply</span>: cvg_within; <span class="nb">apply</span>: nbhs0_lt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs0_le</span> <span class="nv">e</span> : <span class="mi">0</span> &lt; e -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near (<span class="mi">0</span> : V), `|x| &lt;= e.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgr0_norm_le. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dnbhs0_le</span> <span class="nv">e</span> : <span class="mi">0</span> &lt; e -&gt; \<span class="kr">forall</span> <span class="nv">x</span> \near (<span class="mi">0</span> : V)^&#39;, `|x| &lt;= e.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; e_gt0; <span class="nb">apply</span>: cvg_within; <span class="nb">apply</span>: nbhs0_le. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_norm_ball</span> <span class="nv">x</span> (<span class="nv">eps</span> : {posnum R}) : nbhs_norm x (ball x eps%:num).
<span class="kn">Proof</span>. <span class="nb">rewrite</span> nbhs_nbhs_norm; <span class="bp">by</span> <span class="nb">apply</span>: nbhsx_ballx. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhsDl</span> (<span class="nv">P</span> : <span class="nb">set</span> V) (<span class="nv">x</span> <span class="nv">y</span> : V) :
  (\<span class="kr">forall</span> <span class="nv">z</span> \near (x + y), P z) &lt;-&gt; (\near x, P (x + y)).
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; /nbhs_normP[_/posnumP[e]/= Px]; <span class="nb">apply</span>/nbhs_normP; <span class="kr">exists</span> <span class="nv">e</span>%:num =&gt; //=.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; z /= xze; <span class="nb">apply</span>: Px; <span class="nb">rewrite</span> /= opprD addrACA subrr addr0.
<span class="bp">by</span> <span class="nb">move</span>=&gt; z /= xyz; <span class="nb">rewrite</span> -[z](addrNK y); <span class="nb">apply</span>: Px; <span class="nb">rewrite</span> /= opprB addrA.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhsDr</span> (<span class="nv">P</span> : <span class="nb">set</span> V) <span class="nv">x</span> <span class="nv">y</span> :
  (\<span class="kr">forall</span> <span class="nv">z</span> \near (x + y), P z) &lt;-&gt; (\near y, P (x + y)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> addrC nbhsDl -propeqE; <span class="nb">apply</span>: eq_near =&gt; ?; <span class="nb">rewrite</span> addrC. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs0P</span> (<span class="nv">P</span> : <span class="nb">set</span> V) <span class="nv">x</span> : (\near x, P x) &lt;-&gt; (\<span class="kr">forall</span> <span class="nv">e</span> \near <span class="mi">0</span>, P (x + e)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> -nbhsDr addr0. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">PseudoNormedZmod_numDomainType</span>.
#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> normr_ge0 : core.
<span class="kn">Arguments</span> cvgr_dist_lt {_ _ _ F FF}.
<span class="kn">Arguments</span> cvgr_distC_lt {_ _ _ F FF}.
<span class="kn">Arguments</span> cvgr_dist_le {_ _ _ F FF}.
<span class="kn">Arguments</span> cvgr_distC_le {_ _ _ F FF}.
<span class="kn">Arguments</span> cvgr0_norm_lt {_ _ _ F FF}.
<span class="kn">Arguments</span> cvgr0_norm_le {_ _ _ F FF}.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|_ - <span class="nl">?x</span>| &lt; _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr_dist_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|<span class="nl">?x</span> - _| &lt; _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr_distC_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|<span class="nl">?x</span>| &lt; _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr0_norm_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|_ - <span class="nl">?x</span>| &lt;= _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr_dist_le <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|<span class="nl">?x</span> - _| &lt;= _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr_distC_le <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|<span class="nl">?x</span>| &lt;= _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr0_norm_le <span class="kr">end</span> : core.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use `cvgrPdist_lt` or a variation instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_distP</span> := fcvgrPdist_lt.

<span class="kn">Section</span> <span class="nf">open_closed_sets</span>.
<span class="c">(* TODO: duplicate theory within the subspace topology of Num.real</span>
<span class="c">         in a numDomainType *)</span>
<span class="kn">Variable</span> <span class="nv">R</span> : realFieldType.</span></pre><div class="doc">
Some open sets of <span class="inlinecode"><span class="id" title="var">R</span></span>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Lemma</span> <span class="nf">open_lt</span> (<span class="nv">y</span> : R) : open [<span class="nb">set</span> x : R| x &lt; y].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x /=; <span class="nb">rewrite</span> -subr_gt0 =&gt; yDx_gt0. <span class="kr">exists</span> (<span class="nv">y</span> - x) =&gt; // z.
<span class="bp">by</span> <span class="nb">rewrite</span> /= ltr_distlC addrCA subrr addr0 =&gt; /andP[].
<span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> open_lt : core.

<span class="kn">Lemma</span> <span class="nf">open_gt</span> (<span class="nv">y</span> : R) : open [<span class="nb">set</span> x : R | x &gt; y].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x /=; <span class="nb">rewrite</span> -subr_gt0 =&gt; xDy_gt0; <span class="kr">exists</span> (<span class="nv">x</span> - y) =&gt; // z.
<span class="bp">by</span> <span class="nb">rewrite</span> /= ltr_distlC opprB addrCA subrr addr0 =&gt; /andP[].
<span class="kn">Qed</span>.
<span class="kn">Hint Resolve</span> open_gt : core.

<span class="kn">Lemma</span> <span class="nf">open_neq</span> (<span class="nv">y</span> : R) : open [<span class="nb">set</span> x : R | x != y].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (_ : mkset _ = [<span class="nb">set</span> x | x &lt; y] `|` [<span class="nb">set</span> x | x &gt; y]); <span class="kp">first</span> <span class="bp">exact</span>: openU.
<span class="nb">rewrite</span> predeqE =&gt; x /=; <span class="nb">rewrite</span> eq_le !leNgt negb_and !negbK orbC.
<span class="bp">by</span> <span class="nb">symmetry</span>; <span class="nb">apply</span> (rwP orP).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">interval_open</span> <span class="nv">a</span> <span class="nv">b</span> : ~~ bound_side true a -&gt; ~~ bound_side false b -&gt;
  open [<span class="nb">set</span> x : R^o | x \<span class="kr">in</span> Interval a b].
<span class="kn">Proof</span>.
<span class="nb">move</span>: a b =&gt; [[]a|[]] [[]b|[]]// _ _.
- <span class="nb">have</span> -&gt; : [<span class="nb">set</span> x | a &lt; x &lt; b] = [<span class="nb">set</span> x | a &lt; x] `&amp;` [<span class="nb">set</span> x | x &lt; b].
    <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; r; <span class="nb">rewrite</span> /mkset; <span class="nb">split</span> =&gt; [/andP[? ?] //|[-&gt; -&gt;]].
  <span class="bp">by</span> <span class="nb">apply</span> openI; [<span class="bp">exact</span>: open_gt | <span class="bp">exact</span>: open_lt].
- <span class="bp">by</span> <span class="nb">under</span> eq_set <span class="kp">do</span> <span class="nb">rewrite</span> itv_ge// inE.
- <span class="bp">by</span> <span class="nb">under</span> eq_set <span class="kp">do</span> <span class="nb">rewrite</span> in_itv andbT/=; <span class="bp">exact</span>: open_gt.
- <span class="bp">exact</span>: open_lt.
- <span class="bp">by</span> <span class="nb">rewrite</span> (_ : mkset _ = setT); [<span class="bp">exact</span>: openT | <span class="nb">rewrite</span> predeqE].
<span class="kn">Qed</span>.</span></pre><div class="doc">
Some closed sets of <span class="inlinecode"><span class="id" title="var">R</span></span>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* TODO: we can probably extend these results to numFieldType</span>
<span class="c">   by adding a precondition that y \is Num.real *)</span>

<span class="kn">Lemma</span> <span class="nf">closed_le</span> (<span class="nv">y</span> : R) : closed [<span class="nb">set</span> x : R | x &lt;= y].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (_ : mkset _ = ~` [<span class="nb">set</span> x | x &gt; y]); <span class="kp">first</span> <span class="bp">exact</span>: open_closedC.
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; x /=; <span class="nb">rewrite</span> leNgt; <span class="nb">split</span> =&gt; /negP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_ge</span> (<span class="nv">y</span> : R) : closed [<span class="nb">set</span> x : R | y &lt;= x].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (_ : mkset _ = ~` [<span class="nb">set</span> x | x &lt; y]); <span class="kp">first</span> <span class="bp">exact</span>: open_closedC.
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; x /=; <span class="nb">rewrite</span> leNgt; <span class="nb">split</span> =&gt; /negP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_eq</span> (<span class="nv">y</span> : R) : closed [<span class="nb">set</span> x : R | x = y].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> [X <span class="kr">in</span> closed X](_ : (eq^~ _) = ~` (xpredC (eq_op^~ y))).
  <span class="bp">by</span> <span class="nb">apply</span>: open_closedC; <span class="bp">exact</span>: open_neq.
<span class="bp">by</span> <span class="nb">rewrite</span> predeqE /setC =&gt; x /=; <span class="nb">rewrite</span> (rwP eqP); <span class="nb">case</span>: eqP; <span class="nb">split</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">interval_closed</span> <span class="nv">a</span> <span class="nv">b</span> : ~~ bound_side false a -&gt; ~~ bound_side true b -&gt;
  closed [<span class="nb">set</span> x : R^o | x \<span class="kr">in</span> Interval a b].
<span class="kn">Proof</span>.
<span class="nb">move</span>: a b =&gt; [[]a|[]] [[]b|[]]// _ _;
  <span class="kp">do</span> <span class="nl">?by</span> <span class="nb">under</span> eq_set <span class="kp">do</span> <span class="nb">rewrite</span> itv_ge// inE falseE; <span class="nb">apply</span>: closed0.
- <span class="nb">have</span> -&gt; : `[a, b]%classic = [<span class="nb">set</span> x | x &gt;= a] `&amp;` [<span class="nb">set</span> x | x &lt;= b].
    <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; ?; <span class="nb">rewrite</span> /= in_itv/=; <span class="nb">split</span>=&gt; [/andP[]|[-&gt;]].
  <span class="bp">by</span> <span class="nb">apply</span> closedI; [<span class="bp">exact</span>: closed_ge | <span class="bp">exact</span>: closed_le].
- <span class="bp">by</span> <span class="nb">under</span> eq_set <span class="kp">do</span> <span class="nb">rewrite</span> in_itv andbT/=; <span class="bp">exact</span>: closed_ge.
- <span class="bp">exact</span>: closed_le.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">open_closed_sets</span>.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (open _) =&gt; <span class="bp">now</span> <span class="nb">apply</span>: open_gt : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (open _) =&gt; <span class="bp">now</span> <span class="nb">apply</span>: open_lt : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (open _) =&gt; <span class="bp">now</span> <span class="nb">apply</span>: open_neq : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (closed _) =&gt; <span class="bp">now</span> <span class="nb">apply</span>: closed_ge : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (closed _) =&gt; <span class="bp">now</span> <span class="nb">apply</span>: closed_le : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (closed _) =&gt; <span class="bp">now</span> <span class="nb">apply</span>: closed_eq : core.

<span class="kn">Section</span> <span class="nf">at_left_right_pmNormedZmod</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">V</span> : pseudoMetricNormedZmodType R).

<span class="kn">Definition</span> <span class="nf">at_left</span> (<span class="nv">x</span> : R) := within (<span class="kr">fun</span> <span class="nv">u</span> =&gt; u &lt; x) (nbhs x).
<span class="kn">Definition</span> <span class="nf">at_right</span> (<span class="nv">x</span> : R) := within (<span class="kr">fun</span> <span class="nv">u</span> =&gt; x &lt; u) (nbhs x).
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;x ^&#39;-&quot;</span> := (at_left x) : classical_set_scope.
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;x ^&#39;+&quot;</span> := (at_right x) : classical_set_scope.

<span class="kn">Global Instance</span> <span class="nf">at_right_proper_filter</span> (<span class="nv">x</span> : R) : ProperFilter x^&#39;+.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: Build_ProperFilter&#39; =&gt; -[_/posnumP[d] /(_ (x + d%:num / <span class="mi">2</span>))].
<span class="nb">apply</span>; <span class="nb">last</span> (<span class="bp">by</span> <span class="nb">rewrite</span> ltr_addl); <span class="nb">rewrite</span> /=.
<span class="nb">rewrite</span> opprD !addrA subrr add0r normrN normf_div !ger0_norm //.
<span class="bp">by</span> <span class="nb">rewrite</span> ltr_pdivr_mulr // ltr_pmulr // (_ : <span class="mi">1</span> = <span class="mi">1</span>%:R) // ltr_nat.
<span class="kn">Qed</span>.

<span class="kn">Global Instance</span> <span class="nf">at_left_proper_filter</span> (<span class="nv">x</span> : R) : ProperFilter x^&#39;-.
<span class="kn">Proof</span>.
<span class="nb">apply</span>: Build_ProperFilter&#39; =&gt; -[_ /posnumP[d] /(_ (x - d%:num / <span class="mi">2</span>))].
<span class="nb">apply</span>; <span class="nb">last</span> (<span class="bp">by</span> <span class="nb">rewrite</span> ltr_subl_addl ltr_addr); <span class="nb">rewrite</span> /=.
<span class="nb">rewrite</span> opprD !addrA subrr add0r opprK normf_div !ger0_norm //.
<span class="bp">by</span> <span class="nb">rewrite</span> ltr_pdivr_mulr // ltr_pmulr // (_ : <span class="mi">1</span> = <span class="mi">1</span>%:R) // ltr_nat.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_right0P</span> <span class="nv">x</span> (<span class="nv">P</span> : <span class="nb">set</span> R) :
  (\<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;+, P y) &lt;-&gt; \<span class="kr">forall</span> <span class="nv">e</span> \near <span class="mi">0</span>^&#39;+, P (x + e).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> !near_withinE !near_simpl nbhs0P -propeqE.
<span class="bp">by</span> <span class="nb">apply</span>: (@eq_near _ (nbhs (<span class="mi">0</span> : R))) =&gt; y; <span class="nb">rewrite</span> ltr_addl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_left0P</span> <span class="nv">x</span> (<span class="nv">P</span> : <span class="nb">set</span> R) :
  (\<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;-, P y) &lt;-&gt; \<span class="kr">forall</span> <span class="nv">e</span> \near <span class="mi">0</span>^&#39;+, P (x - e).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> !near_withinE !near_simpl nbhs0P; <span class="nb">split</span>=&gt; Px.
  <span class="nb">rewrite</span> -oppr0 nearN; near=&gt; e; <span class="nb">rewrite</span> ltr_opp2 opprK =&gt; e_lt0.
  <span class="bp">by</span> <span class="nb">apply</span>: (near Px) =&gt; //; <span class="nb">rewrite</span> gtr_addl.
<span class="bp">by</span> <span class="nb">rewrite</span> -oppr0 nearN; near=&gt; e; <span class="nb">rewrite</span> gtr_addl oppr_lt0; <span class="nb">apply</span>: (near Px).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_right_gt</span> <span class="nv">x</span> : \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;+, x &lt; y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> near_withinE; <span class="nb">apply</span>: nearW. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_left_lt</span> <span class="nv">x</span> : \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;-, y &lt; x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> near_withinE; <span class="nb">apply</span>: nearW. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_right_neq</span> <span class="nv">x</span> : \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;+, y != x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> near_withinE; <span class="nb">apply</span>: nearW =&gt; ? /gt_eqF-&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_left_neq</span> <span class="nv">x</span> : \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;-, y != x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> near_withinE; <span class="nb">apply</span>: nearW =&gt; ? /lt_eqF-&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_right_ge</span> <span class="nv">x</span> : \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;+, x &lt;= y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> near_withinE; <span class="nb">apply</span>: nearW; <span class="nb">apply</span>/ltW. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_left_le</span> <span class="nv">x</span> : \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;-, y &lt;= x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> near_withinE; <span class="nb">apply</span>: nearW =&gt; ?; <span class="nb">apply</span>/ltW. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_right_lt</span> <span class="nv">x</span> <span class="nv">z</span> : x &lt; z -&gt; \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;+, y &lt; z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; xz; <span class="kr">exists</span> (<span class="nv">z</span> - x) =&gt; //=; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> subr_gt0.
<span class="bp">by</span> <span class="nb">move</span>=&gt; y /= + xy; <span class="nb">rewrite</span> distrC <span class="nl">?ger0_norm</span> <span class="nl">?subr_ge0</span> <span class="mi">1</span><span class="nl">?ltW</span>// ltr_add2r.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_right_le</span> <span class="nv">x</span> <span class="nv">z</span> : x &lt; z -&gt; \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;+, y &lt;= z.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; xz; near <span class="kp">do</span> <span class="nb">apply</span>/ltW; <span class="nb">apply</span>: nbhs_right_lt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_left_gt</span> <span class="nv">x</span> <span class="nv">z</span> : z &lt; x -&gt; \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;-, z &lt; y.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; xz; <span class="nb">rewrite</span> nbhs_left0P; near <span class="kp">do</span> <span class="nb">rewrite</span> -ltr_opp2 opprB ltr_subl_addl.
<span class="bp">by</span> <span class="nb">apply</span>: nbhs_right_lt; <span class="nb">rewrite</span> subr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_left_ge</span> <span class="nv">x</span> <span class="nv">z</span> : z &lt; x -&gt; \<span class="kr">forall</span> <span class="nv">y</span> \near x^&#39;-, z &lt;= y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; xz; near <span class="kp">do</span> <span class="nb">apply</span>/ltW; <span class="nb">apply</span>: nbhs_left_gt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhsr0P</span> (<span class="nv">P</span> : <span class="nb">set</span> V) <span class="nv">x</span> :
  (\<span class="kr">forall</span> <span class="nv">y</span> \near x, P y) &lt;-&gt; (\<span class="kr">forall</span> <span class="nv">e</span> \near <span class="mi">0</span>^&#39;+, <span class="kr">forall</span> <span class="nv">y</span>, `|x - y| &lt;= e -&gt; P y).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> nbhs0P/= near_withinE/= !near_simpl.
<span class="nb">split</span>=&gt; /nbhs_norm0P[/= _/posnumP[e] /(_ _) Px]; <span class="nb">apply</span>/nbhs_norm0P.
  <span class="kr">exists</span> <span class="nv">e</span>%:num =&gt; //= r /= re yr y xyr; <span class="nb">rewrite</span> -[y](addrNK x) addrC.
  <span class="bp">by</span> <span class="nb">apply</span>: Px; <span class="nb">rewrite</span> /= distrC (le_lt_trans _ re)// gtr0_norm.
<span class="kr">exists</span> (<span class="nv">e</span>%:num / <span class="mi">2</span>) =&gt; //= r /= re; <span class="nb">apply</span>: (Px (e%:num / <span class="mi">2</span>)) =&gt; //=.
   <span class="bp">by</span> <span class="nb">rewrite</span> gtr0_norm// ltr_pdivr_mulr// ltr_pmulr// ?(ltr_nat _ <span class="mi">1</span> <span class="mi">2</span>).
<span class="bp">by</span> <span class="nb">rewrite</span> opprD addNKr normrN ltW.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">cvgrP</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> V)} {<span class="nv">FF</span> : Filter F} (<span class="nv">y</span> : V) : [&lt;-&gt;
  F --&gt; y;
  <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|y - t| &lt;= eps;
  \<span class="kr">forall</span> <span class="nv">eps</span> \near <span class="mi">0</span>^&#39;+, \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|y - t| &lt;= eps;
  \<span class="kr">forall</span> <span class="nv">eps</span> \near <span class="mi">0</span>^&#39;+, \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|y - t| &lt; eps].
<span class="kn">Proof</span>.
tfae; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">apply</span>: cvgr_dist_le.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; Fy; near <span class="kp">do</span> <span class="nb">apply</span>: Fy; <span class="nb">apply</span>: nbhs_right_gt.
- <span class="nb">move</span>=&gt; Fy; near=&gt; e; near <span class="mi">0</span>^&#39;+ =&gt; d; near=&gt; x.
  <span class="nb">rewrite</span> (@le_lt_trans _ _ d)//; <span class="kp">first</span> <span class="bp">by</span> near: x; near: d.
  <span class="bp">by</span> near: d; <span class="nb">apply</span>: nbhs_right_lt; near: e; <span class="nb">apply</span>: nbhs_right_gt.
- <span class="nb">move</span>=&gt; Fy; <span class="nb">apply</span>/cvgrPdist_lt =&gt; e e_gt0; near <span class="mi">0</span>^&#39;+ =&gt; d.
  near=&gt; x; <span class="nb">rewrite</span> (@lt_le_trans _ _ d)//; <span class="kp">first</span> <span class="bp">by</span> near: x; near: d.
  <span class="bp">by</span> near: d; <span class="nb">apply</span>: nbhs_right_le.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrPdist_le</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|y - f t| &lt;= eps.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgrP _ <span class="mi">0</span> <span class="mi">1</span>)%N. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrPdist_ltp</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y &lt;-&gt; \<span class="kr">forall</span> <span class="nv">eps</span> \near <span class="mi">0</span>^&#39;+, \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|y - f t| &lt; eps.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgrP _ <span class="mi">0</span> <span class="mi">3</span>)%N. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrPdist_lep</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y &lt;-&gt; \<span class="kr">forall</span> <span class="nv">eps</span> \near <span class="mi">0</span>^&#39;+, \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|y - f t| &lt;= eps.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (cvgrP _ <span class="mi">0</span> <span class="mi">2</span>)%N. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrPdistC_le</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t - y| &lt;= eps.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> cvgrPdist_le.
<span class="bp">by</span> <span class="nb">under</span> [X <span class="kr">in</span> X &lt;-&gt; _]eq_forall <span class="kp">do</span> <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">rewrite</span> distrC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrPdistC_ltp</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y &lt;-&gt; \<span class="kr">forall</span> <span class="nv">eps</span> \near <span class="mi">0</span>^&#39;+, \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t - y| &lt; eps.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgrPdist_ltp; <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">rewrite</span> distrC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrPdistC_lep</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y &lt;-&gt; \<span class="kr">forall</span> <span class="nv">eps</span> \near <span class="mi">0</span>^&#39;+, \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t - y| &lt;= eps.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgrPdist_lep; <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">rewrite</span> distrC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr0Pnorm_le</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) :
  f @ F --&gt; <span class="mi">0</span> &lt;-&gt; <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &lt;= eps.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> cvgrPdistC_le.
<span class="bp">by</span> <span class="nb">under</span> [X <span class="kr">in</span> X &lt;-&gt; _]eq_forall <span class="kp">do</span> <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">rewrite</span> subr0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr0Pnorm_ltp</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) :
  f @ F --&gt; <span class="mi">0</span> &lt;-&gt; \<span class="kr">forall</span> <span class="nv">eps</span> \near <span class="mi">0</span>^&#39;+, \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &lt; eps.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgrPdistC_ltp; <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">rewrite</span> subr0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr0Pnorm_lep</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) :
  f @ F --&gt; <span class="mi">0</span> &lt;-&gt; \<span class="kr">forall</span> <span class="nv">eps</span> \near <span class="mi">0</span>^&#39;+, \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &lt;= eps.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> cvgrPdistC_lep; <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">rewrite</span> subr0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_norm_lt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">u</span>, `|y| &lt; u -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &lt; u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Fy z zy; near <span class="mi">0</span>^&#39;+ =&gt; k; near=&gt; x; <span class="nb">have</span> : `|f x - y| &lt; k.
  <span class="bp">by</span> near: x; <span class="nb">apply</span>: cvgr_distC_lt =&gt; //; near: k; <span class="nb">apply</span>: nbhs_right_gt.
<span class="nb">move</span>=&gt; /(le_lt_trans (ler_dist_dist _ _)) /real_ltr_normlW.
<span class="nb">rewrite</span> realB// ltr_subl_addl =&gt; /(_ _)/lt_le_trans; <span class="nb">apply</span> =&gt; //.
<span class="bp">by</span> <span class="nb">rewrite</span> -ler_subr_addl; near: k; <span class="nb">apply</span>: nbhs_right_le; <span class="nb">rewrite</span> subr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_norm_le</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">u</span>, `|y| &lt; u -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &lt;= u.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; fy u yu; near <span class="kp">do</span> <span class="nb">apply</span>/ltW; <span class="nb">apply</span>: cvgr_norm_lt yu.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_norm_gt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">u</span>, `|y| &gt; u -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &gt; u.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Fy z zy; near <span class="mi">0</span>^&#39;+ =&gt; k; near=&gt; x; <span class="nb">have</span>: `|f x - y| &lt; k.
  <span class="bp">by</span> near: x; <span class="nb">apply</span>: cvgr_distC_lt =&gt; //; near: k; <span class="nb">apply</span>: nbhs_right_gt.
<span class="nb">move</span>=&gt; /(le_lt_trans (ler_dist_dist _ _)); <span class="nb">rewrite</span> distrC =&gt; /real_ltr_normlW.
<span class="nb">rewrite</span> realB// ltr_subl_addl  -ltr_subl_addr =&gt; /(_ isT); <span class="nb">apply</span>: le_lt_trans.
<span class="nb">rewrite</span> ler_subr_addl -ler_subr_addr; near: k; <span class="nb">apply</span>: nbhs_right_le.
<span class="bp">by</span> <span class="nb">rewrite</span> subr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_norm_ge</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">u</span>, `|y| &gt; u -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, `|f t| &gt;= u.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; fy u yu; near <span class="kp">do</span> <span class="nb">apply</span>/ltW; <span class="nb">apply</span>: cvgr_norm_gt yu.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_neq0</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; y != <span class="mi">0</span> -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, f t != <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Fy z; near <span class="kp">do</span> <span class="nb">rewrite</span> -normr_gt0.
<span class="bp">by</span> <span class="nb">apply</span>: (@cvgr_norm_gt _ _ _ _ y); <span class="nb">rewrite</span> // normr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">at_left_right_pmNormedZmod</span>.
<span class="kn">Arguments</span> cvgr_norm_lt {R V T F FF f}.
<span class="kn">Arguments</span> cvgr_norm_le {R V T F FF f}.
<span class="kn">Arguments</span> cvgr_norm_gt {R V T F FF f}.
<span class="kn">Arguments</span> cvgr_norm_ge {R V T F FF f}.
<span class="kn">Arguments</span> cvgr_neq0 {R V T F FF f}.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|_ - <span class="nl">?x</span>| &lt; _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr_dist_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|<span class="nl">?x</span> - _| &lt; _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr_distC_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|<span class="nl">?x</span>| &lt; _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr0_norm_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|_ - <span class="nl">?x</span>| &lt;= _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr_dist_le <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|<span class="nl">?x</span> - _| &lt;= _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr_distC_le <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (`|<span class="nl">?x</span>| &lt;= _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: cvgr0_norm_le <span class="kr">end</span> : core.

#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt; <span class="nl">?x</span>)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_right_gt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="nl">?x</span> &lt; _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_left_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="nl">?x</span> != _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_right_neq <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="nl">?x</span> != _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_left_neq <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt; <span class="nl">?x</span>)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_left_gt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="nl">?x</span> &lt; _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_right_lt <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt;= <span class="nl">?x</span>)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_right_ge <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="nl">?x</span> &lt;= _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_left_le <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (_ &lt;= <span class="nl">?x</span>)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_right_ge <span class="kr">end</span> : core.
#[<span class="kn">global</span>] <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (<span class="nl">?x</span> &lt;= _)) =&gt; <span class="kr">match goal with</span>
  H : x \is_near _ |- _ =&gt; near: x; <span class="bp">exact</span>: nbhs_left_le <span class="kr">end</span> : core.

#[<span class="kn">global</span>] <span class="kn">Typeclasses Opaque</span> at_left at_right.
<span class="kn">Notation</span> <span class="s2">&quot;x ^&#39;-&quot;</span> := (at_left x) : classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;x ^&#39;+&quot;</span> := (at_right x) : classical_set_scope.

<span class="kn">Section</span> <span class="nf">at_left_rightR</span>.
<span class="kn">Variable</span> (<span class="nv">R</span> : numFieldType).

<span class="kn">Lemma</span> <span class="nf">real_cvgr_lt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; R) (<span class="nv">y</span> : R) :
    y \<span class="kr">is</span> Num.real -&gt; f @ F --&gt; y -&gt;
  <span class="kr">forall</span> <span class="nv">z</span>, z &gt; y -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, f t \<span class="kr">is</span> Num.real -&gt; f t &lt; z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; yr Fy z zy; near=&gt; x =&gt; fxr.
<span class="nb">rewrite</span> -(ltr_add2r (- y)) real_ltr_normlW// <span class="nl">?rpredB</span>//.
<span class="bp">by</span> near: x; <span class="nb">apply</span>: cvgr_distC_lt =&gt; //; <span class="nb">rewrite</span> subr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">real_cvgr_le</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; R) (<span class="nv">y</span> : R) :
    y \<span class="kr">is</span> Num.real -&gt;  f @ F --&gt; y -&gt;
  <span class="kr">forall</span> <span class="nv">z</span>, z &gt; y -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, f t \<span class="kr">is</span> Num.real -&gt; f t &lt;= z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /real_cvgr_lt/[<span class="nb">apply</span>] + ? z0 =&gt; /(_ _ z0).
<span class="bp">by</span> <span class="nb">apply</span>: filterS =&gt; ? /[<span class="nb">apply</span>]/ltW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">real_cvgr_gt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; R) (<span class="nv">y</span> : R) :
    y \<span class="kr">is</span> Num.real -&gt; f @ F --&gt; y -&gt;
  <span class="kr">forall</span> <span class="nv">z</span>, y &gt; z -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, f t \<span class="kr">is</span> Num.real -&gt; f t &gt; z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; yr Fy z zy; near=&gt; x =&gt; fxr.
<span class="nb">rewrite</span> -ltr_opp2 -(ltr_add2l y) real_ltr_normlW// <span class="nl">?rpredB</span>//.
<span class="bp">by</span> near: x; <span class="nb">apply</span>: cvgr_dist_lt =&gt; //; <span class="nb">rewrite</span> subr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">real_cvgr_ge</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; R) (<span class="nv">y</span> : R) :
    y \<span class="kr">is</span> Num.real -&gt; f @ F --&gt; y -&gt;
  <span class="kr">forall</span> <span class="nv">z</span>, z &lt; y -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, f t \<span class="kr">is</span> Num.real -&gt; f t &gt;= z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /real_cvgr_gt/[<span class="nb">apply</span>] + ? z0 =&gt; /(_ _ z0).
<span class="bp">by</span> <span class="nb">apply</span>: filterS =&gt; ? /[<span class="nb">apply</span>]/ltW.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">at_left_rightR</span>.
<span class="kn">Arguments</span> real_cvgr_le {R T F FF f}.
<span class="kn">Arguments</span> real_cvgr_lt {R T F FF f}.
<span class="kn">Arguments</span> real_cvgr_ge {R T F FF f}.
<span class="kn">Arguments</span> real_cvgr_gt {R T F FF f}.

<span class="kn">Section</span> <span class="nf">realFieldType</span>.
<span class="kn">Context</span> (<span class="nv">R</span> : realFieldType).

<span class="kn">Lemma</span> <span class="nf">at_right_in_segment</span> (<span class="nv">x</span> : R) (<span class="nv">P</span> : <span class="nb">set</span> R) :
  (\<span class="kr">forall</span> <span class="nv">e</span> \near <span class="mi">0</span>^&#39;+, {<span class="kr">in</span> `[x - e, x + e], <span class="kr">forall</span> <span class="nv">x</span>, P x}) &lt;-&gt; (\near x, P x).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> nbhsr0P -propeqE; <span class="nb">apply</span>: eq_near =&gt; y /=.
<span class="bp">by</span> <span class="nb">rewrite</span> -propeqE; <span class="nb">apply</span>: eq_forall =&gt; z; <span class="nb">rewrite</span> ler_distlC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_lt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; R) (<span class="nv">y</span> : R) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">z</span>, z &gt; y -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, f t &lt; z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Fy z zy; near=&gt; x; <span class="nb">rewrite</span> -(ltr_add2r (- y)) ltr_normlW//.
<span class="bp">by</span> near: x; <span class="nb">apply</span>: cvgr_distC_lt =&gt; //; <span class="nb">rewrite</span> subr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_le</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; R) (<span class="nv">y</span> : R) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">z</span>, z &gt; y -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, f t &lt;= z.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /cvgr_lt + ? z0 =&gt; /(_ _ z0); <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>/ltW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_gt</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; R) (<span class="nv">y</span> : R) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">z</span>, y &gt; z -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, f t &gt; z.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Fy z zy; near=&gt; x; <span class="nb">rewrite</span> -ltr_opp2 -(ltr_add2l y) ltr_normlW//.
<span class="bp">by</span> near: x; <span class="nb">apply</span>: cvgr_dist_lt =&gt; //; <span class="nb">rewrite</span> subr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_ge</span> {<span class="nv">T</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : T -&gt; R) (<span class="nv">y</span> : R) :
  f @ F --&gt; y -&gt; <span class="kr">forall</span> <span class="nv">z</span>, z &lt; y -&gt; \<span class="kr">forall</span> <span class="nv">t</span> \near F, f t &gt;= z.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /cvgr_gt + ? z0 =&gt; /(_ _ z0); <span class="nb">apply</span>: filterS =&gt; ?; <span class="nb">apply</span>/ltW.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">realFieldType</span>.
<span class="kn">Arguments</span> cvgr_le {R T F FF f}.
<span class="kn">Arguments</span> cvgr_lt {R T F FF f}.
<span class="kn">Arguments</span> cvgr_ge {R T F FF f}.
<span class="kn">Arguments</span> cvgr_gt {R T F FF f}.

<span class="kn">Definition</span> <span class="nf">self_sub</span> (<span class="nv">K</span> : numDomainType) (<span class="nv">V</span> <span class="nv">W</span> : normedModType K)
  (<span class="nv">f</span> : V -&gt; W) (<span class="nv">x</span> : V * V) : W := f x.<span class="mi">1</span> - f x.<span class="mi">2</span>.
<span class="kn">Arguments</span> self_sub {K V W} f x /.

<span class="kn">Definition</span> <span class="nf">fun1</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType} : T -&gt; K := <span class="kr">fun</span>=&gt; <span class="mi">1</span>.
<span class="kn">Arguments</span> fun1 {T K} x /.

<span class="kn">Definition</span> <span class="nf">dominated_by</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numDomainType} {<span class="nv">V</span> <span class="nv">W</span> : pseudoMetricNormedZmodType K}
  (<span class="nv">h</span> : T -&gt; V) (<span class="nv">k</span> : K) (<span class="nv">f</span> : T -&gt; W) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :=
  F [<span class="nb">set</span> x | `|f x| &lt;= k * `|h x|].

<span class="kn">Definition</span> <span class="nf">strictly_dominated_by</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numDomainType} {<span class="nv">V</span> <span class="nv">W</span> : pseudoMetricNormedZmodType K}
  (<span class="nv">h</span> : T -&gt; V) (<span class="nv">k</span> : K) (<span class="nv">f</span> : T -&gt; W) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :=
  F [<span class="nb">set</span> x | `|f x| &lt; k * `|h x|].

<span class="kn">Lemma</span> <span class="nf">sub_dominatedl</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">K</span> : numDomainType) (<span class="nv">V</span> <span class="nv">W</span> : pseudoMetricNormedZmodType K)
   (<span class="nv">h</span> : T -&gt; V) (<span class="nv">k</span> : K) (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) : F `=&gt;` G -&gt;
  (@dominated_by T K V W h k)^~ G `&lt;=` (dominated_by h k)^~ F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FG f; <span class="bp">exact</span>: FG. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_dominatedr</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">K</span> : numDomainType) (<span class="nv">V</span> : pseudoMetricNormedZmodType K)
    (<span class="nv">h</span> : T -&gt; V) (<span class="nv">k</span> : K) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : Filter F) :
   (\<span class="kr">forall</span> <span class="nv">x</span> \near F, `|f x| &lt;= `|g x|) -&gt;
   dominated_by h k g F -&gt; dominated_by h k f F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; le_fg; <span class="nb">apply</span>: filterS2 le_fg =&gt; x; <span class="nb">apply</span>: le_trans. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dominated_by1</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : pseudoMetricNormedZmodType K} :
  @dominated_by T K _ V fun1 = <span class="kr">fun</span> <span class="nv">k</span> <span class="nv">f</span> <span class="nv">F</span> =&gt; F [<span class="nb">set</span> x | `|f x| &lt;= k].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeq3E =&gt; k f F.
<span class="bp">by</span> <span class="nb">congr</span> F; <span class="nb">rewrite</span> funeqE =&gt; x/=; <span class="nb">rewrite</span> normr1 mulr1.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">strictly_dominated_by1</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType}
    {<span class="nv">V</span> : pseudoMetricNormedZmodType K} :
  @strictly_dominated_by T K _ V fun1 = <span class="kr">fun</span> <span class="nv">k</span> <span class="nv">f</span> <span class="nv">F</span> =&gt; F [<span class="nb">set</span> x | `|f x| &lt; k].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeq3E =&gt; k f F.
<span class="bp">by</span> <span class="nb">congr</span> F; <span class="nb">rewrite</span> funeqE =&gt; x/=; <span class="nb">rewrite</span> normr1 mulr1.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ex_dom_bound</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> <span class="nv">W</span> : pseudoMetricNormedZmodType K}
    (<span class="nv">h</span> : T -&gt; V) (<span class="nv">f</span> : T -&gt; W) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">PF</span> : ProperFilter F}:
  (\<span class="kr">forall</span> <span class="nv">M</span> \near +oo, dominated_by h M f F) &lt;-&gt;
  <span class="kr">exists</span> <span class="nv">M</span>, dominated_by h M f F.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /dominated_by; <span class="nb">split</span> =&gt; [/pinfty_ex_gt0[M M_gt0]|[M]] FM.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">M</span>.
<span class="nb">have</span> [] := pselect (<span class="kr">exists</span> <span class="nv">x</span>, (h x != <span class="mi">0</span>) &amp;&amp; (`|f x| &lt;= M * `|h x|)); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> -forallNE =&gt; Nex; <span class="kr">exists</span> <span class="mi">0</span>; <span class="nb">split</span> =&gt; //.
  <span class="nb">move</span>=&gt; k k_gt0; <span class="nb">apply</span>: filterS FM =&gt; x /= f_le_Mh.
  <span class="nb">have</span> /negP := Nex x; <span class="nb">rewrite</span> negb_and negbK f_le_Mh orbF =&gt; /eqP h_eq0.
  <span class="bp">by</span> <span class="nb">rewrite</span> h_eq0 normr0 !mulr0 <span class="kr">in</span> f_le_Mh *.
<span class="nb">case</span> =&gt; x0 /andP[hx0_neq0] /(le_trans (normr_ge0 _)) /ger0_real.
<span class="nb">rewrite</span> realrM // <span class="nl">?normr_eq0</span>// =&gt; M_real.
<span class="kr">exists</span> <span class="nv">M</span>; <span class="nb">split</span> =&gt; // k Mk; <span class="nb">apply</span>: filterS FM =&gt; x /le_trans/= -&gt;//.
<span class="bp">by</span> <span class="nb">rewrite</span> ler_wpmul2r// ltW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ex_strict_dom_bound</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType}
    {<span class="nv">V</span> <span class="nv">W</span> : pseudoMetricNormedZmodType K}
    (<span class="nv">h</span> : T -&gt; V) (<span class="nv">f</span> : T -&gt; W) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">PF</span> : ProperFilter F} :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near F, h x != <span class="mi">0</span>) -&gt;
  (\<span class="kr">forall</span> <span class="nv">M</span> \near +oo, dominated_by h M f F) &lt;-&gt;
   <span class="kr">exists</span> <span class="nv">M</span>, strictly_dominated_by h M f F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; hN0; <span class="nb">rewrite</span> ex_dom_bound /dominated_by /strictly_dominated_by.
<span class="nb">split</span> =&gt; -[] M FM; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">M</span>; <span class="nb">apply</span>: filterS FM =&gt; x /ltW.
<span class="kr">exists</span> (<span class="nv">M</span> + <span class="mi">1</span>); <span class="nb">apply</span>: filterS2 hN0 FM =&gt; x hN0 /le_lt_trans/= -&gt;//.
<span class="bp">by</span> <span class="nb">rewrite</span> ltr_pmul2r <span class="nl">?normr_gt0</span>// ltr_addl.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">bounded_near</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType}
    {<span class="nv">V</span> : pseudoMetricNormedZmodType K}
  (<span class="nv">f</span> : T -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) :=
  \<span class="kr">forall</span> <span class="nv">M</span> \near +oo, F [<span class="nb">set</span> x | `|f x| &lt;= M].

<span class="kn">Lemma</span> <span class="nf">boundedE</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : pseudoMetricNormedZmodType K} :
  @bounded_near T K V = <span class="kr">fun</span> <span class="nv">f</span> <span class="nv">F</span> =&gt; \<span class="kr">forall</span> <span class="nv">M</span> \near +oo, dominated_by fun1 M f F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> dominated_by1. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_boundedr</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">K</span> : numFieldType) (<span class="nv">V</span> : pseudoMetricNormedZmodType K)
     (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) : F `=&gt;` G -&gt;
  (@bounded_near T K V)^~ G `&lt;=` bounded_near^~ F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FG f; <span class="nb">rewrite</span> /bounded_near; <span class="nb">apply</span>: filterS=&gt; M; <span class="nb">apply</span>: FG. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_boundedl</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">K</span> : numFieldType) (<span class="nv">V</span> : pseudoMetricNormedZmodType K)
     (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">FF</span> : Filter F) :
 (\<span class="kr">forall</span> <span class="nv">x</span> \near F, `|f x| &lt;= `|g x|) -&gt;  bounded_near g F -&gt; bounded_near f F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; le_fg; <span class="nb">rewrite</span> /bounded_near; <span class="nb">apply</span>: filterS =&gt; M.
<span class="bp">by</span> <span class="nb">apply</span>: filterS2 le_fg =&gt; x; <span class="nb">apply</span>: le_trans.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ex_bound</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : pseudoMetricNormedZmodType K}
  (<span class="nv">f</span> : T -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">PF</span> : ProperFilter F}:
  bounded_near f F &lt;-&gt; <span class="kr">exists</span> <span class="nv">M</span>, F [<span class="nb">set</span> x | `|f x| &lt;= M].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> boundedE ex_dom_bound dominated_by1. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ex_strict_bound</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : pseudoMetricNormedZmodType K}
  (<span class="nv">f</span> : T -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">PF</span> : ProperFilter F}:
  bounded_near f F &lt;-&gt; <span class="kr">exists</span> <span class="nv">M</span>, F [<span class="nb">set</span> x | `|f x| &lt; M].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> boundedE ex_strict_dom_bound <span class="nl">?strictly_dominated_by1</span>//.
<span class="bp">by</span> near=&gt; x; <span class="nb">rewrite</span> oner_eq0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ex_strict_bound_gt0</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : pseudoMetricNormedZmodType K}
  (<span class="nv">f</span> : T -&gt; V) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">PF</span> : Filter F}:
  bounded_near f F -&gt; <span class="kr">exists2</span> M, M &gt; <span class="mi">0</span> &amp; F [<span class="nb">set</span> x | `|f x| &lt; M].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /pinfty_ex_gt0[M M_gt0 FM]; <span class="kr">exists</span> (<span class="nv">M</span> + <span class="mi">1</span>); <span class="nb">rewrite</span> <span class="nl">?addr_gt0</span>//.
<span class="bp">by</span> <span class="nb">apply</span>: filterS FM =&gt; x /le_lt_trans/= -&gt;//; <span class="nb">rewrite</span> ltr_addl.
<span class="kn">Qed</span>.

<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;bounded&#39; E | x &#39;in&#39; A ]&quot;</span> := (bounded_near (<span class="kr">fun</span> <span class="nv">x</span> =&gt; E) (globally A))
  (<span class="kn">at level</span> <span class="mi">0</span>, x name, <span class="kn">format</span> <span class="s2">&quot;[ &#39;bounded&#39;  E  |  x  &#39;in&#39;  A ]&quot;</span>).
<span class="kn">Notation</span> <span class="nf">bounded_set</span> := [<span class="nb">set</span> A | [bounded x | x <span class="kr">in</span> A]].
<span class="kn">Notation</span> <span class="nf">bounded_fun</span> := [<span class="nb">set</span> f | [bounded f x | x <span class="kr">in</span> setT]].

<span class="kn">Lemma</span> <span class="nf">bounded_fun_has_ubound</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : realFieldType) (<span class="nv">a</span> : T -&gt; R) :
  bounded_fun a -&gt; has_ubound (range a).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [M [Mreal]]/(_ (`|M| + <span class="mi">1</span>)).
<span class="nb">rewrite</span> (le_lt_trans (ler_norm _)) <span class="nl">?ltr_addl</span>// =&gt; /(_ erefl) aM.
<span class="bp">by</span> <span class="kr">exists</span> (`|M| + <span class="mi">1</span>) =&gt; _ [n _ &lt;-]; <span class="nb">rewrite</span> (le_trans (ler_norm _))// aM.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bounded_funN</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : realFieldType) (<span class="nv">a</span> : T -&gt; R) :
  bounded_fun a -&gt; bounded_fun (- a).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [M [Mreal aM]]; <span class="nb">rewrite</span> /bounded_fun /bounded_near; near=&gt; x =&gt; y /= _.
<span class="bp">by</span> <span class="nb">rewrite</span> normrN; <span class="nb">apply</span>: aM.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bounded_fun_has_lbound</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : realFieldType) (<span class="nv">a</span> : T -&gt; R) :
  bounded_fun a -&gt; has_lbound (range a).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /bounded_funN/bounded_fun_has_ubound ba; <span class="nb">apply</span>/has_lb_ubN.
<span class="bp">by</span> <span class="nb">apply</span>: subset_has_ubound ba =&gt; _ [_ [n _] &lt;- &lt;-]; <span class="kr">exists</span> <span class="nv">n</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bounded_funD</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : realFieldType) (<span class="nv">a</span> <span class="nv">b</span> : T -&gt; R) :
  bounded_fun a -&gt; bounded_fun b -&gt; bounded_fun (a \+ b).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [M [Mreal Ma]] [N [Nreal Nb]].
<span class="nb">rewrite</span> /bounded_fun/bounded_near; near=&gt; x =&gt; y /= _.
<span class="nb">rewrite</span> (le_trans (ler_norm_add _ _))// [x]splitr.
<span class="bp">by</span> <span class="nb">rewrite</span> ler_add// (Ma, Nb)// ltr_pdivl_mulr//;
   near: x; <span class="nb">apply</span>: nbhs_pinfty_gt; <span class="nb">rewrite</span> <span class="nl">?rpredM</span> <span class="nl">?rpred_nat</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bounded_locally</span> (<span class="nv">T</span> : topologicalType)
    (<span class="nv">R</span> : numFieldType) (<span class="nv">V</span> : normedModType R) (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">f</span> : T -&gt; V) :
  [bounded f x | x <span class="kr">in</span> A] -&gt; [locally [bounded f x | x <span class="kr">in</span> A]].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /sub_boundedr AB x Ax; <span class="nb">apply</span>: AB; <span class="nb">apply</span>: within_nbhsW. <span class="kn">Qed</span>.

<span class="kn">Notation</span> <span class="s2">&quot;k .-lipschitz_on f&quot;</span> := (dominated_by (self_sub id) k (self_sub f))
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;k .-lipschitz_on  f&quot;</span>) : type_scope.

<span class="kn">Definition</span> <span class="nf">sub_klipschitz</span> (<span class="nv">K</span> : numFieldType) (<span class="nv">V</span> <span class="nv">W</span> : normedModType K) (<span class="nv">k</span> : K)
           (<span class="nv">f</span> : V -&gt; W) (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> (V * V))) :
  F `=&gt;` G -&gt; k.-lipschitz_on f G -&gt; k.-lipschitz_on f F.
<span class="kn">Proof</span>. <span class="bp">exact</span>. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">lipschitz_on</span> (<span class="nv">K</span> : numFieldType) (<span class="nv">V</span> <span class="nv">W</span> : normedModType K)
           (<span class="nv">f</span> : V -&gt; W) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (V * V))) :=
  \<span class="kr">forall</span> <span class="nv">M</span> \near +oo, M.-lipschitz_on f F.

<span class="kn">Definition</span> <span class="nf">sub_lipschitz</span> (<span class="nv">K</span> : numFieldType) (<span class="nv">V</span> <span class="nv">W</span> : normedModType K)
           (<span class="nv">f</span> : V -&gt; W) (<span class="nv">F</span> <span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> (V * V))) :
  F `=&gt;` G -&gt; lipschitz_on f G -&gt; lipschitz_on f F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; FG; <span class="nb">rewrite</span> /lipschitz_on; <span class="nb">apply</span>: filterS =&gt; M; <span class="nb">apply</span>: FG. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">klipschitzW</span> (<span class="nv">K</span> : numFieldType) (<span class="nv">V</span> <span class="nv">W</span> : normedModType K) (<span class="nv">k</span> : K)
      (<span class="nv">f</span> : V -&gt; W) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> (V * V))) {<span class="nv">PF</span> : ProperFilter F} :
  k.-lipschitz_on f F -&gt; lipschitz_on f F.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f_lip; <span class="nb">apply</span>/ex_dom_bound; <span class="kr">exists</span> <span class="nv">k</span>. <span class="kn">Qed</span>.

<span class="kn">Notation</span> <span class="s2">&quot;k .-lipschitz_ A f&quot;</span> :=
  (k.-lipschitz_on f (globally (A `*` A)))
  (<span class="kn">at level</span> <span class="mi">2</span>, A <span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;k .-lipschitz_ A  f&quot;</span>).
<span class="kn">Notation</span> <span class="s2">&quot;k .-lipschitz f&quot;</span> := (k.-lipschitz_setT f)
  (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;k .-lipschitz  f&quot;</span>) : type_scope.
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;lipschitz&#39; E | x &#39;in&#39; A ]&quot;</span> :=
  (lipschitz_on (<span class="kr">fun</span> <span class="nv">x</span> =&gt; E) (globally (A `*` A)))
  (<span class="kn">at level</span> <span class="mi">0</span>, x name, <span class="kn">format</span> <span class="s2">&quot;[ &#39;lipschitz&#39;  E  |  x  &#39;in&#39;  A ]&quot;</span>).
<span class="kn">Notation</span> <span class="nf">lipschitz</span> f := [lipschitz f x | x <span class="kr">in</span> setT].

<span class="kn">Lemma</span> <span class="nf">klipschitz_locally</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">V</span> <span class="nv">W</span> : normedModType R)
   (<span class="nv">k</span> : R) (<span class="nv">f</span> : V -&gt; W) (<span class="nv">A</span> : <span class="nb">set</span> V) :
  k.-lipschitz_A f -&gt; [locally k.-lipschitz_A f].
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; bndf x Ax; <span class="nb">apply</span>: sub_klipschitz bndf; <span class="nb">apply</span>: within_nbhsW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lipschitz_locally</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">V</span> <span class="nv">W</span> : normedModType R)
    (<span class="nv">A</span> : <span class="nb">set</span> V) (<span class="nv">f</span> : V -&gt; W) :
  [lipschitz f x | x <span class="kr">in</span> A] -&gt; [locally [lipschitz f x | x <span class="kr">in</span> A]].
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; bndf x Ax; <span class="nb">apply</span>: sub_lipschitz bndf; <span class="nb">apply</span>: within_nbhsW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lipschitz_id</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">V</span> : normedModType R) : <span class="mi">1</span>.-lipschitz (@id V).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; [/= x y] _; <span class="nb">rewrite</span> mul1r. <span class="kn">Qed</span>.
<span class="kn">Arguments</span> lipschitz_id {R V}.

<span class="kn">Section</span> <span class="nf">contractions</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numDomainType} {<span class="nv">X</span> <span class="nv">Y</span> : normedModType R} {<span class="nv">U</span> : <span class="nb">set</span> X} {<span class="nv">V</span> : <span class="nb">set</span> Y}.

<span class="kn">Definition</span> <span class="nf">contraction</span> (<span class="nv">q</span> : {nonneg R}) (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">U</span> &gt;-&gt; V}) :=
  q%:num &lt; <span class="mi">1</span> /\ q%:num.-lipschitz_U f.

<span class="kn">Definition</span> <span class="nf">is_contraction</span> (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">U</span> &gt;-&gt; V}) := <span class="kr">exists</span> <span class="nv">q</span>, contraction q f.

<span class="kn">End</span> <span class="nf">contractions</span>.

<span class="kn">Lemma</span> <span class="nf">contraction_fixpoint_unique</span> {<span class="nv">R</span> : realDomainType}
    {<span class="nv">X</span> : normedModType R} (<span class="nv">U</span> : <span class="nb">set</span> X) (<span class="nv">f</span> : {<span class="kr">fun</span> <span class="nv">U</span> &gt;-&gt; U}) (<span class="nv">x</span> <span class="nv">y</span> : X) :
  is_contraction f -&gt; U x -&gt; U y -&gt; x = f x -&gt; y = f y -&gt; x = y.
<span class="kn">Proof</span>.
<span class="nb">case</span> =&gt; q [q1 ctrfq] Ux Uy fixx fixy; <span class="nb">apply</span>/subr0_eq/normr0_eq0/eqP.
<span class="nb">have</span> [-&gt;|xyneq] := eqVneq x y; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> subrr normr0.
<span class="nb">have</span> xypos : <span class="mi">0</span> &lt; `|x - y| <span class="bp">by</span> <span class="nb">rewrite</span> normr_gt0 subr_eq0.
<span class="nb">suff</span> : `|x - y| &lt;= q%:num * `|x - y| <span class="bp">by</span> <span class="nb">rewrite</span> ler_pmull // leNgt q1.
<span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> leLHS]fixx [<span class="kr">in</span> leLHS]fixy; <span class="bp">exact</span>: (ctrfq (_, _)).
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">PseudoNormedZMod_numFieldType</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">V</span> : pseudoMetricNormedZmodType R).

<span class="kn">Local Notation</span> <span class="nf">ball_norm</span> := (ball_ (@normr R V)).

<span class="kn">Local Notation</span> <span class="nf">nbhs_norm</span> := (@nbhs_ball _ V).

<span class="kn">Lemma</span> <span class="nf">norm_hausdorff</span> : hausdorff_space V.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> ball_hausdorff =&gt; a b ab.
<span class="nb">have</span> ab2 : <span class="mi">0</span> &lt; `|a - b| / <span class="mi">2</span> <span class="bp">by</span> <span class="nb">apply</span> divr_gt0 =&gt; //; <span class="nb">rewrite</span> normr_gt0 subr_eq0.
<span class="nb">set</span> r := PosNum ab2; <span class="kr">exists</span> (<span class="nv">r</span>, r) =&gt; /=.
<span class="nb">apply</span>/negPn/negP =&gt; /set0P[c] []; <span class="nb">rewrite</span> -ball_normE /ball_ =&gt; acr bcr.
<span class="nb">have</span> r22 : r%:num * <span class="mi">2</span> = r%:num + r%:num.
  <span class="bp">by</span> <span class="nb">rewrite</span> (_ : <span class="mi">2</span> = <span class="mi">1</span> + <span class="mi">1</span>) // mulrDr mulr1.
<span class="nb">move</span>: (ltr_add acr bcr); <span class="nb">rewrite</span> -r22 (distrC b c).
<span class="nb">move</span>/(le_lt_trans (ler_dist_add c a b)).
<span class="bp">by</span> <span class="nb">rewrite</span> -mulrA mulVr <span class="nl">?mulr1</span> <span class="nl">?ltxx</span> // unitfE.
<span class="kn">Qed</span>.
<span class="kn">Hint Extern</span> <span class="mi">0</span> (hausdorff_space _) =&gt; <span class="kp">solve</span>[<span class="nb">apply</span>: norm_hausdorff] : core.

<span class="c">(* TODO: check if the following lemma are indeed useless *)</span>
<span class="c">(*       i.e. where the generic lemma is applied, *)</span>
<span class="c">(*            check that norm_hausdorff is not used in a hard way *)</span>

<span class="kn">Lemma</span> <span class="nf">norm_closeE</span> (<span class="nv">x</span> <span class="nv">y</span> : V): close x y = (x = y). <span class="kn">Proof</span>. <span class="bp">exact</span>: closeE. <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">norm_close_eq</span> (<span class="nv">x</span> <span class="nv">y</span> : V) : close x y -&gt; x = y. <span class="kn">Proof</span>. <span class="bp">exact</span>: close_eq. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_cvg_unique</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} : is_subset1 [<span class="nb">set</span> x : V | F --&gt; x].
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvg_unique. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_cvg_eq</span> (<span class="nv">x</span> <span class="nv">y</span> : V) : x --&gt; y -&gt; x = y. <span class="kn">Proof</span>. <span class="bp">exact</span>: (@cvg_eq V). <span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">norm_lim_id</span> (<span class="nv">x</span> : V) : lim x = x. <span class="kn">Proof</span>. <span class="bp">exact</span>: lim_id. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_cvg_lim</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">l</span> : V) : F --&gt; l -&gt; lim F = l.
<span class="kn">Proof</span>. <span class="bp">exact</span>: (@cvg_lim V). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_lim_near_cst</span> <span class="nv">U</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">l</span> : V) (<span class="nv">f</span> : U -&gt; V) :
   (\<span class="kr">forall</span> <span class="nv">x</span> \near F, f x = l) -&gt; lim (f @ F) = l.
<span class="kn">Proof</span>. <span class="bp">exact</span>: lim_near_cst. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_lim_cst</span> <span class="nv">U</span> {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">k</span> : V) :
   lim ((<span class="kr">fun</span> <span class="nv">_</span> : U =&gt; k) @ F) = k.
<span class="kn">Proof</span>. <span class="bp">exact</span>: lim_cst. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_cvgi_unique</span> {<span class="nv">U</span> : <span class="kt">Type</span>} {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">f</span> : U -&gt; <span class="nb">set</span> V) :
  {near F, is_fun f} -&gt; is_subset1 [<span class="nb">set</span> x : V | f `@ F --&gt; x].
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgi_unique. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_cvgi_lim</span> {<span class="nv">U</span>} {<span class="nv">F</span>} {<span class="nv">FF</span> : ProperFilter F} (<span class="nv">f</span> : U -&gt; V -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : V) :
  F (<span class="kr">fun</span> <span class="nv">x</span> : U =&gt; is_subset1 (f x)) -&gt;
  f `@ F --&gt; l -&gt; lim (f `@ F) = l.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgi_lim. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">distm_lt_split</span> (<span class="nv">z</span> <span class="nv">x</span> <span class="nv">y</span> : V) (<span class="nv">e</span> : R) :
  `|x - z| &lt; e / <span class="mi">2</span> -&gt; `|z - y| &lt; e / <span class="mi">2</span> -&gt; `|x - y| &lt; e.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> := @ball_split _ _ z x y e; <span class="nb">rewrite</span> -ball_normE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">distm_lt_splitr</span> (<span class="nv">z</span> <span class="nv">x</span> <span class="nv">y</span> : V) (<span class="nv">e</span> : R) :
  `|z - x| &lt; e / <span class="mi">2</span> -&gt; `|z - y| &lt; e / <span class="mi">2</span> -&gt; `|x - y| &lt; e.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> := @ball_splitr _ _ z x y e; <span class="nb">rewrite</span> -ball_normE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">distm_lt_splitl</span> (<span class="nv">z</span> <span class="nv">x</span> <span class="nv">y</span> : V) (<span class="nv">e</span> : R) :
  `|x - z| &lt; e / <span class="mi">2</span> -&gt; `|y - z| &lt; e / <span class="mi">2</span> -&gt; `|x - y| &lt; e.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> := @ball_splitl _ _ z x y e; <span class="nb">rewrite</span> -ball_normE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">normm_leW</span> (<span class="nv">x</span> : V) (<span class="nv">e</span> : R) : e &gt; <span class="mi">0</span> -&gt; `|x| &lt;= e / <span class="mi">2</span> -&gt; `|x| &lt; e.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /posnumP[{}e] /le_lt_trans -&gt;//; <span class="nb">rewrite</span> [ltRHS]splitr ltr_spaddl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">normm_lt_split</span> (<span class="nv">x</span> <span class="nv">y</span> : V) (<span class="nv">e</span> : R) :
  `|x| &lt; e / <span class="mi">2</span> -&gt; `|y| &lt; e / <span class="mi">2</span> -&gt; `|x + y| &lt; e.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; xlt ylt; <span class="nb">rewrite</span> -[y]opprK (@distm_lt_split <span class="mi">0</span>) <span class="nl">?subr0</span> <span class="nl">?opprK</span> <span class="nl">?add0r</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvg_distW</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> V)} {<span class="nv">FF</span> : Filter F} (<span class="nv">y</span> : V) :
  (<span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt; \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, `|y - y&#39;| &lt;= eps) -&gt;
  F --&gt; y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvgrPdist_le. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">PseudoNormedZMod_numFieldType</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use `cvgrPdist_le` or a variation instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_distW</span> := __deprecated__cvg_distW.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `norm_cvgi_lim`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">norm_cvgi_map_lim</span> := norm_cvgi_lim.

<span class="kn">Section</span> <span class="nf">NormedModule_numFieldType</span>.
<span class="kn">Variables</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">V</span> : normedModType R).

<span class="kn">Section</span> <span class="nf">cvgr_norm_infty</span>.
<span class="kn">Variables</span> (<span class="nv">I</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)) (<span class="nv">FF</span> : Filter F) (<span class="nv">f</span> : I -&gt; V) (<span class="nv">y</span> : V).

<span class="kn">Lemma</span> <span class="nf">cvgr_norm_lty</span> :
  f @ F --&gt; y -&gt; \<span class="kr">forall</span> <span class="nv">M</span> \near +oo, \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, `|f y&#39;| &lt; M.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Fy; near <span class="kp">do</span> <span class="bp">exact</span>: (cvgr_norm_lt y).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_norm_ley</span> :
  f @ F --&gt; y -&gt; \<span class="kr">forall</span> <span class="nv">M</span> \near +oo, \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, `|f y&#39;| &lt;= M.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Fy; near <span class="kp">do</span> <span class="bp">exact</span>: (cvgr_norm_le y).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_norm_gtNy</span> :
  f @ F --&gt; y -&gt; \<span class="kr">forall</span> <span class="nv">M</span> \near -oo, \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, `|f y&#39;| &gt; M.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Fy; near <span class="kp">do</span> <span class="bp">exact</span>: (cvgr_norm_gt y).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_norm_geNy</span> :
  f @ F --&gt; y -&gt; \<span class="kr">forall</span> <span class="nv">M</span> \near -oo, \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, `|f y&#39;| &gt;= M.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Fy; near <span class="kp">do</span> <span class="bp">exact</span>: (cvgr_norm_ge y).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvgr_norm_infty</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvg_bounded_real</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> V)} {<span class="nv">FF</span> : Filter F} (<span class="nv">y</span> : V) :
  F --&gt; y -&gt; \<span class="kr">forall</span> <span class="nv">M</span> \near +oo, \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F, `|y&#39;| &lt; M.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgr_norm_lty. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_bounded</span> {<span class="nv">I</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : I -&gt; V) (<span class="nv">y</span> : V) :
  f @ F --&gt; y -&gt; bounded_near f F.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgr_norm_ley. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">NormedModule_numFieldType</span>.
<span class="kn">Arguments</span> cvgr_norm_lty {R V I F FF}.
<span class="kn">Arguments</span> cvgr_norm_ley {R V I F FF}.
<span class="kn">Arguments</span> cvgr_norm_gtNy {R V I F FF}.
<span class="kn">Arguments</span> cvgr_norm_geNy {R V I F FF}.
<span class="kn">Arguments</span> cvg_bounded {R V I F FF}.
#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (hausdorff_space _) =&gt; <span class="kp">solve</span>[<span class="nb">apply</span>: norm_hausdorff] : core.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use `cvgr_norm_lty` or a variation instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_bounded_real</span> := __deprecated__cvg_bounded_real.

<span class="kn">Module</span> <span class="nf">Export</span> NbhsNorm.
<span class="kn">Definition</span> <span class="nf">nbhs_simpl</span> := (nbhs_simpl,@nbhs_nbhs_norm,@filter_from_norm_nbhs).
<span class="kn">End</span> <span class="nf">NbhsNorm</span>.

<span class="c">(* TODO: generalize to R : numFieldType *)</span>
<span class="kn">Section</span> <span class="nf">hausdorff</span>.

<span class="kn">Lemma</span> <span class="nf">Rhausdorff</span> (<span class="nv">R</span> : realFieldType) : hausdorff_space R.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x y clxy; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le.
<span class="nb">apply</span>/in_segment_addgt0Pr =&gt; _ /posnumP[e].
<span class="nb">rewrite</span> in_itv /= -ler_distl; <span class="nb">set</span> he := (e%:num / <span class="mi">2</span>)%:pos.
<span class="nb">have</span> [z [zx_he yz_he]] := clxy _ _ (nbhsx_ballx x he) (nbhsx_ballx y he).
<span class="nb">have</span> := ball_triangle yz_he (ball_sym zx_he).
<span class="bp">by</span> <span class="nb">rewrite</span> -mulr2n -mulr_natr divfK // =&gt; /ltW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">pseudoMetricNormedZModType_hausdorff</span> (<span class="nv">R</span> : realFieldType)
    (<span class="nv">V</span> : pseudoMetricNormedZmodType R) :
  hausdorff_space V.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; p q clp_q; <span class="nb">apply</span>/subr0_eq/normr0_eq0/Rhausdorff =&gt; A B pq_A.
<span class="nb">rewrite</span> -(@normr0 _ V) -(subrr p) =&gt; pp_B.
<span class="nb">suff</span> loc_preim r C : nbhs`|p - r| C -&gt;
    nbhs r ((<span class="kr">fun</span> <span class="nv">r</span> =&gt; `|p - r|) @^-<span class="mi">1</span>` C).
  <span class="nb">have</span> [r []] := clp_q _ _ (loc_preim _ _ pp_B) (loc_preim _ _ pq_A).
  <span class="bp">by</span> <span class="kr">exists</span> `|p - r|.
<span class="nb">move</span>=&gt; [e egt0 pre_C]; <span class="nb">apply</span>: nbhs_le_nbhs_norm; <span class="kr">exists</span> <span class="nv">e</span> =&gt; //= s /= rse.
<span class="nb">apply</span>: pre_C; <span class="nb">apply</span>: le_lt_trans (ler_dist_dist _ _) _.
<span class="bp">by</span> <span class="nb">rewrite</span> opprB addrC subrKA distrC.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">hausdorff</span>.

<span class="kn">Module</span> <span class="nf">Export</span> NearNorm.
<span class="kn">Definition</span> <span class="nf">near_simpl</span> := (@near_simpl, @nbhs_normE, @filter_from_normE,
  @near_nbhs_norm).
<span class="kn">Ltac</span> <span class="nf">near_simpl</span> := <span class="nb">rewrite</span> <span class="nl">?near_simpl</span>.
<span class="kn">End</span> <span class="nf">NearNorm</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__continuous_cvg_dist</span> {<span class="nv">R</span> : numFieldType}
  (<span class="nv">V</span> <span class="nv">W</span> : pseudoMetricNormedZmodType R) (<span class="nv">f</span> : V -&gt; W) <span class="nv">x</span> <span class="nv">l</span> :
  continuous f -&gt; x --&gt; l -&gt; <span class="kr">forall</span> <span class="nv">e</span> : {posnum R}, `|f l - f x| &lt; e%:num.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf /cvg_eq-&gt;// e; <span class="nb">rewrite</span> subrr normr0. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;simply use the fact that `(x --&gt; l) -&gt; (x = l)`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">continuous_cvg_dist</span> := __deprecated__continuous_cvg_dist.</span></pre><div class="doc">
<a id="lab3"></a><h2 class="section">Matrices</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">mx_norm</span>.
<span class="kn">Variables</span> (<span class="nv">K</span> : numDomainType) (<span class="nv">m</span> <span class="nv">n</span> : nat).
<span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> : &#39;M[K]_(m, n).

<span class="kn">Definition</span> <span class="nf">mx_norm</span> <span class="nv">x</span> : K := (\big[maxr/<span class="mi">0</span>%:nng]_i `|x i.<span class="mi">1</span> i.<span class="mi">2</span>|%:nng)%:num.

<span class="kn">Lemma</span> <span class="nf">mx_normE</span> <span class="nv">x</span> : mx_norm x = (\big[maxr/<span class="mi">0</span>%:nng]_i `|x i.<span class="mi">1</span> i.<span class="mi">2</span>|%:nng)%:num.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ler_mx_norm_add</span> <span class="nv">x</span> <span class="nv">y</span> : mx_norm (x + y) &lt;= mx_norm x + mx_norm y.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> !mx_normE [_ &lt;= _%:num]num_le; <span class="nb">apply</span>/bigmax_leP.
<span class="nb">split</span>=&gt; [|ij _]; <span class="kp">first</span> <span class="bp">exact</span>: addr_ge0.
<span class="nb">rewrite</span> mxE; <span class="nb">apply</span>: le_trans (ler_norm_add _ _) _.
<span class="bp">by</span> <span class="nb">rewrite</span> ler_add// -[leLHS]nngE num_le; <span class="bp">exact</span>: le_bigmax.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_norm_eq0</span> <span class="nv">x</span> : mx_norm x = <span class="mi">0</span> -&gt; x = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>/eqP; <span class="nb">rewrite</span> eq_le -[<span class="mi">0</span>]nngE mx_normE num_le =&gt; /andP[/bigmax_leP[_ x0] _].
<span class="nb">apply</span>/matrixP =&gt; i j; <span class="nb">rewrite</span> mxE; <span class="nb">apply</span>/eqP.
<span class="bp">by</span> <span class="nb">rewrite</span> -num_abs_eq0 eq_le (x0 (i, j))//= -num_le/=.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_norm0</span> : mx_norm <span class="mi">0</span> = <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /mx_norm (eq_bigr (<span class="kr">fun</span>=&gt; <span class="mi">0</span>%R%:nng)) /=.
  <span class="bp">by</span> <span class="nb">elim</span>/big_ind : _ =&gt; // a b; <span class="nb">rewrite</span> num_max =&gt; -&gt; -&gt;; <span class="nb">rewrite</span> maxxx.
<span class="bp">by</span> <span class="nb">move</span>=&gt; i _; <span class="nb">apply</span> val_inj =&gt; /=; <span class="nb">rewrite</span> mxE normr0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_norm_neq0</span> <span class="nv">x</span> : mx_norm x != <span class="mi">0</span> -&gt; <span class="kr">exists</span> <span class="nv">i</span>, mx_norm x = `|x i.<span class="mi">1</span> i.<span class="mi">2</span>|.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /mx_norm.
<span class="nb">elim</span>/big_ind : _ =&gt; [|a b Ha Hb H|/= i _ _]; [<span class="bp">by</span> <span class="nb">rewrite</span> eqxx| |<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>].
<span class="nb">case</span>: (leP a b) =&gt; ab.
+ <span class="nb">suff</span> /Hb[i xi] : b%:num != <span class="mi">0</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: contra H =&gt; b0; <span class="nb">rewrite</span> max_r.
+ <span class="nb">suff</span> /Ha[i xi] : a%:num != <span class="mi">0</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: contra H =&gt; a0; <span class="nb">rewrite</span> max_l // ltW.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_norm_natmul</span> <span class="nv">x</span> <span class="nv">k</span> : mx_norm (x *+ k) = (mx_norm x) *+ k.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> [<span class="kr">in</span> RHS]/mx_norm; <span class="nb">elim</span>: k =&gt; [|k ih]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> !mulr0n mx_norm0.
<span class="nb">rewrite</span> !mulrS; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eq_le; <span class="nb">apply</span>/andP; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -ih; <span class="bp">exact</span>/ler_mx_norm_add.
<span class="nb">have</span> [/mx_norm_eq0-&gt;|x0] := eqVneq (mx_norm x) <span class="mi">0</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -/(mx_norm <span class="mi">0</span>) -/(mx_norm <span class="mi">0</span>) !(mul0rn,addr0,mx_norm0).
<span class="nb">rewrite</span> -/(mx_norm x) -num_abs_le; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> mx_normE.
<span class="nb">apply</span>/bigmax_geP; <span class="nb">right</span> =&gt; /=.
<span class="nb">have</span> [i Hi] := mx_norm_neq0 x0.
<span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">rewrite</span> Hi -!mulrS -normrMn mulmxnE.
<span class="bp">by</span> <span class="nb">rewrite</span> le_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP/val_inj =&gt; /=; <span class="nb">rewrite</span> normr_id.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_normN</span> <span class="nv">x</span> : mx_norm (- x) = mx_norm x.
<span class="kn">Proof</span>.
<span class="nb">congr</span> (_%:nngnum).
<span class="bp">by</span> <span class="nb">apply</span> eq_bigr =&gt; /= ? _; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> mxE -num_eq //= normrN.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">mx_norm</span>.

<span class="kn">Lemma</span> <span class="nf">mx_normrE</span> (<span class="nv">K</span> : realDomainType) (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">x</span> : &#39;M[K]_(m, n)) :
  mx_norm x = \big[maxr/<span class="mi">0</span>]_ij `|x ij.<span class="mi">1</span> ij.<span class="mi">2</span>|.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /mx_norm; <span class="nb">apply</span>/esym.
<span class="nb">elim</span>/big_ind2 : _ =&gt; //= a a&#39; b b&#39; -&gt;{a&#39;} -&gt;{b&#39;}.
<span class="bp">by</span> <span class="nb">have</span> [ab|ab] := leP a b; [<span class="nb">rewrite</span> max_r | <span class="nb">rewrite</span> max_l // ltW].
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">matrix_normedZmodMixin</span> (<span class="nv">K</span> : numDomainType) (<span class="nv">m</span> <span class="nv">n</span> : nat) :=
  @Num.NormedMixin _ _ _ (@mx_norm K m.+<span class="mi">1</span> n.+<span class="mi">1</span>) (@ler_mx_norm_add _ _ _)
    (@mx_norm_eq0 _ _ _) (@mx_norm_natmul _ _ _) (@mx_normN _ _ _).

<span class="kn">Canonical</span> <span class="nf">matrix_normedZmodType</span> (K : numDomainType) (m n : nat) :=
  NormedZmodType K &#39;M[K]_(m.+<span class="mi">1</span>, n.+<span class="mi">1</span>) (matrix_normedZmodMixin K m n).

<span class="kn">Section</span> <span class="nf">matrix_NormedModule</span>.
<span class="kn">Variables</span> (<span class="nv">K</span> : numFieldType) (<span class="nv">m</span> <span class="nv">n</span> : nat).

<span class="kn">Local Lemma</span> <span class="nf">ball_gt0</span> (<span class="nv">x</span> <span class="nv">y</span> : &#39;M[K]_(m.+<span class="mi">1</span>, n.+<span class="mi">1</span>)) <span class="nv">e</span> : ball x e y -&gt; <span class="mi">0</span> &lt; e.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/(_ ord0 ord0); <span class="nb">apply</span>: le_lt_trans. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mx_norm_ball</span> :
  @ball _ [pseudoMetricType K of &#39;M[K]_(m.+<span class="mi">1</span>, n.+<span class="mi">1</span>)] = ball_ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `| x |).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /normr /ball_ predeq3E =&gt; x e y /=; <span class="nb">rewrite</span> mx_normE; <span class="nb">split</span> =&gt; xey.
- <span class="nb">have</span> e_gt0 : <span class="mi">0</span> &lt; e := ball_gt0 xey.
  <span class="nb">move</span>: e_gt0 (e_gt0) xey =&gt; /ltW/nonnegP[{}e] e_gt0 xey.
  <span class="nb">rewrite</span> num_lt; <span class="nb">apply</span>/bigmax_ltP =&gt; /=.
  <span class="bp">by</span> <span class="nb">rewrite</span> -num_lt /=; <span class="nb">split</span> =&gt; // -[? ?] _; <span class="nb">rewrite</span> !mxE; <span class="bp">exact</span>: xey.
- <span class="nb">have</span> e_gt0 : <span class="mi">0</span> &lt; e <span class="bp">by</span> <span class="nb">rewrite</span> (le_lt_trans _ xey).
  <span class="nb">move</span>: e_gt0 (e_gt0) xey =&gt; /ltW/nonnegP[{}e] e_gt0.
  <span class="nb">move</span>=&gt; /(bigmax_ltP _ _ _ (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _%:sgn)) /= [e0 xey] i j.
  <span class="bp">by</span> <span class="nb">move</span>: (xey (i, j)); <span class="nb">rewrite</span> !mxE; <span class="bp">exact</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">matrix_PseudoMetricNormedZmodMixin</span> :=
  PseudoMetricNormedZmodule.Mixin mx_norm_ball.
<span class="kn">Canonical</span> <span class="nf">matrix_pseudoMetricNormedZmodType</span> :=
  PseudoMetricNormedZmodType K &#39;M[K]_(m.+<span class="mi">1</span>, n.+<span class="mi">1</span>) matrix_PseudoMetricNormedZmodMixin.

<span class="kn">Lemma</span> <span class="nf">mx_normZ</span> (<span class="nv">l</span> : K) (<span class="nv">x</span> : &#39;M[K]_(m.+<span class="mi">1</span>, n.+<span class="mi">1</span>)) : `| l *: x | = `| l | * `| x |.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> {<span class="mi">1</span> <span class="mi">3</span>}/normr /= !mx_normE
 (eq_bigr (<span class="kr">fun</span> <span class="nv">i</span> =&gt; (`|l| * `|x i.<span class="mi">1</span> i.<span class="mi">2</span>|)%:nng)); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; i _; <span class="nb">rewrite</span> mxE //=; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> -num_eq /= normrM.
<span class="nb">elim</span>/big_ind2 : _ =&gt; // [|a b c d bE dE]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> mulr0.
<span class="bp">by</span> <span class="nb">rewrite</span> !num_max bE dE maxr_pmulr.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">matrix_NormedModMixin</span> := NormedModMixin mx_normZ.
<span class="kn">Canonical</span> <span class="nf">matrix_normedModType</span> :=
  NormedModType K &#39;M[K]_(m.+<span class="mi">1</span>, n.+<span class="mi">1</span>) matrix_NormedModMixin.

<span class="kn">End</span> <span class="nf">matrix_NormedModule</span>.</span></pre><div class="doc">
<a id="lab4"></a><h2 class="section">Pairs</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">prod_PseudoMetricNormedZmodule</span>.
<span class="kn">Context</span> {<span class="nv">K</span> : numDomainType} {<span class="nv">U</span> <span class="nv">V</span> : pseudoMetricNormedZmodType K}.

<span class="kn">Lemma</span> <span class="nf">ball_prod_normE</span> : ball = ball_ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `| x : U * V |).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeq2E =&gt; - [xu xv] e; <span class="nb">rewrite</span> predeqE =&gt; - [yu yv].
<span class="nb">rewrite</span> /ball /= /prod_ball -!ball_normE /ball_ /=.
<span class="bp">by</span> <span class="nb">rewrite</span> comparable_lt_maxl// <span class="nl">?real_comparable</span>//; <span class="nb">split</span>=&gt; /andP.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">prod_norm_ball</span> : @ball _ [pseudoMetricType K of U * V] = ball_ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|x|).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /= - ball_prod_normE. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">prod_pseudoMetricNormedZmodMixin</span> :=
  PseudoMetricNormedZmodule.Mixin prod_norm_ball.
<span class="kn">Canonical</span> <span class="nf">prod_pseudoMetricNormedZmodType</span> :=
  PseudoMetricNormedZmodType K (U * V) prod_pseudoMetricNormedZmodMixin.

<span class="kn">End</span> <span class="nf">prod_PseudoMetricNormedZmodule</span>.

<span class="kn">Section</span> <span class="nf">prod_NormedModule</span>.
<span class="kn">Context</span> {<span class="nv">K</span> : numDomainType} {<span class="nv">U</span> <span class="nv">V</span> : normedModType K}.

<span class="kn">Lemma</span> <span class="nf">prod_norm_scale</span> (<span class="nv">l</span> : K) (<span class="nv">x</span> : U * V) : `| l *: x | = `|l| * `| x |.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> prod_normE /= !normrZ maxr_pmulr. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">prod_NormedModMixin</span> := NormedModMixin prod_norm_scale.
<span class="kn">Canonical</span> <span class="nf">prod_normedModType</span> :=
  NormedModType K (U * V) prod_NormedModMixin.

<span class="kn">End</span> <span class="nf">prod_NormedModule</span>.

<span class="kn">Section</span> <span class="nf">example_of_sharing</span>.
<span class="kn">Variables</span> (<span class="nv">K</span> : numDomainType).

<span class="kn">Example</span> <span class="nf">matrix_triangke</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">M</span> <span class="nv">N</span> : &#39;M[K]_(m.+<span class="mi">1</span>, n.+<span class="mi">1</span>)) :
  `|M + N| &lt;= `|M| + `|N|.
<span class="kn">Proof</span>. <span class="nb">apply</span> ler_norm_add. <span class="kn">Qed</span>.

<span class="kn">Example</span> <span class="nf">pair_triangle</span> (<span class="nv">x</span> <span class="nv">y</span> : K * K) : `|x + y| &lt;= `|x| + `|y|.
<span class="kn">Proof</span>. <span class="nb">apply</span> ler_norm_add. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">example_of_sharing</span>.

<span class="kn">Section</span> <span class="nf">prod_NormedModule_lemmas</span>.

<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numDomainType} {<span class="nv">U</span> <span class="nv">V</span> : normedModType K}.

<span class="kn">Lemma</span> <span class="nf">fcvgr2dist_ltP</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> V)}
  {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} (<span class="nv">y</span> : U) (<span class="nv">z</span> : V) :
  (F, G) --&gt; (y, z) &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt;
   \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F &amp; z&#39; \near G, `| (y, z) - (y&#39;, z&#39;) | &lt; eps.
<span class="kn">Proof</span>. <span class="bp">exact</span>: fcvgrPdist_lt. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr2dist_ltP</span> {<span class="nv">I</span> <span class="nv">J</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> J)}
  {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} (<span class="nv">f</span> : I -&gt; U) (<span class="nv">g</span> : J -&gt; V) (<span class="nv">y</span> : U) (<span class="nv">z</span> : V) :
  (f @ F, g @ G) --&gt; (y, z) &lt;-&gt;
  <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt;
   \<span class="kr">forall</span> <span class="nv">i</span> \near F &amp; j \near G, `| (y, z) - (f i, g j) | &lt; eps.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> fcvgr2dist_ltP; <span class="nb">split</span>=&gt; + e e0 =&gt; /(_ e e0);
  <span class="bp">by</span> <span class="nb">rewrite</span> !near_simpl// =&gt; ?; <span class="nb">rewrite</span> !near_simpl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr2dist_lt</span> {<span class="nv">I</span> <span class="nv">J</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> J)}
  {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} (<span class="nv">f</span> : I -&gt; U) (<span class="nv">g</span> : J -&gt; V) (<span class="nv">y</span> : U) (<span class="nv">z</span> : V) :
  (f @ F, g @ G) --&gt; (y, z) -&gt;
  <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt;
   \<span class="kr">forall</span> <span class="nv">i</span> \near F &amp; j \near G, `| (y, z) - (f i, g j) | &lt; eps.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> cvgr2dist_ltP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvg_dist2</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)} {<span class="nv">G</span> : <span class="nb">set</span> (<span class="nb">set</span> V)}
  {<span class="nv">FF</span> : Filter F} {<span class="nv">FG</span> : Filter G} (<span class="nv">y</span> : U) (<span class="nv">z</span> : V):
  (F, G) --&gt; (y, z) -&gt;
  <span class="kr">forall</span> <span class="nv">eps</span>, <span class="mi">0</span> &lt; eps -&gt;
   \<span class="kr">forall</span> <span class="nv">y&#39;</span> \near F &amp; z&#39; \near G, `|(y, z) - (y&#39;, z&#39;)| &lt; eps.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgr2dist_lt. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
note=<span class="s2">&quot;use `cvgr2dist_lt` or a variant instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_dist2</span> := __deprecated__cvg_dist2.

<span class="kn">End</span> <span class="nf">prod_NormedModule_lemmas</span>.
<span class="kn">Arguments</span> cvgr2dist_ltP {_ _ _ _ _ F G FF FG}.
<span class="kn">Arguments</span> cvgr2dist_lt {_ _ _ _ _ F G FF FG}.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
note=<span class="s2">&quot;use `fcvgr2dist_ltP` or a variant instead&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_dist2P</span> := fcvgr2dist_ltP.</span></pre><div class="doc">
Normed vector spaces have some continuous functions 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
that are in fact continuous on pseudoMetricNormedZmodType 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">NVS_continuity_pseudoMetricNormedZmodType</span>.
<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : pseudoMetricNormedZmodType K}.

<span class="kn">Lemma</span> <span class="nf">opp_continuous</span> : continuous (@GRing.opp V).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x; <span class="nb">apply</span>/cvgrPdist_lt=&gt; e e0; near <span class="kp">do</span> <span class="nb">rewrite</span> -opprD normrN.
<span class="bp">exact</span>: cvgr_dist_lt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">add_continuous</span> : continuous (<span class="kr">fun</span> <span class="nv">z</span> : V * V =&gt; z.<span class="mi">1</span> + z.<span class="mi">2</span>).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [/= x y]; <span class="nb">apply</span>/cvgrPdist_lt=&gt; _/posnumP[e]; near=&gt; a b =&gt; /=.
<span class="bp">by</span> <span class="nb">rewrite</span> opprD addrACA normm_lt_split.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">natmul_continuous</span> <span class="nv">n</span> : continuous (<span class="kr">fun</span> <span class="nv">x</span> : V =&gt; x *+ n).
<span class="kn">Proof</span>.
<span class="nb">case</span>: n =&gt; [|n] x; <span class="kp">first</span> <span class="bp">exact</span>: cvg_cst.
<span class="nb">apply</span>/cvgrPdist_lt=&gt; _/posnumP[e]; near=&gt; a.
<span class="bp">by</span> <span class="nb">rewrite</span> -mulrnBl normrMn -mulr_natr -ltr_pdivl_mulr.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_continuous</span> : continuous (normr : V -&gt; K).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x; <span class="nb">apply</span>/cvgrPdist_lt =&gt; e e0; <span class="nb">apply</span>/nbhs_normP; <span class="kr">exists</span> <span class="nv">e</span> =&gt; //= y.
<span class="bp">exact</span>/le_lt_trans/ler_dist_dist.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">NVS_continuity_pseudoMetricNormedZmodType</span>.

<span class="kn">Section</span> <span class="nf">NVS_continuity_normedModType</span>.
<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : normedModType K}.

<span class="kn">Lemma</span> <span class="nf">scale_continuous</span> : continuous (<span class="kr">fun</span> <span class="nv">z</span> : K * V =&gt; z.<span class="mi">1</span> *: z.<span class="mi">2</span>).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [/= k x]; <span class="nb">apply</span>/cvgrPdist_lt =&gt; _/posnumP[e]; near +oo_K =&gt; M.
near=&gt; l z =&gt; /=; <span class="nb">have</span> M0 : <span class="mi">0</span> &lt; M <span class="bp">by</span> [].
<span class="nb">rewrite</span> (@distm_lt_split _ _ (k *: z)) // -?(scalerBr, scalerBl) normrZ.
  <span class="nb">rewrite</span> (@le_lt_trans _ _ (M * `|x - z|)) <span class="nl">?ler_wpmul2r</span> -<span class="nl">?ltr_pdivl_mull</span>//.
  <span class="bp">by</span> near: z; <span class="nb">apply</span>: cvgr_dist_lt; <span class="nb">rewrite</span> // mulr_gt0 <span class="nl">?invr_gt0</span>.
<span class="nb">rewrite</span> (@le_lt_trans _ _ (`|k - l| * M)) <span class="nl">?ler_wpmul2l</span> -<span class="nl">?ltr_pdivl_mulr</span>//.
  <span class="bp">by</span> near: z; near: M; <span class="nb">apply</span>: cvg_bounded (@cvg_refl _ _).
<span class="bp">by</span> near: l; <span class="nb">apply</span>: cvgr_dist_lt; <span class="nb">rewrite</span> // divr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Arguments</span> scale_continuous _ _ : <span class="kn">clear implicits</span>.

<span class="kn">Lemma</span> <span class="nf">scaler_continuous</span> <span class="nv">k</span> : continuous (<span class="kr">fun</span> <span class="nv">x</span> : V =&gt; k *: x).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">apply</span>: (cvg_comp2 (cvg_cst _) cvg_id (scale_continuous (_, _))).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">scalel_continuous</span> (<span class="nv">x</span> : V) : continuous (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; k *: x).
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; k; <span class="nb">apply</span>: (cvg_comp2 cvg_id (cvg_cst _) (scale_continuous (_, _))).
<span class="kn">Qed</span>.</span></pre><div class="doc">
Continuity of norm 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">End</span> <span class="nf">NVS_continuity_normedModType</span>.

<span class="kn">Section</span> <span class="nf">NVS_continuity_mul</span>.

<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType}.

<span class="kn">Lemma</span> <span class="nf">mul_continuous</span> : continuous (<span class="kr">fun</span> <span class="nv">z</span> : K * K =&gt; z.<span class="mi">1</span> * z.<span class="mi">2</span>).
<span class="kn">Proof</span>. <span class="bp">exact</span>: scale_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mulrl_continuous</span> (<span class="nv">x</span> : K) : continuous ( *%R x).
<span class="kn">Proof</span>. <span class="bp">exact</span>: scaler_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mulrr_continuous</span> (<span class="nv">y</span> : K) : continuous ( *%R^~ y).
<span class="kn">Proof</span>. <span class="bp">exact</span>: scalel_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">inv_continuous</span> (<span class="nv">x</span> : K) : x != <span class="mi">0</span> -&gt; {<span class="kr">for</span> x, continuous GRing.inv}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x_neq0; <span class="nb">have</span> nx_gt0 : `|x| &gt; <span class="mi">0</span> <span class="bp">by</span> <span class="nb">rewrite</span> normr_gt0.
<span class="nb">apply</span>/(@cvgrPdist_ltp _ _ _ (nbhs x)); near (<span class="mi">0</span> : K)^&#39;+ =&gt; d. near=&gt; e.
near=&gt; y; <span class="nb">have</span> y_neq0 : y != <span class="mi">0</span> <span class="bp">by</span> near: y; <span class="nb">apply</span>: (cvgr_neq0 x).
<span class="nb">rewrite</span> /= -div1r -[y^-<span class="mi">1</span>]div1r -mulNr addf_div// mul1r mulN1r normrM normfV.
<span class="nb">rewrite</span> ltr_pdivr_mulr <span class="nl">?normr_gt0</span> <span class="nl">?mulf_neq0</span>// (@lt_le_trans _ _ (e * d))//.
  <span class="bp">by</span> near: y;  <span class="nb">apply</span>: cvgr_distC_lt =&gt; //; <span class="nb">rewrite</span> mulr_gt0.
<span class="nb">rewrite</span> ler_pmul2l =&gt; //=; <span class="nb">rewrite</span> normrM -ler_pdivr_mull//.
near: y; <span class="nb">apply</span>: (cvgr_norm_ge x) =&gt; //; <span class="nb">rewrite</span> ltr_pdivr_mull//.
<span class="bp">by</span> near: d; <span class="nb">apply</span>: nbhs_right_lt; <span class="nb">rewrite</span> mulr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">NVS_continuity_mul</span>.

<span class="kn">Section</span> <span class="nf">cvg_composition_pseudometric</span>.

<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : pseudoMetricNormedZmodType K} {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Context</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : Filter F}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; V) (<span class="nv">s</span> : T -&gt; K) (<span class="nv">k</span> : K) (<span class="nv">x</span> : T) (<span class="nv">a</span> <span class="nv">b</span> : V).

<span class="kn">Lemma</span> <span class="nf">cvgN</span> <span class="nv">f</span> <span class="nv">a</span> : f @ F --&gt; a -&gt; - f @ F --&gt; - a.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: continuous_cvg =&gt; //; <span class="bp">exact</span>: opp_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgNP</span> <span class="nv">f</span> <span class="nv">a</span> : - f @ F --&gt; - a &lt;-&gt; f @ F --&gt; a.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">split</span>=&gt; /cvgN//; <span class="nb">rewrite</span> !opprK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgN</span> <span class="nv">f</span> : cvg (f @ F) -&gt; cvg (- f @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvgN /cvgP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgNE</span> <span class="nv">f</span> : cvg ((- f) @ F) = cvg (f @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; /cvgN; <span class="nb">rewrite</span> <span class="nl">?opprK</span> =&gt; /cvgP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgMn</span> <span class="nv">f</span> <span class="nv">n</span> <span class="nv">a</span> : f @ F --&gt; a -&gt; ((@GRing.natmul _)^~n \o f) @ F --&gt; a *+ n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?;  <span class="nb">apply</span>: continuous_cvg =&gt; //; <span class="bp">exact</span>: natmul_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgMn</span> <span class="nv">f</span> <span class="nv">n</span> : cvg (f @ F) -&gt; cvg (((@GRing.natmul _)^~n \o f) @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvgMn /cvgP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgD</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">a</span> <span class="nv">b</span> : f @ F --&gt; a -&gt; g @ F --&gt; b -&gt; (f + g) @ F --&gt; a + b.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: continuous2_cvg =&gt; //; <span class="bp">exact</span>: add_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgD</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (f @ F) -&gt; cvg (g @ F) -&gt; cvg (f + g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> := cvgP _ (cvgD _ _); <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgB</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">a</span> <span class="nv">b</span> : f @ F --&gt; a -&gt; g @ F --&gt; b -&gt; (f - g) @ F --&gt; a - b.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: cvgD =&gt; //; <span class="nb">apply</span>: cvgN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgB</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (f @ F) -&gt; cvg (g @ F) -&gt; cvg (f - g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> := cvgP _ (cvgB _ _); <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgDlE</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (g @ F) -&gt; cvg ((f + g) @ F) = cvg (f @ F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; g_cvg; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; /is_cvgD; <span class="nb">apply</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /is_cvgB /(_ g_cvg); <span class="nb">rewrite</span> addrK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgDrE</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (f @ F) -&gt; cvg ((f + g) @ F) = cvg (g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> addrC; <span class="nb">apply</span>: is_cvgDlE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_sub0</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">a</span> : (f - g) @ F --&gt; (<span class="mi">0</span> : V) -&gt; g @ F --&gt; a -&gt; f @ F --&gt; a.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; Cfg Cg; <span class="nb">have</span> := cvgD Cfg Cg; <span class="nb">rewrite</span> subrK add0r; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_zero</span> <span class="nv">f</span> <span class="nv">a</span> : (f - cst a) @ F --&gt; (<span class="mi">0</span> : V) -&gt; f @ F --&gt; a.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; Cfa; <span class="nb">apply</span>: cvg_sub0 Cfa (cvg_cst _). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_norm</span> <span class="nv">f</span> <span class="nv">a</span> : f @ F --&gt; a -&gt; `|f x| @[x --&gt; F] --&gt; (`|a| : K).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: continuous_cvg; <span class="nb">apply</span>: norm_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_norm</span> <span class="nv">f</span> : cvg (f @ F) -&gt; cvg ((Num.norm \o f : T -&gt; K) @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> := cvgP _ (cvg_norm _); <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_cvg0P</span> <span class="nv">f</span> : `|f x| @[x --&gt; F] --&gt; <span class="mi">0</span> &lt;-&gt; f @ F --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvg_norm; <span class="nb">rewrite</span> normr0.
<span class="nb">move</span>=&gt; f0; <span class="nb">apply</span>/cvgr0Pnorm_lt =&gt; e e_gt0.
<span class="bp">by</span> near <span class="kp">do</span> <span class="nb">rewrite</span> -normr_id; <span class="nb">apply</span>: cvgr0_norm_lt.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">norm_cvg0</span> <span class="nv">f</span> : `|f x| @[x --&gt; F] --&gt; <span class="mi">0</span> -&gt; f @ F --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> norm_cvg0P. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvg_composition_pseudometric</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvg_dist0</span> {<span class="nv">U</span>} {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : normedModType K}
  {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> U)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : U -&gt; V) :
  (<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|f x|) @ F --&gt; (<span class="mi">0</span> : K)
  -&gt; f @ F --&gt; (<span class="mi">0</span> : V).
<span class="kn">Proof</span>. <span class="bp">exact</span>: norm_cvg0. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
 note=<span class="s2">&quot;renamed to `norm_cvg0` and generalized to `pseudoMetricNormedZmodType`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_dist0</span> := __deprecated__cvg_dist0.

<span class="kn">Section</span> <span class="nf">cvg_composition_normed</span>.
<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : normedModType K} {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Context</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : Filter F}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; V) (<span class="nv">s</span> : T -&gt; K) (<span class="nv">k</span> : K) (<span class="nv">x</span> : T) (<span class="nv">a</span> <span class="nv">b</span> : V).

<span class="kn">Lemma</span> <span class="nf">cvgZ</span> <span class="nv">s</span> <span class="nv">f</span> <span class="nv">k</span> <span class="nv">a</span> : s @ F --&gt; k -&gt; f @ F --&gt; a -&gt;
                     s x *: f x @[x --&gt; F] --&gt; k *: a.
<span class="kn">Proof</span>. <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: continuous2_cvg =&gt; //; <span class="bp">exact</span>: scale_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgZ</span> <span class="nv">s</span> <span class="nv">f</span> : cvg (s @ F) -&gt;
  cvg (f @ F) -&gt; cvg ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; s x *: f x) @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> := cvgP _ (cvgZ _ _); <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgZl</span> <span class="nv">s</span> <span class="nv">k</span> <span class="nv">a</span> : s @ F --&gt; k -&gt; s x *: a @[x --&gt; F] --&gt; k *: a.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvgZ =&gt; //; <span class="bp">exact</span>: cvg_cst. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgZl</span> <span class="nv">s</span> <span class="nv">a</span> : cvg (s @ F) -&gt; cvg ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; s x *: a) @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> := cvgP _ (cvgZl  _); <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgZr</span> <span class="nv">k</span> <span class="nv">f</span> <span class="nv">a</span> : f @ F --&gt; a -&gt; k \*: f @ F --&gt; k *: a.
<span class="kn">Proof</span>. <span class="nb">apply</span>: cvgZ =&gt; //; <span class="bp">exact</span>: cvg_cst. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgZr</span> <span class="nv">k</span> <span class="nv">f</span> : cvg (f @ F) -&gt; cvg (k *: f  @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">have</span> := cvgP _ (cvgZr  _); <span class="nb">apply</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgZrE</span> <span class="nv">k</span> <span class="nv">f</span> : k != <span class="mi">0</span> -&gt; cvg (k *: f @ F) = cvg (f @ F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; k_neq0; <span class="nb">rewrite</span> propeqE; <span class="nb">split</span> =&gt; [/(@cvgZr k^-<span class="mi">1</span>)|/(@cvgZr k)/cvgP//].
<span class="bp">by</span> <span class="nb">under</span> [_ \*: _]funext =&gt; x /= <span class="kp">do</span> <span class="nb">rewrite</span> scalerK//; <span class="nb">apply</span>: cvgP.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvg_composition_normed</span>.

<span class="kn">Section</span> <span class="nf">cvg_composition_field</span>.
<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType}  {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Context</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : Filter F}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; K) (<span class="nv">a</span> <span class="nv">b</span> : K).

<span class="kn">Lemma</span> <span class="nf">cvgV</span> <span class="nv">f</span> <span class="nv">a</span> : a != <span class="mi">0</span> -&gt; f @ F --&gt; a -&gt; f\^-<span class="mi">1</span> @ F --&gt; a^-<span class="mi">1</span>.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; k_neq0 f_cvg; <span class="nb">apply</span>: continuous_cvg =&gt; //; <span class="nb">apply</span>: inv_continuous.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgVP</span> <span class="nv">f</span> <span class="nv">a</span> : a != <span class="mi">0</span> -&gt; f\^-<span class="mi">1</span> @ F --&gt; a^-<span class="mi">1</span> &lt;-&gt; f @ F --&gt; a.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; aN0; <span class="nb">split</span>=&gt; /(cvgV _); <span class="nb">last</span> <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> invrK invr_eq0 inv_funK; <span class="nb">apply</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgV</span> <span class="nv">f</span> : lim (f @ F) != <span class="mi">0</span> -&gt; cvg (f @ F) -&gt; cvg (f\^-<span class="mi">1</span> @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvgV cvf /cvf /cvgP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgM</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">a</span> <span class="nv">b</span> : f @ F --&gt; a -&gt; g @ F --&gt; b -&gt; (f \* g) @ F --&gt; a * b.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgZ. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgMl</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span> : f @ F --&gt; a -&gt; (f x * b) @[x --&gt; F] --&gt; a * b.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgZl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgMr</span> <span class="nv">g</span> <span class="nv">a</span> <span class="nv">b</span> : g @ F --&gt; b -&gt; (a * g x) @[x --&gt; F] --&gt; a * b.
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgZr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgM</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (f @ F) -&gt; cvg (g @ F) -&gt; cvg (f \* g @ F).
<span class="kn">Proof</span>. <span class="bp">exact</span>: is_cvgZ. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgMr</span> <span class="nv">g</span> <span class="nv">a</span> (<span class="nv">f</span> := <span class="kr">fun</span>=&gt; a) : cvg (g @ F) -&gt; cvg (f \* g @ F).
<span class="kn">Proof</span>. <span class="bp">exact</span>: is_cvgZr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgMrE</span> <span class="nv">g</span> <span class="nv">a</span> (<span class="nv">f</span> := <span class="kr">fun</span>=&gt; a) : a != <span class="mi">0</span> -&gt; cvg (f \* g @ F) = cvg (g @ F).
<span class="kn">Proof</span>. <span class="bp">exact</span>: is_cvgZrE. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgMl</span> <span class="nv">f</span> <span class="nv">a</span> (<span class="nv">g</span> := <span class="kr">fun</span>=&gt; a) : cvg (f @ F) -&gt; cvg (f \* g @ F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_cvg; <span class="nb">have</span> -&gt; : f \* g = g \* f <span class="bp">by</span> <span class="nb">apply</span>/funeqP=&gt; x; <span class="nb">rewrite</span> /= mulrC.
<span class="bp">exact</span>: is_cvgMr.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgMlE</span> <span class="nv">f</span> <span class="nv">a</span> (<span class="nv">g</span> := <span class="kr">fun</span>=&gt; a) : a != <span class="mi">0</span> -&gt; cvg (f \* g @ F) = cvg (f @ F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; a_neq0; <span class="nb">have</span> -&gt; : f \* g = g \* f <span class="bp">by</span> <span class="nb">apply</span>/funeqP=&gt; x; <span class="nb">rewrite</span> /= mulrC.
<span class="bp">exact</span>: is_cvgMrE.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvg_composition_field</span>.

<span class="kn">Section</span> <span class="nf">limit_composition_pseudometric</span>.

<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : pseudoMetricNormedZmodType K} {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Context</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : ProperFilter F}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; V) (<span class="nv">s</span> : T -&gt; K) (<span class="nv">k</span> : K) (<span class="nv">x</span> : T) (<span class="nv">a</span> : V).

<span class="kn">Lemma</span> <span class="nf">limN</span> <span class="nv">f</span> : cvg (f @ F) -&gt; lim (- f @ F) = - lim (f @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">apply</span>: cvgN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limD</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (f @ F) -&gt; cvg (g @ F) -&gt;
   lim (f + g @ F) = lim (f @ F) + lim (g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">apply</span>: cvgD. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limB</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (f @ F) -&gt; cvg (g @ F) -&gt;
   lim (f - g @ F) = lim (f @ F) - lim (g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">apply</span>: cvgB. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_norm</span> <span class="nv">f</span> : cvg (f @ F) -&gt; lim ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; `|f x| : K) @ F) = `|lim (f @ F)|.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">apply</span>: cvg_norm. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">limit_composition_pseudometric</span>.

<span class="kn">Section</span> <span class="nf">limit_composition_normed</span>.

<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : normedModType K} {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Context</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : ProperFilter F}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; V) (<span class="nv">s</span> : T -&gt; K) (<span class="nv">k</span> : K) (<span class="nv">x</span> : T) (<span class="nv">a</span> : V).

<span class="kn">Lemma</span> <span class="nf">limZ</span> <span class="nv">s</span> <span class="nv">f</span> : cvg (s @ F) -&gt; cvg (f @ F) -&gt;
   lim ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; s x *: f x) @ F) = lim (s @ F) *: lim (f @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">apply</span>: cvgZ. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limZl</span> <span class="nv">s</span> <span class="nv">a</span> : cvg (s @ F) -&gt;
   lim ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; s x *: a) @ F) = lim (s @ F) *: a.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">apply</span>: cvgZl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limZr</span> <span class="nv">k</span> <span class="nv">f</span> : cvg (f @ F) -&gt; lim (k *: f @ F) = k *: lim (f @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">apply</span>: cvgZr. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">limit_composition_normed</span>.

<span class="kn">Section</span> <span class="nf">limit_composition_field</span>.

<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType} {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Context</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : ProperFilter F}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; K).

<span class="kn">Lemma</span> <span class="nf">limM</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (f @ F) -&gt; cvg (g @ F) -&gt;
   lim (f \* g @ F) = lim (f @ F) * lim (g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">apply</span>: cvgM. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">limit_composition_field</span>.

<span class="kn">Section</span> <span class="nf">cvg_composition_field_proper</span>.

<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType}  {<span class="nv">T</span> : <span class="kt">Type</span>}.
<span class="kn">Context</span> (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) {<span class="nv">FF</span> : ProperFilter F}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; K) (<span class="nv">a</span> <span class="nv">b</span> : K).

<span class="kn">Lemma</span> <span class="nf">limV</span> <span class="nv">f</span> : lim (f @ F) != <span class="mi">0</span> -&gt; lim (f\^-<span class="mi">1</span> @ F) = (lim (f @ F))^-<span class="mi">1</span>.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">apply</span>: cvgV =&gt; //; <span class="nb">apply</span>: cvgNpoint.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgVE</span> <span class="nv">f</span> : lim (f @ F) != <span class="mi">0</span> -&gt; cvg (f\^-<span class="mi">1</span> @ F) = cvg (f @ F).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>/propeqP; <span class="nb">split</span>=&gt; /is_cvgV; <span class="nb">last</span> <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> inv_funK; <span class="nb">apply</span>; <span class="nb">rewrite</span> limV <span class="nl">?invr_eq0</span>//.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvg_composition_field_proper</span>.

<span class="kn">Section</span> <span class="nf">ProperFilterRealType</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">FF</span> : ProperFilter F} {<span class="nv">R</span> : realFieldType}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : T -&gt; R) (<span class="nv">a</span> <span class="nv">b</span> : R).

<span class="kn">Lemma</span> <span class="nf">cvgr_to_ge</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span> : f @ F --&gt; a -&gt; (\near F, b &lt;= f F) -&gt; b &lt;= a.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /[<span class="nb">swap</span>]/(closed_cvg _ (@closed_ge _ b))/[<span class="nb">apply</span>]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgr_to_le</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span> : f @ F --&gt; a -&gt; (\near F, f F &lt;= b) -&gt; a &lt;= b.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /[<span class="nb">swap</span>]/(closed_cvg _ (@closed_le _ b))/[<span class="nb">apply</span>]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limr_ge</span> <span class="nv">x</span> <span class="nv">f</span> : cvg (f @ F) -&gt; (\near F, x &lt;= f F) -&gt; x &lt;= lim (f @ F).
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgr_to_ge. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limr_le</span> <span class="nv">x</span> <span class="nv">f</span> : cvg (f @ F) -&gt; (\near F, x &gt;= f F) -&gt; x &gt;= lim (f @ F).
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvgr_to_le. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvg_gt_ge</span> (<span class="nv">u</span> : T -&gt; R) <span class="nv">a</span> <span class="nv">b</span> :
  u @ F --&gt; b -&gt; a &lt; b -&gt; \<span class="kr">forall</span> <span class="nv">n</span> \near F, a &lt;= u n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvgr_ge. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__cvg_lt_le</span> (<span class="nv">u</span> : T -&gt; R) <span class="nv">c</span> <span class="nv">b</span> :
  u @ F --&gt; b -&gt; b &lt; c -&gt; \<span class="kr">forall</span> <span class="nv">n</span> \near F, u n &lt;= c.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvgr_le. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ProperFilterRealType</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgr_ge` and generalized to a `Filter`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_gt_ge</span> := __deprecated__cvg_gt_ge.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `cvgr_le` and generalized to a `Filter`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">cvg_lt_le_</span>:= __deprecated__cvg_lt_le.

<span class="kn">Section</span> <span class="nf">local_continuity</span>.

<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType} {<span class="nv">V</span> : normedModType K} {<span class="nv">T</span> : topologicalType}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; V) (<span class="nv">s</span> <span class="nv">t</span> : T -&gt; K) (<span class="nv">x</span> : T) (<span class="nv">k</span> : K) (<span class="nv">a</span> : V).

<span class="kn">Lemma</span> <span class="nf">continuousN</span> (<span class="nv">f</span> : T -&gt; V) <span class="nv">x</span> :
  {<span class="kr">for</span> x, continuous f} -&gt; {<span class="kr">for</span> x, continuous (<span class="kr">fun</span> <span class="nv">x</span> =&gt; - f x)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvgN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuousD</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">x</span> :
  {<span class="kr">for</span> x, continuous f} -&gt; {<span class="kr">for</span> x, continuous g} -&gt;
  {<span class="kr">for</span> x, continuous (f + g)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f_cont g_cont; <span class="nb">apply</span>: cvgD. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuousB</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">x</span> :
  {<span class="kr">for</span> x, continuous f} -&gt; {<span class="kr">for</span> x, continuous g} -&gt;
  {<span class="kr">for</span> x, continuous (f - g)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f_cont g_cont; <span class="nb">apply</span>: cvgB. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuousZ</span> <span class="nv">s</span> <span class="nv">f</span> <span class="nv">x</span> :
  {<span class="kr">for</span> x, continuous s} -&gt; {<span class="kr">for</span> x, continuous f} -&gt;
  {<span class="kr">for</span> x, continuous (<span class="kr">fun</span> <span class="nv">x</span> =&gt; s x *: f x)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>: cvgZ. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuousZr</span> <span class="nv">f</span> <span class="nv">k</span> <span class="nv">x</span> :
  {<span class="kr">for</span> x, continuous f} -&gt; {<span class="kr">for</span> x, continuous (k \*: f)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvgZr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuousZl</span> <span class="nv">s</span> <span class="nv">a</span> <span class="nv">x</span> :
  {<span class="kr">for</span> x, continuous s} -&gt; {<span class="kr">for</span> x, continuous (<span class="kr">fun</span> <span class="nv">z</span> =&gt; s z *: a)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvgZl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuousM</span> <span class="nv">s</span> <span class="nv">t</span> <span class="nv">x</span> :
  {<span class="kr">for</span> x, continuous s} -&gt; {<span class="kr">for</span> x, continuous t} -&gt;
  {<span class="kr">for</span> x, continuous (s * t)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; f_cont g_cont; <span class="nb">apply</span>: cvgM. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuousV</span> <span class="nv">s</span> <span class="nv">x</span> : s x != <span class="mi">0</span> -&gt;
  {<span class="kr">for</span> x, continuous s} -&gt; {<span class="kr">for</span> x, continuous (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (s x)^-<span class="mi">1</span>%R)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: cvgV. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">local_continuity</span>.

<span class="kn">Section</span> <span class="nf">nbhs_ereal</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numFieldType} (<span class="nv">P</span> : \bar R -&gt; <span class="kt">Prop</span>).

<span class="kn">Lemma</span> <span class="nf">nbhs_EFin</span> (<span class="nv">x</span> : R) : (\<span class="kr">forall</span> <span class="nv">y</span> \near x%:E, P y) &lt;-&gt; \near x, P x%:E.
<span class="kn">Proof</span>. <span class="bp">done</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_ereal_pinfty</span> :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near +oo%E, P x) &lt;-&gt; [/\ P +oo%E &amp; \<span class="kr">forall</span> <span class="nv">x</span> \near +oo, P x%:E].
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [|[Py]] [x [xr Px]]; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>=&gt; // -[y||]//; <span class="nb">apply</span>: Px.
<span class="bp">by</span> <span class="nb">split</span>; [|<span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>=&gt; // y xy]; <span class="nb">apply</span>: Px.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_ereal_ninfty</span> :
  (\<span class="kr">forall</span> <span class="nv">x</span> \near -oo%E, P x) &lt;-&gt; [/\ P -oo%E &amp; \<span class="kr">forall</span> <span class="nv">x</span> \near -oo, P x%:E].
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [|[Py]] [x [xr Px]]; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>=&gt; // -[y||]//; <span class="nb">apply</span>: Px.
<span class="bp">by</span> <span class="nb">split</span>; [|<span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>=&gt; // y xy]; <span class="nb">apply</span>: Px.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">nbhs_ereal</span>.

<span class="kn">Section</span> <span class="nf">cvg_fin</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : numFieldType}.

<span class="kn">Section</span> <span class="nf">filter</span>.
<span class="kn">Context</span> {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> \bar R)} {<span class="nv">FF</span> : Filter F}.

<span class="kn">Lemma</span> <span class="nf">fine_fcvg</span> <span class="nv">a</span> : F --&gt; a%:E -&gt; fine @ F --&gt; a.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /(_ _)/= Fa; <span class="nb">apply</span>/cvgrPdist_lt=&gt; // _/posnumP[e]; <span class="nb">rewrite</span> near_simpl.
<span class="bp">by</span> <span class="nb">apply</span>: Fa; <span class="nb">apply</span>/nbhs_EFin =&gt; /=; <span class="nb">apply</span>: (@cvgr_dist_lt _ _ _ (nbhs a)).
<span class="c">(* BUG: using cvgr_dist_lt without (nbhs _) expands the definition of nbhs, *)</span>
<span class="c">(*    so that it is not recognized as a filter anymore *)</span>
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fcvg_is_fine</span> <span class="nv">a</span> : F --&gt; a%:E -&gt; \near F, F \<span class="kr">is</span> a fin_num.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>; <span class="nb">apply</span>/nbhs_EFin; near=&gt; x. <span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">filter</span>.

<span class="kn">Section</span> <span class="nf">limit</span>.
<span class="kn">Context</span> {<span class="nv">I</span> : <span class="kt">Type</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)} {<span class="nv">FF</span> : Filter F} (<span class="nv">f</span> : I -&gt; \bar R).

<span class="kn">Lemma</span> <span class="nf">fine_cvg</span> <span class="nv">a</span> : f @ F --&gt; a%:E -&gt; fine \o f @ F --&gt; a.
<span class="kn">Proof</span>. <span class="bp">exact</span>: fine_fcvg. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_is_fine</span> <span class="nv">a</span> : f @ F --&gt; a%:E -&gt; \near F, f F \<span class="kr">is</span> a fin_num.
<span class="kn">Proof</span>. <span class="bp">exact</span>: fcvg_is_fine. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_EFin</span> <span class="nv">a</span> : (\near F, f F \<span class="kr">is</span> a fin_num) -&gt; fine \o f @ F --&gt; a -&gt;
  f @ F --&gt; a%:E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Ffin Fa P/= /nbhs_EFin /Fa; <span class="nb">rewrite</span> !near_simpl.
<span class="bp">by</span> <span class="nb">apply</span>: filterS2 Ffin =&gt; x /fineK-&gt;.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">fine_cvgP</span> <span class="nv">a</span> :
   f @ F --&gt; a%:E &lt;-&gt; (\near F, f F \<span class="kr">is</span> a fin_num) /\ fine \o f @ F --&gt; a.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>;[<span class="nb">split</span>;[<span class="bp">exact</span>: (@cvg_is_fine a)|<span class="bp">exact</span>: fine_cvg]|<span class="nb">case</span>; <span class="nb">apply</span>: cvg_EFin].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">neq0_fine_cvgP</span> <span class="nv">a</span> : a != <span class="mi">0</span> -&gt; f @ F --&gt; a%:E &lt;-&gt; fine \o f @ F --&gt; a.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; a_neq0; <span class="nb">split</span>=&gt; [|Fa]; <span class="kp">first</span> <span class="bp">exact</span>: fine_cvg.
<span class="nb">apply</span>: cvg_EFin=&gt; //; near (<span class="mi">0</span> : R)^&#39;+ =&gt; e.
<span class="nb">have</span> lea : e &lt;= `|a| <span class="bp">by</span> near: e; <span class="nb">apply</span>: nbhs_right_le; <span class="nb">rewrite</span> normr_gt0.
near=&gt; x; <span class="nb">have</span> : `|a - fine (f x)| &lt; e <span class="bp">by</span> near: x; <span class="nb">apply</span>: cvgr_dist_lt.
<span class="bp">by</span> <span class="nb">case</span>: f=&gt; //=; <span class="nb">rewrite</span> subr0; <span class="nb">apply</span>: contra_ltT.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">limit</span>.

<span class="kn">End</span> <span class="nf">cvg_fin</span>.

<span class="kn">Lemma</span> <span class="nf">eq_cvg</span> (<span class="nv">T</span> <span class="nv">T&#39;</span> : <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; T&#39;) (<span class="nv">x</span> : <span class="nb">set</span> (<span class="nb">set</span> T&#39;)) :
  f =<span class="mi">1</span> g -&gt; (f @ F --&gt; x) = (g @ F --&gt; x).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /funext-&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">eq_is_cvg</span> (<span class="nv">T</span> <span class="nv">T&#39;</span> : <span class="kt">Type</span>) (<span class="nv">fT</span> : filteredType T&#39;) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> T)) (<span class="nv">f</span> <span class="nv">g</span> : T -&gt; T&#39;) :
  f =<span class="mi">1</span> g -&gt; [cvg (f @ F) <span class="kr">in</span> fT] = [cvg (g @ F) <span class="kr">in</span> fT].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /funext-&gt;. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">ecvg_realFieldType</span>.
<span class="kn">Context</span> {<span class="nv">I</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)} {<span class="nv">FF</span> : Filter F} {<span class="nv">R</span> : realFieldType}.
<span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">u</span> <span class="nv">v</span> : I -&gt; \bar R.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">cvgeD</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">a</span> <span class="nv">b</span> :
  a +? b -&gt; f @ F --&gt; a -&gt; g @ F --&gt; b -&gt; f \+ g @ F --&gt; a + b.
<span class="kn">Proof</span>.
<span class="nb">have</span> yE u v x : u @ F --&gt; +oo -&gt; v @ F --&gt; x%:E -&gt; u \+ v @ F --&gt; +oo.
  <span class="nb">move</span>=&gt; /cvgeyPge/= foo /fine_cvgP[Fg gb]; <span class="nb">apply</span>/cvgeyPgey.
  near=&gt; A; near=&gt; n; <span class="nb">have</span> /(_ _)/wrap[//|Fgn] := near Fg n.
  <span class="nb">rewrite</span> -lee_subl_addr// (@le_trans _ _ (A - (x - <span class="mi">1</span>))%:E)//; <span class="nb">last</span> <span class="bp">by</span> near: n.
  <span class="nb">rewrite</span> <span class="nl">?EFinB</span> lee_sub// lee_subl_addr// -[v n]fineK// -EFinD lee_fin.
  <span class="bp">by</span> <span class="nb">rewrite</span> ler_distl_addr// ltW//; near: n; <span class="nb">apply</span>: cvgr_dist_lt.
<span class="nb">have</span> NyE u v x : u @ F --&gt; -oo -&gt; v @ F --&gt; x%:E -&gt; u \+ v @ F --&gt; -oo.
  <span class="nb">move</span>=&gt; /cvgeNyPle/= foo /fine_cvgP -[Fg gb]; <span class="nb">apply</span>/cvgeNyPleNy.
  near=&gt; A; near=&gt; n; <span class="nb">have</span> /(_ _)/wrap[//|Fgn] := near Fg n.
  <span class="nb">rewrite</span> -lee_subr_addr// (@le_trans _ _ (A - (x + <span class="mi">1</span>))%:E)//; <span class="kp">first</span> <span class="bp">by</span> near: n.
  <span class="nb">rewrite</span> <span class="nl">?EFinB</span> <span class="nl">?EFinD</span> lee_sub// -[v n]fineK// -EFinD lee_fin.
  <span class="bp">by</span> <span class="nb">rewrite</span> ler_distlC_addr// ltW//; near: n; <span class="nb">apply</span>: cvgr_dist_lt.
<span class="nb">have</span> yyE u v : u @ F --&gt; +oo -&gt; v @ F --&gt; +oo -&gt; u \+ v @ F --&gt; +oo.
  <span class="nb">move</span>=&gt; /cvgeyPge foo /cvgeyPge goo; <span class="nb">apply</span>/cvgeyPge =&gt; A; near=&gt; y.
  <span class="bp">by</span> <span class="nb">rewrite</span> -[leLHS]adde0 lee_add//; near: y; [<span class="nb">apply</span>: foo|<span class="nb">apply</span>: goo].
<span class="nb">have</span> NyNyE u v : u @ F --&gt; -oo -&gt; v @ F --&gt; -oo -&gt; u \+ v @ F --&gt; -oo.
  <span class="nb">move</span>=&gt; /cvgeNyPle foo /cvgeNyPle goo; <span class="nb">apply</span>/cvgeNyPle =&gt; A; near=&gt; y.
  <span class="bp">by</span> <span class="nb">rewrite</span> -[leRHS]adde0 lee_add//; near: y; [<span class="nb">apply</span>: foo|<span class="nb">apply</span>: goo].
<span class="nb">have</span> addfC u v : u \+ v = v \+ u.
  <span class="bp">by</span> <span class="nb">apply</span>/funeqP =&gt; x; <span class="nb">rewrite</span> /= addeC.
<span class="nb">move</span>: a b =&gt; [a| |] [b| |] //= _; <span class="nb">rewrite</span> ?(addey, addye, addeNy, addNye)//=;
  <span class="kp">do</span> <span class="nl">?by</span> [<span class="nb">apply</span>: yE|<span class="nb">apply</span>: NyE|<span class="nb">apply</span>: yyE|<span class="nb">apply</span>: NyNyE].
- <span class="nb">move</span>=&gt; /fine_cvgP[Ff fa] /fine_cvgP[Fg ga]; <span class="nb">rewrite</span> -EFinD.
  <span class="nb">apply</span>/fine_cvgP; <span class="nb">split</span>.
    <span class="bp">by</span> near <span class="kp">do</span> [<span class="nb">rewrite</span> fin_numD; <span class="nb">apply</span>/andP; <span class="nb">split</span>].
  <span class="nb">apply</span>: (@cvg_trans _ ((fine \o f) \+ (fine \o g) @ F))%R; <span class="nb">last</span> <span class="bp">exact</span>: cvgD.
  <span class="bp">by</span> <span class="nb">apply</span>: near_eq_cvg; near <span class="kp">do</span> <span class="nb">rewrite</span> /= fineD//.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; /[<span class="nb">swap</span>]; <span class="nb">rewrite</span> addfC; <span class="nb">apply</span>: yE.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; /[<span class="nb">swap</span>]; <span class="nb">rewrite</span> addfC; <span class="nb">apply</span>: NyE.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeN</span> <span class="nv">f</span> <span class="nv">x</span> : f @ F --&gt; x -&gt; - f x @[x --&gt; F] --&gt; - x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: continuous_cvg =&gt; //; <span class="bp">exact</span>: oppe_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeNP</span> <span class="nv">f</span> <span class="nv">a</span> : - f x @[x --&gt; F] --&gt; - a &lt;-&gt; f @ F --&gt; a.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">split</span>=&gt; /cvgeN//; <span class="nb">rewrite</span> oppeK//; <span class="nb">under</span> eq_cvg <span class="kp">do</span> <span class="nb">rewrite</span> /= oppeK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeB</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">a</span> <span class="nv">b</span> :
  a +? - b -&gt; f @ F --&gt; a -&gt; g @ F --&gt; b -&gt; f \- g @ F --&gt; a - b.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ab fa gb; <span class="nb">apply</span>: cvgeD =&gt; //; <span class="bp">exact</span>: cvgeN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvge_sub0</span> <span class="nv">f</span> (<span class="nv">k</span> : \bar R) :
  k \<span class="kr">is</span> a fin_num -&gt; (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x - k) @ F --&gt; <span class="mi">0</span> &lt;-&gt; f @ F --&gt; k.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; kfin; <span class="nb">split</span>.
  <span class="nb">move</span>=&gt; /cvgeD-/(_ (cst k) _ isT (cvg_cst _)).
  <span class="bp">by</span> <span class="nb">rewrite</span> add0e; <span class="nb">under</span> eq_fun =&gt; x <span class="kp">do</span> <span class="nb">rewrite</span> subeK//.
<span class="nb">move</span>: k kfin =&gt; [k _ fk| |]//; <span class="nb">rewrite</span> -(@subee _ k%:E)//.
<span class="bp">by</span> <span class="nb">apply</span>: cvgeB =&gt; //; <span class="bp">exact</span>: cvg_cst.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">abse_continuous</span> : continuous (@abse R).
<span class="kn">Proof</span>.
<span class="nb">case</span>=&gt; [r|A /= [r [rreal rA]]|A /= [r [rreal rA]]]/=.
- <span class="bp">exact</span>/(cvg_comp (@norm_continuous _ [normedModType R of R^o] r)).
- <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">r</span>; <span class="nb">split</span> =&gt; // y ry; <span class="nb">apply</span>: rA; <span class="nb">rewrite</span> (lt_le_trans ry)// lee_abs.
- <span class="kr">exists</span> (- r)%R; <span class="nb">rewrite</span> realN; <span class="nb">split</span> =&gt; // y; <span class="nb">rewrite</span> EFinN -lte_oppr =&gt; yr.
  <span class="bp">by</span> <span class="nb">apply</span>: rA; <span class="nb">rewrite</span> (lt_le_trans yr)// -abseN lee_abs.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_abse</span> <span class="nv">f</span> (<span class="nv">a</span> : \bar R) : f @ F --&gt; a -&gt; `|f x|%E @[x --&gt; F] --&gt; `|a|%E.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: continuous_cvg =&gt; //; <span class="nb">apply</span>: abse_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvg_abse</span> (<span class="nv">f</span> : I -&gt; \bar R) : cvg (f @ F) -&gt; cvg (`|f x|%E @[x --&gt; F]).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>/cvg_abse/cvgP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgeN</span> <span class="nv">f</span> : cvg (f @ F) -&gt; cvg (\- f @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvg_ex[l fl]; <span class="nb">apply</span>: (cvgP (- l)); <span class="bp">exact</span>: cvgeN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgeNE</span> <span class="nv">f</span> : cvg (\- f @ F) = cvg (f @ F).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE; <span class="nb">split</span>=&gt; /cvgeNP/cvgP//.
<span class="bp">by</span> <span class="nb">under</span> eq_is_cvg <span class="kp">do</span> <span class="nb">rewrite</span> oppeK.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mule_continuous</span> (<span class="nv">r</span> : R) : continuous (mule r%:E).
<span class="kn">Proof</span>.
<span class="nb">wlog</span> r0 : r / (r &gt; <span class="mi">0</span>)%R =&gt; [hwlog|].
  <span class="nb">have</span> [r0|r0|-&gt;] := ltrgtP r <span class="mi">0</span>; <span class="kp">do</span> <span class="nl">?exact</span>: hwlog; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">rewrite</span> mul0e; <span class="nb">apply</span>: cvg_near_cst; near=&gt; y; <span class="nb">rewrite</span> mul0e.
  <span class="nb">have</span> -&gt; : *%E r%:E = \- ( *%E (- r)%:E ).
    <span class="bp">by</span> <span class="nb">apply</span>/funeqP=&gt; x /=; <span class="nb">rewrite</span> EFinN mulNe oppeK.
  <span class="nb">move</span>=&gt; x; <span class="nb">apply</span>: (continuous_comp (hwlog (- r)%R _ _)); <span class="nb">rewrite</span> <span class="nl">?oppr_gt0</span>//.
  <span class="bp">exact</span>: oppe_continuous.
<span class="nb">move</span>=&gt; [s||]/=.
- <span class="nb">rewrite</span> -EFinM; <span class="nb">apply</span>: cvg_EFin =&gt; /=.
    <span class="bp">by</span> <span class="nb">apply</span>/nbhs_EFin; near <span class="kp">do</span> <span class="nb">rewrite</span> fin_numM//.
  <span class="nb">move</span>=&gt; P /= Prs; <span class="nb">apply</span>/nbhs_EFin=&gt; //=.
  <span class="bp">by</span> <span class="nb">apply</span>: near_fun =&gt; //=; <span class="nb">apply</span>: continuousM =&gt; //=; <span class="nb">apply</span>: cvg_cst.
- <span class="nb">rewrite</span> muleC /mule/= eqe gt_eqF// lte_fin r0 =&gt; A [u [realu uA]].
  <span class="kr">exists</span> (<span class="nv">r</span>^-<span class="mi">1</span> * u)%R; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> realM// realV realE ltW.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x rux; <span class="nb">apply</span>: uA; <span class="nb">move</span>: rux; <span class="nb">rewrite</span> EFinM lte_pdivr_mull.
- <span class="nb">rewrite</span> muleC /mule/= eqe gt_eqF// lte_fin r0 =&gt; A [u [realu uA]].
  <span class="kr">exists</span> (<span class="nv">r</span>^-<span class="mi">1</span> * u)%R; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> realM// realV realE ltW.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; x xru; <span class="nb">apply</span>: uA; <span class="nb">move</span>: xru; <span class="nb">rewrite</span> EFinM lte_pdivl_mull.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeMl</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nv">y</span> : y \<span class="kr">is</span> a fin_num -&gt;
  f @ F --&gt; x -&gt; (<span class="kr">fun</span> <span class="nv">n</span> =&gt; y * f n) @ F --&gt; y * x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>: y =&gt; [r| |]// _ /cvg_comp; <span class="nb">apply</span>; <span class="bp">exact</span>: mule_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgeMl</span> <span class="nv">f</span> <span class="nv">y</span> : y \<span class="kr">is</span> a fin_num -&gt;
  cvg (f @ F) -&gt; cvg ((<span class="kr">fun</span> <span class="nv">n</span> =&gt; y * f n) @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fy /(cvgeMl fy)/cvgP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeMr</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nv">y</span> : y \<span class="kr">is</span> a fin_num -&gt;
  f @ F --&gt; x -&gt; (<span class="kr">fun</span> <span class="nv">n</span> =&gt; f n * y) @ F --&gt; x * y.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">rewrite</span> muleC; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC; <span class="bp">exact</span>: cvgeMl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgeMr</span> <span class="nv">f</span> <span class="nv">y</span> : y \<span class="kr">is</span> a fin_num -&gt;
  cvg (f @ F) -&gt; cvg ((<span class="kr">fun</span> <span class="nv">n</span> =&gt; f n * y) @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fy /(cvgeMr fy)/cvgP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_abse0P</span> <span class="nv">f</span> : abse \o f @ F --&gt; <span class="mi">0</span> &lt;-&gt; f @ F --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvg_abse; <span class="nb">rewrite</span> abse0.
<span class="nb">move</span>=&gt; /cvg_ballP f0; <span class="nb">apply</span>/cvg_ballP =&gt; _/posnumP[e].
<span class="nb">have</span> := !! f0 _ (gt0 e); <span class="nb">rewrite</span> !near_simpl =&gt; absf0; <span class="nb">rewrite</span> near_simpl.
<span class="nb">apply</span>: filterS absf0 =&gt; x /=; <span class="nb">rewrite</span> /ball/= /ereal_ball !contract0 !sub0r !normrN.
<span class="nb">have</span> [fx0|fx0] := leP <span class="mi">0</span> (f x); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> gee0_abs.
<span class="bp">by</span> <span class="nb">rewrite</span> (lte0_abs fx0) contractN normrN.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">cvgeM_gt0_pinfty</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">b</span> :
  (<span class="mi">0</span> &lt; b)%R -&gt; f @ F --&gt; +oo -&gt; g @ F --&gt; b%:E -&gt; f \* g @ F --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; b_gt0 /cvgeyPge foo /fine_cvgP[gfin gb]; <span class="nb">apply</span>/cvgeyPgey.
near (<span class="mi">0</span>%R : R)^&#39;+ =&gt; e; near=&gt; A; near=&gt; n.
<span class="nb">rewrite</span> (@le_trans _ _ (f n * e%:E))// <span class="nl">?lee_pmul</span>// <span class="nl">?lee_fin</span>//.
- <span class="bp">by</span> <span class="nb">rewrite</span> -lee_pdivr_mulr <span class="nl">?divr_gt0</span>//; near: n; <span class="nb">apply</span>: foo.
- <span class="bp">by</span> <span class="nb">rewrite</span> (@le_trans _ _ <span class="mi">1</span>) <span class="nl">?lee_fin</span>//; near: n; <span class="nb">apply</span>: foo.
<span class="nb">rewrite</span> -(@fineK _ (g n)) <span class="nl">?lee_fin</span>; <span class="nb">last</span> <span class="bp">by</span> near: n; <span class="bp">exact</span>: gfin.
<span class="bp">by</span> near: n; <span class="nb">apply</span>: (cvgr_ge b).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">cvgeM_lt0_pinfty</span>  <span class="nv">f</span> <span class="nv">g</span> <span class="nv">b</span> :
  (b &lt; <span class="mi">0</span>)%R -&gt; f @ F --&gt; +oo -&gt; g @ F --&gt; b%:E -&gt; f \* g @ F --&gt; -oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; b0 /cvgeyPge foo /fine_cvgP -[gfin gb]; <span class="nb">apply</span>/cvgeNyPleNy.
near (<span class="mi">0</span>%R : R)^&#39;+ =&gt; e; near=&gt; A; near=&gt; n.
<span class="nb">rewrite</span> -lee_opp -muleN (@le_trans _ _ (f n * e%:E))//.
  <span class="bp">by</span> <span class="nb">rewrite</span> -lee_pdivr_mulr <span class="nl">?mulr_gt0</span> <span class="nl">?oppr_gt0</span>//; near: n; <span class="nb">apply</span>: foo.
<span class="nb">rewrite</span> lee_pmul <span class="nl">?lee_fin</span>//.
  <span class="bp">by</span> <span class="nb">rewrite</span> (@le_trans _ _ <span class="mi">1</span>) <span class="nl">?lee_fin</span>//; near: n; <span class="nb">apply</span>: foo.
<span class="nb">rewrite</span> -(@fineK _ (g n)) <span class="nl">?lee_fin</span>; <span class="nb">last</span> <span class="bp">by</span> near: n; <span class="bp">exact</span>: gfin.
near: n; <span class="nb">apply</span>: (cvgr_ge (- b)); <span class="nb">rewrite</span> <span class="mi">1</span><span class="nl">?cvgNP</span>//.
<span class="bp">by</span> near: e; <span class="nb">apply</span>: nbhs_right_lt; <span class="nb">rewrite</span> oppr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">cvgeM_gt0_ninfty</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">b</span> :
  (<span class="mi">0</span> &lt; b)%R -&gt; f @ F --&gt; -oo -&gt; g @ F --&gt; b%:E -&gt; f \* g @ F --&gt; -oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; b0 foo gb; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -muleNN.
<span class="nb">apply</span>: (@cvgeM_lt0_pinfty _ _ (- b)%R); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> oppr_lt0.
- <span class="bp">by</span> <span class="nb">rewrite</span> -(oppeK +oo); <span class="nb">apply</span>: cvgeN.
- <span class="bp">by</span> <span class="nb">rewrite</span> EFinN; <span class="nb">apply</span>: cvgeN.
<span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">cvgeM_lt0_ninfty</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">b</span> :
  (b &lt; <span class="mi">0</span>)%R -&gt; f @ F --&gt; -oo -&gt; g @ F --&gt; b%:E -&gt; f \* g @ F --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; b0 foo gb; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -muleNN.
<span class="nb">apply</span>: (@cvgeM_gt0_pinfty _ _ (- b)%R); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> oppr_gt0.
- <span class="bp">by</span> <span class="nb">rewrite</span> -(oppeK +oo); <span class="nb">apply</span>: cvgeN.
- <span class="bp">by</span> <span class="nb">rewrite</span> EFinN; <span class="nb">apply</span>: cvgeN.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgeM</span> <span class="nv">f</span> <span class="nv">g</span> (<span class="nv">a</span> <span class="nv">b</span> : \bar R) :
 a *? b -&gt; f @ F --&gt; a -&gt; g @ F --&gt; b -&gt; f \* g @ F --&gt; a * b.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [:apoo] [:bnoo] [:poopoo] [:poonoo]; <span class="nb">move</span>: a b =&gt; [a| |] [b| |] //.
- <span class="nb">move</span>=&gt; _ /fine_cvgP[finf fa] /fine_cvgP[fing gb].
  <span class="nb">apply</span>/fine_cvgP; <span class="nb">split</span>.
    <span class="bp">by</span> near <span class="kp">do</span> <span class="nb">apply</span>: fin_numM; [<span class="nb">apply</span>: finf | <span class="nb">apply</span>: fing].
  <span class="nb">apply</span>: (@cvg_trans _ (((fine \o f) \* (fine \o g)) @ F)%R).
    <span class="nb">apply</span>: near_eq_cvg; near=&gt; n =&gt; //=.
    <span class="nb">rewrite</span> -[<span class="kr">in</span> RHS](@fineK _ (f n)); <span class="nb">last</span> <span class="bp">by</span> near: n; <span class="bp">exact</span>: finf.
    <span class="bp">by</span> <span class="nb">rewrite</span> -[<span class="kr">in</span> RHS](@fineK _ (g n)) //; near: n; <span class="bp">exact</span>: fing.
  <span class="bp">exact</span>: cvgM.
- <span class="nb">move</span>: f g a; <span class="kp">abstract</span>: apoo.
  <span class="nb">move</span>=&gt; {}f {}g {}a + fa goo; <span class="nb">have</span> [a0 _|a0 _|-&gt;] := ltgtP a <span class="mi">0</span>%R.
  + <span class="nb">rewrite</span> mulry ltr0_sg// <span class="nl">?mulN1e</span>.
    <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC; <span class="bp">exact</span>: (cvgeM_lt0_pinfty a0).
  + <span class="nb">rewrite</span> mulry gtr0_sg// <span class="nl">?mul1e</span>.
    <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC; <span class="bp">exact</span>: (cvgeM_gt0_pinfty a0).
  + <span class="bp">by</span> <span class="nb">rewrite</span> /mule_def eqxx.
- <span class="nb">move</span>: f g a; <span class="kp">abstract</span>: bnoo.
  <span class="nb">move</span>=&gt; {}f {}g {}a + fa goo; <span class="nb">have</span> [a0 _|a0 _|-&gt;] := ltgtP a <span class="mi">0</span>%R.
  + <span class="nb">rewrite</span> mulrNy ltr0_sg// <span class="nl">?mulN1e</span>.
    <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC; <span class="bp">exact</span>: (cvgeM_lt0_ninfty a0).
  + <span class="nb">rewrite</span> mulrNy gtr0_sg// <span class="nl">?mul1e</span>.
    <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC; <span class="bp">exact</span>: (cvgeM_gt0_ninfty a0).
  + <span class="bp">by</span> <span class="nb">rewrite</span> /mule_def eqxx.
- <span class="nb">rewrite</span> mule_defC =&gt; ? foo gb; <span class="nb">rewrite</span> muleC.
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC; <span class="bp">exact</span>: apoo.
- <span class="nb">move</span>=&gt; _; <span class="nb">move</span>: f g; <span class="kp">abstract</span>: poopoo.
  <span class="nb">move</span>=&gt; {}f {}g /cvgeyPge foo /cvgeyPge goo.
  <span class="nb">rewrite</span> mulyy; <span class="nb">apply</span>/cvgeyPgey; near=&gt; A; near=&gt; n.
  <span class="nb">have</span> A_gt0 : (<span class="mi">0</span> &lt;= A)%R <span class="bp">by</span> [].
  <span class="bp">by</span> <span class="nb">rewrite</span> -[leLHS]mule1 lee_pmul//=; near: n; [<span class="nb">apply</span>: foo|<span class="nb">apply</span>: goo].
- <span class="nb">move</span>=&gt; _; <span class="nb">move</span>: f g; <span class="kp">abstract</span>: poonoo.
  <span class="nb">move</span>=&gt; {}f {}g /cvgeyPge foo /cvgeNyPle goo.
  <span class="nb">rewrite</span> mulyNy; <span class="nb">apply</span>/cvgeNyPle =&gt; A; near=&gt; n.
  <span class="nb">rewrite</span> (@le_trans _ _ (g n))//; <span class="nb">last</span> <span class="bp">by</span> near: n; <span class="bp">exact</span>: goo.
  <span class="nb">apply</span>: lee_nemull; <span class="nb">last</span> <span class="bp">by</span> near: n; <span class="nb">apply</span>: foo.
  <span class="bp">by</span> <span class="nb">rewrite</span> (@le_trans _ _ (- <span class="mi">1</span>)%:E)//; near: n; <span class="nb">apply</span>: goo; <span class="nb">rewrite</span> ltrN10.
- <span class="nb">rewrite</span> mule_defC =&gt; ? foo gb; <span class="nb">rewrite</span> muleC.
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC; <span class="bp">exact</span>: bnoo.
- <span class="nb">move</span>=&gt; _ foo goo.
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> muleC; <span class="bp">exact</span>: poonoo.
- <span class="nb">move</span>=&gt; _ foo goo; <span class="nb">rewrite</span> mulNyNy -mulyy.
  <span class="bp">by</span> <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> -muleNN; <span class="nb">apply</span>: poopoo;
    <span class="nb">rewrite</span> -/(- -oo); <span class="nb">apply</span>: cvgeN.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ecvg_realFieldType</span>.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to cvgeN, and generalized to filter in Type&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgN</span> := cvgeN.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to is_cvgeN, and generalized to filter in Type&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_is_cvgN</span> := is_cvgeN.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to cvgeMl, and generalized to filter in Type&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgrM</span> := cvgeMl.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to is_cvgeMl, and generalized to filter in Type&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_is_cvgrM</span> := is_cvgeMl.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to cvgeMr, and generalized to filter in Type&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgMr</span> := cvgeMr.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to is_cvgeMr, and generalized to filter in Type&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_is_cvgMr</span> := is_cvgeMr.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to cvgeM, and generalized to a realFieldType&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_cvgM</span> := cvgeM.

<span class="kn">Section</span> <span class="nf">open_closed_sets_ereal</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realFieldType <span class="c">(* TODO: generalize to numFieldType? *)</span>.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Implicit Types</span> <span class="nv">x</span> <span class="nv">y</span> : \bar R.
<span class="kn">Implicit Types</span> <span class="nv">r</span> : R.

<span class="kn">Lemma</span> <span class="nf">open_ereal_lt</span> <span class="nv">y</span> : open [<span class="nb">set</span> r : R | r%:E &lt; y].
<span class="kn">Proof</span>.
<span class="nb">case</span>: y =&gt; [y||] /=; <span class="kp">first</span> <span class="bp">exact</span>: open_lt.
- <span class="nb">rewrite</span> (_ : [<span class="nb">set</span> _ | _] = setT); <span class="kp">first</span> <span class="bp">exact</span>: openT.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; ? /=; <span class="nb">rewrite</span> ltry trueE.
- <span class="nb">rewrite</span> (_ : [<span class="nb">set</span> _ | _] = set0); <span class="kp">first</span> <span class="bp">exact</span>: open0.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; ? /=; <span class="nb">rewrite</span> falseE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_ereal_gt</span> <span class="nv">y</span> : open [<span class="nb">set</span> r : R | y &lt; r%:E].
<span class="kn">Proof</span>.
<span class="nb">case</span>: y =&gt; [y||] /=; <span class="kp">first</span> <span class="bp">exact</span>: open_gt.
- <span class="nb">rewrite</span> (_ : [<span class="nb">set</span> _ | _] = set0); <span class="kp">first</span> <span class="bp">exact</span>: open0.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; ? /=; <span class="nb">rewrite</span> falseE.
- <span class="nb">rewrite</span> (_ : [<span class="nb">set</span> _ | _] = setT); <span class="kp">first</span> <span class="bp">exact</span>: openT.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; ? /=; <span class="nb">rewrite</span> ltNyr trueE.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_ereal_lt&#39;</span> <span class="nv">x</span> <span class="nv">y</span> : x &lt; y -&gt; ereal_nbhs x (<span class="kr">fun</span> <span class="nv">u</span> =&gt; u &lt; y).
<span class="kn">Proof</span>.
<span class="nb">case</span>: x =&gt; [x|//|] xy; <span class="kp">first</span> <span class="bp">exact</span>: open_ereal_lt.
- <span class="nb">case</span>: y =&gt; [y||//] /= <span class="kr">in</span> xy *; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>%R.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">rewrite</span> num_real; <span class="nb">split</span> =&gt; //= x ?.
- <span class="nb">case</span>: y =&gt; [y||//] /= <span class="kr">in</span> xy *.
  + <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">rewrite</span> num_real; <span class="nb">split</span> =&gt; //= x ?.
  + <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>%R; <span class="nb">split</span> =&gt; // x /lt_le_trans; <span class="nb">apply</span>; <span class="nb">rewrite</span> leey.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_ereal_gt&#39;</span> <span class="nv">x</span> <span class="nv">y</span> : y &lt; x -&gt; ereal_nbhs x (<span class="kr">fun</span> <span class="nv">u</span> =&gt; y &lt; u).
<span class="kn">Proof</span>.
<span class="nb">case</span>: x =&gt; [x||] //=; <span class="kp">do</span> ?[<span class="bp">exact</span>: open_ereal_gt];
  <span class="nb">case</span>: y =&gt; [y||] //=; <span class="kp">do</span> <span class="nl">?by</span> <span class="kr">exists</span> <span class="mi">0</span>.
- <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>; <span class="nb">rewrite</span> num_real.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="kr">exists</span> <span class="mi">0</span>%R; <span class="nb">split</span> =&gt; // x; <span class="nb">apply</span>/le_lt_trans; <span class="nb">rewrite</span> leNye.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_ereal_lt_ereal</span> <span class="nv">x</span> : open [<span class="nb">set</span> y | y &lt; x].
<span class="kn">Proof</span>.
<span class="nb">have</span> openr r : open [<span class="nb">set</span> x | x &lt; r%:E].
  <span class="nb">case</span> =&gt; [? | // | ?]; [<span class="nb">rewrite</span> /= lte_fin =&gt; xy | <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">r</span>].
  <span class="bp">by</span> <span class="nb">move</span>: (@open_ereal_lt r%:E); <span class="nb">rewrite</span> openE; <span class="nb">apply</span>; <span class="nb">rewrite</span> /= lte_fin.
<span class="nb">case</span>: x =&gt; [ // | | [] // ].
<span class="nb">suff</span> -&gt; : [<span class="nb">set</span> y | y &lt; +oo] = \bigcup_r [<span class="nb">set</span> y : \bar R | y &lt; r%:E].
  <span class="bp">exact</span>: bigcup_open.
<span class="nb">rewrite</span> predeqE =&gt; -[r | | ]/=.
- <span class="nb">rewrite</span> ltry; <span class="nb">split</span> =&gt; // _.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">r</span> + <span class="mi">1</span>)%R =&gt; //=; <span class="nb">rewrite</span> lte_fin ltr_addl.
- <span class="bp">by</span> <span class="nb">rewrite</span> ltxx; <span class="nb">split</span> =&gt; // -[] x /=; <span class="nb">rewrite</span> ltNge leey.
- <span class="bp">by</span> <span class="nb">split</span> =&gt; // _; <span class="kr">exists</span> <span class="mi">0</span>%R =&gt; //=.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_ereal_gt_ereal</span> <span class="nv">x</span> : open [<span class="nb">set</span> y | x &lt; y].
<span class="kn">Proof</span>.
<span class="nb">have</span> openr r : open [<span class="nb">set</span> x | r%:E &lt; x].
  <span class="nb">case</span> =&gt; [? | ? | //]; [<span class="nb">rewrite</span> /= lte_fin =&gt; xy | <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">r</span>].
  <span class="bp">by</span> <span class="nb">move</span>: (@open_ereal_gt r%:E); <span class="nb">rewrite</span> openE; <span class="nb">apply</span>; <span class="nb">rewrite</span> /= lte_fin.
<span class="nb">case</span>: x =&gt; [ // | [] // | ].
<span class="nb">suff</span> -&gt; : [<span class="nb">set</span> y | -oo &lt; y] = \bigcup_r [<span class="nb">set</span> y : \bar R | r%:E &lt; y].
  <span class="bp">exact</span>: bigcup_open.
<span class="nb">rewrite</span> predeqE =&gt; -[r | | ]/=.
- <span class="nb">rewrite</span> ltNyr; <span class="nb">split</span> =&gt; // _.
  <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">r</span> - <span class="mi">1</span>)%R =&gt; //=; <span class="nb">rewrite</span> lte_fin ltr_subl_addr ltr_addl.
- <span class="bp">by</span> <span class="nb">split</span> =&gt; // _; <span class="kr">exists</span> <span class="mi">0</span>%R =&gt; //=.
- <span class="bp">by</span> <span class="nb">rewrite</span> ltxx; <span class="nb">split</span> =&gt; // -[] x _ /=; <span class="nb">rewrite</span> ltNge leNye.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_ereal_le_ereal</span> <span class="nv">y</span> : closed [<span class="nb">set</span> x | y &lt;= x].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (_ : [<span class="nb">set</span> x | y &lt;= x] = ~` [<span class="nb">set</span> x | y &gt; x]); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE=&gt; x; <span class="nb">split</span>=&gt; [rx|/negP]; [<span class="nb">apply</span>/negP|]; <span class="nb">rewrite</span> -leNgt.
<span class="bp">exact</span>/open_closedC/open_ereal_lt_ereal.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_ereal_ge_ereal</span> <span class="nv">y</span> : closed [<span class="nb">set</span> x | y &gt;= x].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> (_ : [<span class="nb">set</span> x | y &gt;= x] = ~` [<span class="nb">set</span> x | y &lt; x]); <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE=&gt; x; <span class="nb">split</span>=&gt; [rx|/negP]; [<span class="nb">apply</span>/negP|]; <span class="nb">rewrite</span> -leNgt.
<span class="bp">exact</span>/open_closedC/open_ereal_gt_ereal.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">open_closed_sets_ereal</span>.

<span class="kn">Section</span> <span class="nf">closure_left_right_open</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realFieldType.
<span class="kn">Implicit Types</span> <span class="nv">z</span> : R.

<span class="kn">Lemma</span> <span class="nf">closure_gt</span> <span class="nv">z</span> : closure ([<span class="nb">set</span> x | z &lt; x] : <span class="nb">set</span> R) = [<span class="nb">set</span> x | z &lt;= x].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> closureE; <span class="nb">apply</span>: smallest_sub =&gt; // ? /ltW.
<span class="nb">move</span>=&gt; v; <span class="nb">rewrite</span> /mkset le_eqVlt =&gt; /predU1P[&lt;-{v}|]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: subset_closure.
<span class="nb">move</span>=&gt; B [e /= e0 zB]; near (<span class="mi">0</span> : R)^&#39;+ =&gt; d.
<span class="kr">exists</span> (<span class="nv">z</span> + d); <span class="nb">split</span>; <span class="nb">rewrite</span> /= <span class="nl">?ltr_addl</span>//; <span class="nb">apply</span>: zB =&gt; /=.
<span class="bp">by</span> <span class="nb">rewrite</span> opprD addNKr normrN gtr0_norm//.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closure_lt</span> <span class="nv">z</span> : closure ([<span class="nb">set</span> x : R | x &lt; z]) = [<span class="nb">set</span> x | x &lt;= z].
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> closureE; <span class="nb">apply</span>: smallest_sub =&gt; // ? /ltW.
<span class="nb">move</span>=&gt; v; <span class="nb">rewrite</span> /mkset le_eqVlt =&gt; /predU1P[&lt;-{z}|]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>: subset_closure.
<span class="nb">move</span>=&gt; B [e /= e0 vB]; near (<span class="mi">0</span> : R)^&#39;+ =&gt; d.
<span class="kr">exists</span> (<span class="nv">v</span> - d); <span class="nb">split</span>; <span class="nb">rewrite</span> /= <span class="nl">?gtr_addl</span> <span class="nl">?oppr_lt0</span>//; <span class="nb">apply</span>: vB =&gt; /=.
<span class="bp">by</span> <span class="nb">rewrite</span> opprB addrC addrNK gtr0_norm//; near: d.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">closure_left_right_open</span>.</span></pre><div class="doc">
<a id="lab5"></a><h2 class="section">Complete Normed Modules</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Module</span> <span class="nf">CompleteNormedModule</span>.

<span class="kn">Section</span> <span class="nf">ClassDef</span>.

<span class="kn">Variable</span> <span class="nv">K</span> : numFieldType.

<span class="kn">Record</span> <span class="nf">class_of</span> (<span class="nv">T</span> : <span class="kt">Type</span>) := <span class="kn">Class</span> {
  base : NormedModule.class_of K T ;
  mixin : Complete.axiom (PseudoMetric.Pack base)
}.
<span class="kn">Local Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; NormedModule.class_of.
<span class="kn">Definition</span> <span class="nf">base2</span> <span class="nv">T</span> (<span class="nv">cT</span> : class_of T) : CompletePseudoMetric.class_of K T :=
  @CompletePseudoMetric.<span class="kn">Class</span> <span class="nf">_</span> <span class="nv">_</span> (@base T cT) (@mixin T cT).
<span class="kn">Local Coercion</span> <span class="nf">base2</span> : class_of &gt;-&gt; CompletePseudoMetric.class_of.

<span class="kn">Structure</span> <span class="nf">type</span> (<span class="nv">phK</span> : phant K) := Pack { sort; _ : class_of sort }.
<span class="kn">Local Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.

<span class="kn">Variables</span> (<span class="nv">phK</span> : phant K) (<span class="nv">cT</span> : type phK) (<span class="nv">T</span> : <span class="kt">Type</span>).

<span class="kn">Definition</span> <span class="nf">class</span> := <span class="kr">let</span>: Pack _ c := cT <span class="kr">return</span> class_of cT <span class="kr">in</span> c.

<span class="kn">Definition</span> <span class="nf">pack</span> :=
  <span class="kr">fun</span> <span class="nv">bT</span> (<span class="nv">b</span> : NormedModule.class_of K T) &amp; phant_id (@NormedModule.class K phK bT) b =&gt;
  <span class="kr">fun</span> <span class="nv">mT</span> <span class="nv">m</span> &amp; phant_id (@Complete.class mT) (@Complete.<span class="kn">Class</span> <span class="nf">T</span> <span class="nv">b</span> <span class="nv">m</span>) =&gt;
    Pack phK (@<span class="kn">Class</span> <span class="nf">T</span> <span class="nv">b</span> <span class="nv">m</span>).
<span class="kn">Let</span> <span class="nf">xT</span> := <span class="kr">let</span>: Pack T _ := cT <span class="kr">in</span> T.
<span class="kn">Notation</span> <span class="nf">xclass</span> := (class : class_of xT).

<span class="kn">Definition</span> <span class="nf">eqType</span> := @Equality.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">choiceType</span> := @Choice.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">zmodType</span> := @GRing.Zmodule.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">normedZmodType</span> := @Num.NormedZmodule.Pack K phK cT xclass.
<span class="kn">Definition</span> <span class="nf">lmodType</span> := @GRing.Lmodule.Pack K phK cT xclass.
<span class="kn">Definition</span> <span class="nf">pointedType</span> := @Pointed.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">filteredType</span> := @Filtered.Pack cT cT xclass.
<span class="kn">Definition</span> <span class="nf">topologicalType</span> := @Topological.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">uniformType</span> := @Uniform.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetricType</span> := @PseudoMetric.Pack K cT xclass.
<span class="kn">Definition</span> <span class="nf">pseudoMetricNormedZmodType</span> :=
  @PseudoMetricNormedZmodule.Pack K phK cT xclass.
<span class="kn">Definition</span> <span class="nf">normedModType</span> := @NormedModule.Pack K phK cT xclass.
<span class="kn">Definition</span> <span class="nf">completeType</span> := @Complete.Pack cT xclass.
<span class="kn">Definition</span> <span class="nf">completePseudoMetricType</span> := @CompletePseudoMetric.Pack K cT xclass.
<span class="kn">Definition</span> <span class="nf">complete_zmodType</span> := @GRing.Zmodule.Pack completeType xclass.
<span class="kn">Definition</span> <span class="nf">complete_lmodType</span> := @GRing.Lmodule.Pack K phK completeType xclass.
<span class="kn">Definition</span> <span class="nf">complete_normedZmodType</span> := @Num.NormedZmodule.Pack K phK completeType xclass.
<span class="kn">Definition</span> <span class="nf">complete_pseudoMetricNormedZmodType</span> :=
  @PseudoMetricNormedZmodule.Pack K phK completeType xclass.
<span class="kn">Definition</span> <span class="nf">complete_normedModType</span> := @NormedModule.Pack K phK completeType xclass.
<span class="kn">Definition</span> <span class="nf">completePseudoMetric_lmodType</span> : GRing.Lmodule.type phK :=
  @GRing.Lmodule.Pack K phK (CompletePseudoMetric.sort completePseudoMetricType)
  xclass.
<span class="kn">Definition</span> <span class="nf">completePseudoMetric_zmodType</span> : GRing.Zmodule.type :=
  @GRing.Zmodule.Pack (CompletePseudoMetric.sort completePseudoMetricType)
  xclass.
<span class="kn">Definition</span> <span class="nf">completePseudoMetric_normedModType</span> : NormedModule.type phK :=
  @NormedModule.Pack K phK (CompletePseudoMetric.sort completePseudoMetricType)
  xclass.
<span class="kn">Definition</span> <span class="nf">completePseudoMetric_normedZmodType</span> : Num.NormedZmodule.type phK :=
  @Num.NormedZmodule.Pack K phK
  (CompletePseudoMetric.sort completePseudoMetricType) xclass.
<span class="kn">Definition</span> <span class="nf">completePseudoMetric_pseudoMetricNormedZmodType</span> :
  PseudoMetricNormedZmodule.type phK :=
  @PseudoMetricNormedZmodule.Pack K phK
  (CompletePseudoMetric.sort completePseudoMetricType) xclass.
<span class="kn">End</span> <span class="nf">ClassDef</span>.

<span class="kn">Module</span> <span class="nf">Exports</span>.

<span class="kn">Coercion</span> <span class="nf">base</span> : class_of &gt;-&gt; NormedModule.class_of.
<span class="kn">Coercion</span> <span class="nf">base2</span> : class_of &gt;-&gt; CompletePseudoMetric.class_of.
<span class="kn">Coercion</span> <span class="nf">sort</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.
<span class="kn">Coercion</span> <span class="nf">eqType</span> : type &gt;-&gt; Equality.type.
<span class="kn">Canonical</span> <span class="nf">eqType</span>.
<span class="kn">Coercion</span> <span class="nf">choiceType</span> : type &gt;-&gt; Choice.type.
<span class="kn">Canonical</span> <span class="nf">choiceType</span>.
<span class="kn">Coercion</span> <span class="nf">zmodType</span> : type &gt;-&gt; GRing.Zmodule.type.
<span class="kn">Canonical</span> <span class="nf">zmodType</span>.
<span class="kn">Coercion</span> <span class="nf">pseudoMetricNormedZmodType</span> : type &gt;-&gt; PseudoMetricNormedZmodule.type.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricNormedZmodType</span>.
<span class="kn">Coercion</span> <span class="nf">normedZmodType</span> : type &gt;-&gt; Num.NormedZmodule.type.
<span class="kn">Canonical</span> <span class="nf">normedZmodType</span>.
<span class="kn">Coercion</span> <span class="nf">lmodType</span> : type &gt;-&gt; GRing.Lmodule.type.
<span class="kn">Canonical</span> <span class="nf">lmodType</span>.
<span class="kn">Coercion</span> <span class="nf">pointedType</span> : type &gt;-&gt; Pointed.type.
<span class="kn">Canonical</span> <span class="nf">pointedType</span>.
<span class="kn">Coercion</span> <span class="nf">filteredType</span> : type &gt;-&gt; Filtered.type.
<span class="kn">Canonical</span> <span class="nf">filteredType</span>.
<span class="kn">Coercion</span> <span class="nf">topologicalType</span> : type &gt;-&gt; Topological.type.
<span class="kn">Canonical</span> <span class="nf">topologicalType</span>.
<span class="kn">Coercion</span> <span class="nf">uniformType</span> : type &gt;-&gt; Uniform.type.
<span class="kn">Canonical</span> <span class="nf">uniformType</span>.
<span class="kn">Coercion</span> <span class="nf">pseudoMetricType</span> : type &gt;-&gt; PseudoMetric.type.
<span class="kn">Canonical</span> <span class="nf">pseudoMetricType</span>.
<span class="kn">Coercion</span> <span class="nf">normedModType</span> : type &gt;-&gt; NormedModule.type.
<span class="kn">Canonical</span> <span class="nf">normedModType</span>.
<span class="kn">Coercion</span> <span class="nf">completeType</span> : type &gt;-&gt; Complete.type.
<span class="kn">Canonical</span> <span class="nf">completeType</span>.
<span class="kn">Coercion</span> <span class="nf">completePseudoMetricType</span> : type &gt;-&gt; CompletePseudoMetric.type.
<span class="kn">Canonical</span> <span class="nf">completePseudoMetricType</span>.
<span class="kn">Canonical</span> <span class="nf">complete_zmodType</span>.
<span class="kn">Canonical</span> <span class="nf">complete_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">complete_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">complete_pseudoMetricNormedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">complete_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">completePseudoMetric_lmodType</span>.
<span class="kn">Canonical</span> <span class="nf">completePseudoMetric_zmodType</span>.
<span class="kn">Canonical</span> <span class="nf">completePseudoMetric_normedModType</span>.
<span class="kn">Canonical</span> <span class="nf">completePseudoMetric_normedZmodType</span>.
<span class="kn">Canonical</span> <span class="nf">completePseudoMetric_pseudoMetricNormedZmodType</span>.
<span class="kn">Notation</span> <span class="nf">completeNormedModType</span> K := (type (Phant K)).
<span class="kn">Notation</span> <span class="s2">&quot;[ &#39;completeNormedModType&#39; K &#39;of&#39; T ]&quot;</span> := (@pack _ (Phant K) T _ _ idfun _ _ idfun)
  (<span class="kn">at level</span> <span class="mi">0</span>, <span class="kn">format</span> <span class="s2">&quot;[ &#39;completeNormedModType&#39;  K  &#39;of&#39;  T ]&quot;</span>) : form_scope.
<span class="kn">End</span> <span class="nf">Exports</span>.

<span class="kn">End</span> <span class="nf">CompleteNormedModule</span>.

<span class="kn">Export</span> CompleteNormedModule.Exports.</span></pre><div class="doc">
<a id="lab6"></a><h1 class="section">Extended Types</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
<a id="lab7"></a><h1 class="section">The topology on real numbers</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Lemma</span> <span class="nf">R_complete</span> (<span class="nv">R</span> : realType) (<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> R)) : ProperFilter F -&gt; cauchy F -&gt; cvg F.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; FF /cauchy_ballP F_cauchy; <span class="nb">apply</span>/cvg_ex.
<span class="nb">pose</span> D := \bigcap_(A <span class="kr">in</span> F) (down A).
<span class="nb">have</span> /cauchy_ballP /cauchyP /(_ <span class="mi">1</span>) [//|x0 x01] := F_cauchy.
<span class="nb">have</span> D_has_sup : has_sup D; <span class="kp">first</span> <span class="nb">split</span>.
- <span class="kr">exists</span> (<span class="nv">x0</span> - <span class="mi">1</span>) =&gt; A FA.
  near F =&gt; x.
  <span class="nb">apply</span>/downP; <span class="kr">exists</span> <span class="nv">x</span>; <span class="kp">first</span> <span class="bp">by</span> near: x.
  <span class="bp">by</span> <span class="nb">rewrite</span> ler_distl_subl // ltW //; near: x.
- <span class="kr">exists</span> (<span class="nv">x0</span> + <span class="mi">1</span>); <span class="nb">apply</span>/ubP =&gt; x /(_ _ x01) /downP [y].
  <span class="nb">rewrite</span> -[ball _ _ _]/(_ (_ &lt; _)) ltr_distl ltr_subl_addr =&gt; /andP[/ltW].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /(le_trans _) yx01 _ /yx01.
<span class="kr">exists</span> (<span class="nv">sup</span> <span class="nv">D</span>).
<span class="nb">apply</span>/cvgrPdist_le =&gt; /= _ /posnumP[eps]; near=&gt; x.
<span class="nb">rewrite</span> ler_distl; <span class="nb">move</span>/ubP: (sup_upper_bound D_has_sup) =&gt; -&gt; //=.
  <span class="nb">apply</span>: sup_le_ub =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: D_has_sup.
  <span class="nb">have</span> Fxeps : F (ball_ [eta normr] x eps%:num).
    <span class="bp">by</span> near: x; <span class="nb">apply</span>: nearP_dep; <span class="nb">apply</span>: F_cauchy.
  <span class="nb">apply</span>/ubP =&gt; y /(_ _ Fxeps) /downP[z].
  <span class="nb">rewrite</span> /ball_/= ltr_distl ltr_subl_addr.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; /andP [/ltW /(le_trans _) le_xeps _ /le_xeps].
<span class="nb">rewrite</span> /D /= =&gt; A FA; near F =&gt; y.
<span class="nb">apply</span>/downP; <span class="kr">exists</span> <span class="nv">y</span>.
<span class="bp">by</span> near: y.
<span class="nb">rewrite</span> ler_subl_addl -ler_subl_addr ltW //.
<span class="nb">suff</span>: `|x - y| &lt; eps%:num <span class="bp">by</span> <span class="nb">rewrite</span> ltr_norml =&gt; /andP[_].
<span class="bp">by</span> near: y; near: x; <span class="nb">apply</span>: nearP_dep; <span class="nb">apply</span>: F_cauchy.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Canonical</span> <span class="nf">R_regular_completeType</span> (R : realType) :=
  CompleteType R^o (@R_complete R). <span class="c">(*todo : delete*)</span>
<span class="kn">Canonical</span> <span class="nf">R_regular_CompleteNormedModule</span> (R : realType) :=
  [completeNormedModType R of R^o]. <span class="c">(*todo : delete*)</span>

<span class="kn">Canonical</span> <span class="nf">R_completeType</span> (R : realType) :=
  [completeType of R <span class="kr">for</span> [completeType of R^o]].
<span class="kn">Canonical</span> <span class="nf">R_CompleteNormedModule</span> (R : realType) :=
  [completeNormedModType R of R].
<span class="c">(* new *)</span>

<span class="kn">Section</span> <span class="nf">cvg_seq_bounded</span>.
<span class="kn">Context</span> {<span class="nv">K</span> : numFieldType}.
<span class="kn">Local</span> <span class="kn">Notation</span> <span class="s2">&quot;&#39;+oo&#39;&quot;</span> := (@pinfty_nbhs K).

<span class="kn">Lemma</span> <span class="nf">cvg_seq_bounded</span> {<span class="nv">V</span> : normedModType K} (<span class="nv">a</span> : nat -&gt; V) :
  cvg a -&gt; bounded_fun a.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /cvg_bounded/ex_bound =&gt; -[/= Moo] =&gt; -[N _ /(_ _) aM].
<span class="nb">have</span> Moo_real : Moo \<span class="kr">is</span> Num.real <span class="bp">by</span> <span class="nb">rewrite</span> ger0_real ?(le_trans _ (aM N _))/=.
<span class="nb">rewrite</span> /bounded_near /=; near=&gt; M =&gt; n _.
<span class="nb">have</span> [nN|nN]/= := leqP N n; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: (le_trans (aM _ _)).
<span class="nb">move</span>: n nN; <span class="nb">suff</span> /(_ (Ordinal _)) : <span class="kr">forall</span> <span class="nv">n</span> : &#39;I_N, `|a n| &lt;= M <span class="bp">by</span> [].
<span class="bp">by</span> near: M; <span class="nb">apply</span>: filter_forall =&gt; i; <span class="nb">apply</span>: nbhs_pinfty_ge.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvg_seq_bounded</span>.

<span class="kn">Lemma</span> <span class="nf">closure_sup</span> (<span class="nv">R</span> : realType) (<span class="nv">A</span> : <span class="nb">set</span> R) :
  A !=set0 -&gt; has_ubound A -&gt; closure A (sup A).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; A0 ?; <span class="nb">have</span> [|AsupA] := pselect (A (sup A)); <span class="kp">first</span> <span class="bp">exact</span>: subset_closure.
<span class="nb">rewrite</span> closure_limit_point; <span class="nb">right</span> =&gt; U /nbhs_ballP[_ /posnumP[e]] supAeU.
<span class="nb">suff</span> [x [Ax /andP[sAex xsA]]] : <span class="kr">exists</span> <span class="nv">x</span>, A x /\ sup A - e%:num &lt; x &lt; sup A.
  <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span> =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> lt_eqF.
  <span class="nb">apply</span> supAeU; <span class="nb">rewrite</span> /ball /= ltr_distl (addrC x e%:num) -ltr_subl_addl sAex.
  <span class="bp">by</span> <span class="nb">rewrite</span> andbT (le_lt_trans _ xsA) // ler_subl_addl ler_addr.
<span class="nb">apply</span>: contrapT =&gt; /forallNP Ax.
<span class="nb">suff</span> /(sup_le_ub A0) : ubound A (sup A - e%:num).
  <span class="bp">by</span> <span class="nb">rewrite</span> leNgt =&gt; /negP; <span class="nb">apply</span>; <span class="nb">rewrite</span> ltr_subl_addl ltr_addr.
<span class="nb">move</span>=&gt; y Ay; <span class="nb">have</span> /not_andP[//|/negP] := Ax y.
<span class="nb">rewrite</span> negb_and leNgt =&gt; /orP[//|]; <span class="nb">apply</span>: contra =&gt; sAey.
<span class="nb">rewrite</span> lt_neqAle sup_upper_bound // andbT.
<span class="bp">by</span> <span class="nb">apply</span>: contra_not_neq AsupA =&gt; &lt;-.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_infty_natSinv_lt</span> (<span class="nv">R</span> : archiFieldType) (<span class="nv">e</span> : {posnum R}) :
  \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, n.+<span class="mi">1</span>%:R^-<span class="mi">1</span> &lt; e%:num.
<span class="kn">Proof</span>.
near=&gt; n; <span class="nb">rewrite</span> -(@ltr_pmul2r _ n.+<span class="mi">1</span>%:R) // mulVr <span class="nl">?unitfE</span> //.
<span class="nb">rewrite</span> -(@ltr_pmul2l _ e%:num^-<span class="mi">1</span>) // mulr1 mulrA mulVr <span class="nl">?unitfE</span> // mul1r.
<span class="nb">rewrite</span> (lt_trans (archi_boundP _)) // ltr_nat.
<span class="bp">by</span> near: n; <span class="kr">exists</span> (<span class="nv">Num</span>.bound e%:num^-<span class="mi">1</span>).
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_infty_natSinv_expn_lt</span> (<span class="nv">R</span> : archiFieldType) (<span class="nv">e</span> : {posnum R}) :
  \<span class="kr">forall</span> <span class="nv">n</span> \near \oo, <span class="mi">1</span> / <span class="mi">2</span> ^+ n &lt; e%:num.
<span class="kn">Proof</span>.
near=&gt; n.
<span class="nb">rewrite</span> -(@ltr_pmul2r _ (<span class="mi">2</span> ^+ n)) // -<span class="nl">?natrX</span> <span class="nl">?ltr0n</span> <span class="nl">?expn_gt0</span>//.
<span class="nb">rewrite</span> mul1r mulVr <span class="nl">?unitfE</span> <span class="nl">?gt_eqF</span>// <span class="nl">?ltr0n</span> <span class="nl">?expn_gt0</span>//.
<span class="nb">rewrite</span> -(@ltr_pmul2l _ e%:num^-<span class="mi">1</span>) // mulr1 mulrA mulVr <span class="nl">?unitfE</span> // mul1r.
<span class="nb">rewrite</span> (lt_trans (archi_boundP _)) // natrX upper_nthrootP //.
near: n; <span class="nb">eexists</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; m; <span class="bp">exact</span>.
<span class="bp">by</span> [].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limit_pointP</span> (<span class="nv">T</span> : archiFieldType) (<span class="nv">A</span> : <span class="nb">set</span> T) (<span class="nv">x</span> : T) :
  limit_point A x &lt;-&gt; <span class="kr">exists</span> <span class="nv">a_</span> : nat -&gt; T,
    [/\ a_ @` setT `&lt;=` A, <span class="kr">forall</span> <span class="nv">n</span>, a_ n != x &amp; a_ --&gt; x].
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [Ax|[a_ [aTA a_x] ax]]; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; U /ax[m _ a_U]; near \oo =&gt; n; <span class="kr">exists</span> (<span class="nv">a_</span> <span class="nv">n</span>); <span class="nb">split</span> =&gt; //.
  <span class="bp">by</span> <span class="nb">apply</span> aTA; <span class="kr">exists</span> <span class="nv">n</span>.
  <span class="bp">by</span> <span class="nb">apply</span> a_U; near: n; <span class="kr">exists</span> <span class="nv">m</span>.
<span class="nb">pose</span> U := <span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; [<span class="nb">set</span> z : T | `|x - z| &lt; n.+<span class="mi">1</span>%:R^-<span class="mi">1</span>].
<span class="nb">suff</span> /(_ _)/cid-/all_sig[a_ anx] : <span class="kr">forall</span> <span class="nv">n</span>, <span class="kr">exists</span> <span class="nv">a</span>, a != x /\ (U n `&amp;` A) a.
  <span class="kr">exists</span> <span class="nv">a_</span>; <span class="nb">split</span>.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; a [n _ &lt;-]; <span class="nb">have</span> [? []] := anx n.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; n; <span class="nb">have</span> [] := anx n.
  - <span class="nb">apply</span>/cvgrPdist_lt =&gt; _/posnumP[e]; near=&gt; n;  <span class="nb">have</span> [? [] Uan Aan] := anx n.
    <span class="bp">by</span> <span class="nb">rewrite</span> (lt_le_trans Uan)// ltW//; near: n; <span class="bp">exact</span>: near_infty_natSinv_lt.
<span class="nb">move</span>=&gt; n; <span class="nb">have</span> : nbhs (x : T) (U n).
  <span class="bp">by</span> <span class="nb">apply</span>/(nbhs_ballP (x:T) (U n)); <span class="nb">rewrite</span> nbhs_ballE; <span class="kr">exists</span> <span class="nv">n</span>.+<span class="mi">1</span>%:R^-<span class="mi">1</span> =&gt; //=.
<span class="bp">by</span> <span class="nb">move</span>/Ax/cid =&gt; [/= an [anx Aan Uan]]; <span class="kr">exists</span> <span class="nv">an</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">interval</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : numDomainType.

<span class="kn">Definition</span> <span class="nf">is_interval</span> (<span class="nv">E</span> : <span class="nb">set</span> R) :=
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, E x -&gt; E y -&gt; <span class="kr">forall</span> <span class="nv">z</span>, x &lt;= z &lt;= y -&gt; E z.

<span class="kn">Lemma</span> <span class="nf">is_intervalPlt</span> (<span class="nv">E</span> : <span class="nb">set</span> R) :
  is_interval E &lt;-&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, E x -&gt; E y -&gt; <span class="kr">forall</span> <span class="nv">z</span>, x &lt; z &lt; y -&gt; E z.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; iE x y Ex Ey z /andP[].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; xz zy; <span class="nb">apply</span>: (iE x y); <span class="nb">rewrite</span> <span class="nl">?ltW</span>.
<span class="nb">rewrite</span> !le_eqVlt =&gt; /predU1P[&lt;-//|xz] /predU1P[-&gt;//|zy].
<span class="bp">by</span> <span class="nb">apply</span>: (iE x y); <span class="nb">rewrite</span> <span class="nl">?xz</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">interval_is_interval</span> (<span class="nv">i</span> : interval R) : is_interval [<span class="nb">set</span>` i].
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">case</span>: i =&gt; -[[]a|[]] [[]b|[]] // x y /=; <span class="kp">do</span> ?[<span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?itv_ge</span>//];
  <span class="nb">move</span>=&gt; xi yi z; <span class="nb">rewrite</span> -[x &lt;= z &lt;= y]/(z \<span class="kr">in</span> `[x, y]); <span class="nb">apply</span>/subitvP;
  <span class="nb">rewrite</span> subitvE /Order.le/= ?(itvP xi, itvP yi).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">interval</span>.

<span class="kn">Section</span> <span class="nf">ereal_is_hausdorff</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realFieldType.
<span class="kn">Implicit Types</span> <span class="nv">r</span> : R.

<span class="kn">Lemma</span> <span class="nf">nbhs_image_EFin</span> (<span class="nv">x</span> : R) (<span class="nv">X</span> : <span class="nb">set</span> R) :
  nbhs x X -&gt; nbhs x%:E ((<span class="kr">fun</span> <span class="nv">r</span> =&gt; r%:E) @` X).
<span class="kn">Proof</span>.
<span class="nb">case</span> =&gt; _/posnumP[e] xeX; <span class="kr">exists</span> <span class="nv">e</span>%:num =&gt; //= r xer.
<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">r</span> =&gt; //; <span class="nb">apply</span> xeX.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_open_ereal_lt</span> <span class="nv">r</span> (<span class="nv">f</span> : R -&gt; R) : r &lt; f r -&gt;
  nbhs r%:E [<span class="nb">set</span> y | y &lt; (f r)%:E]%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; xfx; <span class="nb">rewrite</span> nbhsE /=; <span class="nb">eexists</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; y; <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span> open_ereal_lt_ereal | <span class="nb">rewrite</span> /= lte_fin].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_open_ereal_gt</span> <span class="nv">r</span> (<span class="nv">f</span> : R -&gt; R) : f r &lt; r -&gt;
  nbhs r%:E [<span class="nb">set</span> y | (f r)%:E &lt; y]%E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; xfx; <span class="nb">rewrite</span> nbhsE /=; <span class="nb">eexists</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; y; <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span> open_ereal_gt_ereal | <span class="nb">rewrite</span> /= lte_fin].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_open_ereal_pinfty</span> <span class="nv">r</span> : (nbhs +oo [<span class="nb">set</span> y | r%:E &lt; y])%E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> nbhsE /=; <span class="nb">eexists</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; y; <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span> open_ereal_gt_ereal | <span class="nb">rewrite</span> /= ltry].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_open_ereal_ninfty</span> <span class="nv">r</span> : (nbhs -oo [<span class="nb">set</span> y | y &lt; r%:E])%E.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> nbhsE /=; <span class="nb">eexists</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; y; <span class="bp">exact</span>.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span> open_ereal_lt_ereal | <span class="nb">rewrite</span> /= ltNyr].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ereal_hausdorff</span> : hausdorff_space (ereal_topologicalType R).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; -[r| |] // [r&#39; | |] //=.
- <span class="nb">move</span>=&gt; rr&#39;; <span class="nb">congr</span> (_%:E); <span class="nb">apply</span> Rhausdorff =&gt; /= A B rA r&#39;B.
  <span class="nb">have</span> [/= z [[r0 ? r0z] [r1 ?]]] :=
    rr&#39; _ _ (nbhs_image_EFin rA) (nbhs_image_EFin r&#39;B).
  <span class="bp">by</span> <span class="nb">rewrite</span> -r0z =&gt; -[r1r0]; <span class="kr">exists</span> <span class="nv">r0</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> -r1r0.
- <span class="nb">have</span> /(@nbhs_open_ereal_lt _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x + <span class="mi">1</span>)) loc_r : r &lt; r + <span class="mi">1</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltr_addl.
  <span class="nb">move</span>/(_ _ _ loc_r (nbhs_open_ereal_pinfty (r + <span class="mi">1</span>))) =&gt; -[z [zr rz]].
  <span class="bp">by</span> <span class="nb">move</span>: (lt_trans rz zr); <span class="nb">rewrite</span> lte_fin ltxx.
- <span class="nb">have</span> /(@nbhs_open_ereal_gt _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x - <span class="mi">1</span>)) loc_r : r - <span class="mi">1</span> &lt; r.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltr_subl_addr ltr_addl.
  <span class="nb">move</span>/(_ _ _ loc_r (nbhs_open_ereal_ninfty (r - <span class="mi">1</span>))) =&gt; -[z [rz zr]].
  <span class="bp">by</span> <span class="nb">move</span>: (lt_trans zr rz); <span class="nb">rewrite</span> ltxx.
- <span class="nb">have</span> /(@nbhs_open_ereal_lt _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x + <span class="mi">1</span>)) loc_r&#39; : r&#39; &lt; r&#39; + <span class="mi">1</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltr_addl.
  <span class="nb">move</span>/(_ _ _ (nbhs_open_ereal_pinfty (r&#39; + <span class="mi">1</span>)) loc_r&#39;) =&gt; -[z [r&#39;z zr&#39;]].
  <span class="bp">by</span> <span class="nb">move</span>: (lt_trans zr&#39; r&#39;z); <span class="nb">rewrite</span> ltxx.
- <span class="nb">move</span>/(_ _ _ (nbhs_open_ereal_pinfty <span class="mi">0</span>) (nbhs_open_ereal_ninfty <span class="mi">0</span>)).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; -[z [zx xz]]; <span class="nb">move</span>: (lt_trans xz zx); <span class="nb">rewrite</span> ltxx.
- <span class="nb">have</span> /(@nbhs_open_ereal_gt _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x - <span class="mi">1</span>)) yB : r&#39; - <span class="mi">1</span> &lt; r&#39;.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltr_subl_addr ltr_addl.
  <span class="nb">move</span>/(_ _ _ (nbhs_open_ereal_ninfty (r&#39; - <span class="mi">1</span>)) yB) =&gt; -[z [zr&#39; r&#39;z]].
  <span class="bp">by</span> <span class="nb">move</span>: (lt_trans r&#39;z zr&#39;); <span class="nb">rewrite</span> ltxx.
- <span class="nb">move</span>/(_ _ _ (nbhs_open_ereal_ninfty <span class="mi">0</span>) (nbhs_open_ereal_pinfty <span class="mi">0</span>)).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; -[z [zO Oz]]; <span class="nb">move</span>: (lt_trans Oz zO); <span class="nb">rewrite</span> ltxx.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ereal_is_hausdorff</span>.

#[<span class="kn">global</span>]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (hausdorff_space _) =&gt; <span class="kp">solve</span>[<span class="nb">apply</span>: ereal_hausdorff] : core.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;renamed to `nbhs_image_EFin`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">nbhs_image_ERFin</span> := nbhs_image_EFin.

<span class="kn">Lemma</span> <span class="nf">EFin_lim</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">f</span> : nat -&gt; R) : cvg f -&gt;
  lim (EFin \o f) = (lim f)%:E.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; cf; <span class="nb">apply</span>: cvg_lim =&gt; //; <span class="nb">move</span>/cvg_ex : cf =&gt; [l fl].
<span class="bp">by</span> <span class="nb">apply</span>: (cvg_comp fl); <span class="nb">rewrite</span> (cvg_lim _ fl).
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">ProperFilterERealType</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">a</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">Fa</span> : ProperFilter a} {<span class="nv">R</span> : realFieldType}.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : T -&gt; \bar R.

<span class="kn">Lemma</span> <span class="nf">cvge_to_ge</span> <span class="nv">f</span> <span class="nv">b</span> <span class="nv">c</span> : f @ a --&gt; c -&gt; (\near a, b &lt;= f a) -&gt; b &lt;= c.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /[<span class="nb">swap</span>]/(closed_cvg _ (@closed_ereal_le_ereal _ b)) /[<span class="nb">apply</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvge_to_le</span> <span class="nv">f</span> <span class="nv">b</span> <span class="nv">c</span> : f @ a --&gt; c -&gt; (\near a, f a &lt;= b) -&gt; c &lt;= b.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /[<span class="nb">swap</span>]/(closed_cvg _ (@closed_ereal_ge_ereal _ b))/[<span class="nb">apply</span>].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lime_ge</span> <span class="nv">x</span> <span class="nv">f</span> : cvg (f @ a) -&gt; (\near a, x &lt;= f a) -&gt; x &lt;= lim (f @ a).
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvge_to_ge. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lime_le</span> <span class="nv">x</span> <span class="nv">f</span> : cvg (f @ a) -&gt; (\near a, x &gt;= f a) -&gt; x &gt;= lim (f @ a).
<span class="kn">Proof</span>. <span class="bp">exact</span>: cvge_to_le. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ProperFilterERealType</span>.

<span class="kn">Section</span> <span class="nf">ecvg_realFieldType_proper</span>.
<span class="kn">Context</span> {<span class="nv">I</span>} {<span class="nv">F</span> : <span class="nb">set</span> (<span class="nb">set</span> I)} {<span class="nv">FF</span> : ProperFilter F} {<span class="nv">R</span> : realFieldType}.
<span class="kn">Implicit Types</span> (<span class="nv">f</span> <span class="nv">g</span> : I -&gt; \bar R) (<span class="nv">u</span> <span class="nv">v</span> : I -&gt; R) (<span class="nv">x</span> : \bar R) (<span class="nv">r</span> : R).
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.

<span class="kn">Lemma</span> <span class="nf">is_cvgeD</span> <span class="nv">f</span> <span class="nv">g</span> :
  lim (f @ F) +? lim (g @ F) -&gt; cvg (f @ F) -&gt; cvg (g @ F) -&gt; cvg (f \+ g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fg fc gc; <span class="nb">have</span> /(_ _)/cvgP := cvgeD fg fc gc. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limeD</span> <span class="nv">f</span> <span class="nv">g</span> :
  cvg (f @ F) -&gt; cvg (g @ F) -&gt; lim (f @ F) +? lim (g @ F) -&gt;
  lim (f \+ g @ F) = lim (f @ F) + lim (g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf cg fg; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="bp">exact</span>: cvgeD. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limeMl</span> <span class="nv">f</span> <span class="nv">y</span> : y \<span class="kr">is</span> a fin_num -&gt; cvg (f @ F) -&gt;
  lim ((<span class="kr">fun</span> <span class="nv">n</span> =&gt; y * f n) @ F) = y * lim (f @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; yfn cf; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="bp">exact</span>: cvgeMl. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limeMr</span> <span class="nv">f</span> <span class="nv">y</span> : y \<span class="kr">is</span> a fin_num -&gt; cvg (f @ F) -&gt;
  lim ((<span class="kr">fun</span> <span class="nv">n</span> =&gt; f n * y) @ F) = lim (f @ F) * y.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; yfn cf; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>: cvgeMr. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_cvgeM</span> <span class="nv">f</span> <span class="nv">g</span> :
  lim (f @ F) *? lim (g @ F) -&gt; cvg (f @ F) -&gt; cvg (g @ F) -&gt; cvg (f \* g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; fg fc gc; <span class="nb">have</span> /(_ _)/cvgP := cvgeM fg fc gc. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limeM</span> <span class="nv">f</span> <span class="nv">g</span> :
  cvg (f @ F) -&gt; cvg (g @ F) -&gt; lim (f @ F) *? lim (g @ F) -&gt;
  lim (f \* g @ F) = lim (f @ F) * lim (g @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf cg fg; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="bp">exact</span>: cvgeM. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">limeN</span> <span class="nv">f</span> : cvg (f @ F) -&gt; lim (\- f @ F) = - lim (f @ F).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; cf; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>: cvgeN. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvge_ge</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span> : (\<span class="kr">forall</span> <span class="nv">x</span> \near F, b &lt;= f x) -&gt; f @ F --&gt; a -&gt; b &lt;= a.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? fa; <span class="nb">rewrite</span> -(cvg_lim _ fa) <span class="nl">?lime_ge</span>//=; <span class="nb">apply</span>: cvgP fa. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvge_le</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span> : (\<span class="kr">forall</span> <span class="nv">x</span> \near F, b &gt;= f x) -&gt; f @ F --&gt; a -&gt; b &gt;= a.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? fa; <span class="nb">rewrite</span> -(cvg_lim _ fa) <span class="nl">?lime_le</span>//=; <span class="nb">apply</span>: cvgP fa. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_nnesum</span> (<span class="nv">J</span> : <span class="kt">Type</span>) (<span class="nv">r</span> : seq J) (<span class="nv">f</span> : J -&gt; I -&gt; \bar R)
   (<span class="nv">l</span> : J -&gt; \bar R) (<span class="nv">P</span> : pred J) :
  (<span class="kr">forall</span> <span class="nv">j</span>, P j -&gt; \near F, <span class="mi">0</span> &lt;= f j F) -&gt;
  (<span class="kr">forall</span> <span class="nv">j</span>, P j -&gt; f j @ F --&gt; l j) -&gt;
  \sum_(j &lt;- r | P j) f j i @[i --&gt; F] --&gt; \sum_(j &lt;- r | P j) l j.
<span class="kn">Proof</span>.
<span class="nb">pose</span> bigsimp := (big_nil, big_cons);
<span class="nb">elim</span>: r =&gt; [|x r IHr]/= f0 fl; <span class="nb">rewrite</span> bigsimp; <span class="nb">under</span> eq_fun <span class="kp">do</span> <span class="nb">rewrite</span> bigsimp.
  <span class="bp">exact</span>: cvg_cst.
<span class="nb">case</span>: ifPn =&gt; [Px|Pnx]; <span class="nb">last</span> <span class="bp">exact</span>: IHr.
<span class="nb">apply</span>: cvgeD; [|<span class="bp">exact</span>: fl|<span class="bp">exact</span>: IHr].
<span class="bp">by</span> <span class="nb">rewrite</span> ge0_adde_def <span class="nl">?inE</span>// <span class="nl">?sume_ge0</span>// =&gt; [|j Pj];
   <span class="nb">rewrite</span> (cvge_ge _ (fl _ _))//; <span class="nb">apply</span>: f0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lim_nnesum</span> (<span class="nv">J</span> : <span class="kt">Type</span>) (<span class="nv">r</span> : seq J) (<span class="nv">f</span> : J -&gt; I -&gt; \bar R)
   (<span class="nv">l</span> : J -&gt; \bar R) (<span class="nv">P</span> : pred J) :
  (<span class="kr">forall</span> <span class="nv">j</span>, P j -&gt; \near F, <span class="mi">0</span> &lt;= f j F) -&gt;
  (<span class="kr">forall</span> <span class="nv">j</span>, P j -&gt; cvg (f j @ F)) -&gt;
  lim (\sum_(j &lt;- r | P j) f j i @[i --&gt; F]) = \sum_(j &lt;- r | P j) (lim (f j @ F)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="nb">apply</span>/cvg_lim =&gt; //; <span class="nb">apply</span>: cvg_nnesum. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">ecvg_realFieldType_proper</span>.

#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;generalized to `limeMl`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_limrM</span> := limeMl.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;generalized to `limeMr`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_limMr</span> := limeMr.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>, note=<span class="s2">&quot;generalized to `limeN`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ereal_limN</span> := limeN.

<span class="kn">Section</span> <span class="nf">cvg_0_pinfty</span>.
<span class="kn">Context</span> {<span class="nv">R</span> : realFieldType} {<span class="nv">I</span> : <span class="kt">Type</span>} {<span class="nv">a</span> : <span class="nb">set</span> (<span class="nb">set</span> I)} {<span class="nv">FF</span> : Filter a}.
<span class="kn">Implicit Types</span> <span class="nv">f</span> : I -&gt; R.

<span class="kn">Lemma</span> <span class="nf">gtr0_cvgV0</span> <span class="nv">f</span> : (\near a, <span class="mi">0</span> &lt; f a) -&gt; f\^-<span class="mi">1</span> @ a --&gt; <span class="mi">0</span> &lt;-&gt; f @ a --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; f_gt0; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="nb">move</span>=&gt; /cvgryPgt cvg_f_oo; <span class="nb">apply</span>/cvgr0Pnorm_lt =&gt; _/posnumP[e].
  near=&gt; i; <span class="nb">rewrite</span> gtr0_norm <span class="nl">?invr_gt0</span>//; <span class="nb">last</span> <span class="bp">by</span> near: i.
  <span class="bp">by</span> <span class="nb">rewrite</span> -ltf_pinv <span class="nl">?qualifE</span> <span class="nl">?invr_gt0</span> <span class="nl">?invrK</span>//=; near: i.
<span class="nb">move</span>=&gt; /cvgr0Pnorm_lt uB; <span class="nb">apply</span>/cvgryPgty.
near=&gt; M; near=&gt; i; <span class="nb">suff</span>: `|(f i)^-<span class="mi">1</span>| &lt; M^-<span class="mi">1</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> gtr0_norm <span class="nl">?ltf_pinv</span> <span class="nl">?qualifE</span> <span class="nl">?invr_gt0</span>//; near: i.
<span class="bp">by</span> near: i; <span class="nb">apply</span>: uB; <span class="nb">rewrite</span> <span class="nl">?invr_gt0</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrVy</span> <span class="nv">f</span> : (\near a, <span class="mi">0</span> &lt; f a) -&gt; f\^-<span class="mi">1</span> @ a --&gt; +oo &lt;-&gt; f @ a --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; f_gt0; <span class="nb">rewrite</span> -gtr0_cvgV0 <span class="nl">?inv_funK</span>//; near <span class="kp">do</span> <span class="nb">rewrite</span> invr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ltr0_cvgV0</span> <span class="nv">f</span> : (\near a, <span class="mi">0</span> &gt; f a) -&gt; f\^-<span class="mi">1</span> @ a --&gt; <span class="mi">0</span> &lt;-&gt; f @ a --&gt; -oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fL0; <span class="nb">rewrite</span> -cvgNP oppr0 (_ : - f\^-<span class="mi">1</span> =  (- f)\^-<span class="mi">1</span>); <span class="nb">last first</span>.
   <span class="bp">by</span> <span class="nb">apply</span>/funeqP =&gt; i; <span class="nb">rewrite</span> opprfctE/= invrN.
<span class="bp">by</span> <span class="nb">rewrite</span> gtr0_cvgV0 <span class="nl">?cvgNry</span>//; near <span class="kp">do</span> <span class="nb">rewrite</span> oppr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvgrVNy</span> <span class="nv">f</span> : (\near a, <span class="mi">0</span> &gt; f a) -&gt; f\^-<span class="mi">1</span> @ a --&gt; -oo &lt;-&gt; f @ a --&gt; <span class="mi">0</span>.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">move</span>=&gt; f_lt0; <span class="nb">rewrite</span> -ltr0_cvgV0 <span class="nl">?inv_funK</span>//; near <span class="kp">do</span> <span class="nb">rewrite</span> invr_lt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">cvg_0_pinfty</span>.

<span class="kn">Section</span> <span class="nf">FilterRealType</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">a</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">Fa</span> : Filter a} {<span class="nv">R</span> : realFieldType}.
<span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : T -&gt; R.

<span class="kn">Lemma</span> <span class="nf">squeeze_cvgr</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : (\near a, f a &lt;= g a &lt;= h a) -&gt;
  <span class="kr">forall</span> (<span class="nv">l</span> : R), f @ a --&gt; l -&gt; h @ a --&gt; l -&gt; g @ a --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fgh l lfa lga; <span class="nb">apply</span>/cvgrPdist_lt =&gt; e e_gt0.
near=&gt; x; <span class="nb">have</span> /(_ _)/andP[//|fg gh] := near fgh x.
<span class="nb">rewrite</span> distrC ltr_distl (lt_le_trans _ fg) ?(le_lt_trans gh)//=.
  <span class="bp">by</span> near: x; <span class="nb">apply</span>: (cvgr_lt l); <span class="nb">rewrite</span> // ltr_addl.
<span class="bp">by</span> near: x; <span class="nb">apply</span>: (cvgr_gt l); <span class="nb">rewrite</span> // gtr_addl oppr_lt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ger_cvgy</span> <span class="nv">f</span> <span class="nv">g</span> : (\near a, f a &lt;= g a) -&gt;
  f @ a --&gt; +oo -&gt; g @ a --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; uv /cvgryPge ucvg; <span class="nb">apply</span>/cvgryPge =&gt; A.
<span class="bp">by</span> near=&gt; x <span class="kp">do</span> <span class="nb">rewrite</span> (le_trans _ (near uv x _))//.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ler_cvgNy</span> <span class="nv">f</span> <span class="nv">g</span> : (\near a, f a &gt;= g a) -&gt;
  f @ a --&gt; -oo -&gt; g @ a --&gt; -oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; uv /cvgrNyPle ucvg; <span class="nb">apply</span>/cvgrNyPle =&gt; A.
<span class="bp">by</span> near=&gt; x <span class="kp">do</span> <span class="nb">rewrite</span> (le_trans (near uv x _))//.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">FilterRealType</span>.

<span class="kn">Section</span> <span class="nf">TopoProperFilterRealType</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType} {<span class="nv">a</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">Fa</span> : ProperFilter a}.
<span class="kn">Context</span> {<span class="nv">R</span> : realFieldType}.
<span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : T -&gt; R.

<span class="kn">Lemma</span> <span class="nf">ler_cvg_to</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">l</span> <span class="nv">l&#39;</span> : f @ a --&gt; l -&gt; g @ a --&gt; l&#39; -&gt;
  (\near a, f a &lt;= g a) -&gt; l &lt;= l&#39;.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fl gl; <span class="nb">under</span> eq_near <span class="kp">do</span> <span class="nb">rewrite</span> -subr_ge0; <span class="nb">rewrite</span> -subr_ge0.
<span class="bp">by</span> <span class="nb">apply</span>: cvgr_to_ge; <span class="nb">apply</span>: cvgB.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">ler_lim</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (f @ a) -&gt; cvg (g @ a) -&gt;
  (\near a, f a &lt;= g a) -&gt; lim (f @ a) &lt;= lim (g @ a).
<span class="kn">Proof</span>. <span class="bp">exact</span>: ler_cvg_to. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">TopoProperFilterRealType</span>.

<span class="kn">Section</span> <span class="nf">FilterERealType</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">a</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">Fa</span> : Filter a} {<span class="nv">R</span> : realFieldType}.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : T -&gt; \bar R.

<span class="kn">Lemma</span> <span class="nf">gee_cvgy</span> <span class="nv">f</span> <span class="nv">g</span> : (\near a, f a &lt;= g a) -&gt;
  f @ a --&gt; +oo -&gt; g @ a --&gt; +oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; uv /cvgeyPge uecvg; <span class="nb">apply</span>/cvgeyPge =&gt; A.
<span class="bp">by</span> near=&gt; x <span class="kp">do</span> <span class="nb">rewrite</span> (le_trans _ (near uv x _))//.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lee_cvgNy</span> <span class="nv">f</span> <span class="nv">g</span> : (\near a, f a &gt;= g a) -&gt;
  f @ a --&gt; -oo -&gt; g @ a --&gt; -oo.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; uv /cvgeNyPle uecvg; <span class="nb">apply</span>/cvgeNyPle =&gt; A.
<span class="bp">by</span> near=&gt; x <span class="kp">do</span> <span class="nb">rewrite</span> (le_trans (near uv x _))//.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">squeeze_fin</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : (\near a, f a &lt;= g a &lt;= h a) -&gt;
    (\near a, f a \<span class="kr">is</span> a fin_num) -&gt; (\near a, h a \<span class="kr">is</span> a fin_num) -&gt;
  (\near a, g a \<span class="kr">is</span> a fin_num).
<span class="kn">Proof</span>.
<span class="nb">apply</span>: filterS3 =&gt; x /andP[fg gh].
<span class="nb">rewrite</span> !fin_numElt =&gt; /andP[oof _] /andP[_ hoo].
<span class="bp">by</span> <span class="nb">rewrite</span> (lt_le_trans oof) ?(le_lt_trans gh).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">squeeze_cvge</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : (\near a, f a &lt;= g a &lt;= h a) -&gt;
  <span class="kr">forall</span> (<span class="nv">l</span> : \bar R), f @ a --&gt; l -&gt; h @ a --&gt; l -&gt; g @ a --&gt; l.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; fgh [l||]; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; + _; <span class="nb">apply</span>: gee_cvgy; <span class="nb">apply</span>: filterS fgh =&gt; ? /andP[].
- <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">apply</span>: lee_cvgNy; <span class="nb">apply</span>: filterS fgh =&gt; ? /andP[].
<span class="nb">move</span>=&gt; /fine_cvgP[Ff fl] /fine_cvgP[Fh hl]; <span class="nb">apply</span>/fine_cvgP.
<span class="nb">have</span> Fg := squeeze_fin fgh Ff Fh; <span class="nb">split</span>=&gt; //.
<span class="nb">apply</span>: squeeze_cvgr fl hl; near=&gt; x =&gt; /=.
<span class="bp">by</span> <span class="nb">have</span> /(_ _)/andP[//|fg gh] := near fgh x; <span class="nb">rewrite</span> !fine_le//=; near: x.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">FilterERealType</span>.

<span class="kn">Section</span> <span class="nf">TopoProperFilterERealType</span>.
<span class="kn">Context</span> {<span class="nv">T</span> : topologicalType} {<span class="nv">a</span> : <span class="nb">set</span> (<span class="nb">set</span> T)} {<span class="nv">Fa</span> : ProperFilter a}.
<span class="kn">Context</span> {<span class="nv">R</span> : realFieldType}.
<span class="kn">Local</span> <span class="kn">Open Scope</span> ereal_scope.
<span class="kn">Implicit Types</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : T -&gt; \bar R.

<span class="kn">Lemma</span> <span class="nf">lee_cvg_to</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">l</span> <span class="nv">l&#39;</span> : f @ a --&gt; l -&gt; g @ a --&gt; l&#39; -&gt;
  (\near a, f a &lt;= g a) -&gt; l &lt;= l&#39;.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; + + fg; <span class="nb">move</span>: l&#39; l.
<span class="nb">move</span>=&gt; /= [l&#39;||] [l||]//=; <span class="nb">rewrite</span> <span class="nl">?leNye</span> <span class="nl">?leey</span>//=; <span class="kp">first</span> <span class="mi">1</span> <span class="nb">last</span>.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; /(gee_cvgy fg) /cvg_lim&lt;-// /cvg_lim&lt;-.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; /cvg_lim &lt;-// /(lee_cvgNy fg) /cvg_lim&lt;-.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; /(gee_cvgy fg) /cvg_lim&lt;-// /cvg_lim&lt;-.
<span class="nb">move</span>=&gt; /fine_cvgP[Ff fl] /fine_cvgP[Fg gl].
<span class="nb">rewrite</span> lee_fin -(cvg_lim _ fl)// -(cvg_lim _ gl)//.
<span class="bp">by</span> <span class="nb">apply</span>: ler_lim; [<span class="nb">apply</span>: cvgP fl|<span class="nb">apply</span>: cvgP gl|near <span class="kp">do</span> <span class="nb">apply</span>: fine_le].
<span class="kn">Unshelve</span>. <span class="kp">all</span>: end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">lee_lim</span> <span class="nv">f</span> <span class="nv">g</span> : cvg (f @ a) -&gt; cvg (g @ a) -&gt;
  (\near a, f a &lt;= g a) -&gt; lim (f @ a) &lt;= lim (g @ a).
<span class="kn">Proof</span>. <span class="bp">exact</span>: lee_cvg_to. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">TopoProperFilterERealType</span>.

<span class="kn">Section</span> <span class="nf">open_union_rat</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.
<span class="kn">Implicit Types</span> <span class="nv">A</span> <span class="nv">U</span> : <span class="nb">set</span> R.

<span class="kn">Let</span> <span class="nf">ointsub</span> <span class="nv">A</span> <span class="nv">U</span> := [/\ open A, is_interval A &amp; A `&lt;=` U].

<span class="kn">Let</span> <span class="nf">ointsub_rat</span> <span class="nv">U</span> <span class="nv">q</span> := [<span class="nb">set</span> A | ointsub A U /\ A (ratr q)].

<span class="kn">Let</span> <span class="nf">ointsub_rat0</span> <span class="nv">q</span> : ointsub_rat set0 q = set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>/seteqP; <span class="nb">split</span> =&gt; // A [[_ _]]; <span class="nb">rewrite</span> subset0 =&gt; -&gt;. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">bigcup_ointsub</span> <span class="nv">U</span> <span class="nv">q</span> := \bigcup_(A <span class="kr">in</span> ointsub_rat U q) A.

<span class="kn">Lemma</span> <span class="nf">bigcup_ointsub0</span> <span class="nv">q</span> : bigcup_ointsub set0 q = set0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /bigcup_ointsub ointsub_rat0 bigcup_set0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_bigcup_ointsub</span> <span class="nv">U</span> <span class="nv">q</span> : open (bigcup_ointsub U q).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">apply</span>: bigcup_open =&gt; i [[]]. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_interval_bigcup_ointsub</span> <span class="nv">U</span> <span class="nv">q</span> : is_interval (bigcup_ointsub U q).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /= a b [A [[oA iA AU] Aq] Aa] [B [[oB iB BU] Bq] Bb] c /andP[ac cb].
<span class="nb">have</span> [cq|cq|-&gt;] := ltgtP c (ratr q); <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span>.
- <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">A</span> =&gt; //; <span class="nb">apply</span>: (iA a (ratr q)) =&gt; //; <span class="nb">rewrite</span> ac (ltW cq).
- <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="nb">apply</span>: (iB (ratr q) b) =&gt; //; <span class="nb">rewrite</span> cb (ltW cq).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bigcup_ointsub_sub</span> <span class="nv">U</span> <span class="nv">q</span> : bigcup_ointsub U q `&lt;=` U.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; y [A [[oA _ +] _ Ay]]; <span class="bp">exact</span>. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_bigcup_rat</span> <span class="nv">U</span> : open U -&gt;
  U = \bigcup_(q <span class="kr">in</span> [<span class="nb">set</span> q | ratr q \<span class="kr">in</span> U]) bigcup_ointsub U q.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; oU; <span class="nb">have</span> [-&gt;|U0] := eqVneq U set0.
  <span class="bp">by</span> <span class="nb">rewrite</span> bigcup0// =&gt; q _; <span class="nb">rewrite</span> bigcup_ointsub0.
<span class="nb">apply</span>/seteqP; <span class="nb">split</span>=&gt; [x Ux|x [p _ Ipx]]; <span class="nb">last</span> <span class="bp">exact</span>: bigcup_ointsub_sub Ipx.
<span class="nb">suff</span> [q Iqx] : <span class="kr">exists</span> <span class="nv">q</span>, bigcup_ointsub U q x.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">q</span> =&gt; //=; <span class="nb">rewrite</span> in_setE; <span class="nb">case</span>: Iqx =&gt; A [[_ _ +] ? _]; <span class="bp">exact</span>.
<span class="nb">have</span> : nbhs x U <span class="bp">by</span> <span class="nb">rewrite</span> nbhsE /=; <span class="kr">exists</span> <span class="nv">U</span>.
<span class="nb">rewrite</span> -nbhs_ballE /nbhs_ball /nbhs_ball_ =&gt; -[_/posnumP[r] xrU].
<span class="nb">have</span> /rat_in_itvoo[q qxxr] : (x - r%:num &lt; x + r%:num)%R.
  <span class="bp">by</span> <span class="nb">rewrite</span> ltr_subl_addr -addrA ltr_addl.
<span class="kr">exists</span> <span class="nv">q</span>, `](x - r%:num)%R, (x + r%:num)%R[%classic; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= in_itv/= ltr_subl_addl ltr_addr// ltr_addl//; <span class="nb">apply</span>/andP.
<span class="nb">split</span>=&gt; //; <span class="nb">split</span>; [<span class="bp">exact</span>: interval_open|<span class="bp">exact</span>: interval_is_interval|].
<span class="nb">move</span>=&gt; y /=; <span class="nb">rewrite</span> in_itv/= =&gt; /andP[xy yxr]; <span class="nb">apply</span> xrU =&gt; /=.
<span class="nb">rewrite</span> /ball /= /ball_ /= <span class="kr">in</span> xrU *; <span class="nb">have</span> [yx|yx] := leP x y.
  <span class="bp">by</span> <span class="nb">rewrite</span> ler0_norm <span class="nl">?subr_le0</span>// opprB ltr_subl_addl.
<span class="bp">by</span> <span class="nb">rewrite</span> gtr0_norm <span class="nl">?subr_gt0</span>// ltr_subl_addr -ltr_subl_addl.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">open_union_rat</span>.

<span class="kn">Lemma</span> <span class="nf">right_bounded_interior</span> (<span class="nv">R</span> : realType) (<span class="nv">X</span> : <span class="nb">set</span> R) :
  has_ubound X -&gt; X^¬∞ `&lt;=` [<span class="nb">set</span> r | r &lt; sup X].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; uX r Xr; <span class="nb">rewrite</span> /mkset ltNge; <span class="nb">apply</span>/negP.
<span class="nb">rewrite</span> le_eqVlt =&gt; /orP[/eqP supXr|]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -leNgt sup_ub //; <span class="bp">exact</span>: interior_subset.
<span class="nb">suff</span> : ~ X^¬∞ (sup X) <span class="bp">by</span> <span class="nb">rewrite</span> supXr.
<span class="nb">case</span>/nbhs_ballP =&gt; _/posnumP[e] supXeX.
<span class="nb">have</span> [f XsupXf] : <span class="kr">exists</span> <span class="nv">f</span> : {posnum R}, X (sup X + f%:num).
  <span class="kr">exists</span> (<span class="nv">e</span>%:num / <span class="mi">2</span>)%:pos; <span class="nb">apply</span> supXeX; <span class="nb">rewrite</span> /ball /= opprD addrA subrr.
  <span class="bp">by</span> <span class="nb">rewrite</span> sub0r normrN gtr0_norm // ltr_pdivr_mulr // ltr_pmulr // ltr1n.
<span class="nb">have</span> : sup X + f%:num &lt;= sup X <span class="bp">by</span> <span class="nb">apply</span> sup_ub.
<span class="bp">by</span> <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -ltNge; <span class="nb">rewrite</span> ltr_addl.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">left_bounded_interior</span> (<span class="nv">R</span> : realType) (<span class="nv">X</span> : <span class="nb">set</span> R) :
  has_lbound X -&gt; X^¬∞ `&lt;=` [<span class="nb">set</span> r | inf X &lt; r].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; lX r Xr; <span class="nb">rewrite</span> /mkset ltNge; <span class="nb">apply</span>/negP.
<span class="nb">rewrite</span> le_eqVlt =&gt; /orP[/eqP rinfX|]; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -leNgt inf_lb //; <span class="bp">exact</span>: interior_subset.
<span class="nb">suff</span> : ~ X^¬∞ (inf X) <span class="bp">by</span> <span class="nb">rewrite</span> -rinfX.
<span class="nb">case</span>/nbhs_ballP =&gt; _/posnumP[e] supXeX.
<span class="nb">have</span> [f XsupXf] : <span class="kr">exists</span> <span class="nv">f</span> : {posnum R}, X (inf X - f%:num).
  <span class="kr">exists</span> (<span class="nv">e</span>%:num / <span class="mi">2</span>)%:pos; <span class="nb">apply</span> supXeX; <span class="nb">rewrite</span> /ball /= opprB addrCA subrr.
  <span class="bp">by</span> <span class="nb">rewrite</span> addr0 gtr0_norm // ltr_pdivr_mulr // ltr_pmulr // ltr1n.
<span class="nb">have</span> : inf X &lt;= inf X - f%:num <span class="bp">by</span> <span class="nb">apply</span> inf_lb.
<span class="bp">by</span> <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -ltNge; <span class="nb">rewrite</span> ltr_subl_addr ltr_addl.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">interval_realType</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.

<span class="kn">Lemma</span> <span class="nf">interval_unbounded_setT</span> (<span class="nv">X</span> : <span class="nb">set</span> R) : is_interval X -&gt;
  ~ has_lbound X -&gt; ~ has_ubound X -&gt; X = setT.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; iX lX uX; <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span> =&gt; // _.
<span class="nb">move</span>/has_lbPn : lX =&gt; /(_ x) [y Xy xy].
<span class="nb">move</span>/has_ubPn : uX =&gt; /(_ x) [z Xz xz].
<span class="bp">by</span> <span class="nb">apply</span>: (iX y z); <span class="nb">rewrite</span> <span class="nl">?ltW</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">interval_left_unbounded_interior</span> (<span class="nv">X</span> : <span class="nb">set</span> R) : is_interval X -&gt;
  ~ has_lbound X -&gt; has_ubound X -&gt; X^¬∞ = [<span class="nb">set</span> r | r &lt; sup X].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; iX lX uX; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: right_bounded_interior.
<span class="nb">rewrite</span> -(open_subsetE _ (@open_lt _ _)) =&gt; r rsupX.
<span class="nb">move</span>/has_lbPn : lX =&gt; /(_ r)[y Xy yr].
<span class="nb">have</span> hsX : has_sup X <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">y</span>.
<span class="nb">have</span> /sup_adherent/(_ hsX)[e Xe] : <span class="mi">0</span> &lt; sup X - r <span class="bp">by</span> <span class="nb">rewrite</span> subr_gt0.
<span class="bp">by</span> <span class="nb">rewrite</span> opprB addrCA subrr addr0 =&gt; re; <span class="nb">apply</span>: (iX y e); <span class="nb">rewrite</span> <span class="nl">?ltW</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">interval_right_unbounded_interior</span> (<span class="nv">X</span> : <span class="nb">set</span> R) : is_interval X -&gt;
  has_lbound X -&gt; ~ has_ubound X -&gt; X^¬∞ = [<span class="nb">set</span> r | inf X &lt; r].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; iX lX uX; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: left_bounded_interior.
<span class="nb">rewrite</span> -(open_subsetE _ (@open_gt _ _)) =&gt; r infXr.
<span class="nb">move</span>/has_ubPn : uX =&gt; /(_ r)[y Xy yr].
<span class="nb">have</span> hiX : has_inf X <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="kr">exists</span> <span class="nv">y</span>.
<span class="nb">have</span> /inf_adherent/(_ hiX)[e Xe] : <span class="mi">0</span> &lt; r - inf X <span class="bp">by</span> <span class="nb">rewrite</span> subr_gt0.
<span class="bp">by</span> <span class="nb">rewrite</span> addrCA subrr addr0 =&gt; er; <span class="nb">apply</span>: (iX e y); <span class="nb">rewrite</span> <span class="nl">?ltW</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">interval_bounded_interior</span> (<span class="nv">X</span> : <span class="nb">set</span> R) : is_interval X -&gt;
  has_lbound X -&gt; has_ubound X -&gt; X^¬∞ = [<span class="nb">set</span> r | inf X &lt; r &lt; sup X].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; iX bX aX; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>=&gt; [r Xr|].
  <span class="nb">apply</span>/andP; <span class="nb">split</span>;
    [<span class="bp">exact</span>: left_bounded_interior|<span class="bp">exact</span>: right_bounded_interior].
<span class="nb">rewrite</span> -open_subsetE; <span class="nb">last</span> <span class="bp">exact</span>: (@interval_open _ (BRight _) (BLeft _)).
<span class="nb">move</span>=&gt; r /andP[iXr rsX].
<span class="nb">have</span> [X0|/set0P X0] := eqVneq X set0.
  <span class="bp">by</span> <span class="nb">move</span>: (lt_trans iXr rsX); <span class="nb">rewrite</span> X0 inf_out <span class="nl">?sup_out</span> <span class="nl">?ltxx</span> // =&gt; - [[]].
<span class="nb">have</span> hiX : has_inf X <span class="bp">by</span> <span class="nb">split</span>.
<span class="nb">have</span> /inf_adherent/(_ hiX)[e Xe] : <span class="mi">0</span> &lt; r - inf X <span class="bp">by</span> <span class="nb">rewrite</span> subr_gt0.
<span class="nb">rewrite</span> addrCA subrr addr0 =&gt; er.
<span class="nb">have</span> hsX : has_sup X <span class="bp">by</span> <span class="nb">split</span>.
<span class="nb">have</span> /sup_adherent/(_ hsX)[f Xf] : <span class="mi">0</span> &lt; sup X - r <span class="bp">by</span> <span class="nb">rewrite</span> subr_gt0.
<span class="bp">by</span> <span class="nb">rewrite</span> opprB addrCA subrr addr0 =&gt; rf; <span class="nb">apply</span>: (iX e f); <span class="nb">rewrite</span> <span class="nl">?ltW</span>.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">Rhull</span> (<span class="nv">X</span> : <span class="nb">set</span> R) : interval R := Interval
  (<span class="kr">if</span> `[&lt; has_lbound X &gt;] <span class="kr">then</span> BSide `[&lt; X (inf X) &gt;] (inf X)
                          <span class="kr">else</span> BInfty _ true)
  (<span class="kr">if</span> `[&lt; has_ubound X &gt;] <span class="kr">then</span> BSide (~~ `[&lt; X (sup X) &gt;]) (sup X)
                          <span class="kr">else</span> BInfty _ false).

<span class="kn">Lemma</span> <span class="nf">Rhull0</span> : Rhull set0 = `]<span class="mi">0</span>, <span class="mi">0</span>[ :&gt; interval R.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /Rhull  (asboolT (has_lbound0 R)) (asboolT (has_ubound0 R)) asboolF //.
<span class="bp">by</span> <span class="nb">rewrite</span> sup0 inf0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sub_Rhull</span> (<span class="nv">X</span> : <span class="nb">set</span> R) : X `&lt;=` [<span class="nb">set</span> x | x \<span class="kr">in</span> Rhull X].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x Xx/=; <span class="nb">rewrite</span> in_itv/=.
<span class="nb">case</span>: (asboolP (has_lbound _)) =&gt; ?; <span class="nb">case</span>: (asboolP (has_ubound _)) =&gt; ? //=.
+ <span class="bp">by</span> <span class="nb">case</span>: asboolP =&gt; ?; <span class="nb">case</span>: asboolP =&gt; ? //=;
     <span class="nb">rewrite</span> !(lteifF, lteifT, sup_ub, inf_lb, sup_ub_strict, inf_lb_strict).
+ <span class="bp">by</span> <span class="nb">case</span>: asboolP =&gt; XinfX; <span class="nb">rewrite</span> !(lteifF, lteifT);
     [<span class="nb">rewrite</span> inf_lb | <span class="nb">rewrite</span> inf_lb_strict].
+ <span class="bp">by</span> <span class="nb">case</span>: asboolP =&gt; XsupX; <span class="nb">rewrite</span> !(lteifF, lteifT);
     [<span class="nb">rewrite</span> sup_ub | <span class="nb">rewrite</span> sup_ub_strict].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">is_intervalP</span> (<span class="nv">X</span> : <span class="nb">set</span> R) : is_interval X &lt;-&gt; X = [<span class="nb">set</span> x | x \<span class="kr">in</span> Rhull X].
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [iX|-&gt;]; <span class="nb">last</span> <span class="bp">exact</span>: interval_is_interval.
<span class="nb">rewrite</span> predeqE =&gt; x /=; <span class="nb">split</span>; [<span class="bp">exact</span>: sub_Rhull | <span class="nb">rewrite</span> in_itv/=].
<span class="nb">case</span>: (asboolP (has_lbound _)) =&gt; ?; <span class="nb">case</span>: (asboolP (has_ubound _)) =&gt; ? //=.
- <span class="nb">case</span>: asboolP =&gt; XinfX; <span class="nb">case</span>: asboolP =&gt; XsupX;
    <span class="nb">rewrite</span> !(lteifF, lteifT).
  + <span class="nb">move</span>=&gt; /andP[]; <span class="nb">rewrite</span> le_eqVlt =&gt; /orP[/eqP &lt;- //|infXx].
    <span class="nb">rewrite</span> le_eqVlt =&gt; /orP[/eqP -&gt; //|xsupX].
    <span class="nb">apply</span>: (@interior_subset R).
    <span class="bp">by</span> <span class="nb">rewrite</span> interval_bounded_interior // /mkset infXx.
  + <span class="nb">move</span>=&gt; /andP[]; <span class="nb">rewrite</span> le_eqVlt =&gt; /orP[/eqP &lt;- //|infXx supXx].
    <span class="nb">apply</span>: (@interior_subset R).
    <span class="bp">by</span> <span class="nb">rewrite</span> interval_bounded_interior // /mkset infXx.
  + <span class="nb">move</span>=&gt; /andP[infXx]; <span class="nb">rewrite</span> le_eqVlt =&gt; /orP[/eqP -&gt; //|xsupX].
    <span class="nb">apply</span>: (@interior_subset R).
    <span class="bp">by</span> <span class="nb">rewrite</span> interval_bounded_interior // /mkset infXx.
  + <span class="nb">move</span>=&gt; ?; <span class="nb">apply</span>: (@interior_subset R).
    <span class="bp">by</span> <span class="nb">rewrite</span> interval_bounded_interior // /mkset infXx.
- <span class="nb">case</span>: asboolP =&gt; XinfX; <span class="nb">rewrite</span> !(lteifF, lteifT, andbT).
  + <span class="nb">rewrite</span> le_eqVlt =&gt; /orP[/eqP&lt;-//|infXx].
    <span class="nb">apply</span>: (@interior_subset R).
    <span class="bp">by</span> <span class="nb">rewrite</span> interval_right_unbounded_interior.
  + <span class="nb">move</span>=&gt; infXx; <span class="nb">apply</span>: (@interior_subset R).
    <span class="bp">by</span> <span class="nb">rewrite</span> interval_right_unbounded_interior.
- <span class="nb">case</span>: asboolP =&gt; XsupX /=.
  + <span class="nb">rewrite</span> le_eqVlt =&gt; /orP[/eqP-&gt;//|xsupX].
    <span class="nb">apply</span>: (@interior_subset R).
    <span class="bp">by</span> <span class="nb">rewrite</span> interval_left_unbounded_interior.
  + <span class="nb">move</span>=&gt; xsupX; <span class="nb">apply</span>: (@interior_subset R).
    <span class="bp">by</span> <span class="nb">rewrite</span> interval_left_unbounded_interior.
- <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> (interval_unbounded_setT iX).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">connected_intervalP</span> (<span class="nv">E</span> : <span class="nb">set</span> R) : connected E &lt;-&gt; is_interval E.
<span class="kn">Proof</span>.
<span class="nb">split</span> =&gt; [cE x y Ex Ey z /andP[xz zy]|].
- <span class="nb">apply</span>: contrapT =&gt; Ez.
  <span class="nb">pose</span> Az := E `&amp;` [<span class="nb">set</span> x | x &lt; z]; <span class="nb">pose</span> Bz := E `&amp;` [<span class="nb">set</span> x | z &lt; x].
  <span class="nb">apply</span>/connectedPn : cE; <span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">b</span> =&gt; <span class="kr">if</span> b <span class="kr">then</span> Az <span class="kr">else</span> Bz); <span class="nb">split</span>.
  + <span class="nb">move</span>: xz zy Ez.
    <span class="nb">rewrite</span> !le_eqVlt =&gt; /predU1P[&lt;-//|xz] /predU1P[-&gt;//|zy] Ez.
    <span class="bp">by</span> <span class="nb">case</span>; [<span class="kr">exists</span> <span class="nv">x</span> | <span class="kr">exists</span> <span class="nv">y</span>].
  + <span class="nb">rewrite</span> /Az /Bz -setIUr; <span class="nb">apply</span>/esym/setIidPl =&gt; u Eu.
    <span class="bp">by</span> <span class="nb">apply</span>/orP; <span class="nb">rewrite</span> -neq_lt; <span class="nb">apply</span>/negP; <span class="nb">apply</span>: contraPnot Eu =&gt; /eqP &lt;-.
  + <span class="nb">split</span>; [|<span class="nb">rewrite</span> setIC].
    + <span class="nb">apply</span>/disjoints_subset =&gt; /= u /closureI[_]; <span class="nb">rewrite</span> closure_gt =&gt; zu.
      <span class="bp">by</span> <span class="nb">rewrite</span> /Az setCI; <span class="nb">right</span>; <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -leNgt.
    + <span class="nb">apply</span>/disjoints_subset =&gt; /= u /closureI[_]; <span class="nb">rewrite</span> closure_lt =&gt; zu.
      <span class="bp">by</span> <span class="nb">rewrite</span> /Bz setCI; <span class="nb">right</span>; <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -leNgt.
- <span class="nb">apply</span>: contraPP =&gt; /connectedPn[A [A0 EU sepA]] intE.
  <span class="nb">have</span> [/= x A0x] := A0 false; <span class="nb">have</span> [/= y A1y] := A0 true.
  <span class="nb">wlog</span> xy : A A0 EU sepA x A0x y A1y / x &lt; y.
    <span class="nb">move</span>=&gt; /= wlog_hypo; <span class="nb">have</span> [xy|yx|{wlog_hypo}yx] := ltgtP x y.
    + <span class="bp">exact</span>: (wlog_hypo _ _ _ _ _ A0x _ A1y).
    + <span class="nb">apply</span>: (wlog_hypo (A \o negb) _ _ _ y _ x) =&gt; //=;
      <span class="bp">by</span> [<span class="nb">rewrite</span> setUC | <span class="nb">rewrite</span> separatedC].
    + <span class="nb">move</span>/separated_disjoint : sepA; <span class="nb">rewrite</span> predeqE =&gt; /(_ x)[] + _; <span class="nb">apply</span>.
      <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> yx.
  <span class="nb">pose</span> z := sup (A false `&amp;` [<span class="nb">set</span> z | x &lt;= z &lt;= y]).
  <span class="nb">have</span> A1z : ~ (A true) z.
    <span class="nb">have</span> cA0z : closure (A false) z.
      <span class="nb">suff</span> : closure (A false `&amp;` [<span class="nb">set</span> z | x &lt;= z &lt;= y]) z <span class="bp">by</span> <span class="nb">case</span>/closureI.
      <span class="nb">apply</span>: closure_sup; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span> =&gt; u [_] /andP[].
      <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> /mkset lexx /= (ltW xy).
    <span class="bp">by</span> <span class="nb">move</span>: sepA; <span class="nb">rewrite</span> /separated =&gt; -[] /disjoints_subset + _; <span class="nb">apply</span>.
  <span class="nb">have</span> /andP[xz zy] : x &lt;= z &lt; y.
    <span class="nb">rewrite</span> sup_ub //=; [|<span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span> =&gt; u [_] /andP[]|].
    + <span class="nb">rewrite</span> lt_neqAle sup_le_ub <span class="nl">?andbT</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; u [_] /andP[].
      * <span class="bp">by</span> <span class="nb">apply</span>/negP; <span class="nb">apply</span>: contraPnot A1y =&gt; /eqP &lt;-.
      * <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> /mkset /= lexx /= (ltW xy).
    + <span class="bp">by</span> <span class="nb">split</span>=&gt; //; <span class="nb">rewrite</span> /mkset lexx (ltW xy).
  <span class="nb">have</span> [A0z|A0z] := pselect ((A false) z); <span class="nb">last first</span>.
  <span class="nb">have</span> {}xzy : x &lt;= z &lt;= y <span class="bp">by</span> <span class="nb">rewrite</span> xz ltW.
    <span class="nb">have</span> : ~ E z <span class="bp">by</span> <span class="nb">rewrite</span> EU =&gt; -[].
    <span class="bp">by</span> <span class="nb">apply</span>; <span class="nb">apply</span> (intE x y) =&gt; //; <span class="nb">rewrite</span> EU; [<span class="nb">left</span>|<span class="nb">right</span>].
  <span class="nb">suff</span> [z1 [/andP[zz1 z1y] Ez1]] : <span class="kr">exists</span> <span class="nv">z1</span> : R, z &lt;= z1 &lt;= y /\ ~ E z1.
    <span class="nb">apply</span> Ez1; <span class="nb">apply</span> (intE x y) =&gt; //; <span class="nb">rewrite</span> <span class="nl">?EU</span>; [<span class="bp">by</span> <span class="nb">left</span>|<span class="bp">by</span> <span class="nb">right</span>|].
    <span class="bp">by</span> <span class="nb">rewrite</span> z1y (le_trans _ zz1).
  <span class="nb">have</span> [r zcA1] : {r:{posnum R}| ball z r%:num `&lt;=` ~` closure (A true)}.
    <span class="nb">have</span> ? : ~ closure (A true) z.
      <span class="bp">by</span> <span class="nb">move</span>: sepA; <span class="nb">rewrite</span> /separated =&gt; -[] _ /disjoints_subset; <span class="nb">apply</span>.
    <span class="nb">have</span> ? : open (~` closure (A true)) <span class="bp">by</span> <span class="bp">exact</span>/closed_openC/closed_closure.
    <span class="bp">exact</span>/nbhsC_ball/open_nbhs_nbhs.
  <span class="nb">pose</span> z1 : R := z + r%:num / <span class="mi">2</span>; <span class="kr">exists</span> <span class="nv">z1</span>.
  <span class="nb">have</span> z1y : z1 &lt;= y.
    <span class="nb">rewrite</span> leNgt; <span class="nb">apply</span>/negP =&gt; yz1.
    <span class="nb">suff</span> : (~` closure (A true)) y <span class="bp">by</span> <span class="nb">apply</span>; <span class="bp">exact</span>: subset_closure.
    <span class="nb">apply</span> zcA1; <span class="nb">rewrite</span> /ball /= ltr_distl (lt_le_trans zy) // <span class="nl">?ler_addl</span> //.
    <span class="nb">rewrite</span> andbT ltr_subl_addl addrC (lt_trans yz1) // ltr_add2l.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltr_pdivr_mulr // ltr_pmulr // ltr1n.
  <span class="nb">rewrite</span> z1y andbT ler_addl; <span class="nb">split</span> =&gt; //.
  <span class="nb">have</span> ncA1z1 : (~` closure (A true)) z1.
    <span class="nb">apply</span> zcA1; <span class="nb">rewrite</span> /ball /= /z1 opprD addrA subrr add0r normrN.
    <span class="bp">by</span> <span class="nb">rewrite</span> ger0_norm // ltr_pdivr_mulr // ltr_pmulr // ltr1n.
  <span class="nb">have</span> nA0z1 : ~ (A false) z1.
    <span class="nb">move</span>=&gt; A0z1; <span class="nb">have</span> : z &lt; z1 <span class="bp">by</span> <span class="nb">rewrite</span> /z1 ltr_addl.
    <span class="nb">apply</span>/negP; <span class="nb">rewrite</span> -leNgt.
     <span class="nb">apply</span>: sup_ub; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span> =&gt; u [_] /andP[].
    <span class="bp">by</span> <span class="nb">split</span> =&gt; //; <span class="nb">rewrite</span> /mkset /z1 (le_trans xz) /= <span class="nl">?ler_addl</span> // (ltW z1y).
  <span class="bp">by</span> <span class="nb">rewrite</span> EU =&gt; -[//|]; <span class="nb">apply</span>: contra_not ncA1z1; <span class="bp">exact</span>: subset_closure.
<span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">interval_realType</span>.

<span class="kn">Section</span> <span class="nf">segment</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realType.</span></pre><div class="doc">
properties of segments in <span class="inlinecode"><span class="id" title="var">R</span></span>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Lemma</span> <span class="nf">segment_connected</span> (<span class="nv">a</span> <span class="nv">b</span> : R) : connected `[a, b].
<span class="kn">Proof</span>. <span class="bp">exact</span>/connected_intervalP/interval_is_interval. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">segment_compact</span> (<span class="nv">a</span> <span class="nv">b</span> : R) : compact `[a, b].
<span class="kn">Proof</span>.
<span class="nb">have</span> [leab|ltba] := lerP a b; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; F FF /filter_ex [x abx]; <span class="nb">move</span>: ltba; <span class="nb">rewrite</span> (itvP abx).
<span class="nb">rewrite</span> compact_cover =&gt; I D f fop sabUf.
<span class="nb">set</span> B := [<span class="nb">set</span> x | <span class="kr">exists2</span> E : {fset I}, {subset E &lt;= D} &amp;
  `[a, x] `&lt;=` \bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` E]) f i /\ (\bigcup_(i <span class="kr">in</span> [<span class="nb">set</span>` E]) f i) x].
<span class="nb">set</span> A := `[a, b] `&amp;` B.
<span class="nb">suff</span> Aeab : A = `[a, b]%classic.
  <span class="nb">suff</span> [_ [E ? []]] : A b <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">E</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> Aeab/= inE/=; <span class="nb">apply</span>/andP.
<span class="nb">apply</span>: segment_connected.
- <span class="nb">have</span> aba : a \<span class="kr">in</span> `[a, b] <span class="bp">by</span> <span class="nb">rewrite</span> in_itv /= lexx.
  <span class="kr">exists</span> <span class="nv">a</span>; <span class="nb">split</span>=&gt; //; <span class="nb">have</span> /sabUf [i /= Di fia] := aba.
  <span class="kr">exists</span> [fset i]%fset; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="nb">rewrite</span> inE inE =&gt; /eqP-&gt;.
  <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //=; <span class="nb">rewrite</span> inE.
  <span class="nb">move</span>=&gt; x /= aex; <span class="kr">exists</span> <span class="nv">i</span>; [<span class="bp">by</span> <span class="nb">rewrite</span> /= inE|<span class="nb">suff</span> /eqP-&gt; : x == a <span class="bp">by</span> []].
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_le !(itvP aex).
- <span class="kr">exists</span> <span class="nv">B</span> =&gt; //; <span class="nb">rewrite</span> openE =&gt; x [E sD [saxUf [i Di fx]]].
  <span class="nb">have</span> : open (f i) <span class="bp">by</span> <span class="nb">have</span> /sD := Di; <span class="nb">rewrite</span> inE =&gt; /fop.
  <span class="nb">rewrite</span> openE =&gt; /(_ _ fx) [e egt0 xe_fi]; <span class="kr">exists</span> <span class="nv">e</span> =&gt; // y xe_y.
  <span class="kr">exists</span> <span class="nv">E</span> =&gt; //; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">apply</span>/xe_fi.
  <span class="nb">move</span>=&gt; z /= ayz; <span class="nb">have</span> [lezx|ltxz] := lerP z x.
    <span class="bp">by</span> <span class="nb">apply</span>/saxUf; <span class="nb">rewrite</span> /= in_itv/= (itvP ayz) lezx.
  <span class="kr">exists</span> <span class="nv">i</span> =&gt; //; <span class="nb">apply</span>/xe_fi; <span class="nb">rewrite</span> /ball_/= distrC ger0_norm.
    <span class="nb">have</span> lezy : z &lt;= y <span class="bp">by</span> <span class="nb">rewrite</span> (itvP ayz).
    <span class="nb">rewrite</span> ltr_subl_addl; <span class="nb">apply</span>: le_lt_trans lezy _; <span class="nb">rewrite</span> -ltr_subl_addr.
    <span class="bp">by</span> <span class="nb">have</span> := xe_y; <span class="nb">rewrite</span> /ball_ =&gt; /ltr_distlC_subl.
  <span class="bp">by</span> <span class="nb">rewrite</span> subr_ge0; <span class="nb">apply</span>/ltW.
<span class="kr">exists</span> <span class="nv">A</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; x; <span class="nb">split</span>=&gt; [[] | []].
<span class="nb">move</span>=&gt; x clAx; <span class="nb">have</span> abx : x \<span class="kr">in</span> `[a, b].
  <span class="bp">by</span> <span class="nb">apply</span>: interval_closed; <span class="nb">have</span> /closureI [] := clAx.
<span class="nb">split</span>=&gt; //; <span class="nb">have</span> /sabUf [i Di fx] := abx.
<span class="nb">have</span> /fop := Di; <span class="nb">rewrite</span> openE =&gt; /(_ _ fx) [_ /posnumP[e] xe_fi].
<span class="nb">have</span> /clAx [y [[aby [E sD [sayUf _]]] xe_y]] := nbhsx_ballx x e.
<span class="kr">exists</span> (<span class="nv">i</span> |` E)%fset; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; j /fset1UP[-&gt;|/sD] //; <span class="nb">rewrite</span> inE.
<span class="nb">split</span>=&gt; [z axz|]; <span class="nb">last first</span>.
  <span class="kr">exists</span> <span class="nv">i</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /= !inE eq_refl.
  <span class="bp">by</span> <span class="nb">apply</span>/xe_fi; <span class="nb">rewrite</span> /ball_/= subrr normr0.
<span class="nb">have</span> [lezy|ltyz] := lerP z y.
  <span class="nb">have</span> /sayUf [j Dj fjz] : z \<span class="kr">in</span> `[a, y] <span class="bp">by</span> <span class="nb">rewrite</span> in_itv /= (itvP axz) lezy.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">j</span> =&gt; //=; <span class="nb">rewrite</span> inE orbC Dj.
<span class="kr">exists</span> <span class="nv">i</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /= !inE eq_refl.
<span class="nb">apply</span>/xe_fi; <span class="nb">rewrite</span> /ball_/= ger0_norm; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> subr_ge0 (itvP axz).
<span class="nb">rewrite</span> ltr_subl_addl -ltr_subl_addr; <span class="nb">apply</span>: lt_trans ltyz.
<span class="bp">by</span> <span class="nb">apply</span>: ltr_distlC_subl; <span class="nb">rewrite</span> distrC.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">segment</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__ler0_addgt0P</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">x</span> : R) :
  reflect (<span class="kr">forall</span> <span class="nv">e</span>, e &gt; <span class="mi">0</span> -&gt; x &lt;= e) (x &lt;= <span class="mi">0</span>).
<span class="kn">Proof</span>. <span class="bp">exact</span>: ler_gtP. <span class="kn">Qed</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;use `ler_gtP` instead which generalizes it to any upper bound.&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">ler0_addgt0P</span> := __deprecated__ler0_addgt0P.

<span class="kn">Lemma</span> <span class="nf">IVT</span> (<span class="nv">R</span> : realType) (<span class="nv">f</span> : R -&gt; R) (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">v</span> : R) :
  a &lt;= b -&gt; {within `[a, b], continuous f} -&gt;
  minr (f a) (f b) &lt;= v &lt;= maxr (f a) (f b) -&gt;
  <span class="kr">exists2</span> c, c \<span class="kr">in</span> `[a, b] &amp; f c = v.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; leab fcont; <span class="nb">gen have</span> ivt : f v fcont / f a &lt;= v &lt;= f b -&gt;
    <span class="kr">exists2</span> c, c \<span class="kr">in</span> `[a, b] &amp; f c = v; <span class="nb">last first</span>.
  <span class="nb">case</span>: (leP (f a) (f b)) =&gt; [] _ fabv; <span class="kp">first</span> <span class="bp">exact</span>: ivt.
  <span class="nb">have</span> [| |c cab /oppr_inj] := ivt (- f) (- v); <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">c</span>.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; x; <span class="nb">apply</span>: continuousN; <span class="nb">apply</span>: fcont.
  - <span class="bp">by</span> <span class="nb">rewrite</span> ler_oppr opprK ler_oppr opprK andbC.
<span class="nb">move</span>=&gt; favfb; <span class="nb">suff</span>: is_interval (f @` `[a,b]).
  <span class="nb">apply</span>; <span class="nb">last</span> <span class="bp">exact</span>: favfb.
  - <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">a</span> =&gt; //=; <span class="nb">rewrite</span> in_itv/= lexx.
  - <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">b</span> =&gt; //=; <span class="nb">rewrite</span> in_itv/= leab lexx.
<span class="nb">apply</span>/connected_intervalP/connected_continuous_connected =&gt; //.
<span class="bp">exact</span>: segment_connected.
<span class="kn">Qed</span>.

<span class="c">(* Local properties in [R] *)</span>

<span class="c">(* Topology on [R]¬≤ *)</span>

<span class="c">(* Lemma locally_2d_align : *)</span>
<span class="c">(*   forall (P Q : R -&gt; R -&gt; Prop) x y, *)</span>
<span class="c">(*   ( forall eps : {posnum R}, (forall uv, ball (x, y) eps uv -&gt; P uv.1 uv.2) -&gt; *)</span>
<span class="c">(*     forall uv, ball (x, y) eps uv -&gt; Q uv.1 uv.2 ) -&gt; *)</span>
<span class="c">(*   {near x &amp; y, forall x y, P x y} -&gt;  *)</span>
<span class="c">(*   {near x &amp; y, forall x y, Q x y}. *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move=&gt; P Q x y /= K =&gt; /locallyP [d _ H]. *)</span>
<span class="c">(* apply/locallyP; exists d =&gt; // uv Huv. *)</span>
<span class="c">(* by apply (K d) =&gt; //. *)</span>
<span class="c">(* Qed. *)</span>

<span class="c">(* Lemma locally_2d_1d_const_x : *)</span>
<span class="c">(*   forall (P : R -&gt; R -&gt; Prop) x y, *)</span>
<span class="c">(*   locally_2d x y P -&gt; *)</span>
<span class="c">(*   locally y (fun t =&gt; P x t). *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move=&gt; P x y /locallyP [d _ Hd]. *)</span>
<span class="c">(* exists d =&gt; // z Hz. *)</span>
<span class="c">(* by apply (Hd (x, z)). *)</span>
<span class="c">(* Qed. *)</span>

<span class="c">(* Lemma locally_2d_1d_const_y : *)</span>
<span class="c">(*   forall (P : R -&gt; R -&gt; Prop) x y, *)</span>
<span class="c">(*   locally_2d x y P -&gt; *)</span>
<span class="c">(*   locally x (fun t =&gt; P t y). *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move=&gt; P x y /locallyP [d _ Hd]. *)</span>
<span class="c">(* apply/locallyP; exists d =&gt; // z Hz. *)</span>
<span class="c">(* by apply (Hd (z, y)). *)</span>
<span class="c">(* Qed. *)</span>

<span class="c">(* Lemma locally_2d_1d_strong (P : R -&gt; R -&gt; Prop) (x y : R): *)</span>
<span class="c">(*   (\near x &amp; y, P x y) -&gt; *)</span>
<span class="c">(*   \forall u \near x &amp; v \near y, *)</span>
<span class="c">(*       forall (t : R), 0 &lt;= t &lt;= 1 -&gt; *)</span>
<span class="c">(*       \forall z \near t, \forall a \near (x + z * (u - x)) *)</span>
<span class="c">(*                                &amp; b \near (y + z * (v - y)), P a b. *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move=&gt; P x y. *)</span>
<span class="c">(* apply locally_2d_align =&gt; eps HP uv Huv t Ht. *)</span>
<span class="c">(* set u := uv.1. set v := uv.2. *)</span>
<span class="c">(* have Zm : 0 &lt;= Num.max `|u - x| `|v - y| by rewrite ler_maxr 2!normr_ge0. *)</span>
<span class="c">(* rewrite ler_eqVlt in Zm. *)</span>
<span class="c">(* case/orP : Zm =&gt; Zm. *)</span>
<span class="c">(* - apply filterE =&gt; z. *)</span>
<span class="c">(*   apply/locallyP. *)</span>
<span class="c">(*   exists eps =&gt; // pq. *)</span>
<span class="c">(*   rewrite !(RminusE,RmultE,RplusE). *)</span>
<span class="c">(*   move: (Zm). *)</span>
<span class="c">(*   have : Num.max `|u - x| `|v - y| &lt;= 0 by rewrite -(eqP Zm). *)</span>
<span class="c">(*   rewrite ler_maxl =&gt; /andP[H1 H2] _. *)</span>
<span class="c">(*   rewrite (_ : u - x = 0); last by apply/eqP; rewrite -normr_le0. *)</span>
<span class="c">(*   rewrite (_ : v - y = 0); last by apply/eqP; rewrite -normr_le0. *)</span>
<span class="c">(*   rewrite !(mulr0,addr0); by apply HP. *)</span>
<span class="c">(* - have : Num.max (`|u - x|) (`|v - y|) &lt; eps. *)</span>
<span class="c">(*     rewrite ltr_maxl; apply/andP; split. *)</span>
<span class="c">(*     - case: Huv =&gt; /sub_ball_abs /=; by rewrite mul1r absrB. *)</span>
<span class="c">(*     - case: Huv =&gt; _ /sub_ball_abs /=; by rewrite mul1r absrB. *)</span>
<span class="c">(*   rewrite -subr_gt0 =&gt; /RltP H1. *)</span>
<span class="c">(*   set d1 := mk{posnum R} _ H1. *)</span>
<span class="c">(*   have /RltP H2 : 0 &lt; pos d1 / 2 / Num.max `|u - x| `|v - y| *)</span>
<span class="c">(*     by rewrite mulr_gt0 // invr_gt0. *)</span>
<span class="c">(*   set d2 := mk{posnum R} _ H2. *)</span>
<span class="c">(*   exists d2 =&gt; // z Hz. *)</span>
<span class="c">(*   apply/locallyP. *)</span>
<span class="c">(*   exists [{posnum R} of d1 / 2] =&gt; //= pq Hpq. *)</span>
<span class="c">(*   set p := pq.1. set q := pq.2. *)</span>
<span class="c">(*   apply HP; split. *)</span>
<span class="c">(*   + apply/sub_abs_ball =&gt; /=. *)</span>
<span class="c">(*     rewrite absrB. *)</span>
<span class="c">(*     rewrite (_ : p - x = p - (x + z * (u - x)) + (z - t + t) * (u - x)); last first. *)</span>
<span class="c">(*       by rewrite subrK opprD addrA subrK. *)</span>
<span class="c">(*     apply: (ler_lt_trans (ler_abs_add _ _)). *)</span>
<span class="c">(*     rewrite (_ : pos eps = pos d1 / 2 + (pos eps - pos d1 / 2)); last first. *)</span>
<span class="c">(*       by rewrite addrCA subrr addr0. *)</span>
<span class="c">(*     rewrite (_ : pos eps - _ = d1) // in Hpq. *)</span>
<span class="c">(*     case: Hpq =&gt; /sub_ball_abs Hp /sub_ball_abs Hq. *)</span>
<span class="c">(*     rewrite mul1r /= (_ : pos eps - _ = d1) // !(RminusE,RplusE,RmultE,RdivE) // in Hp, Hq. *)</span>
<span class="c">(*     rewrite absrB in Hp. rewrite absrB in Hq. *)</span>
<span class="c">(*     rewrite (ltr_le_add Hp) // (ler_trans (absrM _ _)) //. *)</span>
<span class="c">(*     apply (@ler_trans _ ((pos d2 + 1) * Num.max `|u - x| `|v - y|)). *)</span>
<span class="c">(*     apply ler_pmul; [by rewrite normr_ge0 | by rewrite normr_ge0 | | ]. *)</span>
<span class="c">(*     rewrite (ler_trans (ler_abs_add _ _)) // ler_add //. *)</span>
<span class="c">(*     move/sub_ball_abs : Hz; rewrite mul1r =&gt; tzd2; by rewrite absrB ltrW. *)</span>
<span class="c">(*     rewrite absRE ger0_norm //; by case/andP: Ht. *)</span>
<span class="c">(*     by rewrite ler_maxr lerr. *)</span>
<span class="c">(*     rewrite /d2 /d1 /=. *)</span>
<span class="c">(*     set n := Num.max _ _. *)</span>
<span class="c">(*     rewrite mulrDl mul1r -mulrA mulVr ?unitfE ?lt0r_neq0 // mulr1. *)</span>
<span class="c">(*     rewrite ler_sub_addr addrAC -mulrDl -mulr2n -mulr_natr. *)</span>
<span class="c">(*     by rewrite -mulrA mulrV ?mulr1 ?unitfE // subrK. *)</span>
<span class="c">(*   + apply/sub_abs_ball =&gt; /=. *)</span>
<span class="c">(*     rewrite absrB. *)</span>
<span class="c">(*     rewrite (_ : (q - y) = (q - (y + z * (v - y)) + (z - t + t) * (v - y))); last first. *)</span>
<span class="c">(*       by rewrite subrK opprD addrA subrK. *)</span>
<span class="c">(*     apply: (ler_lt_trans (ler_abs_add _ _)). *)</span>
<span class="c">(*     rewrite (_ : pos eps = pos d1 / 2 + (pos eps - pos d1 / 2)); last first. *)</span>
<span class="c">(*       by rewrite addrCA subrr addr0. *)</span>
<span class="c">(*     rewrite (_ : pos eps - _ = d1) // in Hpq. *)</span>
<span class="c">(*     case: Hpq =&gt; /sub_ball_abs Hp /sub_ball_abs Hq. *)</span>
<span class="c">(*     rewrite mul1r /= (_ : pos eps - _ = d1) // !(RminusE,RplusE,RmultE,RdivE) // in Hp, Hq. *)</span>
<span class="c">(*     rewrite absrB in Hp. rewrite absrB in Hq. *)</span>
<span class="c">(*     rewrite (ltr_le_add Hq) // (ler_trans (absrM _ _)) //. *)</span>
<span class="c">(*     rewrite (@ler_trans _ ((pos d2 + 1) * Num.max `|u - x| `|v - y|)) //. *)</span>
<span class="c">(*     apply ler_pmul; [by rewrite normr_ge0 | by rewrite normr_ge0 | | ]. *)</span>
<span class="c">(*     rewrite (ler_trans (ler_abs_add _ _)) // ler_add //. *)</span>
<span class="c">(*     move/sub_ball_abs : Hz; rewrite mul1r =&gt; tzd2; by rewrite absrB ltrW. *)</span>
<span class="c">(*     rewrite absRE ger0_norm //; by case/andP: Ht. *)</span>
<span class="c">(*     by rewrite ler_maxr lerr orbT. *)</span>
<span class="c">(*     rewrite /d2 /d1 /=. *)</span>
<span class="c">(*     set n := Num.max _ _. *)</span>
<span class="c">(*     rewrite mulrDl mul1r -mulrA mulVr ?unitfE ?lt0r_neq0 // mulr1. *)</span>
<span class="c">(*     rewrite ler_sub_addr addrAC -mulrDl -mulr2n -mulr_natr. *)</span>
<span class="c">(*     by rewrite -mulrA mulrV ?mulr1 ?unitfE // subrK. *)</span>
<span class="c">(* Qed. *)</span>
<span class="c">(* Admitted. *)</span>

<span class="c">(* TODO redo *)</span>
<span class="c">(* Lemma locally_2d_1d (P : R -&gt; R -&gt; Prop) x y : *)</span>
<span class="c">(*   locally_2d x y P -&gt; *)</span>
<span class="c">(*   locally_2d x y (fun u v =&gt; forall t, 0 &lt;= t &lt;= 1 -&gt; locally_2d (x + t * (u - x)) (y + t * (v - y)) P). *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move/locally_2d_1d_strong. *)</span>
<span class="c">(* apply: locally_2d_impl. *)</span>
<span class="c">(* apply locally_2d_forall =&gt; u v H t Ht. *)</span>
<span class="c">(* specialize (H t Ht). *)</span>
<span class="c">(* have : locally t (fun z =&gt; locally_2d (x + z * (u - x)) (y + z * (v - y)) P) by []. *)</span>
<span class="c">(* by apply: locally_singleton. *)</span>
<span class="c">(* Qed. *)</span>

<span class="c">(* TODO redo *)</span>
<span class="c">(* Lemma locally_2d_ex_dec : *)</span>
<span class="c">(*   forall P x y, *)</span>
<span class="c">(*   (forall x y, P x y \/ ~P x y) -&gt; *)</span>
<span class="c">(*   locally_2d x y P -&gt; *)</span>
<span class="c">(*   {d : {posnum R} | forall u v, `|u - x| &lt; d -&gt; `|v - y| &lt; d -&gt; P u v}. *)</span>
<span class="c">(* Proof. *)</span>
<span class="c">(* move=&gt; P x y P_dec H. *)</span>
<span class="c">(* destruct (@locally_ex _ (x, y) (fun z =&gt; P (fst z) (snd z))) as [d Hd]. *)</span>
<span class="c">(* - move: H =&gt; /locallyP [e _ H]. *)</span>
<span class="c">(*   by apply/locallyP; exists e. *)</span>
<span class="c">(* exists d=&gt;  u v Hu Hv. *)</span>
<span class="c">(* by apply (Hd (u, v)) =&gt; /=; split; apply sub_abs_ball; rewrite absrB. *)</span>
<span class="c">(* Qed. *)</span>

<span class="kn">Lemma</span> <span class="nf">compact_bounded</span> (<span class="nv">K</span> : realType) (<span class="nv">V</span> : normedModType K) (<span class="nv">A</span> : <span class="nb">set</span> V) :
  compact A -&gt; bounded_set A.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> compact_cover =&gt; Aco.
<span class="nb">have</span> covA : A `&lt;=` \bigcup_(n : int) [<span class="nb">set</span> p | `|p| &lt; n%:~R].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; p _; <span class="kr">exists</span> (<span class="nv">floor</span> `|p| + <span class="mi">1</span>) =&gt; //; <span class="nb">rewrite</span> rmorphD/= lt_succ_floor.
<span class="nb">have</span> /Aco [] := covA.
  <span class="nb">move</span>=&gt; n _; <span class="nb">rewrite</span> openE =&gt; p; <span class="nb">rewrite</span> /= -subr_gt0 =&gt; ltpn.
  <span class="nb">apply</span>/nbhs_ballP; <span class="kr">exists</span> (<span class="nv">n</span>%:~R - `|p|) =&gt; // q.
  <span class="nb">rewrite</span> -ball_normE /= ltr_subr_addr distrC; <span class="nb">apply</span>: le_lt_trans.
  <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}(subrK p q) ler_norm_add.
<span class="nb">move</span>=&gt; D _ DcovA.
<span class="kr">exists</span> (\big[maxr/<span class="mi">0</span>]_(i : D) (fsval i)%:~R).
<span class="nb">rewrite</span> bigmax_real//; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; ? _; <span class="nb">rewrite</span> realz.
<span class="nb">split</span> =&gt; // x ltmaxx p /DcovA [n Dn /lt_trans /(_ _)/ltW].
<span class="nb">apply</span>; <span class="nb">apply</span>: le_lt_trans ltmaxx.
<span class="nb">have</span> : n \<span class="kr">in</span> enum_fset D <span class="bp">by</span> [].
<span class="bp">by</span> <span class="nb">rewrite</span> enum_fsetE =&gt; /mapP[/= i iD -&gt;]; <span class="bp">exact</span>/le_bigmax.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">rV_compact</span> (<span class="nv">T</span> : topologicalType) <span class="nv">n</span> (<span class="nv">A</span> : &#39;I_n.+<span class="mi">1</span> -&gt; <span class="nb">set</span> T) :
  (<span class="kr">forall</span> <span class="nv">i</span>, compact (A i)) -&gt;
  compact [ <span class="nb">set</span> v : &#39;rV[T]_n.+<span class="mi">1</span> | <span class="kr">forall</span> <span class="nv">i</span>, A i (v ord0 i)].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; Aico.
<span class="nb">have</span> : @compact (product_topologicalType _) [<span class="nb">set</span> f | <span class="kr">forall</span> <span class="nv">i</span>, A i (f i)].
  <span class="bp">by</span> <span class="nb">apply</span>: tychonoff.
<span class="nb">move</span>=&gt; Aco F FF FA.
<span class="nb">set</span> G := [<span class="nb">set</span> [<span class="nb">set</span> f : &#39;I_n.+<span class="mi">1</span> -&gt; T | B (\row_j f j)] | B <span class="kr">in</span> F].
<span class="nb">have</span> row_simpl (v : &#39;rV[T]_n.+<span class="mi">1</span>) : \row_j (v ord0 j) = v.
  <span class="bp">by</span> <span class="nb">apply</span>/rowP =&gt; ?; <span class="nb">rewrite</span> mxE.
<span class="nb">have</span> row_simpl&#39; (f : &#39;I_n.+<span class="mi">1</span> -&gt; T) : (\row_j f j) ord0 = f.
  <span class="bp">by</span> <span class="nb">rewrite</span> funeqE=&gt; ?; <span class="nb">rewrite</span> mxE.
<span class="nb">have</span> [f [Af clGf]] : [<span class="nb">set</span> f | <span class="kr">forall</span> <span class="nv">i</span>, A i (f i)] `&amp;`
  @cluster (product_topologicalType _) G !=set0.
  <span class="nb">suff</span> GF : ProperFilter G.
    <span class="nb">apply</span>: Aco; <span class="kr">exists</span> [<span class="nb">set</span> v : &#39;rV[T]_n.+<span class="mi">1</span> | <span class="kr">forall</span> <span class="nv">i</span>, A i (v ord0 i)] =&gt; //.
    <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; f; <span class="nb">split</span> =&gt; Af i; [<span class="nb">have</span> := Af i|]; <span class="nb">rewrite</span> row_simpl&#39;.
  <span class="nb">apply</span> Build_ProperFilter.
    <span class="nb">move</span>=&gt; _ [C FC &lt;-]; <span class="nb">have</span> /filter_ex [v Cv] := FC.
    <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">v</span> <span class="nv">ord0</span>); <span class="nb">rewrite</span> /= row_simpl.
  <span class="nb">split</span>.
  - <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">setT</span> =&gt; //; <span class="nb">apply</span>: filterT.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; _ _ [C FC &lt;-] [D FD &lt;-]; <span class="kr">exists</span> (<span class="nv">C</span> `&amp;` D) =&gt; //; <span class="nb">apply</span>: filterI.
  <span class="nb">move</span>=&gt; C D sCD [E FE EeqC]; <span class="kr">exists</span> [<span class="nb">set</span> v : &#39;rV[T]_n.+<span class="mi">1</span> | D (v ord0)].
    <span class="bp">by</span> <span class="nb">apply</span>: filterS FE =&gt; v Ev; <span class="nb">apply</span>/sCD; <span class="nb">rewrite</span> -EeqC/= row_simpl.
  <span class="bp">by</span> <span class="nb">rewrite</span> predeqE =&gt; ? /=; <span class="nb">rewrite</span> row_simpl&#39;.
<span class="kr">exists</span> (\row_j f j); <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">rewrite</span> mxE; <span class="nb">apply</span>: Af.
<span class="nb">move</span>=&gt; C D FC f_D; <span class="nb">have</span> {}f_D :
  nbhs (f : product_topologicalType _) [<span class="nb">set</span> g | D (\row_j g j)].
  <span class="nb">have</span> [E f_E sED] := f_D; <span class="nb">rewrite</span> nbhsE.
  <span class="nb">set</span> Pj := <span class="kr">fun</span> <span class="nv">j</span> <span class="nv">Bj</span> =&gt; open_nbhs (f j) Bj /\ Bj `&lt;=` E ord0 j.
  <span class="nb">have</span> exPj : <span class="kr">forall</span> <span class="nv">j</span>, <span class="kr">exists</span> <span class="nv">Bj</span>, open_nbhs (f j) Bj /\ Bj `&lt;=` E ord0 j.
    <span class="nb">move</span>=&gt; j; <span class="nb">have</span> := f_E ord0 j; <span class="nb">rewrite</span> nbhsE =&gt; - [Bj].
    <span class="bp">by</span> <span class="nb">rewrite</span> row_simpl&#39;; <span class="kr">exists</span> <span class="nv">Bj</span>.
  <span class="kr">exists</span> [<span class="nb">set</span> g | <span class="kr">forall</span> <span class="nv">j</span>, (get (Pj j)) (g j)]; <span class="nb">last first</span>.
    <span class="nb">move</span>=&gt; g Pg; <span class="nb">apply</span>: sED =&gt; i j; <span class="nb">rewrite</span> ord1 row_simpl&#39;.
    <span class="bp">by</span> <span class="nb">have</span> /getPex [_ /(_ _ (Pg j))] := exPj j.
  <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; j; <span class="nb">have</span> /getPex [[]] := exPj j.
  <span class="kr">exists</span> [<span class="nb">set</span> [<span class="nb">set</span> g | <span class="kr">forall</span> <span class="nv">j</span>, get (Pj j) (g j)] | k <span class="kr">in</span> [<span class="nb">set</span> x | &#39;I_n.+<span class="mi">1</span> x]];
    <span class="nb">last first</span>.
    <span class="nb">rewrite</span> predeqE =&gt; g; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; [_ [_ _ &lt;-]].
    <span class="nb">move</span>=&gt; Pg; <span class="kr">exists</span> [<span class="nb">set</span> g | <span class="kr">forall</span> <span class="nv">j</span>, get (Pj j) (g j)] =&gt; //.
    <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">ord0</span>.
  <span class="nb">move</span>=&gt; _ [_ _ &lt;-]; <span class="nb">set</span> s := [seq (@^~ j) @^-<span class="mi">1</span>` (get (Pj j)) | j : &#39;I_n.+<span class="mi">1</span>].
  <span class="kr">exists</span> [fset x <span class="kr">in</span> s]%fset.
    <span class="nb">move</span>=&gt; B&#39;; <span class="nb">rewrite</span> in_fset =&gt; /mapP [j _ -&gt;]; <span class="nb">rewrite</span> inE.
    <span class="kr">exists</span> <span class="nv">j</span> =&gt; //; <span class="kr">exists</span> (<span class="nv">get</span> (Pj j)) =&gt; //.
    <span class="bp">by</span> <span class="nb">have</span> /getPex [[]] := exPj j.
  <span class="nb">rewrite</span> predeqE =&gt; g; <span class="nb">split</span>=&gt; [Ig j|Ig B&#39;].
    <span class="nb">apply</span>: (Ig ((@^~ j) @^-<span class="mi">1</span>` (get (Pj j)))).
    <span class="bp">by</span> <span class="nb">rewrite</span> /= in_fset; <span class="nb">apply</span>/mapP; <span class="kr">exists</span> <span class="nv">j</span> =&gt; //; <span class="nb">rewrite</span> mem_enum.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= in_fset =&gt; /mapP [j _ -&gt;]; <span class="nb">apply</span>: Ig.
<span class="nb">have</span> GC : G [<span class="nb">set</span> g | C (\row_j g j)] <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">C</span>.
<span class="bp">by</span> <span class="nb">have</span> [g []] := clGf _ _ GC f_D; <span class="kr">exists</span> (\row_j (g j : T)).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bounded_closed_compact</span> (<span class="nv">R</span> : realType) <span class="nv">n</span> (<span class="nv">A</span> : <span class="nb">set</span> &#39;rV[R]_n.+<span class="mi">1</span>) :
  bounded_set A -&gt; closed A -&gt; compact A.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [M [Mreal normAltM]] Acl.
<span class="nb">have</span> Mnco : compact
  [<span class="nb">set</span> v : &#39;rV[R]_n.+<span class="mi">1</span> | <span class="kr">forall</span> <span class="nv">i</span>, v ord0 i \<span class="kr">in</span> `[(- (M + <span class="mi">1</span>)), (M + <span class="mi">1</span>)]].
  <span class="nb">apply</span>: (@rV_compact _  _ (<span class="kr">fun</span> <span class="nv">_</span> =&gt; `[(- (M + <span class="mi">1</span>)), (M + <span class="mi">1</span>)]%classic)).
  <span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">apply</span>: segment_compact.
<span class="nb">apply</span>: subclosed_compact Acl Mnco _ =&gt; v /normAltM normvleM i.
<span class="nb">suff</span> : `|v ord0 i : R| &lt;= M + <span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> ler_norml.
<span class="nb">apply</span>: le_trans (normvleM _ _); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltr_addl.
<span class="nb">have</span> /mapP[j Hj -&gt;] : `|v ord0 i| \<span class="kr">in</span> [seq `|v x.<span class="mi">1</span> x.<span class="mi">2</span>| | x : &#39;I_1 * &#39;I_n.+<span class="mi">1</span>].
  <span class="bp">by</span> <span class="nb">apply</span>/mapP; <span class="kr">exists</span> (<span class="nv">ord0</span>, i) =&gt; //=; <span class="nb">rewrite</span> mem_enum.
<span class="bp">by</span> <span class="nb">rewrite</span> [leRHS]/normr /= mx_normrE; <span class="nb">apply</span>/bigmax_geP; <span class="nb">right</span> =&gt; /=; <span class="kr">exists</span> <span class="nv">j</span>.
<span class="kn">Qed</span>.</span></pre><div class="doc">
<a id="lab8"></a><h1 class="section">Some limits on real functions</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Section</span> <span class="nf">Shift</span>.

<span class="kn">Context</span> {<span class="nv">R</span> : zmodType} {<span class="nv">T</span> : <span class="kt">Type</span>}.

<span class="kn">Definition</span> <span class="nf">shift</span> (<span class="nv">x</span> <span class="nv">y</span> : R) := y + x.
<span class="kn">Notation</span> <span class="nf">center</span> c := (shift (- c)).
<span class="kn">Arguments</span> shift x / y.

<span class="kn">Lemma</span> <span class="nf">comp_shiftK</span> (<span class="nv">x</span> : R) (<span class="nv">f</span> : R -&gt; T) : (f \o shift x) \o center x = f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; y /=; <span class="nb">rewrite</span> addrNK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">comp_centerK</span> (<span class="nv">x</span> : R) (<span class="nv">f</span> : R -&gt; T) : (f \o center x) \o shift x = f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; y /=; <span class="nb">rewrite</span> addrK. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">shift0</span> : shift <span class="mi">0</span> = id.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> funeqE =&gt; x /=; <span class="nb">rewrite</span> addr0. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">center0</span> : center <span class="mi">0</span> = id.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> oppr0 shift0. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Shift</span>.
<span class="kn">Arguments</span> shift {R} x / y.
<span class="kn">Notation</span> <span class="nf">center</span> c := (shift (- c)).

<span class="kn">Lemma</span> <span class="nf">near_shift</span> {<span class="nv">K</span> : numDomainType} {<span class="nv">R</span> : normedModType K}
   (<span class="nv">y</span> <span class="nv">x</span> : R) (<span class="nv">P</span> : <span class="nb">set</span> R) :
   (\near x, P x) = (\<span class="kr">forall</span> <span class="nv">z</span> \near y, (P \o shift (x - y)) z).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> propeqE nbhs0P [X <span class="kr">in</span> _ &lt;-&gt; X]nbhs0P/= -propeqE.
<span class="bp">by</span> <span class="nb">apply</span>: eq_near =&gt; e; <span class="nb">rewrite</span> ![_ + e]addrC addrACA subrr addr0.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">cvg_comp_shift</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">K</span> : numDomainType} {<span class="nv">R</span> : normedModType K}
  (<span class="nv">x</span> <span class="nv">y</span> : R) (<span class="nv">f</span> : R -&gt; T) :
  (f \o shift x) @ y = f @ (y + x).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> funeqE =&gt; A; <span class="nb">rewrite</span> /= !near_simpl (near_shift (y + x)).
<span class="bp">by</span> <span class="nb">rewrite</span> (_ : _ \o _ = A \o f) // funeqE=&gt; z; <span class="nb">rewrite</span> /= opprD addNKr addrNK.
<span class="kn">Qed</span>.

<span class="kn">Section</span> <span class="nf">continuous</span>.
<span class="kn">Variables</span> (<span class="nv">K</span> : numFieldType) (<span class="nv">U</span> <span class="nv">V</span> : normedModType K).

<span class="kn">Lemma</span> <span class="nf">continuous_shift</span> (<span class="nv">f</span> : U -&gt; V) <span class="nv">u</span> :
  {<span class="kr">for</span> u, continuous f} = {<span class="kr">for</span> <span class="mi">0</span>, continuous (f \o shift u)}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> [<span class="kr">in</span> RHS]forE /= add0r cvg_comp_shift add0r. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_withinNshiftx</span> (<span class="nv">f</span> : U -&gt; V) <span class="nv">u</span> :
  f \o shift u @ <span class="mi">0</span>^&#39; --&gt; f u &lt;-&gt; {<span class="kr">for</span> u, continuous f}.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> continuous_shift; <span class="nb">split</span>=&gt; [cfu|].
  <span class="bp">by</span> <span class="nb">apply</span>/(continuous_withinNx _ _).<span class="mi">2</span>/(cvg_trans cfu); <span class="nb">rewrite</span> /= add0r.
<span class="bp">by</span> <span class="nb">move</span>/(continuous_withinNx _ _).<span class="mi">1</span>/cvg_trans; <span class="nb">apply</span>; <span class="nb">rewrite</span> /= add0r.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">continuous</span>.

<span class="kn">Section</span> <span class="nf">Closed_Ball</span>.

<span class="kn">Lemma</span> <span class="nf">ball_open</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">V</span> : normedModType R) (<span class="nv">x</span> : V) (<span class="nv">r</span> : R) :
  <span class="mi">0</span> &lt; r -&gt; open (ball x r).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> openE -ball_normE /interior =&gt; r0 y /= Bxy; near=&gt; z.
<span class="nb">rewrite</span> /= (le_lt_trans (ler_dist_add y _ _)) // addrC -ltr_subr_addr.
<span class="bp">by</span> near: z; <span class="nb">apply</span>: cvgr_dist_lt; <span class="nb">rewrite</span> // subr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">closed_ball_</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">V</span> : zmodType) (<span class="nv">norm</span> : V -&gt; R)
  (<span class="nv">x</span> : V) (<span class="nv">e</span> : R) := [<span class="nb">set</span> y | norm (x - y) &lt;= e].

<span class="kn">Lemma</span> <span class="nf">closed_closed_ball_</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">V</span> : normedModType R)
  (<span class="nv">x</span> : V) (<span class="nv">e</span> : R) : closed (closed_ball_ normr x e).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /closed_ball_ -/((normr \o (<span class="kr">fun</span> <span class="nv">y</span> =&gt; x - y)) @^-<span class="mi">1</span>` [<span class="nb">set</span> x | x &lt;= e]).
<span class="nb">apply</span>: (closed_comp _ (@closed_le _ _)) =&gt; y _.
<span class="nb">apply</span>: (continuous_comp _ (@norm_continuous _ _ _)).
<span class="bp">exact</span>: (continuousB (@cst_continuous _ _ _ _)).
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">closed_ball</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">V</span> : pseudoMetricType R)
  (<span class="nv">x</span> : V) (<span class="nv">e</span> : R) := closure (ball x e).

<span class="kn">Lemma</span> <span class="nf">closed_ballxx</span> (<span class="nv">R</span>: numDomainType) (<span class="nv">V</span> : pseudoMetricType R) (<span class="nv">x</span> : V)
  (<span class="nv">e</span> : R) : <span class="mi">0</span> &lt; e -&gt; closed_ball x e x.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ?; <span class="bp">exact</span>/subset_closure/ballxx. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_ballE</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">V</span> : normedModType R) (<span class="nv">x</span> : V)
  (<span class="nv">r</span> : R) : <span class="mi">0</span> &lt; r -&gt; closed_ball x r = closed_ball_ normr x r.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /posnumP[e]; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span> =&gt; y.
  <span class="nb">rewrite</span> /closed_ball closureE; <span class="nb">apply</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: closed_closed_ball_.
  <span class="bp">by</span> <span class="nb">move</span>=&gt; z; <span class="nb">rewrite</span> -ball_normE; <span class="bp">exact</span>: ltW.
<span class="nb">have</span> [-&gt; _|xy] := eqVneq x y; <span class="kp">first</span> <span class="bp">exact</span>: closed_ballxx.
<span class="nb">rewrite</span> /closed_ball closureE -ball_normE.
<span class="nb">rewrite</span> /closed_ball_ /= le_eqVlt.
<span class="nb">move</span> =&gt; /orP[/eqP xye B [Bc Be]|xye _ [_ /(_ _ xye)]//].
<span class="nb">apply</span>: Bc =&gt; B0 /nbhs_ballP[s s0] B0y.
<span class="nb">have</span> [es|se] := leP s e%:num; <span class="nb">last first</span>.
  <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: Be; <span class="nb">rewrite</span> ball_normE; <span class="nb">apply</span>: ballxx.
  <span class="bp">by</span> <span class="nb">apply</span>: B0y; <span class="nb">rewrite</span> -ball_normE /ball_ /= distrC xye.
<span class="kr">exists</span> (<span class="nv">y</span> + (s / <span class="mi">2</span>) *: (`|x - y|^-<span class="mi">1</span> *: (x - y))); <span class="nb">split</span>; [<span class="nb">apply</span>: Be|<span class="nb">apply</span>: B0y].
  <span class="nb">rewrite</span> /= opprD addrA -[X <span class="kr">in</span> `|X - _|](scale1r (x - y)) scalerA -scalerBl.
  <span class="nb">rewrite</span> -[X <span class="kr">in</span> X - _](@divrr _ `|x - y|) <span class="nl">?unitfE</span> <span class="nl">?normr_eq0</span> <span class="nl">?subr_eq0</span>//.
  <span class="nb">rewrite</span> -mulrBl -scalerA normrZ normfZV <span class="nl">?subr_eq0</span>// mulr1.
  <span class="nb">rewrite</span> gtr0_norm; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltr_subl_addl xye ltr_addr mulr_gt0.
  <span class="bp">by</span> <span class="nb">rewrite</span> subr_gt0 xye ltr_pdivr_mulr // mulr_natr mulr2n ltr_spaddl.
<span class="nb">rewrite</span> -ball_normE /ball_ /= opprD addrA addrN add0r normrN normrZ.
<span class="nb">rewrite</span> normfZV <span class="nl">?subr_eq0</span>// mulr1 normrM (gtr0_norm s0) gtr0_norm //.
<span class="bp">by</span> <span class="nb">rewrite</span> ltr_pdivr_mulr // ltr_pmulr // ltr1n.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_ball_closed</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">V</span> : normedModType R) (<span class="nv">x</span> : V)
  (<span class="nv">r</span> : R) : <span class="mi">0</span> &lt; r -&gt; closed (closed_ball x r).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span> =&gt; r0; <span class="nb">rewrite</span> closed_ballE //; <span class="bp">exact</span>: closed_closed_ball_. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_ballR_compact</span> (<span class="nv">R</span> : realType) (<span class="nv">x</span> <span class="nv">e</span> : R) : <span class="mi">0</span> &lt; e -&gt;
  compact (closed_ball x e).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; e_gt0; <span class="nb">have</span> : compact `[x - e, x + e] <span class="bp">by</span> <span class="nb">apply</span>: segment_compact.
<span class="bp">by</span> <span class="nb">rewrite</span> closed_ballE//; <span class="nb">under</span> eq_set <span class="kp">do</span> <span class="nb">rewrite</span> in_itv -ler_distlC.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">closed_ball_subset</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">M</span> : normedModType R) (<span class="nv">x</span> : M)
  (<span class="nv">r0</span> <span class="nv">r1</span> : R) : <span class="mi">0</span> &lt; r0 -&gt; r0 &lt; r1 -&gt; closed_ball x r0 `&lt;=` ball x r1.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; r00 r01; <span class="nb">rewrite</span> (_ : r0 = (PosNum r00)%:num) // closed_ballE //.
<span class="bp">by</span> <span class="nb">move</span>=&gt; m xm; <span class="nb">rewrite</span> -ball_normE /ball_ /= (le_lt_trans _ r01).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">nbhs_closedballP</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">M</span> : normedModType R) (<span class="nv">B</span> : <span class="nb">set</span> M)
  (<span class="nv">x</span> : M) : nbhs x B &lt;-&gt; <span class="kr">exists</span> (<span class="nv">r</span> : {posnum R}), closed_ball x r%:num `&lt;=` B.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [/nbhs_ballP[_/posnumP[r] xrB]|[e xeB]]; <span class="nb">last first</span>.
  <span class="nb">apply</span>/nbhs_ballP; <span class="kr">exists</span> <span class="nv">e</span>%:num =&gt; //=.
  <span class="bp">exact</span>: (subset_trans (@subset_closure _ _) xeB).
<span class="kr">exists</span> (<span class="nv">r</span>%:num / <span class="mi">2</span>)%:sgn.
<span class="nb">apply</span>: (subset_trans (closed_ball_subset _ _) xrB) =&gt; //=.
<span class="bp">by</span> <span class="nb">rewrite</span> lter_pdivr_mulr // ltr_pmulr // ltr1n.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">subset_closed_ball</span> (<span class="nv">R</span> : realFieldType) (<span class="nv">V</span> : normedModType R) (<span class="nv">x</span> : V)
  (<span class="nv">r</span> : R) : <span class="mi">0</span> &lt; r -&gt; ball x r `&lt;=` closed_ball x r.
<span class="kn">Proof</span>. <span class="nb">move</span>=&gt; r0; <span class="nb">rewrite</span> /closed_ball; <span class="nb">apply</span>: subset_closure. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">locally_compactR</span> (<span class="nv">R</span> : realType) : locally_compact [<span class="nb">set</span>: R].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; x _; <span class="nb">rewrite</span> withinET; <span class="kr">exists</span> (<span class="nv">closed_ball</span> <span class="nv">x</span> <span class="mi">1</span>).
  <span class="bp">by</span> <span class="nb">apply</span>/nbhs_closedballP; <span class="kr">exists</span> <span class="mi">1</span>%:pos.
<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span>: closed_ballR_compact | <span class="nb">apply</span>: closed_ball_closed].
<span class="kn">Qed</span>.

<span class="c">(*TBA topology.v once ball_normE is there*)</span>

<span class="kn">Lemma</span> <span class="nf">interior_closed_ballE</span> (<span class="nv">R</span> : realType) (<span class="nv">V</span> : normedModType R) (<span class="nv">x</span> : V)
  (<span class="nv">r</span> : R) : <span class="mi">0</span> &lt; r -&gt; (closed_ball x r)^¬∞ = ball x r.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; r0; <span class="nb">rewrite</span> eqEsubset; <span class="nb">split</span>; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -open_subsetE; [<span class="bp">exact</span>: subset_closure | <span class="bp">exact</span>: ball_open].
<span class="nb">move</span>=&gt; /= t; <span class="nb">rewrite</span> closed_ballE // /interior /= -nbhs_ballE =&gt; [[]] s s0.
<span class="nb">have</span> [-&gt; _|nxt] := eqVneq t x; <span class="kp">first</span> <span class="bp">exact</span>: ballxx.
near ((<span class="mi">0</span> : R^o)^&#39;) =&gt; e; <span class="nb">rewrite</span> -ball_normE /closed_ball_ =&gt; tsxr.
<span class="nb">pose</span> z := t + `|e| *: (t - x); <span class="nb">have</span> /tsxr /= : `|t - z| &lt; s.
  <span class="nb">rewrite</span> distrC addrAC subrr add0r normrZ normr_id.
  <span class="nb">rewrite</span> -ltr_pdivl_mulr ?(normr_gt0,subr_eq0) //.
  <span class="bp">by</span> near: e; <span class="nb">apply</span>/dnbhs0_lt; <span class="nb">rewrite</span> divr_gt0 // normr_gt0 subr_eq0.
<span class="nb">rewrite</span> /z opprD addrA -scalerN -{<span class="mi">1</span>}(scale1r (x - t)) opprB -scalerDl normrZ.
<span class="nb">apply</span> lt_le_trans; <span class="nb">rewrite</span> ltr_pmull; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> normr_gt0 subr_eq0 eq_sym.
<span class="bp">by</span> <span class="nb">rewrite</span> ger0_norm // ltr_addl normr_gt0; near: e; <span class="kr">exists</span> <span class="mi">1</span> =&gt; /=.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">open_nbhs_closed_ball</span> (<span class="nv">R</span> : realType) (<span class="nv">V</span> : normedModType R) (<span class="nv">x</span> : V)
  (<span class="nv">r</span> : R) : <span class="mi">0</span> &lt; r -&gt; open_nbhs x (closed_ball x r)^¬∞.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; r0; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: open_interior.
<span class="bp">by</span> <span class="nb">rewrite</span> interior_closed_ballE //; <span class="bp">exact</span>: ballxx.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Closed_Ball</span>.

<span class="c">(* multi-rule bound_in_itv already exists in interval.v, but we</span>
<span class="c">  advocate that it should actually have the following statement.</span>
<span class="c">  This does not expose the order between interval bounds. *)</span>
<span class="kn">Lemma</span> <span class="nf">bound_itvE</span> (<span class="nv">R</span> : numDomainType) (<span class="nv">a</span> <span class="nv">b</span> : R) :
  ((a \<span class="kr">in</span> `[a, b]) = (a &lt;= b)) *
  ((b \<span class="kr">in</span> `[a, b]) = (a &lt;= b)) *
  ((a \<span class="kr">in</span> `[a, b[) = (a &lt; b)) *
  ((b \<span class="kr">in</span> `]a, b]) = (a &lt; b)) *
  (a \<span class="kr">in</span> `[a, +oo[) *
  (a \<span class="kr">in</span> `]-oo, a]).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> !(boundr_in_itv, boundl_in_itv). <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">near_in_itv</span> {<span class="nv">R</span> : realFieldType} (<span class="nv">a</span> <span class="nv">b</span> : R) :
  {<span class="kr">in</span> `]a, b[, <span class="kr">forall</span> <span class="nv">y</span>, \<span class="kr">forall</span> <span class="nv">z</span> \near y, z \<span class="kr">in</span> `]a, b[}.
<span class="kn">Proof</span>. <span class="bp">exact</span>: interval_open. <span class="kn">Qed</span>.

<span class="kn">Notation</span> <span class="s2">&quot;f @`[ a , b ]&quot;</span> :=
  (`[minr (f a) (f b), maxr (f a) (f b)]) : ring_scope.
<span class="kn">Notation</span> <span class="s2">&quot;f @`[ a , b ]&quot;</span> :=
  (`[minr (f a) (f b), maxr (f a) (f b)]%classic) : classical_set_scope.
<span class="kn">Notation</span> <span class="s2">&quot;f @`] a , b [&quot;</span> :=
  (`](minr (f a) (f b)), (maxr (f a) (f b))[) : ring_scope.
<span class="kn">Notation</span> <span class="s2">&quot;f @`] a , b [&quot;</span> :=
  (`](minr (f a) (f b)), (maxr (f a) (f b))[%classic) : classical_set_scope.

<span class="kn">Section</span> <span class="nf">image_interval</span>.
<span class="kn">Variable</span> <span class="nv">R</span> : realDomainType.
<span class="kn">Implicit Types</span> (<span class="nv">a</span> <span class="nv">b</span> : R) (<span class="nv">f</span> : R -&gt; R).

<span class="kn">Lemma</span> <span class="nf">mono_mem_image_segment</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : monotonous `[a, b] f -&gt;
  {homo f : x / x \<span class="kr">in</span> `[a, b] &gt;-&gt; x \<span class="kr">in</span> f @`[a, b]}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; [fle|fge] x xab; <span class="nb">have</span> leab : a &lt;= b <span class="bp">by</span> <span class="nb">rewrite</span> (itvP xab).
  <span class="nb">have</span>: f a &lt;= f b <span class="bp">by</span> <span class="nb">rewrite</span> fle <span class="nl">?bound_itvE</span>.
  <span class="bp">by</span> <span class="nb">case</span>: leP =&gt; // fafb _; <span class="nb">rewrite</span> in_itv/= !fle ?(itvP xab).
<span class="nb">have</span>: f a &gt;= f b <span class="bp">by</span> <span class="nb">rewrite</span> fge <span class="nl">?bound_itvE</span>.
<span class="bp">by</span> <span class="nb">case</span>: leP =&gt; // fafb _; <span class="nb">rewrite</span> in_itv/= !fge ?(itvP xab).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mono_mem_image_itvoo</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : monotonous `[a, b] f -&gt;
  {homo f : x / x \<span class="kr">in</span> `]a, b[ &gt;-&gt; x \<span class="kr">in</span> f @`]a, b[}.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; []/[dup] =&gt; [/leW_mono_in|/leW_nmono_in] flt fle x xab;
    <span class="nb">have</span> ltab : a &lt; b <span class="bp">by</span> <span class="nb">rewrite</span> (itvP xab).
  <span class="nb">have</span>: f a &lt;= f b <span class="bp">by</span> <span class="nb">rewrite</span> <span class="nl">?fle</span> <span class="nl">?bound_itvE</span> <span class="nl">?ltW</span>.
  <span class="bp">by</span> <span class="nb">case</span>: leP =&gt; // fafb _; <span class="nb">rewrite</span> in_itv/= <span class="nl">?flt</span> <span class="nl">?in_itv</span>/= ?(itvP xab, lexx).
<span class="nb">have</span>: f a &gt;= f b <span class="bp">by</span> <span class="nb">rewrite</span> fle <span class="nl">?bound_itvE</span> <span class="nl">?ltW</span>.
<span class="bp">by</span> <span class="nb">case</span>: leP =&gt; // fafb _; <span class="nb">rewrite</span> in_itv/= <span class="nl">?flt</span> <span class="nl">?in_itv</span>/= ?(itvP xab, lexx).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mono_surj_image_segment</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : a &lt;= b -&gt;
    monotonous `[a, b] f -&gt; set_surj `[a, b] (f @`[a, b]) f -&gt;
  f @` `[a, b] = f @`[a, b]%classic.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; leab fmono; <span class="nb">apply</span>: surj_image_eq =&gt; _ /= [x xab &lt;-];
<span class="bp">exact</span>: mono_mem_image_segment.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">inc_segment_image</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : f a &lt;= f b -&gt; f @`[a, b] = `[f a, f b].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: ltrP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dec_segment_image</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : f b &lt;= f a -&gt; f @`[a, b] = `[f b, f a].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">case</span>: ltrP. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">inc_surj_image_segment</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : a &lt;= b -&gt;
    {<span class="kr">in</span> `[a, b] &amp;, {mono f : x y / x &lt;= y}} -&gt;
    set_surj `[a, b] `[f a, f b] f -&gt;
  f @` `[a, b] = `[f a, f b]%classic.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; leab fle f_surj; <span class="nb">have</span> fafb : f a &lt;= f b <span class="bp">by</span> <span class="nb">rewrite</span> fle <span class="nl">?bound_itvE</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> mono_surj_image_segment <span class="nl">?inc_segment_image</span>//; <span class="nb">left</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dec_surj_image_segment</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : a &lt;= b -&gt;
    {<span class="kr">in</span> `[a, b] &amp;, {mono f : x y /~ x &lt;= y}} -&gt;
    set_surj `[a, b] `[f b, f a] f -&gt;
  f @` `[a, b] = `[f b, f a]%classic.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; leab fge f_surj; <span class="nb">have</span> fafb : f b &lt;= f a <span class="bp">by</span> <span class="nb">rewrite</span> fge <span class="nl">?bound_itvE</span>.
<span class="bp">by</span> <span class="nb">rewrite</span> mono_surj_image_segment <span class="nl">?dec_segment_image</span>//; <span class="nb">right</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">inc_surj_image_segmentP</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : a &lt;= b -&gt;
    {<span class="kr">in</span> `[a, b] &amp;, {mono f : x y / x &lt;= y}} -&gt;
    set_surj `[a, b] `[f a, f b] f -&gt;
  <span class="kr">forall</span> <span class="nv">y</span>, reflect (<span class="kr">exists2</span> x, x \<span class="kr">in</span> `[a, b] &amp; f x = y) (y \<span class="kr">in</span> `[f a, f b]).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /inc_surj_image_segment/[<span class="nb">apply</span>]/[<span class="nb">apply</span>]/predeqP + y =&gt; /(_ y) fab.
<span class="bp">by</span> <span class="nb">apply</span>/(equivP idP); <span class="nb">symmetry</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">dec_surj_image_segmentP</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : a &lt;= b -&gt;
    {<span class="kr">in</span> `[a, b] &amp;, {mono f : x y /~ x &lt;= y}} -&gt;
    set_surj `[a, b] `[f b, f a] f -&gt;
  <span class="kr">forall</span> <span class="nv">y</span>, reflect (<span class="kr">exists2</span> x, x \<span class="kr">in</span> `[a, b] &amp; f x = y) (y \<span class="kr">in</span> `[f b, f a]).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /dec_surj_image_segment/[<span class="nb">apply</span>]/[<span class="nb">apply</span>]/predeqP + y =&gt; /(_ y) fab.
<span class="bp">by</span> <span class="nb">apply</span>/(equivP idP); <span class="nb">symmetry</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">mono_surj_image_segmentP</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">f</span> : a &lt;= b -&gt;
    monotonous `[a, b] f -&gt; set_surj `[a, b] (f @`[a, b]) f -&gt;
  <span class="kr">forall</span> <span class="nv">y</span>, reflect (<span class="kr">exists2</span> x, x \<span class="kr">in</span> `[a, b] &amp; f x = y) (y \<span class="kr">in</span> f @`[a, b]).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /mono_surj_image_segment/[<span class="nb">apply</span>]/[<span class="nb">apply</span>]/predeqP + y =&gt; /(_ y) fab.
<span class="bp">by</span> <span class="nb">apply</span>/(equivP idP); <span class="nb">symmetry</span>.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">image_interval</span>.

<span class="kn">Section</span> <span class="nf">LinearContinuousBounded</span>.

<span class="kn">Variables</span> (<span class="nv">R</span> : numFieldType) (<span class="nv">V</span> <span class="nv">W</span> : normedModType R).

<span class="kn">Lemma</span> <span class="nf">linear_boundedP</span> (<span class="nv">f</span> : {linear V -&gt; W}) : bounded_near f (nbhs <span class="mi">0</span>) &lt;-&gt;
  \<span class="kr">forall</span> <span class="nv">r</span> \near +oo, <span class="kr">forall</span> <span class="nv">x</span>, `|f x| &lt;= r * `|x|.
<span class="kn">Proof</span>.
<span class="nb">split</span>=&gt; [|/pinfty_ex_gt0 [r r0 Bf]]; <span class="nb">last first</span>.
  <span class="nb">apply</span>/ex_bound; <span class="kr">exists</span> <span class="nv">r</span>; <span class="nb">apply</span>/nbhs_norm0P; <span class="kr">exists</span> <span class="mi">1</span> =&gt; //= x /=.
  <span class="bp">by</span> <span class="nb">rewrite</span> -(gtr_pmulr _ r0) =&gt; /ltW; <span class="bp">exact</span>/le_trans/Bf.
<span class="nb">rewrite</span> /bounded_near =&gt; /pinfty_ex_gt0 [M M0 /nbhs_norm0P [_/posnumP[e] efM]].
near (<span class="mi">0</span> : R)^&#39;+ =&gt; d; near=&gt; r =&gt; x.
<span class="nb">have</span>[-&gt;|x0] := eqVneq x <span class="mi">0</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> raddf0 !normr0 mulr0.
<span class="nb">have</span> nd0 : d / `|x| &gt; <span class="mi">0</span> <span class="bp">by</span> <span class="nb">rewrite</span> divr_gt0 <span class="nl">?normr_gt0</span>.
<span class="nb">have</span>: `|f (d / `|x| *: x)| &lt;= M.
  <span class="bp">by</span> <span class="nb">apply</span>: efM =&gt; /=; <span class="nb">rewrite</span> normrZ gtr0_norm// divfK <span class="nl">?normr_eq0</span>//.
<span class="nb">rewrite</span> linearZ/= normrZ gtr0_norm// -ler_pdivl_mull//; <span class="nb">move</span>/le_trans; <span class="nb">apply</span>.
<span class="nb">rewrite</span> invfM invrK mulrAC ler_wpmul2r//; near: r; <span class="nb">apply</span>: nbhs_pinfty_ge.
<span class="bp">by</span> <span class="nb">rewrite</span> rpredM// <span class="nl">?rpredV</span> <span class="nl">?gtr0_real</span>.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuous_linear_bounded</span> (<span class="nv">x</span> : V) (<span class="nv">f</span> : {linear V -&gt; W}) :
  {<span class="kr">for</span> <span class="mi">0</span>, continuous f} -&gt; bounded_near f (nbhs x).
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /prop_for linear0 /bounded_near =&gt; f0; near=&gt; M; <span class="nb">apply</span>/nbhs0P.
near <span class="kp">do</span> <span class="nb">rewrite</span> /= linearD (le_trans (ler_norm_add _ _))// -ler_subr_addl.
<span class="bp">by</span> <span class="nb">apply</span>: cvgr0_norm_le; <span class="nb">rewrite</span> // subr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__linear_continuous0</span> (<span class="nv">f</span> : {linear V -&gt; W}) :
  {<span class="kr">for</span> <span class="mi">0</span>, continuous f} -&gt; bounded_near f (nbhs (<span class="mi">0</span> : V)).
<span class="kn">Proof</span>. <span class="bp">exact</span>: continuous_linear_bounded. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bounded_linear_continuous</span> (<span class="nv">f</span> : {linear V -&gt; W}) :
  bounded_near f (nbhs (<span class="mi">0</span> : V)) -&gt; continuous f.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /linear_boundedP [y [yreal fr]] x; near +oo_R =&gt; r.
<span class="nb">apply</span>/(@cvgrPdist_lt _ _ _ (nbhs x)) =&gt; e e_gt0; near=&gt; z; <span class="nb">rewrite</span> -linearB.
<span class="nb">rewrite</span> (le_lt_trans (fr r _ _))// -<span class="nl">?ltr_pdivl_mull</span>//.
<span class="bp">by</span> near: z; <span class="nb">apply</span>: cvgr_dist_lt =&gt; //; <span class="nb">rewrite</span> mulrC divr_gt0.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">__deprecated__linear_bounded0</span> (<span class="nv">f</span> : {linear V -&gt; W}) :
  bounded_near f (nbhs (<span class="mi">0</span> : V)) -&gt; {<span class="kr">for</span> <span class="mi">0</span>, continuous f}.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; ? ?; <span class="bp">exact</span>: bounded_linear_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">continuousfor0_continuous</span> (<span class="nv">f</span> : {linear V -&gt; W}) :
  {<span class="kr">for</span> <span class="mi">0</span>, continuous f} -&gt; continuous f.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; /continuous_linear_bounded/bounded_linear_continuous. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">linear_bounded_continuous</span> (<span class="nv">f</span> : {linear V -&gt; W}) :
  bounded_near f (nbhs <span class="mi">0</span>) &lt;-&gt; continuous f.
<span class="kn">Proof</span>.
<span class="nb">split</span>; <span class="kp">first</span> <span class="bp">exact</span>: bounded_linear_continuous.
<span class="bp">by</span> <span class="nb">move</span>=&gt; /(_ <span class="mi">0</span>); <span class="nb">apply</span>: continuous_linear_bounded.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">bounded_funP</span> (<span class="nv">f</span> : {linear V -&gt; W}) :
  (<span class="kr">forall</span> <span class="nv">r</span>, <span class="kr">exists</span> <span class="nv">M</span>, <span class="kr">forall</span> <span class="nv">x</span>, `|x| &lt;= r -&gt; `|f x| &lt;= M) &lt;-&gt;
  bounded_near f (nbhs (<span class="mi">0</span> : V)).
<span class="kn">Proof</span>.
<span class="nb">split</span> =&gt; [/(_ <span class="mi">1</span>) [M Bf]|/linear_boundedP fr y].
  <span class="nb">apply</span>/ex_bound; <span class="kr">exists</span> <span class="nv">M</span>; <span class="nb">apply</span>/nbhs_normP =&gt; /=; <span class="kr">exists</span> <span class="mi">1</span> =&gt; //= x /=.
  <span class="bp">by</span> <span class="nb">rewrite</span> sub0r normrN =&gt; x1; <span class="bp">exact</span>/Bf/ltW.
near +oo_R =&gt; r; <span class="kr">exists</span> (<span class="nv">r</span> * y) =&gt; x xe.
<span class="nb">rewrite</span> (@le_trans _ _ (r * `|x|)) //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">move</span>: {xe} x; near: r.
<span class="bp">by</span> <span class="nb">rewrite</span> ler_pmul //.
<span class="kn">Unshelve</span>. <span class="kp">all</span>: <span class="bp">by</span> end_near. <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">LinearContinuousBounded</span>.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;generalized to `continuous_linear_bounded`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">linear_continuous0</span> := __deprecated__linear_continuous0.
#[deprecated(since=<span class="s2">&quot;mathcomp-analysis 0.6.0&quot;</span>,
  note=<span class="s2">&quot;generalized to `bounded_linear_continuous`&quot;</span>)]
<span class="kn">Notation</span> <span class="nf">linear_bounded0</span> := __deprecated__linear_bounded0.</span></pre></article></body></html>